System.register([], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      exports({
        BitMask: BitMask,
        CCClass: CCClass,
        Enum: Enum,
        Eventify: Eventify,
        WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI,
        __checkObsoleteInNamespace__: __checkObsoleteInNamespace__,
        __checkObsolete__: __checkObsolete__,
        _resetDebugSetting: _resetDebugSetting,
        absMax: absMax,
        absMaxComponent: absMaxComponent,
        applyMixins: applyMixins,
        approx: approx,
        assert: assert,
        assertID: assertID,
        assertIsNonNullable: assertIsNonNullable,
        assertIsTrue: assertIsTrue,
        assertsArrayIndex: assertsArrayIndex,
        bezier: bezier,
        bezierByTime: bezierByTime,
        binarySearch: binarySearch,
        binarySearchBy: binarySearchBy,
        binarySearchEpsilon: binarySearchEpsilon,
        ccenum: ccenum,
        clamp: clamp$1,
        clamp01: clamp01,
        color: color,
        debug: debug,
        deprecateModuleExportedName: deprecateModuleExportedName,
        deserialize: deserialize,
        enumerableProps: enumerableProps,
        equals: equals$1,
        error: error,
        errorID: errorID,
        find: find,
        flattenCodeArray: flattenCodeArray,
        floatToHalf: floatToHalf,
        formerlySerializedAs: formerlySerializedAs$3,
        fragmentText: fragmentText,
        getBaselineOffset: getBaselineOffset,
        getEnglishWordPartAtFirst: getEnglishWordPartAtFirst,
        getEnglishWordPartAtLast: getEnglishWordPartAtLast,
        getError: getError,
        getSerializationMetadata: getSerializationMetadata,
        getSymbolAt: getSymbolAt,
        getSymbolCodeAt: getSymbolCodeAt,
        getSymbolLength: getSymbolLength,
        halfToFloat: halfToFloat,
        instantiate: instantiate,
        inverseLerp: inverseLerp,
        isCCClassOrFastDefined: isCCClassOrFastDefined,
        isCCObject: isCCObject,
        isDisplayStats: isDisplayStats,
        isEnglishWordPartAtFirst: isEnglishWordPartAtFirst,
        isEnglishWordPartAtLast: isEnglishWordPartAtLast,
        isUnicodeCJK: isUnicodeCJK,
        isUnicodeSpace: isUnicodeSpace,
        isValid: isValid,
        lerp: lerp,
        log: log,
        logID: logID,
        mat4: mat4,
        murmurhash2_32_gc: murmurhash2_32_gc,
        nextPow2: nextPow2,
        pingPong: pingPong,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        quat: quat,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        rect: rect,
        repeat: repeat$2,
        safeMeasureText: safeMeasureText,
        setDefaultLogTimes: setDefaultLogTimes,
        setDisplayStats: setDisplayStats,
        setPropertyEnumType: setPropertyEnumType,
        setPropertyEnumTypeOnAttrs: setPropertyEnumTypeOnAttrs,
        setRandGenerator: setRandGenerator,
        shift: shift,
        size: size,
        toDegree: toDegree,
        toRadian: toRadian,
        tween: tween,
        tweenUtil: tweenUtil,
        v2: v2$1,
        v3: v3,
        v4: v4,
        warn: warn,
        warnID: warnID
      });

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }
        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);
        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }
        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }
        return desc;
      }

      function tryDefineGlobal (name, value) {
          const _global = typeof window === 'undefined' ? global : window;
          if (typeof _global[name] === 'undefined') {
              return (_global[name] = value);
          } else {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              return _global[name];
          }
      }

      const NATIVE = true;

      const OPEN_HARMONY = false;
      tryDefineGlobal('CC_WECHAT', false);
      tryDefineGlobal('CC_BAIDU', false);

      const XIAOMI = false;
      tryDefineGlobal('CC_XIAOMI', false);
      tryDefineGlobal('CC_ALIPAY', false);
      tryDefineGlobal('CC_BYTEDANCE', false);
      tryDefineGlobal('CC_OPPO', false);
      tryDefineGlobal('CC_VIVO', false);
      tryDefineGlobal('CC_HUAWEI', false);
      tryDefineGlobal('CC_COCOSPLAY', false);
      tryDefineGlobal('CC_QTT', false);
      tryDefineGlobal('CC_LINKSURE', false);

      const EDITOR = false;
      tryDefineGlobal('CC_EDITOR', false);

      const EDITOR_NOT_IN_PREVIEW = false;

      const PREVIEW = false;
      tryDefineGlobal('CC_PREVIEW', false);
      tryDefineGlobal('CC_BUILD', true);
      tryDefineGlobal('CC_TEST', false);
      tryDefineGlobal('CC_DEBUG', true);
      tryDefineGlobal('CC_DEV', false);

      const MINIGAME = false;
      tryDefineGlobal('CC_MINIGAME', false);

      const RUNTIME_BASED = false;
      tryDefineGlobal('CC_RUNTIME_BASED', false);
      tryDefineGlobal('CC_SUPPORT_JIT', true);

      const JSB = true;
      tryDefineGlobal('CC_JSB', true);

      const _global = typeof window === 'undefined' ? global : window;
      const legacyCC = exports('cclegacy', {
        _global
      });
      legacyCC.internal = {};
      const engineVersion = exports('VERSION', '3.8.3');
      _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
      _global.cc = legacyCC;
      const ccwindow$1 = typeof globalThis.jsb !== 'undefined' ? typeof jsb.window !== 'undefined' ? jsb.window : globalThis : globalThis;
      _global.ccwindow = ccwindow$1;

      const INT_BITS = 32;
      const INT_MAX = 0x7fffffff;
      const INT_MIN = -1 << INT_BITS - 1;
      function sign$1(v) {
        return (v > 0) - (v < 0);
      }
      function abs$1(v) {
        const mask = v >> INT_BITS - 1;
        return (v ^ mask) - mask;
      }
      function min$3(x, y) {
        return y ^ (x ^ y) & -(x < y);
      }
      function max$4(x, y) {
        return x ^ (x ^ y) & -(x < y);
      }
      function isPow2(v) {
        return !(v & v - 1) && !!v;
      }
      function log2(v) {
        let r;
        let shift;
        r = (v > 0xFFFF) << 4;
        v >>>= r;
        shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | v >> 1;
      }
      function log10(v) {
        return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
      }
      function popCount(v) {
        v -= v >>> 1 & 0x55555555;
        v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
        return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
      }
      function countTrailingZeros(v) {
        let c = 32;
        v &= -v;
        if (v) {
          c--;
        }
        if (v & 0x0000FFFF) {
          c -= 16;
        }
        if (v & 0x00FF00FF) {
          c -= 8;
        }
        if (v & 0x0F0F0F0F) {
          c -= 4;
        }
        if (v & 0x33333333) {
          c -= 2;
        }
        if (v & 0x55555555) {
          c -= 1;
        }
        return c;
      }
      function nextPow2$1(v) {
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
      }
      function prevPow2(v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v >>> 1);
      }
      function parity(v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 0xf;
        return 0x6996 >>> v & 1;
      }
      const REVERSE_TABLE = new Array(256);
      (tab => {
        for (let i = 0; i < 256; ++i) {
          let v = i;
          let r = i;
          let s = 7;
          for (v >>>= 1; v; v >>>= 1) {
            r <<= 1;
            r |= v & 1;
            --s;
          }
          tab[i] = r << s & 0xff;
        }
      })(REVERSE_TABLE);
      function reverse(v) {
        return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
      }
      function interleave2(x, y) {
        x &= 0xFFFF;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y &= 0xFFFF;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }
      function deinterleave2(v, n) {
        v = v >>> n & 0x55555555;
        v = (v | v >>> 1) & 0x33333333;
        v = (v | v >>> 2) & 0x0F0F0F0F;
        v = (v | v >>> 4) & 0x00FF00FF;
        v = (v | v >>> 16) & 0x000FFFF;
        return v << 16 >> 16;
      }
      function interleave3(x, y, z) {
        x &= 0x3FF;
        x = (x | x << 16) & 4278190335;
        x = (x | x << 8) & 251719695;
        x = (x | x << 4) & 3272356035;
        x = (x | x << 2) & 1227133513;
        y &= 0x3FF;
        y = (y | y << 16) & 4278190335;
        y = (y | y << 8) & 251719695;
        y = (y | y << 4) & 3272356035;
        y = (y | y << 2) & 1227133513;
        x |= y << 1;
        z &= 0x3FF;
        z = (z | z << 16) & 4278190335;
        z = (z | z << 8) & 251719695;
        z = (z | z << 4) & 3272356035;
        z = (z | z << 2) & 1227133513;
        return x | z << 2;
      }
      function deinterleave3(v, n) {
        v = v >>> n & 1227133513;
        v = (v | v >>> 2) & 3272356035;
        v = (v | v >>> 4) & 251719695;
        v = (v | v >>> 8) & 4278190335;
        v = (v | v >>> 16) & 0x3FF;
        return v << 22 >> 22;
      }
      function nextCombination(v) {
        const t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
      }

      var bits = /*#__PURE__*/Object.freeze({
        __proto__: null,
        INT_BITS: INT_BITS,
        INT_MAX: INT_MAX,
        INT_MIN: INT_MIN,
        sign: sign$1,
        abs: abs$1,
        min: min$3,
        max: max$4,
        isPow2: isPow2,
        log2: log2,
        log10: log10,
        popCount: popCount,
        countTrailingZeros: countTrailingZeros,
        nextPow2: nextPow2$1,
        prevPow2: prevPow2,
        parity: parity,
        reverse: reverse,
        interleave2: interleave2,
        deinterleave2: deinterleave2,
        interleave3: interleave3,
        deinterleave3: deinterleave3,
        nextCombination: nextCombination
      });
      exports('bits', bits);

      var debugInfos = {
      	"1006": "[Action step]. override me",
      	"1007": "[Action update]. override me",
      	"1008": "[Action reverse]. override me",
      	"1100": "Expected 'data' dict, but not found. Config file: %s",
      	"1101": "Please load the resource first : %s",
      	"1102": "Effect settings not found, effects will not be imported.",
      	"1103": "Success to load scene: %s",
      	"1200": "cocos2d: Director: Error in gettimeofday",
      	"1204": "Running scene should not be null",
      	"1205": "The scene should not be null",
      	"1206": "loadScene: The scene index to load (%s) is out of range.",
      	"1207": "loadScene: Unknown name type to load: '%s'",
      	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
      	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1210": "Failed to preload '%s', %s",
      	"1211": "loadScene: The scene index to load (%s) is out of range.",
      	"1212": "loadScene: Unknown name type to load: '%s'",
      	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1215": "Failed to preload '%s', %s",
      	"1216": "Director.runSceneImmediate: scene is not valid",
      	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
      	"1218": "Forward render pipeline initialized.",
      	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
      	"1220": "Failed to set shading scale, pipelineSceneData is invalid.",
      	"1221": "Setting orientation is not supported yet.",
      	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
      	"1400": "'%s' is deprecated, please use '%s' instead.",
      	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      	"1406": "'%s.%s' is removed",
      	"1408": "'%s' is removed",
      	"1409": "element type is wrong!",
      	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
      	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
      	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
      	"1506": "warning: you CANNOT change update priority in scheduled function",
      	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
      	"1508": "Argument callback must not be empty",
      	"1509": "Argument target must be non-nullptr",
      	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1514": "since v3.8.0, `Scheduler.schedule(target, callback, interval)` is deprecated, please use `Scheduler.schedule(callback, target, interval)` instead.",
      	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      	"1619": "callback function must be non-null",
      	"1620": "interval must be positive",
      	"1623": "Set '%s' to normal node (not persist root node).",
      	"1624": "Replacing with the same sgNode",
      	"1625": "The replacement sgNode should not contain any child.",
      	"1626": "Should not set alpha via 'color', set 'opacity' please.",
      	"1627": "Not support for asynchronous creating node in SG",
      	"1632": "Node name can not include '/'.",
      	"1633": "Internal error, should not remove unknown node from parent.",
      	"1635": "reorderChild: this child is not in children list.",
      	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
      	"1900": "Invalid parameter.",
      	"2104": "Layer collision. The name of layer (%s) is collided with the name or value of some layer",
      	"2200": "Design resolution not valid",
      	"2201": "should set resolutionPolicy",
      	"2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      	"2402": "Forward pipeline startup failed!",
      	"3103": "cc.Texture.addImage(): path should be non-null",
      	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
      	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
      	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
      	"3122": "Error Texture in %s.",
      	"3123": "Set same texture %s.",
      	"3124": "Texture: setMipRange failed because base level is larger than max level",
      	"3300": "Rect width exceeds maximum margin: %s",
      	"3301": "Rect height exceeds maximum margin: %s",
      	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      	"3501": "Invalid listener type!",
      	"3502": "Can't set fixed priority with scene graph based listener.",
      	"3503": "Invalid parameters.",
      	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
      	"3505": "The listener has been registered, please don't register it again.",
      	"3506": "Unsupported listener target.",
      	"3507": "Invalid scene graph priority!",
      	"3508": "If program goes here, there should be event in dispatch.",
      	"3509": "_inDispatch should be 1 here.",
      	"3510": "%s's scene graph node not contains in the parent's children",
      	"3511": "event is undefined",
      	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
      	"3520": "Device Motion Event request permission: %s",
      	"3521": "Device Motion Event request permission failed: %s",
      	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      	"3602": "Unknown editor property '%s' in class '%s'.",
      	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
      	"3604": "Can only indicate one type attribute for %s.",
      	"3605": "The default value of %s is not instance of %s.",
      	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3607": "The default value of %s must be an empty string.",
      	"3608": "The type of %s must be CCString, not String.",
      	"3609": "The type of %s must be CCBoolean, not Boolean.",
      	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
      	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
      	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      	"3614": "Should not define constructor for cc.Component %s.",
      	"3615": "Each script can have at most one Component.",
      	"3616": "Should not specify class name %s for Component which defines in project.",
      	"3618": "ctor of '%s' can not be another CCClass",
      	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
      	"3625": "[isChildClassOf] superclass should be function type, not",
      	"3626": "Can't remove '%s' because '%s' depends on it.",
      	"3627": "Should not add renderer component (%s) to a Canvas node.",
      	"3628": "Should not add %s to a node which size is already used by its other component.",
      	"3633": "Properties function of '%s' should return an object!",
      	"3634": "Disallow to use '.' in property name",
      	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
      	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      	"3640": "'%s': the setter of '%s' is already defined!",
      	"3641": "Can not construct %s because it contains object property.",
      	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
      	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
      	"3646": "Unknown 'type' parameter of %s.%s：%s",
      	"3647": "The length of range array must be equal or greater than 2",
      	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
      	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
      	"3653": "Please do not specify \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
      	"3654": "Please specify a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
      	"3655": "Can not specify \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
      	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
      	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
      	"3700": "internal error: _prefab is undefined",
      	"3701": "Failed to load prefab asset for node '%s'",
      	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3801": "The node can not be made persist because it's not under root node.",
      	"3802": "The node can not be made persist because it's not in current scene.",
      	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3804": "getComponent: Type must be non-nil",
      	"3805": "Can't add component '%s' because %s already contains the same component.",
      	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      	"3807": "addComponent: Failed to get class '%s'",
      	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
      	"3809": "addComponent: The component to add must be a constructor",
      	"3810": "addComponent: The component to add must be child class of cc.Component",
      	"3811": "_addComponentAt: The component to add must be a constructor",
      	"3812": "_addComponentAt: Index out of range",
      	"3813": "removeComponent: Component must be non-nil",
      	"3814": "Argument must be non-nil",
      	"3815": "Component not owned by this entity",
      	"3816": "Node '%s' is already activating",
      	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      	"3818": "Failed to read or parse project.json",
      	"3819": "Warning: target element is not a DIV or CANVAS",
      	"3820": "The renderer doesn't support the renderMode %s",
      	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
      	"3822": "addComponent: Cannot add any component to the scene.",
      	"3823": "The enabled component (id: %s, name: %s) doesn't have a valid node",
      	"3900": "Invalid clip to add",
      	"3901": "Invalid clip to remove",
      	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
      	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
      	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      	"3905": "sprite frames must be an Array.",
      	"3906": "Can't find easing type [%s]",
      	"3907": "Animation state is not playing or already removed",
      	"3912": "already-playing",
      	"3920": "Current context does not allow root motion.",
      	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
      	"3923": "Root motion is ignored since root bone could not be located in animation.",
      	"3924": "Root motion is ignored since the root bone could not be located in scene.",
      	"3925": "Target of hierarchy path should be of type Node.",
      	"3926": "Node \"%s\" has no path \"%s\".",
      	"3927": "Target of component path should be of type Node.",
      	"3928": "Node \"%s\" has no component \"%s\".",
      	"3929": "Target object has no property \"%s\".",
      	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
      	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
      	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
      	"3933": "Each curve that has common target should be numeric curve and targets string property.",
      	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
      	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
      	"3936": "Instancing/Batching enabled for non-baked skinning model '%s', this may result in unexpected rendering artifacts. Consider turning it off in the material if you do not intend to do this.",
      	"3937": "Previous error occurred when instantiating animation clip %s on node %s.",
      	"3938": "'%s' is not found from '%s'. It's specified as the root node to play animation clip '%s'.",
      	"3940": "Error when animation attempted to bind material uniform target: target %s is not a material.",
      	"3941": "Error when animation attempted to bind material uniform target: material %s has no recorded pass %s.",
      	"3942": "Error when animation attempted to bind material uniform target: material %s at pass %s has no recorded uniform %s.",
      	"3943": "Error when animation attempted to bind material uniform target: material %s at pass %s's uniform %s has no recorded channel %s.",
      	"4003": "Label font size can't be shirnked less than 0!",
      	"4004": "force notify all fonts loaded!",
      	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      	"4013": "Sorry, lineHeight of system font not supported on JSB.",
      	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
      	"4201": "The alphaThreshold invalid in Canvas Mode.",
      	"4202": "The inverted invalid in Canvas Mode.",
      	"4300": "Can not found the %s page.",
      	"4301": "Can not add a page without UITransform.",
      	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
      	"4303": "The %s scrollBar on the '%s' node is not available, please check it.",
      	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      	"4500": "Graphics: There is no model in %s.",
      	"4600": "Script attached to '%s' is missing or invalid.",
      	"4601": "Failed to load wasm module, WebAssembly is not supported on this platform, but as a fallback Asm.js module is culled by mistake.",
      	"4700": "The dom control is not created!",
      	"4800": "unknown asset type",
      	"4901": "loadRes: should not specify the extname in %s %s",
      	"4902": "No need to release non-cached asset.",
      	"4914": "Resources url '%s' does not exist.",
      	"4915": "Pack indices and data do not match in size",
      	"4916": "Failed to download package for %s",
      	"4921": "Invalid pipe or invalid index provided!",
      	"4922": "The pipe to be inserted is already in the pipeline!",
      	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
      	"4924": "JSON Loader: Input item doesn't contain string content",
      	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      	"4926": "Audio Downloader: no web audio context.",
      	"4927": "Audio Downloader: audio not supported on this browser!",
      	"4928": "Load %s failed!",
      	"4929": "Load Webp ( %s ) failed",
      	"4930": "Load image ( %s ) failed",
      	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
      	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
      	"4934": "Please assure that the full path of sub asset is correct!",
      	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
      	"5000": "You are trying to destroy a object twice or more.",
      	"5001": "object not yet destroyed",
      	"5100": "Not a plist file!",
      	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      	"5201": "browser don't support web audio",
      	"5202": "This feature supports WebGL render mode only.",
      	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
      	"5301": "Can not find script '%s'",
      	"5302": "Can not find class '%s'",
      	"5303": "Failed to deserialize %s, missing _deserialize function.",
      	"5304": "Unable to deserialize version %s data.",
      	"5402": "cc.js.addon called on non-object:",
      	"5403": "cc.js.mixin: arguments must be type object:",
      	"5404": "The base class to extend from must be non-nil",
      	"5405": "The class to extend must be non-nil",
      	"5406": "Class should be extended before assigning any prototype members.",
      	"5500": "'notify' can not be used in 'get/set' !",
      	"5501": "'notify' must be used with 'default' !",
      	"5507": "The 'default' attribute of '%s.%s' must be an array",
      	"5508": "Invalid type of %s.%s",
      	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
      	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
      	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      	"5601": "Can not get current scene.",
      	"5602": "Scene is destroyed",
      	"5603": "reference node is destroyed",
      	"5700": "no %s or %s on %s",
      	"5800": "%s.lerp not yet implemented.",
      	"5801": "%s.clone not yet implemented.",
      	"5802": "%s.equals not yet implemented.",
      	"5900": "MotionStreak only support WebGL mode.",
      	"5901": "cc.MotionStreak.getOpacity has not been supported.",
      	"5902": "cc.MotionStreak.setOpacity has not been supported.",
      	"6000": "Custom should not be false if file is not specified.",
      	"6001": "The new %s must not be NaN",
      	"6017": "Incomplete or corrupt PNG file",
      	"6018": "Invalid filter algorithm: %s",
      	"6019": "Invalid byte order value.",
      	"6020": "You forgot your towel!",
      	"6021": "Unknown Field Tag: %s",
      	"6022": "Too many bits requested",
      	"6023": "No bits requested",
      	"6024": "Cannot recover from missing StripByteCounts",
      	"6025": "Cannot handle sub-byte bits per sample",
      	"6026": "Cannot handle sub-byte bits per pixel",
      	"6027": "Palette image missing color map",
      	"6028": "Unknown Photometric Interpretation: %s",
      	"6029": "Unkown error",
      	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
      	"6031": "cc.ParticleSystem: unknown image format with Data",
      	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
      	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
      	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
      	"6035": "cc.ParticleSystem: change material failed, please use proper particle material",
      	"6036": "cc.ParticleSystem: life time should bigger than 1 or buffer will be insufficient",
      	"6400": "asset.url is not usable in core process",
      	"6402": "AssetLibrary has already been initialized!",
      	"6500": "Widget target must be one of the parent nodes of it",
      	"6600": "collider not added or already removed",
      	"6601": "Can't find testFunc for (%s, $s).",
      	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
      	"6705": "Argument must be non-nil",
      	"6706": "Priority can't be set in RenderRoot2D node",
      	"6800": "Callback of event must be non-nil",
      	"6801": "The message must be provided",
      	"6900": "The thing you want to instantiate must be an object",
      	"6901": "The thing you want to instantiate is nil",
      	"6902": "The thing you want to instantiate is destroyed",
      	"6903": "The instantiate method for given asset do not implemented",
      	"6904": "Can not instantiate array",
      	"6905": "Can not instantiate DOM element",
      	"7100": "%s already defined in Enum.",
      	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
      	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      	"7202": "Add component TiledLayer into node failed.",
      	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      	"7210": "TMX Hexa zOrder not supported",
      	"7211": "TMX invalid value",
      	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
      	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
      	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
      	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      	"7222": "Parse %s failed.",
      	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
      	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
      	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7504": "Can not render dynamic created SkeletonData",
      	"7506": "Failed to load spine atlas '$s'",
      	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      	"7508": "The atlas asset of '%s' is not exists!",
      	"7509": "Spine: Animation not found: %s",
      	"7510": "Spine: Animation not found: %s",
      	"7511": "Spine: Invalid input!",
      	"7600": "The context of RenderTexture is invalid.",
      	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      	"7602": "Could not attach texture to the framebuffer",
      	"7603": "clearDepth isn't supported on Cocos2d-Html5",
      	"7604": "saveToFile isn't supported on Cocos2d-Html5",
      	"7605": "newCCImage isn't supported on Cocos2d-Html5",
      	"7606": "GFXTexture is null",
      	"7607": "readPixels buffer size smaller than %d",
      	"7700": "On the web is always keep the aspect ratio",
      	"7701": "Can't know status",
      	"7702": "Video player's duration is not ready to get now!",
      	"7703": "Video Downloader: video not supported on this browser!",
      	"7800": "Web does not support loading",
      	"7801": "Web does not support query history",
      	"7802": "Web does not support query history",
      	"7803": "The current browser does not support the GoBack",
      	"7804": "The current browser does not support the GoForward",
      	"7805": "Web does not support zoom",
      	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
      	"7901": "cc.math.mat4Assign(): pOut equals pIn",
      	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
      	"7905": "cc.math.mat4Assign(): pOut equals pIn",
      	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      	"7908": "Invalid matrix mode specified",
      	"7909": "current quaternion is an invalid value",
      	"8000": "Can't handle this field type or size",
      	"8001": "No bytes requested",
      	"8002": "Too many bytes requested",
      	"8003": "Missing StripByteCounts!",
      	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
      	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
      	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
      	"8103": "cc.GLProgram.link(): Cannot link invalid program",
      	"8104": "cocos2d: ERROR: Failed to link program: %s",
      	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      	"8106": "Please load the resource firset : %s",
      	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      	"8109": "modelView matrix is undefined.",
      	"8200": "Please set node's active instead of rigidbody's enabled.",
      	"8300": "Should only one camera exists, please check your project.",
      	"8301": "Camera does not support Canvas Mode.",
      	"8302": "Camera.viewport is deprecated, please use setViewportInOrientedSpace instead.",
      	"8400": "Wrong type arguments, 'filePath' must be a String.",
      	"9000": "Stencil manager does not support level bigger than %d in this device.",
      	"9001": "Stencil manager is already empty, cannot pop any mask",
      	"9002": "Failed to request any buffer from a mesh buffer without accessor",
      	"9003": "The internal state of LinearBufferAccessor have severe issue and irreversible, please check the reason",
      	"9004": "Failed to allocate chunk in StaticVBAccessor, the requested buffer might be too large: %d bytes",
      	"9005": "BATCHER2D_MEM_INCREMENT is too large, the Max value for BATCHER2D_MEM_INCREMENT is 2303KB (smaller than 65536 *9* 4 / 1024 = 2304KB)",
      	"9006": "QuadRenderData is removed, please use MeshRenderData instead.",
      	"9007": "Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation.",
      	"9100": "texture size exceeds current device limits %d/%d",
      	"9101": "The length of the TypedArrayBuffer must be an integer.",
      	"9201": "Cannot access game frame or container.",
      	"9202": "Setting window size is not supported.",
      	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
      	"9301": "The UI has not been initialized",
      	"9302": "Can't getGFXSampler with out device",
      	"9600": "[Physics]: please check to see if physics modules are included",
      	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
      	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
      	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
      	"9613": "[Physics]: cannon.js physics system doesn't support hinge drive and angular limit",
      	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
      	"9630": "[Physics]: A dynamic rigid body can not have the following collider shapes: Terrain, Plane and Non-convex Mesh. Node name: %s",
      	"9640": "[Physics][builtin]: sweep functions are not supported in builtin",
      	"9641": "[Physics][cannon.js]: sweep functions are not supported in cannon.js",
      	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
      	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
      	"11000": "WebGL context lost.",
      	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
      	"12002": "Can't add renderable component to this node because it already have one.",
      	"12004": "SubModel can only support %d passes.",
      	"12005": "Material already initialized, request aborted.",
      	"12006": "Pass already destroyed.",
      	"12007": "This is old usage, please swap the parameters.",
      	"12008": "GeometryRenderer: too many lines.",
      	"12009": "GeometryRenderer: too many triangles.",
      	"12010": "PassUtils: illegal uniform handle, accessing uniform at offset %d",
      	"12011": "Pass: setUniform is invoked with incompatible uniform data type for binding %d, expected type is %s",
      	"12012": "Can't set a material instance to a sharedMaterial slot",
      	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
      	"12101": "The asset %s has been destroyed!",
      	"12102": "Base pass cannot override states, please use pass instance instead.",
      	"12103": "Custom pipeline create shader %s failed. Please restart editor.",
      	"12104": "Create shader %s failed.",
      	"12105": "Pass resources incomplete.",
      	"12106": "Cannot patch non-builtin macros.",
      	"12107": "Custom pipeline invalid render pass, program: %s. Please restart editor.",
      	"12108": "Custom pipeline invalid render phase, program: %s. Please restart editor.",
      	"13100": "Incorrect CCON magic.",
      	"13101": "Unknown CCON version number: %d.",
      	"13102": "CCON Format error.",
      	"13103": "Can not encode CCON binary: lack of text encoder.",
      	"13104": "Can not decode CCON binary: lack of text decoder.",
      	"14000": "State machine matched too many transitions(greater than %s) during this frame: %s.",
      	"14100": "Pool.destroy no longer take a function as parameter, Please specify destruct function in the construction of Pool instead",
      	"14200": "Can not update a static mesh.",
      	"14201": "The primitiveIndex is out of range.",
      	"14202": "meshopt asm decoder initialized",
      	"14203": "meshopt wasm decoder initialized",
      	"14204": "meshopt decoder error: %d",
      	"14300": "Can not keep world transform due to the zero scaling of parent node",
      	"14400": "Spline error: less than 2 knots.",
      	"14401": "Spline error: less than 4 knots or not a multiple of 4.\n\n<!-- Rendering algorithm reserved: 15000 - 16000 -->",
      	"15000": "Can not find corresponding diffuse map for environment lighting, use hemisphere diffuse instead, change environment lighting type to regenerate diffuse map",
      	"15001": "Can not find environment map, disable IBL lighting",
      	"15002": "Diffuse map resource is missing, please change environment lighting type to regenerate resource",
      	"15003": "The shadow visible distance is so small that CSM stratification is not effective, Please change the value of shadowDistance so that it is 10 times greater than 0.1",
      	"15004": "The native folder may be generated from older versions, please refer https://docs.cocos.com/creator/manual/en/release-notes/ to upgrade.",
      	"15100": "Camera '%s' clear flag is skybox, but skybox is disabled,  may cause strange background effect, please set camera clear flag to solid color.",
      	"16000": "'%s' is deprecated since v%s.",
      	"16001": "'%s' is deprecated since v%s, please use '%s' instead.",
      	"16002": "'%s' is removed since v%s.",
      	"16003": "'%s' is removed since v%s, please use '%s' instead.",
      	"16101": "The effect('%s') you are looking for does not exist, please confirm the effect name in the editor. NOTE: Since 3.6, the name of the built-in effect has been changed to its name in the editor, please check it out. More information please refer to https://docs.cocos.com/creator/manual/en/shader/effect-inspector.html",
      	"16201": "The asset replacing failed, can not found override asset('%s') for '%s'",
      	"16301": "node '%s' doesn't have any ModelRenderer component, this component will not work. please add ModelRenderer component first",
      	"16302": "There is no reflection probe in the scene or no probe is near the current object. No reflection probe will take effect on this object. Please create a new reflection probe or move existing ones closer.",
      	"16303": "Skin material needs floating-point render target, please check ENABLE_FLOAT_OUTPUT define in Project Settings--Macro",
      	"16304": "Skin material may need more accurate calculations, please select a head model of standard size, check the isGlobalStandardSkinObject option in the MeshRender component.",
      	"0100": "%s not yet implemented.",
      	"0200": "You should specify a valid DOM canvas element."
      };

      const ccdocument$4 = ccwindow$1.document;
      let logList = null;
      let ccLog = console.log.bind(console);
      let ccWarn = ccLog;
      let ccError = ccLog;
      let ccAssert = (condition, message, ...optionalParams) => {
        if (!condition) {
          console.log(`ASSERT: ${formatString(message, ...optionalParams)}`);
        }
      };
      let ccDebug = ccLog;
      function formatString(...data) {
        return legacyCC.js.formatStr.apply(null, data);
      }
      function log(...data) {
        return ccLog(...data);
      }
      function warn(...data) {
        return ccWarn(...data);
      }
      function error(...data) {
        return ccError(...data);
      }
      function assert(condition, message, ...optionalParams) {
        return ccAssert(condition, message, ...optionalParams);
      }
      function debug(...data) {
        return ccDebug(...data);
      }
      function _resetDebugSetting(mode) {
        ccLog = ccWarn = ccError = ccAssert = ccDebug = () => {};
        if (mode === DebugMode.NONE) {
          return;
        }
        if (mode > DebugMode.ERROR) {
          const logToWebPage = msg => {
            if (!legacyCC.game.canvas) {
              return;
            }
            if (!logList) {
              const logDiv = ccdocument$4.createElement('Div');
              logDiv.setAttribute('id', 'logInfoDiv');
              logDiv.setAttribute('width', '200');
              logDiv.setAttribute('height', legacyCC.game.canvas.height);
              const logDivStyle = logDiv.style;
              logDivStyle.zIndex = '99999';
              logDivStyle.position = 'absolute';
              logDivStyle.top = logDivStyle.left = '0';
              logList = ccdocument$4.createElement('textarea');
              logList.setAttribute('rows', '20');
              logList.setAttribute('cols', '30');
              logList.setAttribute('disabled', 'true');
              const logListStyle = logList.style;
              logListStyle.backgroundColor = 'transparent';
              logListStyle.borderBottom = '1px solid #cccccc';
              logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
              logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
              logListStyle.padding = '0px';
              logListStyle.margin = '0px';
              logDiv.appendChild(logList);
              legacyCC.game.canvas.parentNode.appendChild(logDiv);
            }
            logList.value = `${logList.value + msg}\r\n`;
            logList.scrollTop = logList.scrollHeight;
          };
          ccError = (...data) => {
            logToWebPage(`ERROR :  ${formatString(...data)}`);
          };
          ccAssert = (condition, message, ...optionalParams) => {
            if (!condition) {
              logToWebPage(`ASSERT: ${formatString(message, ...optionalParams)}`);
            }
          };
          if (mode !== DebugMode.ERROR_FOR_WEB_PAGE) {
            ccWarn = (...data) => {
              logToWebPage(`WARN :  ${formatString(...data)}`);
            };
          }
          if (mode === DebugMode.INFO_FOR_WEB_PAGE) {
            ccLog = (...data) => {
              logToWebPage(formatString(...data));
            };
          }
        } else if (console) {
          if (!console.error) {
            console.error = console.log;
          }
          if (!console.warn) {
            console.warn = console.log;
          }
          if (console.error.bind) {
            ccError = console.error.bind(console);
          } else {
            ccError = console.error ;
          }
          ccAssert = (condition, message, ...optionalParams) => {
            if (!condition) {
              const errorText = formatString(message, ...optionalParams);
              {
                throw new Error(errorText);
              }
            }
          };
        }
        if (mode !== DebugMode.ERROR) {
          if (console.warn.bind) {
            ccWarn = console.warn.bind(console);
          } else {
            ccWarn = console.warn ;
          }
        }
        if (mode <= DebugMode.INFO) {
          {
            ccLog = console.log;
          }
        }
        if (mode <= DebugMode.VERBOSE) {
          if (typeof console.debug === 'function') {
            const vendorDebug = console.debug.bind(console);
            ccDebug = (...data) => vendorDebug(...data);
          }
        }
      }
      function _throw(error_) {
        {
          const stack = error_.stack;
          if (stack) {
            error(`${error_}\n${stack}` );
          } else {
            error(error_);
          }
          return undefined;
        }
      }
      function getTypedFormatter(type) {
        return (id, ...args) => {
          const msg = debugInfos[id] || 'unknown id' ;
          if (args.length === 0) {
            return msg;
          }
          return formatString(msg, ...args) ;
        };
      }
      const logFormatter = getTypedFormatter();
      function logID(id, ...optionalParams) {
        log(logFormatter(id, ...optionalParams));
      }
      const warnFormatter = getTypedFormatter();
      function warnID(id, ...optionalParams) {
        warn(warnFormatter(id, ...optionalParams));
      }
      const errorFormatter = getTypedFormatter();
      function errorID(id, ...optionalParams) {
        error(errorFormatter(id, ...optionalParams));
      }
      const assertFormatter = getTypedFormatter();
      function assertID(condition, id, ...optionalParams) {
        if (condition) {
          return;
        }
        assert(false, assertFormatter(id, ...optionalParams));
      }
      let DebugMode; exports('DebugMode', DebugMode);
      (function (DebugMode) {
        DebugMode[DebugMode["NONE"] = 0] = "NONE";
        DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
        DebugMode[DebugMode["INFO"] = 2] = "INFO";
        DebugMode[DebugMode["WARN"] = 3] = "WARN";
        DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
        DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
        DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
        DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
      })(DebugMode || (exports('DebugMode', DebugMode = {})));
      function getError(errorId, ...param) {
        return errorFormatter(errorId, ...param);
      }
      function isDisplayStats() {
        return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
      }
      function setDisplayStats(displayStats) {
        if (legacyCC.profiler) {
          displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
        }
      }

      var debug$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        log: log,
        warn: warn,
        error: error,
        assert: assert,
        debug: debug,
        _resetDebugSetting: _resetDebugSetting,
        _throw: _throw,
        logID: logID,
        warnID: warnID,
        errorID: errorID,
        assertID: assertID,
        get DebugMode () { return DebugMode; },
        getError: getError,
        isDisplayStats: isDisplayStats,
        setDisplayStats: setDisplayStats
      });

      let defaultLogTimes = 10;
      function setDefaultLogTimes(times) {
        if (times > 0) {
          defaultLogTimes = times;
        }
      }
      let replaceProperty; exports('replaceProperty', replaceProperty);
      let removeProperty; exports('removeProperty', removeProperty);
      let markAsWarning; exports('markAsWarning', markAsWarning);
      let replacePropertyLog;
      let markAsWarningLog;
      let removePropertyLog;
      let messageID = 0;
      const messageMap = new Map();
      replacePropertyLog = (n, dp, n2, newp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' is deprecated, please use '%s' instead. ${s}`, `${n}.${dp}`, `${n2}.${newp}`);
          item.count++;
        }
      };
      exports('replaceProperty', replaceProperty = (owner, ownerName, properties) => {
        if (owner == null) return;
        properties.forEach(item => {
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const target = item.target != null ? item.target : owner;
          const newName = item.newName != null ? item.newName : item.name;
          const targetName = item.targetName != null ? item.targetName : ownerName;
          const sameTarget = target === owner;
          const suggest = item.suggest ? `(${item.suggest})` : '';
          if (item.customFunction != null) {
            owner[item.name] = function () {
              replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
              return item.customFunction.call(this, ...arguments);
            };
          } else if (item.customSetter != null || item.customGetter != null) {
            const hasSetter = item.customSetter != null;
            const hasGetter = item.customGetter != null;
            if (hasSetter && hasGetter) {
              Object.defineProperty(owner, item.name, {
                get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasSetter) {
              Object.defineProperty(owner, item.name, {
                set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasGetter) {
              Object.defineProperty(owner, item.name, {
                get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                enumerable: false
              });
            }
          } else {
            Object.defineProperty(owner, item.name, {
              get() {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                return sameTarget ? this[newName] : target[newName];
              },
              set(v) {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                if (sameTarget) {
                  this[newName] = v;
                } else {
                  target[newName] = v;
                }
              },
              enumerable: false
            });
          }
        });
      });
      removePropertyLog = (n, dp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' has been removed. ${s}`, `${n}.${dp}`);
          item.count++;
        }
      };
      exports('removeProperty', removeProperty = (owner, ownerName, properties) => {
        if (owner == null) return;
        properties.forEach(item => {
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const suggest = item.suggest ? `(${item.suggest})` : '';
          Object.defineProperty(owner, item.name, {
            get() {
              return removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            set() {
              removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            enumerable: false
          });
        });
      });
      markAsWarningLog = (n, dp, f, id, s) => {
        const item = messageMap.get(id);
        if (item && item.logTimes > item.count) {
          f(`'%s' is deprecated. ${s}`, `${n}.${dp}`);
          item.count++;
        }
      };
      exports('markAsWarning', markAsWarning = (owner, ownerName, properties) => {
        if (owner == null) return;
        const _defaultGetSet = (d, n, dp, f, id, s) => {
          if (d.get) {
            const oldGet = d.get;
            d.get = function () {
              markAsWarningLog(n, dp, f, id, s);
              return oldGet.call(this);
            };
          }
          if (d.set) {
            const oldSet = d.set;
            d.set = function (v) {
              markAsWarningLog(n, dp, f, id, s);
              oldSet.call(this, v);
            };
          }
          Object.defineProperty(owner, dp, d);
        };
        properties.forEach(item => {
          const deprecatedProp = item.name;
          const descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
          if (!descriptor || !descriptor.configurable) {
            return;
          }
          const id = messageID++;
          messageMap.set(id, {
            id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          const suggest = item.suggest ? `(${item.suggest})` : '';
          if (typeof descriptor.value !== 'undefined') {
            if (typeof descriptor.value === 'function') {
              const oldValue = descriptor.value;
              owner[deprecatedProp] = function () {
                markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                return oldValue.call(this, ...arguments);
              };
            } else {
              let oldValue = descriptor.value;
              Object.defineProperty(owner, deprecatedProp, {
                configurable: true,
                get() {
                  markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                  return oldValue;
                }
              });
              if (descriptor.writable) {
                Object.defineProperty(owner, deprecatedProp, {
                  set(value) {
                    markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                    oldValue = value;
                  }
                });
              }
            }
          } else {
            _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
          }
          Object.defineProperty(owner, deprecatedProp, {
            enumerable: false
          });
        });
      });
      const topLevelDeprecateList = {};
      function deprecateModuleExportedName(deprecateList) {
        for (let deprecateName in deprecateList) {
          const deprecateInfo = deprecateList[deprecateName];
          topLevelDeprecateList[deprecateName] = deprecateInfo;
        }
      }
      function _checkObsoleteByName(checkName) {
        const deprecateInfo = topLevelDeprecateList[checkName];
        if (!deprecateInfo) {
          return;
        }
        const {
          newName,
          since,
          removed
        } = deprecateInfo;
        if (removed) {
          if (newName) {
            errorID(16003, checkName, since, newName);
          } else {
            errorID(16002, checkName, since);
          }
        } else if (newName) {
          warnID(16001, checkName, since, newName);
        } else {
          warnID(16000, checkName, since);
        }
      }
      function __checkObsolete__(checkList) {
        for (let checkName of checkList) {
          _checkObsoleteByName(checkName);
        }
      }
      let _cachedProxy;
      function __checkObsoleteInNamespace__(ccNamespace) {
        if (!_cachedProxy) {
          if (typeof Proxy === 'undefined') {
            _cachedProxy = {};
          } else {
            _cachedProxy = new Proxy(ccNamespace, {
              get(target, name, receiver) {
                _checkObsoleteByName(name);
                return Reflect.get(target, name, receiver);
              }
            });
          }
        }
        return _cachedProxy;
      }

      var _class$1T;
      const NonUuidMark = '.';
      class IDGenerator {
        constructor(category) {
          this.id = void 0;
          this.prefix = void 0;
          this.id = 0 | Math.random() * 998;
          this.prefix = category ? category + NonUuidMark : '';
        }
        getNewId() {
          return this.prefix + (++this.id).toString();
        }
      }
      _class$1T = IDGenerator;
      IDGenerator.global = new _class$1T('global');

      const tempCIDGenerator = new IDGenerator('TmpCId.');
      const aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
      const classNameTag = '__classname__';
      const classIdTag = '__cid__';
      function isNumber(object) {
        return typeof object === 'number' || object instanceof Number;
      }
      function isString(object) {
        return typeof object === 'string' || object instanceof String;
      }
      function isEmptyObject(obj) {
        for (const key in obj) {
          return false;
        }
        return true;
      }
      const value = (() => {
        const descriptor = {
          value: undefined,
          enumerable: false,
          writable: false,
          configurable: true
        };
        return (object, propertyName, value_, writable, enumerable) => {
          descriptor.value = value_;
          descriptor.writable = writable;
          descriptor.enumerable = enumerable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.value = undefined;
        };
      })();
      const getset = (() => {
        const descriptor = {
          get: undefined,
          set: undefined,
          enumerable: false
        };
        return (object, propertyName, getter, setter, enumerable = false, configurable = false) => {
          if (typeof setter === 'boolean') {
            console.log('Set `setter` to boolean is deprecated. Please don not use like this again.');
            enumerable = setter;
            setter = undefined;
          }
          descriptor.get = getter;
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
          descriptor.set = undefined;
        };
      })();
      const get = (() => {
        const descriptor = {
          get: undefined,
          enumerable: false,
          configurable: false
        };
        return (object, propertyName, getter, enumerable, configurable) => {
          descriptor.get = getter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
        };
      })();
      const set = (() => {
        const descriptor = {
          set: undefined,
          enumerable: false,
          configurable: false
        };
        return (object, propertyName, setter, enumerable, configurable) => {
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.set = undefined;
        };
      })();
      function createMap(forceDictMode) {
        const map = Object.create(null);
        if (forceDictMode) {
          const INVALID_IDENTIFIER_1 = '.';
          const INVALID_IDENTIFIER_2 = '/';
          map[INVALID_IDENTIFIER_1] = 1;
          map[INVALID_IDENTIFIER_2] = 1;
          delete map[INVALID_IDENTIFIER_1];
          delete map[INVALID_IDENTIFIER_2];
        }
        return map;
      }
      function getClassName(objOrCtor) {
        if (typeof objOrCtor === 'function') {
          const prototype = objOrCtor.prototype;
          if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
            return prototype[classNameTag];
          }
          let ret = '';
          if (objOrCtor.name) {
            ret = objOrCtor.name;
          }
          if (objOrCtor.toString) {
            let arr;
            const str = objOrCtor.toString();
            if (str.charAt(0) === '[') {
              arr = /\[\w+\s*(\w+)\]/.exec(str);
            } else {
              arr = /function\s*(\w+)/.exec(str);
            }
            if (arr && arr.length === 2) {
              ret = arr[1];
            }
          }
          return ret !== 'Object' ? ret : '';
        } else if (objOrCtor && objOrCtor.constructor) {
          return getClassName(objOrCtor.constructor);
        }
        return '';
      }
      function obsolete(object, obsoleted, newExpr, writable) {
        const extractPropName = /([^.]+)$/;
        const oldProp = extractPropName.exec(obsoleted)[0];
        const newProp = extractPropName.exec(newExpr)[0];
        function getter() {
          return this[newProp];
        }
        function setter(value_) {
          this[newProp] = value_;
        }
        if (writable) {
          getset(object, oldProp, getter, setter);
        } else {
          get(object, oldProp, getter);
        }
      }
      function obsoletes(obj, objName, props, writable) {
        for (const obsoleted in props) {
          const newName = props[obsoleted];
          obsolete(obj, `${objName}.${obsoleted}`, newName, writable);
        }
      }
      const REGEXP_NUM_OR_STR = /(%d)|(%s)/;
      const REGEXP_STR = /%s/;
      function formatStr(msg, ...subst) {
        if (arguments.length === 0) {
          return '';
        }
        if (subst.length === 0) {
          return `${msg}`;
        }
        const hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);
        if (hasSubstitution) {
          for (const arg of subst) {
            const regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;
            if (regExpToTest.test(msg)) {
              const notReplaceFunction = `${arg}`;
              msg = msg.replace(regExpToTest, notReplaceFunction);
            } else {
              msg += ` ${arg}`;
            }
          }
        } else {
          for (const arg of subst) {
            msg += ` ${arg}`;
          }
        }
        return msg;
      }
      function shiftArguments() {
        const len = arguments.length - 1;
        const args = new Array(len);
        for (let i = 0; i < len; ++i) {
          args[i] = arguments[i + 1];
        }
        return args;
      }
      function getPropertyDescriptor(object, propertyName) {
        while (object) {
          const pd = Object.getOwnPropertyDescriptor(object, propertyName);
          if (pd) {
            return pd;
          }
          object = Object.getPrototypeOf(object);
        }
        return null;
      }
      function _copyProp(name, source, target) {
        const pd = getPropertyDescriptor(source, name);
        if (pd) {
          Object.defineProperty(target, name, pd);
        }
      }
      function copyAllProperties(source, target, excepts) {
        const propertyNames = Object.getOwnPropertyNames(source);
        for (let i = 0, len = propertyNames.length; i < len; ++i) {
          const propertyName = propertyNames[i];
          if (excepts.indexOf(propertyName) !== -1) {
            continue;
          }
          _copyProp(propertyName, source, target);
        }
      }
      function addon(object, ...sources) {
        object = object || {};
        for (const source of sources) {
          if (source) {
            if (typeof source !== 'object') {
              errorID(5402, source);
              continue;
            }
            for (const name in source) {
              if (!(name in object)) {
                _copyProp(name, source, object);
              }
            }
          }
        }
        return object;
      }
      function mixin(object, ...sources) {
        object = object || {};
        for (const source of sources) {
          if (source) {
            if (typeof source !== 'object') {
              errorID(5403, source);
              continue;
            }
            for (const name in source) {
              _copyProp(name, source, object);
            }
          }
        }
        return object;
      }
      function extend(cls, base) {
        for (const p in base) {
          if (base.hasOwnProperty(p)) {
            cls[p] = base[p];
          }
        }
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      }
      function getSuper(constructor) {
        const proto = constructor.prototype;
        const dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      }
      function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
          if (typeof subclass !== 'function') {
            return false;
          }
          if (typeof superclass !== 'function') {
            return false;
          }
          if (subclass === superclass) {
            return true;
          }
          for (;;) {
            subclass = getSuper(subclass);
            if (!subclass) {
              return false;
            }
            if (subclass === superclass) {
              return true;
            }
          }
        }
        return false;
      }
      function clear$1(object) {
        for (const key of Object.keys(object)) {
          delete object[key];
        }
      }
      function isTempClassId(id) {
        return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
      }
      const _idToClass = createMap(true);
      const _nameToClass = createMap(true);
      function setup(tag, table, allowExist) {
        return function (id, constructor) {
          if (constructor.prototype.hasOwnProperty(tag)) {
            delete table[constructor.prototype[tag]];
          }
          value(constructor.prototype, tag, id);
          if (id) {
            const registered = table[id];
            if (!allowExist && registered && registered !== constructor) {
              let err = `A Class already exists with the same ${tag} : "${id}".`;
              error(err);
            } else {
              table[id] = constructor;
            }
          }
        };
      }
      const _setClassId = setup('__cid__', _idToClass, false);
      const doSetClassName = setup('__classname__', _nameToClass, true);
      function setClassName(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty(classIdTag)) {
          const id = className || tempCIDGenerator.getNewId();
          if (id) {
            _setClassId(id, constructor);
          }
        }
      }
      function setClassAlias(target, alias) {
        const nameRegistry = _nameToClass[alias];
        const idRegistry = _idToClass[alias];
        let ok = true;
        if (nameRegistry && nameRegistry !== target) {
          error(`"${alias}" has already been set as name or alias of another class.`);
          ok = false;
        }
        if (idRegistry && idRegistry !== target) {
          error(`"${alias}" has already been set as id or alias of another class.`);
          ok = false;
        }
        if (ok) {
          let classAliases = target[aliasesTag];
          if (!classAliases) {
            classAliases = [];
            target[aliasesTag] = classAliases;
          }
          classAliases.push(alias);
          _nameToClass[alias] = target;
          _idToClass[alias] = target;
        }
      }
      function unregisterClass(...constructors) {
        for (const constructor of constructors) {
          const p = constructor.prototype;
          const classId = p[classIdTag];
          if (classId) {
            delete _idToClass[classId];
          }
          const classname = p[classNameTag];
          if (classname) {
            delete _nameToClass[classname];
          }
          const aliases = p[aliasesTag];
          if (aliases) {
            for (let iAlias = 0; iAlias < aliases.length; ++iAlias) {
              const alias = aliases[iAlias];
              delete _nameToClass[alias];
              delete _idToClass[alias];
            }
          }
        }
      }
      function _getClassById(classId) {
        return getClassById(classId);
      }
      function getClassById(classId) {
        return _idToClass[classId];
      }
      function getClassByName(classname) {
        return _nameToClass[classname];
      }
      function _getClassId(obj, allowTempId) {
        return getClassId(obj, allowTempId);
      }
      function getClassId(obj, allowTempId) {
        allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
        let res;
        if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
          res = obj.prototype[classIdTag];
          if (!allowTempId && (EDITOR) && isTempClassId(res)) {
            return '';
          }
          return res;
        }
        if (obj && obj.constructor) {
          const prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty(classIdTag)) {
            res = obj[classIdTag];
            if (!allowTempId && (EDITOR) && isTempClassId(res)) {
              return '';
            }
            return res;
          }
        }
        return '';
      }

      class Pool$1 {
        get() {
          return this._get();
        }
        constructor(_0, _1) {
          this.count = void 0;
          this._pool = void 0;
          this._cleanup = void 0;
          const size = _1 === undefined ? _0 : _1;
          const cleanupFunc = _1 === undefined ? null : _0;
          this.count = 0;
          this._pool = new Array(size);
          this._cleanup = cleanupFunc;
        }
        _get() {
          if (this.count > 0) {
            --this.count;
            const cache = this._pool[this.count];
            this._pool[this.count] = null;
            return cache;
          }
          return null;
        }
        put(obj) {
          const pool = this._pool;
          if (this.count < pool.length) {
            if (this._cleanup && this._cleanup(obj) === false) {
              return;
            }
            pool[this.count] = obj;
            ++this.count;
          }
        }
        resize(length) {
          if (length >= 0) {
            this._pool.length = length;
            if (this.count > length) {
              this.count = length;
            }
          }
        }
      }

      class MutableForwardIterator {
        constructor(array) {
          this.i = 0;
          this.array = array;
        }
        get length() {
          return this.array.length;
        }
        set length(value) {
          this.array.length = value;
          if (this.i >= value) {
            this.i = value - 1;
          }
        }
        remove(value) {
          const index = this.array.indexOf(value);
          if (index >= 0) {
            this.removeAt(index);
          }
        }
        removeAt(i) {
          this.array.splice(i, 1);
          if (i <= this.i) {
            --this.i;
          }
        }
        fastRemove(value) {
          const index = this.array.indexOf(value);
          if (index >= 0) {
            this.fastRemoveAt(index);
          }
        }
        fastRemoveAt(i) {
          const array = this.array;
          array[i] = array[array.length - 1];
          --array.length;
          if (i <= this.i) {
            --this.i;
          }
        }
        push(item) {
          this.array.push(item);
        }
      }

      function removeAt(array, index) {
        array.splice(index, 1);
      }
      function fastRemoveAt$2(array, index) {
        const length = array.length;
        if (index < 0 || index >= length) {
          return;
        }
        array[index] = array[length - 1];
        array.length = length - 1;
      }
      function remove(array, value) {
        const index = array.indexOf(value);
        if (index >= 0) {
          removeAt(array, index);
          return true;
        } else {
          return false;
        }
      }
      function fastRemove(array, value) {
        const index = array.indexOf(value);
        if (index >= 0) {
          array[index] = array[array.length - 1];
          --array.length;
        }
      }
      function removeIf(array, predicate) {
        const index = array.findIndex(predicate);
        if (index >= 0) {
          const value = array[index];
          removeAt(array, index);
          return value;
        }
      }
      function verifyType(array, type) {
        if (array && array.length > 0) {
          for (const item of array) {
            if (!(item instanceof type)) {
              logID(1300);
              return false;
            }
          }
        }
        return true;
      }
      function removeArray(array, removals) {
        for (let i = 0, l = removals.length; i < l; i++) {
          remove(array, removals[i]);
        }
      }
      function appendObjectsAt(array, objects, index) {
        array.splice.apply(array, [index, 0, ...objects]);
        return array;
      }
      function contains$2(array, value) {
        return array.indexOf(value) >= 0;
      }
      function copy(array) {
        const len = array.length;
        const cloned = new Array(len);
        for (let i = 0; i < len; i += 1) {
          cloned[i] = array[i];
        }
        return cloned;
      }

      var array = /*#__PURE__*/Object.freeze({
        __proto__: null,
        removeAt: removeAt,
        fastRemoveAt: fastRemoveAt$2,
        remove: remove,
        fastRemove: fastRemove,
        removeIf: removeIf,
        verifyType: verifyType,
        removeArray: removeArray,
        appendObjectsAt: appendObjectsAt,
        contains: contains$2,
        copy: copy,
        MutableForwardIterator: MutableForwardIterator
      });

      const js = {
        IDGenerator,
        Pool: Pool$1,
        array,
        isNumber,
        isString,
        isEmptyObject,
        getPropertyDescriptor,
        addon,
        mixin,
        extend,
        getSuper,
        isChildClassOf,
        clear: clear$1,
        value,
        getset,
        get,
        set,
        unregisterClass,
        getClassName,
        setClassName,
        setClassAlias,
        getClassByName,
        getClassById,
        get _registeredClassNames() {
          return {
            ..._nameToClass
          };
        },
        set _registeredClassNames(value) {
          clear$1(_nameToClass);
          Object.assign(_nameToClass, value);
        },
        get _registeredClassIds() {
          return {
            ..._idToClass
          };
        },
        set _registeredClassIds(value) {
          clear$1(_idToClass);
          Object.assign(_idToClass, value);
        },
        _getClassId,
        getClassId,
        _setClassId,
        _getClassById,
        obsolete,
        obsoletes,
        formatStr,
        shiftArguments,
        createMap
      };
      legacyCC.js = js;

      var js$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        array: array,
        js: js,
        IDGenerator: IDGenerator,
        Pool: Pool$1,
        isNumber: isNumber,
        isString: isString,
        isEmptyObject: isEmptyObject,
        value: value,
        getset: getset,
        get: get,
        set: set,
        createMap: createMap,
        getClassName: getClassName,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        getPropertyDescriptor: getPropertyDescriptor,
        copyAllProperties: copyAllProperties,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear$1,
        _idToClass: _idToClass,
        _nameToClass: _nameToClass,
        _setClassId: _setClassId,
        setClassName: setClassName,
        setClassAlias: setClassAlias,
        unregisterClass: unregisterClass,
        _getClassById: _getClassById,
        getClassById: getClassById,
        getClassByName: getClassByName,
        _getClassId: _getClassId,
        getClassId: getClassId
      });
      exports('js', js$1);

      function BitMask(obj) {
        if ('__bitmask__' in obj) {
          return obj;
        }
        value(obj, '__bitmask__', null, true);
        let lastIndex = -1;
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          let val = obj[key];
          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }
          const reverseKey = `${val}`;
          if (key !== reverseKey) {
            value(obj, reverseKey, key);
          }
        }
        return obj;
      }
      BitMask.isBitMask = BitMaskType => BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');
      BitMask.getList = BitMaskDef => {
        if (BitMaskDef.__bitmask__) {
          return BitMaskDef.__bitmask__;
        }
        return BitMask.update(BitMaskDef);
      };
      BitMask.update = BitMaskDef => {
        if (!Array.isArray(BitMaskDef.__bitmask__)) {
          BitMaskDef.__bitmask__ = [];
        }
        const bitList = BitMaskDef.__bitmask__;
        bitList.length = 0;
        for (const name in BitMaskDef) {
          const v = BitMaskDef[name];
          if (Number.isInteger(v)) {
            bitList.push({
              name,
              value: v
            });
          }
        }
        bitList.sort((a, b) => a.value - b.value);
        return bitList;
      };
      legacyCC.BitMask = BitMask;

      function assertIsNonNullable(expr, message) {
        assertIsTrue(!(expr === null || expr === undefined), message);
      }
      function assertIsTrue(expr, message) {
        if (!expr) {
          throw new Error(`Assertion failed: ${message !== null && message !== void 0 ? message : '<no-message>'}`);
        }
      }
      function assertsArrayIndex(array, index) {
        assertIsTrue(index >= 0 && index < array.length, `Array index ${index} out of bounds: [0, ${array.length})`);
      }

      function Enum(obj) {
        if ('__enums__' in obj) {
          return obj;
        }
        value(obj, '__enums__', null, true);
        return Enum.update(obj);
      }
      Enum.update = obj => {
        let lastIndex = -1;
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          let val = obj[key];
          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }
          const reverseKey = `${val}`;
          if (key !== reverseKey) {
            value(obj, reverseKey, key);
          }
        }
        if (Array.isArray(obj.__enums__)) {
          updateList(obj);
        }
        return obj;
      };
      (function (_Enum) {})(Enum || (exports('Enum', Enum = {})));
      Enum.isEnum = enumType => enumType && enumType.hasOwnProperty('__enums__');
      function assertIsEnum(enumType) {
        assertIsTrue(enumType.hasOwnProperty('__enums__'));
      }
      Enum.getList = enumType => {
        assertIsEnum(enumType);
        if (enumType.__enums__) {
          return enumType.__enums__;
        }
        return updateList(enumType);
      };
      function updateList(enumType) {
        assertIsEnum(enumType);
        const enums = enumType.__enums__ || [];
        enums.length = 0;
        for (const name in enumType) {
          const v = enumType[name];
          if (Number.isInteger(v)) {
            enums.push({
              name,
              value: v
            });
          }
        }
        enums.sort((a, b) => a.value - b.value);
        enumType.__enums__ = enums;
        return enums;
      }
      Enum.sortList = (enumType, compareFn) => {
        assertIsEnum(enumType);
        if (!Array.isArray(enumType.__enums__)) {
          return;
        }
        enumType.__enums__.sort(compareFn);
      };
      function ccenum(enumType) {
        if (!('__enums__' in enumType)) {
          value(enumType, '__enums__', null, true);
        }
      }
      legacyCC.Enum = Enum;

      class ValueType {
        clone() {
          errorID(100, `${getClassName(this)}.clone`);
          return this;
        }
        equals(other) {
          return false;
        }
        set(other) {
          errorID(100, `${getClassName(this)}.set`);
        }
        toString() {
          return `${''}`;
        }
      } exports('ValueType', ValueType);
      setClassName('cc.ValueType', ValueType);
      legacyCC.ValueType = ValueType;

      var Category;
      (function (Category) {
        Category["PATH"] = "path";
        Category["ENGINE"] = "engine";
        Category["ASSETS"] = "assets";
        Category["SCRIPTING"] = "scripting";
        Category["PHYSICS"] = "physics";
        Category["RENDERING"] = "rendering";
        Category["LAUNCH"] = "launch";
        Category["SCREEN"] = "screen";
        Category["SPLASH_SCREEN"] = "splashScreen";
        Category["ANIMATION"] = "animation";
        Category["PROFILING"] = "profiling";
        Category["PLUGINS"] = "plugins";
        Category["XR"] = "xr";
      })(Category || (Category = {}));
      class Settings {
        constructor() {
          this._settings = {};
          this._override = {};
        }
        init(path = '', overrides = {}) {
          for (const categoryName in overrides) {
            const category = overrides[categoryName];
            if (category) {
              for (const name in category) {
                this.overrideSettings(categoryName, name, category[name]);
              }
            }
          }
          if (!path) return Promise.resolve();
          {
            if (window.oh && window.scriptEngineType === 'napi') {
              return new Promise((resolve, reject) => {
                const settingsModule = '../settings.js';
                module.import(settingsModule).then(res => {
                  this._settings = res.default;
                  resolve();
                }).catch(e => reject(e));
              });
            }
          }
          return new Promise((resolve, reject) => {
            if (!path.startsWith('http')) {
              {
                const result = fsUtils.readJsonSync(path);
                if (result instanceof Error) {
                  reject(result);
                } else {
                  this._settings = result;
                  resolve();
                }
              }
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open('GET', path);
              xhr.responseType = 'text';
              xhr.onload = () => {
                this._settings = JSON.parse(xhr.response);
                resolve();
              };
              xhr.onerror = () => {
                reject(new Error('request settings failed!'));
              };
              xhr.send(null);
            }
          });
        }
        overrideSettings(category, name, value) {
          if (!(category in this._override)) {
            this._override[category] = {};
          }
          this._override[category][name] = value;
        }
        querySettings(category, name) {
          if (category in this._override) {
            const categorySettings = this._override[category];
            if (categorySettings && name in categorySettings) {
              return categorySettings[name];
            }
          }
          if (category in this._settings) {
            const categorySettings = this._settings[category];
            if (categorySettings && name in categorySettings) {
              return categorySettings[name];
            }
          }
          return null;
        }
      } exports('Settings', Settings);
      Settings.Category = Category;
      const settings = exports('settings', new Settings());
      legacyCC.settings = settings;

      const _PORTRAIT = 1;
      const _PORTRAIT_UPSIDE_DOWN = _PORTRAIT << 1;
      const _LEFT = _PORTRAIT << 2;
      const _RIGHT = _PORTRAIT << 3;
      const _LANDSCAPE = _LEFT | _RIGHT;
      const _AUTO = _PORTRAIT | _LANDSCAPE;
      let Orientation;
      (function (Orientation) {
        Orientation[Orientation["PORTRAIT"] = _PORTRAIT] = "PORTRAIT";
        Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = _PORTRAIT_UPSIDE_DOWN] = "PORTRAIT_UPSIDE_DOWN";
        Orientation[Orientation["LANDSCAPE_LEFT"] = _LEFT] = "LANDSCAPE_LEFT";
        Orientation[Orientation["LANDSCAPE_RIGHT"] = _RIGHT] = "LANDSCAPE_RIGHT";
        Orientation[Orientation["LANDSCAPE"] = _LANDSCAPE] = "LANDSCAPE";
        Orientation[Orientation["AUTO"] = _AUTO] = "AUTO";
      })(Orientation || (Orientation = {}));

      const SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
      const KEY = {
        none: 0,
        back: 6,
        menu: 18,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        select: 41,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        '*': 106,
        '+': 107,
        '-': 109,
        numdel: 110,
        '/': 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        ';': 186,
        semicolon: 186,
        equal: 187,
        '=': 187,
        ',': 188,
        comma: 188,
        dash: 189,
        '.': 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        '[': 219,
        openbracket: 219,
        backslash: 220,
        ']': 221,
        closebracket: 221,
        quote: 222,
        dpadLeft: 1000,
        dpadRight: 1001,
        dpadUp: 1003,
        dpadDown: 1004,
        dpadCenter: 1005
      };
      const macro = exports('macro', {
        SUPPORT_TEXTURE_FORMATS,
        KEY,
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 0.0000001192092896,
        ORIENTATION_PORTRAIT: Orientation.PORTRAIT,
        ORIENTATION_PORTRAIT_UPSIDE_DOWN: Orientation.PORTRAIT_UPSIDE_DOWN,
        ORIENTATION_LANDSCAPE: Orientation.LANDSCAPE,
        ORIENTATION_LANDSCAPE_LEFT: Orientation.LANDSCAPE_LEFT,
        ORIENTATION_LANDSCAPE_RIGHT: Orientation.LANDSCAPE_RIGHT,
        ORIENTATION_AUTO: Orientation.AUTO,
        ENABLE_TILEDMAP_CULLING: true,
        TOUCH_TIMEOUT: 5000,
        ENABLE_TRANSPARENT_CANVAS: false,
        ENABLE_WEBGL_ANTIALIAS: true,
        ENABLE_FLOAT_OUTPUT: false,
        CLEANUP_IMAGE_CACHE: false,
        ENABLE_MULTI_TOUCH: true,
        MAX_LABEL_CANVAS_POOL_SIZE: 20,
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: false,
        BATCHER2D_MEM_INCREMENT: 144,
        CUSTOM_PIPELINE_NAME: '',
        init() {
          {
            this.CLEANUP_IMAGE_CACHE = true;
          }
          const defaultValues = settings.querySettings(Settings.Category.ENGINE, 'macros');
          if (defaultValues) {
            for (const key in defaultValues) {
              macro[key] = defaultValues[key];
            }
          }
        }
      });
      legacyCC.macro = macro;

      function setTimeoutRAF(callback, delay, ...args) {
        var _globalThis$__globalX;
        const start = performance.now();
        const raf = requestAnimationFrame || window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (raf === undefined || (_globalThis$__globalX = globalThis.__globalXR) !== null && _globalThis$__globalX !== void 0 && _globalThis$__globalX.isWebXR) {
          return setTimeout(callback, delay, ...args);
        }
        const handleRAF = () => {
          if (performance.now() - start < delay) {
            raf(handleRAF);
          } else {
            callback(...args);
          }
        };
        return raf(handleRAF);
      }

      const BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
      const BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      const values = new Array(123);
      for (let i = 0; i < 123; ++i) {
        values[i] = 64;
      }
      for (let i = 0; i < 64; ++i) {
        values[BASE64_KEYS.charCodeAt(i)] = i;
      }
      const BASE64_VALUES = values;
      function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
        function define(np, propName, getter, setter) {
          const pd = Object.getOwnPropertyDescriptor(np, propName);
          if (pd) {
            if (pd.get) {
              np[getter] = pd.get;
            }
            if (pd.set && setter) {
              np[setter] = pd.set;
            }
          } else {
            const getterFunc = np[getter];
            {
              getset(np, propName, getterFunc, np[setter]);
            }
          }
        }
        let propName;
        const np = ctor.prototype;
        for (let i = 0; i < sameNameGetSets.length; i++) {
          propName = sameNameGetSets[i];
          const suffix = propName[0].toUpperCase() + propName.slice(1);
          define(np, propName, `get${suffix}`, `set${suffix}`);
        }
        for (propName in diffNameGetSets) {
          const gs = diffNameGetSets[propName];
          define(np, propName, gs[0], gs[1]);
        }
      }
      function pushToMap(map, key, value, pushFront) {
        const exists = map[key];
        if (exists) {
          if (Array.isArray(exists)) {
            if (pushFront) {
              exists.push(exists[0]);
              exists[0] = value;
            } else {
              exists.push(value);
            }
          } else {
            map[key] = pushFront ? [value, exists] : [exists, value];
          }
        } else {
          map[key] = value;
        }
      }
      function contains$1(refNode, otherNode) {
        if (typeof refNode.contains === 'function') {
          return refNode.contains(otherNode);
        } else if (typeof refNode.compareDocumentPosition === 'function') {
          return !!(refNode.compareDocumentPosition(otherNode) & 16);
        } else {
          let node = otherNode.parentNode;
          if (node) {
            do {
              if (node === refNode) {
                return true;
              } else {
                node = node.parentNode;
              }
            } while (node !== null);
          }
          return false;
        }
      }
      function isDomNode(node) {
        if (typeof window === 'object' && typeof Node === 'function') {
          return node instanceof Node;
        } else {
          return !!node && typeof node === 'object' && typeof node.nodeType === 'number' && typeof node.nodeName === 'string';
        }
      }
      function callInNextTick(callback, p1, p2) {
        if (callback) {
          setTimeoutRAF(() => {
            callback(p1, p2);
          }, 0);
        }
      }
      function tryCatchFunctor_EDITOR(funcName) {
        return Function('target', `${'try {\n' + '  target.'}${funcName}();\n` + `}\n` + `catch (e) {\n` + `  cc._throw(e);\n` + `}`);
      }
      function isPlainEmptyObj_DEV(obj) {
        if (!obj || obj.constructor !== Object) {
          return false;
        }
        return isEmptyObject(obj);
      }
      function clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
          const temp = min_inclusive;
          min_inclusive = max_inclusive;
          max_inclusive = temp;
        }
        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
      }
      function degreesToRadians(angle) {
        return angle * macro.RAD;
      }
      function radiansToDegrees(angle) {
        return angle * macro.DEG;
      }
      legacyCC.misc = {
        BUILTIN_CLASSID_RE,
        BASE64_VALUES,
        propertyDefine,
        pushToMap,
        contains: contains$1,
        isDomNode,
        callInNextTick,
        isPlainEmptyObj_DEV,
        clampf,
        degreesToRadians,
        radiansToDegrees
      };

      var misc = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        clampf: clampf,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees
      });
      exports('misc', misc);

      const DELIMETER$1 = '$_$';
      function createAttrsSingle(owner, superAttrs) {
        const attrs = superAttrs ? Object.create(superAttrs) : {};
        value(owner, '__attrs__', attrs);
        return attrs;
      }
      function createAttrs(subclass) {
        if (typeof subclass !== 'function') {
          const instance = subclass;
          return createAttrsSingle(instance, getClassAttrs(instance.constructor));
        }
        let superClass;
        const chains = legacyCC.Class.getInheritanceChain(subclass);
        for (let i = chains.length - 1; i >= 0; i--) {
          const cls = chains[i];
          const attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;
          if (!attrs) {
            superClass = chains[i + 1];
            createAttrsSingle(cls, superClass && superClass.__attrs__);
          }
        }
        superClass = chains[0];
        createAttrsSingle(subclass, superClass && superClass.__attrs__);
        return subclass.__attrs__;
      }
      function attr(constructor, propertyName) {
        const attrs = getClassAttrs(constructor);
        const prefix = propertyName + DELIMETER$1;
        const ret = {};
        for (const key in attrs) {
          if (key.startsWith(prefix)) {
            ret[key.slice(prefix.length)] = attrs[key];
          }
        }
        return ret;
      }
      function getClassAttrs(constructor) {
        return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
      }
      function setClassAttr$1(ctor, propName, key, value) {
        getClassAttrs(ctor)[propName + DELIMETER$1 + key] = value;
      }
      class PrimitiveType$1 {
        constructor(name, defaultValue) {
          this.name = void 0;
          this.default = void 0;
          this.name = name;
          this.default = defaultValue;
        }
        toString() {
          return this.name;
        }
      }
      const CCInteger = exports('CCInteger', new PrimitiveType$1('Integer', 0));
      legacyCC.Integer = CCInteger;
      legacyCC.CCInteger = CCInteger;
      const CCFloat = exports('CCFloat', new PrimitiveType$1('Float', 0.0));
      legacyCC.Float = CCFloat;
      legacyCC.CCFloat = CCFloat;
      const CCBoolean = exports('CCBoolean', new PrimitiveType$1('Boolean', false));
      legacyCC.Boolean = CCBoolean;
      legacyCC.CCBoolean = CCBoolean;
      const CCString = exports('CCString', new PrimitiveType$1('String', ''));
      legacyCC.String = CCString;
      legacyCC.CCString = CCString;
      function getTypeChecker_ET(type, attributeName) {
        return function (constructor, mainPropertyName) {
          const propInfo = `"${getClassName(constructor)}.${mainPropertyName}"`;
          const mainPropAttrs = attr(constructor, mainPropertyName);
          let mainPropAttrsType = mainPropAttrs.type;
          if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
            mainPropAttrsType = 'Number';
          } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
            mainPropAttrsType = `${mainPropAttrsType}`;
          }
          if (mainPropAttrsType !== type) {
            warnID(3604, propInfo);
            return;
          }
          if (!mainPropAttrs.hasOwnProperty('default')) {
            return;
          }
          const defaultVal = mainPropAttrs.default;
          if (typeof defaultVal === 'undefined') {
            return;
          }
          const isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);
          if (isContainer) {
            return;
          }
          const defaultType = typeof defaultVal;
          const type_lowerCase = type.toLowerCase();
          if (defaultType === type_lowerCase) {
            if (type_lowerCase === 'object') {
              if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
              } else {
                return;
              }
            } else if (type !== 'Number') {
              warnID(3606, attributeName, propInfo, type);
            }
          } else if (defaultType !== 'function') {
            if (type === CCString.default && defaultVal == null) {
              warnID(3607, propInfo);
            } else {
              warnID(3611, attributeName, propInfo, defaultType);
            }
          } else {
            return;
          }
          delete mainPropAttrs.type;
        };
      }
      function getObjTypeChecker_ET(typeCtor) {
        return function (classCtor, mainPropName) {
          getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
          const defaultDef = getClassAttrs(classCtor)[`${mainPropName + DELIMETER$1}default`];
          const defaultVal = legacyCC.Class.getDefault(defaultDef);
          if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
            const typename = getClassName(typeCtor);
            const info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
            if (defaultDef) {
              log(info);
            } else {
              warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
            }
          }
        };
      }

      var attributeUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DELIMETER: DELIMETER$1,
        createAttrsSingle: createAttrsSingle,
        createAttrs: createAttrs,
        attr: attr,
        getClassAttrs: getClassAttrs,
        setClassAttr: setClassAttr$1,
        PrimitiveType: PrimitiveType$1,
        CCInteger: CCInteger,
        CCFloat: CCFloat,
        CCBoolean: CCBoolean,
        CCString: CCString,
        getTypeChecker_ET: getTypeChecker_ET,
        getObjTypeChecker_ET: getObjTypeChecker_ET
      });

      const SerializableAttrs = {
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
      };
      function parseNotify(val, propName, notify, properties) {
        if (val.get || val.set) {
          return;
        }
        if (val.hasOwnProperty('default')) {
          const newKey = `_N$${propName}`;
          val.get = function () {
            return this[newKey];
          };
          val.set = function (value) {
            const oldValue = this[newKey];
            this[newKey] = value;
            notify.call(this, oldValue);
          };
          const newValue = {};
          properties[newKey] = newValue;
          for (const attr in SerializableAttrs) {
            const v = SerializableAttrs[attr];
            if (val.hasOwnProperty(attr)) {
              newValue[attr] = val[attr];
              if (!v.canUsedInGet) {
                delete val[attr];
              }
            }
          }
        }
      }
      function parseType(val, type, className, propName) {
        if (Array.isArray(type)) {
          if (type.length > 0) {
            val.type = type = type[0];
          } else {
            return errorID(5508, className, propName);
          }
        }
        if (typeof type === 'function') {
          if (type === String) {
            val.type = legacyCC.String;
          } else if (type === Boolean) {
            val.type = legacyCC.Boolean;
          } else if (type === Number) {
            val.type = legacyCC.Float;
          }
        }
      }
      function _wrapOptions(isGetset, _default, type) {
        const res = isGetset || typeof _default === 'undefined' ? {
          _short: true
        } : {
          _short: true,
          default: _default
        };
        if (type) {
          res.type = type;
        }
        return res;
      }
      function getFullFormOfProperty(options, isGetset) {
        const isLiteral = options && options.constructor === Object;
        if (!isLiteral) {
          if (Array.isArray(options) && options.length > 0) {
            return _wrapOptions(isGetset, [], options);
          } else if (typeof options === 'function') {
            const type = options;
            return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
          } else if (options instanceof PrimitiveType$1) {
            return _wrapOptions(isGetset, undefined, options);
          } else {
            return _wrapOptions(isGetset, options);
          }
        }
        return null;
      }
      function preprocessAttrs(properties, className, cls) {
        for (const propName in properties) {
          let val = properties[propName];
          const fullForm = getFullFormOfProperty(val, false);
          if (fullForm) {
            val = properties[propName] = fullForm;
          }
          if (val) {
            const notify = val.notify;
            if (notify) {
              {
                parseNotify(val, propName, notify, properties);
              }
            }
            if ('type' in val) {
              parseType(val, val.type, className, propName);
            }
          }
        }
      }

      let requiringFrames = [];
      function push(module, uuid, script, importMeta) {
        if (script === undefined) {
          script = uuid;
          uuid = '';
        }
        requiringFrames.push({
          uuid,
          script,
          module,
          exports: module.exports,
          beh: null,
          importMeta
        });
      }
      function pop() {
        const frameInfo = requiringFrames.pop();
        const module = frameInfo.module;
        let exports = module.exports;
        if (exports === frameInfo.exports) {
          for (const anykey in exports) {
            return;
          }
          module.exports = exports = frameInfo.cls;
        }
      }
      function peek() {
        return requiringFrames[requiringFrames.length - 1];
      }
      legacyCC._RF = {
        push,
        pop,
        peek
      };

      let PropertyStashInternalFlag;
      (function (PropertyStashInternalFlag) {
        PropertyStashInternalFlag[PropertyStashInternalFlag["STANDALONE"] = 1] = "STANDALONE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_VISIBLE"] = 2] = "IMPLICIT_VISIBLE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_SERIALIZABLE"] = 4] = "IMPLICIT_SERIALIZABLE";
      })(PropertyStashInternalFlag || (PropertyStashInternalFlag = {}));

      function setPropertyEnumType(objectOrConstructor, propertyName, enumType) {
        setPropertyEnumTypeOnAttrs(getClassAttrs(objectOrConstructor), propertyName, enumType);
      }
      function setPropertyEnumTypeOnAttrs(attrs, propertyName, enumType) {
        attrs[`${propertyName}${DELIMETER$1}type`] = 'Enum';
        attrs[`${propertyName}${DELIMETER$1}enumList`] = Enum.getList(enumType);
      }

      const DELIMETER = DELIMETER$1;
      const CCCLASS_TAG = '__ctors__';
      const ENUM_TAG = exports('ENUM_TAG', 'Enum');
      const BITMASK_TAG = exports('BITMASK_TAG', 'BitMask');
      function pushUnique(array, item) {
        if (array.indexOf(item) < 0) {
          array.push(item);
        }
      }
      function appendProp(cls, name) {
        pushUnique(cls.__props__, name);
      }
      function defineProp(cls, className, propName, val) {
        appendProp(cls, propName);
        parseAttributes(cls, val, className, propName);
      }
      function defineGetSet(cls, name, propName, val) {
        const getter = val.get;
        val.set;
        if (getter) {
          parseAttributes(cls, val, name, propName);
          setClassAttr$1(cls, propName, 'serializable', false);
        }
      }
      function getDefault(defaultVal) {
        if (typeof defaultVal === 'function') {
          {
            return defaultVal();
          }
        }
        return defaultVal;
      }
      function doDefine(className, baseClass, options) {
        const ctor = options.ctor;
        value(ctor, CCCLASS_TAG, true, true);
        ctor.prototype;
        if (baseClass) {
          ctor.$super = baseClass;
        }
        setClassName(className, ctor);
        return ctor;
      }
      function define$2(className, baseClass, options) {
        const Component = legacyCC.Component;
        const frame = peek();
        if (frame && isChildClassOf(baseClass, Component)) {
          if (isChildClassOf(frame.cls, Component)) {
            errorID(3615);
            return null;
          }
          className = className || frame.script;
        }
        const cls = doDefine(className, baseClass, options);
        if (frame) {
          if (isChildClassOf(baseClass, Component)) {
            const uuid = frame.uuid;
            if (uuid) {
              _setClassId(uuid, cls);
            }
            frame.cls = cls;
          } else if (!isChildClassOf(frame.cls, Component)) {
            frame.cls = cls;
          }
        }
        return cls;
      }
      function getNewValueTypeCodeJit(value) {
        const clsName = getClassName(value);
        const type = value.constructor;
        let res = `new ${clsName}(`;
        for (let i = 0; i < type.__props__.length; i++) {
          const prop = type.__props__[i];
          const propVal = value[prop];
          res += propVal;
          if (i < type.__props__.length - 1) {
            res += ',';
          }
        }
        return `${res})`;
      }
      function escapeForJS$1(s) {
        return JSON.stringify(s).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
      }
      const IDENTIFIER_RE$1 = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
      function declareProperties(cls, className, properties, baseClass) {
        cls.__props__ = [];
        if (baseClass && baseClass.__props__) {
          cls.__props__ = baseClass.__props__.slice();
        }
        if (properties) {
          preprocessAttrs(properties, className);
          for (const propName in properties) {
            const val = properties[propName];
            if (!val.get && !val.set) {
              defineProp(cls, className, propName, val);
            } else {
              defineGetSet(cls, className, propName, val);
            }
          }
        }
        const attrs = getClassAttrs(cls);
        cls.__values__ = cls.__props__.filter(prop => attrs[`${prop}${DELIMETER}serializable`] !== false);
      }
      function CCClass(options) {
        let name = options.name;
        const base = options.extends;
        const cls = define$2(name, base, options);
        if (!name) {
          name = legacyCC.js.getClassName(cls);
        }
        cls._sealed = true;
        if (base) {
          base._sealed = false;
        }
        const properties = options.properties;
        declareProperties(cls, name, properties, base);
        const editor = options.editor;
        if (editor) {
          if (isChildClassOf(base, legacyCC.Component)) {
            legacyCC.Component._registerEditorProps(cls, editor);
          }
        }
        return cls;
      }
      CCClass._isCCClass = function isCCClass(constructor) {
        var _constructor$hasOwnPr;
        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, CCCLASS_TAG);
      };
      CCClass.fastDefine = function (className, constructor, serializableFields) {
        setClassName(className, constructor);
        const props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
        const attrs = getClassAttrs(constructor);
        for (let i = 0; i < props.length; i++) {
          const key = props[i];
          attrs[`${key + DELIMETER}visible`] = false;
          attrs[`${key + DELIMETER}default`] = serializableFields[key];
        }
      };
      CCClass.Attr = attributeUtils;
      CCClass.attr = attr;
      function isCCClassOrFastDefined(constructor) {
        var _constructor$hasOwnPr2;
        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr2 = constructor.hasOwnProperty) === null || _constructor$hasOwnPr2 === void 0 ? void 0 : _constructor$hasOwnPr2.call(constructor, '__values__');
      }
      CCClass.isCCClassOrFastDefined = isCCClassOrFastDefined;
      function getInheritanceChain(constructor) {
        const chain = [];
        for (;;) {
          constructor = getSuper(constructor);
          if (!constructor) {
            break;
          }
          if (constructor !== Object) {
            chain.push(constructor);
          }
        }
        return chain;
      }
      CCClass.getInheritanceChain = getInheritanceChain;
      const PrimitiveTypes = {
        Integer: 'Number',
        Float: 'Number',
        Boolean: 'Boolean',
        String: 'String'
      };
      function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
        let attrs = null;
        let propertyNamePrefix = '';
        function initAttrs() {
          propertyNamePrefix = propertyName + DELIMETER;
          return attrs = getClassAttrs(constructor);
        }
        if ('type' in attributes && typeof attributes.type === 'undefined') {
          warnID(3660, propertyName, className);
        }
        const type = attributes.type;
        if (type) {
          const primitiveType = PrimitiveTypes[type];
          if (primitiveType) {
            (attrs || initAttrs())[`${propertyNamePrefix}type`] = type;
          } else if (type === 'Object') ; else if (typeof type === 'object') {
            if (Enum.isEnum(type)) {
              setPropertyEnumTypeOnAttrs(attrs || initAttrs(), propertyName, type);
            } else if (BitMask.isBitMask(type)) {
              (attrs || initAttrs())[`${propertyNamePrefix}type`] = BITMASK_TAG;
              attrs[`${propertyNamePrefix}bitmaskList`] = BitMask.getList(type);
            } else ;
          } else if (typeof type === 'function') {
            (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Object';
            attrs[`${propertyNamePrefix}ctor`] = type;
          } else ;
        }
        if ('default' in attributes) {
          (attrs || initAttrs())[`${propertyNamePrefix}default`] = attributes.default;
        }
        const parseSimpleAttribute = (attributeName, expectType) => {
          if (attributeName in attributes) {
            const val = attributes[attributeName];
            if (typeof val === expectType) {
              (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
            }
          }
        };
        if (attributes.editorOnly) {
          {
            (attrs || initAttrs())[`${propertyNamePrefix}editorOnly`] = true;
          }
        }
        const isStandaloneMode = attributes.__internalFlags & PropertyStashInternalFlag.STANDALONE;
        let normalizedSerializable;
        if (isStandaloneMode) {
          normalizedSerializable = attributes.serializable === true || (attributes.__internalFlags & PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE) !== 0;
        } else if (attributes.serializable === false) {
          normalizedSerializable = false;
        }
        if (typeof normalizedSerializable !== 'undefined') {
          (attrs || initAttrs())[`${propertyNamePrefix}serializable`] = normalizedSerializable;
        }
        parseSimpleAttribute('formerlySerializedAs', 'string');
        const range = attributes.range;
        if (range) {
          if (Array.isArray(range)) {
            if (range.length >= 2) {
              (attrs || initAttrs())[`${propertyNamePrefix}min`] = range[0];
              attrs[`${propertyNamePrefix}max`] = range[1];
              if (range.length > 2) {
                attrs[`${propertyNamePrefix}step`] = range[2];
              }
            }
          }
        }
        parseSimpleAttribute('min', 'number');
        parseSimpleAttribute('max', 'number');
        parseSimpleAttribute('step', 'number');
      }
      CCClass.isArray = function (defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      };
      CCClass.getDefault = getDefault;
      CCClass.escapeForJS = escapeForJS$1;
      CCClass.IDENTIFIER_RE = IDENTIFIER_RE$1;
      CCClass.getNewValueTypeCode = getNewValueTypeCodeJit;
      legacyCC.Class = CCClass;

      const _d2r = Math.PI / 180.0;
      const _r2d = 180.0 / Math.PI;
      let _random = Math.random;
      const HALF_PI = exports('HALF_PI', Math.PI * 0.5);
      const TWO_PI = exports('TWO_PI', Math.PI * 2.0);
      const EPSILON$2 = exports('EPSILON', 0.000001);
      function equals$1(a, b) {
        return Math.abs(a - b) <= EPSILON$2 * Math.max(1.0, Math.abs(a), Math.abs(b));
      }
      function approx(a, b, maxDiff) {
        maxDiff = maxDiff || EPSILON$2;
        return Math.abs(a - b) <= maxDiff;
      }
      function clamp$1(val, min, max) {
        if (min > max) {
          const temp = min;
          min = max;
          max = temp;
        }
        return val < min ? min : val > max ? max : val;
      }
      function clamp01(val) {
        return val < 0 ? 0 : val > 1 ? 1 : val;
      }
      function lerp(from, to, ratio) {
        return from + (to - from) * ratio;
      }
      function toRadian(a) {
        return a * _d2r;
      }
      function toDegree(a) {
        return a * _r2d;
      }
      function random() {
        return _random();
      }
      function setRandGenerator(func) {
        _random = func;
      }
      function randomRange(min, max) {
        return random() * (max - min) + min;
      }
      function randomRangeInt(min, max) {
        return Math.floor(randomRange(min, max));
      }
      function pseudoRandom(seed) {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280.0;
      }
      function pseudoRandomRange(seed, min, max) {
        return pseudoRandom(seed) * (max - min) + min;
      }
      function pseudoRandomRangeInt(seed, min, max) {
        return Math.floor(pseudoRandomRange(seed, min, max));
      }
      function nextPow2(val) {
        return nextPow2$1(val);
      }
      function repeat$2(t, length) {
        return t - Math.floor(t / length) * length;
      }
      function pingPong(t, length) {
        t = repeat$2(t, length * 2);
        t = length - Math.abs(t - length);
        return t;
      }
      function inverseLerp(from, to, value) {
        return (value - from) / (to - from);
      }
      function absMaxComponent(v) {
        if (Math.abs(v.x) > Math.abs(v.y)) {
          if (Math.abs(v.x) > Math.abs(v.z)) {
            return v.x;
          } else {
            return v.z;
          }
        } else if (Math.abs(v.y) > Math.abs(v.z)) {
          return v.y;
        } else {
          return v.z;
        }
      }
      function absMax(a, b) {
        if (Math.abs(a) > Math.abs(b)) {
          return a;
        } else {
          return b;
        }
      }
      function enumerableProps(prototype, attrs) {
        attrs.forEach(key => {
          Object.defineProperty(prototype, key, {
            enumerable: true
          });
        });
      }
      const toHalf = function () {
        const floatView = new Float32Array(1);
        const int32View = new Int32Array(floatView.buffer);
        return function toHalf(fval) {
          floatView[0] = fval;
          const fbits = int32View[0];
          const s = fbits >> 16 & 0x8000;
          const em = fbits & 0x7fffffff;
          let h = em - (112 << 23) + (1 << 12) >> 13;
          h = em < 113 << 23 ? 0 : h;
          h = em >= 143 << 23 ? 0x7c00 : h;
          h = em > 255 << 23 ? 0x7e00 : h;
          int32View[0] = s | h;
          return int32View[0];
        };
      }();
      const fromHalf = function () {
        const floatView = new Float32Array(1);
        const int32View = new Int32Array(floatView.buffer);
        return function fromHalf(hval) {
          const s = hval >> 15 & 0x00000001;
          const em = hval & 0x00007fff;
          let h = em << 13;
          let fbits = 0;
          if (h !== 0x7c00) {
            h += 112 << 23;
            if (em === 0) {
              h = (h & 0xfffff) >> 1;
            } else if (em === 0x7fff) {
              h = 0x7fffffff;
            }
          } else {
            h = 0x7f800000;
          }
          fbits = s << 31 | h;
          int32View[0] = fbits;
          return floatView[0];
        };
      }();
      function floatToHalf(val) {
        return toHalf(val);
      }
      function halfToFloat(val) {
        return fromHalf(val);
      }

      var _class$1S;
      class Vec4 extends ValueType {
        static clone(a) {
          return new Vec4(a.x, a.y, a.z, a.w);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        }
        static set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static fromColor(out, color) {
          out.x = color.r;
          out.y = color.g;
          out.z = color.b;
          out.w = color.a;
          return out;
        }
        static angle(a, b) {
          const dx = a.y * b.z - a.z * b.y;
          const dy = a.z * b.x - a.x * b.z;
          const dz = a.x * b.y - a.y * b.x;
          const dotVal = a.x * b.x + a.y * b.y + a.z * b.z;
          return Math.atan2(Math.sqrt(dx * dx + dy * dy + dz * dz), dotVal);
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          out.w = a.w + b.w;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          out.w = a.w - b.w;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          out.w = a.w * b.w;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          out.w = a.w / b.w;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          out.w = Math.ceil(a.w);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          out.w = Math.floor(a.w);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          out.w = Math.min(a.w, b.w);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          out.w = Math.max(a.w, b.w);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          out.w = Math.round(a.w);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          const w = b.w - a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          const w = b.w - a.w;
          return x * x + y * y + z * z + w * w;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          return x * x + y * y + z * z + w * w;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = -a.w;
          return out;
        }
        static inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          out.w = 1.0 / a.w;
          return out;
        }
        static inverseSafe(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          if (Math.abs(z) < EPSILON$2) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }
          if (Math.abs(w) < EPSILON$2) {
            out.w = 0;
          } else {
            out.w = 1.0 / w;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          let len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
            out.w = w * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        }
        static scale(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const phi = random() * 2.0 * Math.PI;
          const cosTheta = random() * 2 - 1;
          const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          out.w = 0;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          const w = a.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
          return out;
        }
        static transformAffine(out, v, m) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          const w = v.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = v.w;
          return out;
        }
        static transformQuat(out, a, q) {
          const {
            x,
            y,
            z
          } = a;
          const _x = q.x;
          const _y = q.y;
          const _z = q.z;
          const _w = q.w;
          const ix = _w * x + _y * z - _z * y;
          const iy = _w * y + _z * x - _x * z;
          const iz = _w * z + _x * y - _y * x;
          const iw = -_x * x - _y * y - _z * z;
          out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
          out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
          out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
          out.w = a.w;
          return out;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          out[ofs + 3] = v.w;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const hasInf = Math.abs(a.x) === Infinity || Math.abs(a.y) === Infinity || Math.abs(a.z) === Infinity || Math.abs(a.w) === Infinity || Math.abs(b.x) === Infinity || Math.abs(b.y) === Infinity || Math.abs(b.z) === Infinity || Math.abs(b.w) === Infinity;
          return !hasInf && Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        }
        constructor(x, y, z, w) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
        }
        clone() {
          return new Vec4(this.x, this.y, this.z, this.w);
        }
        set(x, y, z, w) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        }
        equals4f(x, y, z, w, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(w));
        }
        strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
        strictEquals4f(x, y, z, w) {
          return this.x === x && this.y === y && this.z === z && this.w === w;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          this.z = z + ratio * (to.z - z);
          this.w = w + ratio * (to.w - w);
          return this;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)}, ${this.w.toFixed(2)})`;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp$1(this.z, minInclusive.z, maxInclusive.z);
          this.w = clamp$1(this.w, minInclusive.w, maxInclusive.w);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          this.w += other.w;
          return this;
        }
        add4f(x, y, z, w) {
          this.x += x;
          this.y += y;
          this.z += z;
          this.w += w;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          this.w -= other.w;
          return this;
        }
        subtract4f(x, y, z, w) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          this.w -= w;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec4.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec4.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          this.w *= other.w;
          return this;
        }
        multiply4f(x, y, z, w) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          this.w *= w;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          this.w /= other.w;
          return this;
        }
        divide4f(x, y, z, w) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          this.w /= w;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(vector) {
          return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        }
        cross(vector) {
          const {
            x: ax,
            y: ay,
            z: az
          } = this;
          const {
            x: bx,
            y: by,
            z: bz
          } = vector;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        length() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        }
        lengthSqr() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return x * x + y * y + z * z + w * w;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
          }
          return this;
        }
        scale(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
          this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
          this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
          return this;
        }
      } exports('Vec4', Vec4);
      _class$1S = Vec4;
      Vec4.ZERO = Object.freeze(new _class$1S(0, 0, 0, 0));
      Vec4.ONE = Object.freeze(new _class$1S(1, 1, 1, 1));
      Vec4.NEG_ONE = Object.freeze(new _class$1S(-1, -1, -1, -1));
      Vec4.UNIT_X = Object.freeze(new _class$1S(1, 0, 0, 0));
      Vec4.UNIT_Y = Object.freeze(new _class$1S(0, 1, 0, 0));
      Vec4.UNIT_Z = Object.freeze(new _class$1S(0, 0, 1, 0));
      Vec4.UNIT_W = Object.freeze(new _class$1S(0, 0, 0, 1));
      CCClass.fastDefine('cc.Vec4', Vec4, {
        x: 0,
        y: 0,
        z: 0,
        w: 0
      });
      legacyCC.Vec4 = Vec4;
      function v4(x, y, z, w) {
        return new Vec4(x, y, z, w);
      }
      legacyCC.v4 = v4;

      var _class$1R;
      class Vec3 extends ValueType {
        static zero(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          return out;
        }
        static clone(a) {
          return new Vec3(a.x, a.y, a.z);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          return out;
        }
        static set(out, x, y, z) {
          out.x = x;
          out.y = y;
          out.z = z;
          return out;
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          return Math.sqrt(x * x + y * y + z * z);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          const z = b.z - a.z;
          return x * x + y * y + z * z;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          return Math.sqrt(x * x + y * y + z * z);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          return x * x + y * y + z * z;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          return out;
        }
        static invert(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          return out;
        }
        static invertSafe(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          if (Math.abs(z) < EPSILON$2) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }
        static cross(out, a, b) {
          const {
            x: ax,
            y: ay,
            z: az
          } = a;
          const {
            x: bx,
            y: by,
            z: bz
          } = b;
          out.x = ay * bz - az * by;
          out.y = az * bx - ax * bz;
          out.z = ax * by - ay * bx;
          return out;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const phi = random() * 2.0 * Math.PI;
          const cosTheta = random() * 2 - 1;
          const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
          rhw = rhw ? 1 / rhw : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
          return out;
        }
        static transformMat4Normal(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          let rhw = m.m03 * x + m.m07 * y + m.m11 * z;
          rhw = rhw ? 1 / rhw : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
          return out;
        }
        static transformMat3(out, a, m) {
          const x = a.x;
          const y = a.y;
          const z = a.z;
          out.x = x * m.m00 + y * m.m03 + z * m.m06;
          out.y = x * m.m01 + y * m.m04 + z * m.m07;
          out.z = x * m.m02 + y * m.m05 + z * m.m08;
          return out;
        }
        static transformAffine(out, v, m) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
          return out;
        }
        static transformQuat(out, a, q) {
          const ix = q.w * a.x + q.y * a.z - q.z * a.y;
          const iy = q.w * a.y + q.z * a.x - q.x * a.z;
          const iz = q.w * a.z + q.x * a.y - q.y * a.x;
          const iw = -q.x * a.x - q.y * a.y - q.z * a.z;
          out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
          out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
          out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
          return out;
        }
        static transformRTS(out, a, r, t, s) {
          const x = a.x * s.x;
          const y = a.y * s.y;
          const z = a.z * s.z;
          const ix = r.w * x + r.y * z - r.z * y;
          const iy = r.w * y + r.z * x - r.x * z;
          const iz = r.w * z + r.x * y - r.y * x;
          const iw = -r.x * x - r.y * y - r.z * z;
          out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
          out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
          out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
          return out;
        }
        static transformInverseRTS(out, a, r, t, s) {
          const x = a.x - t.x;
          const y = a.y - t.y;
          const z = a.z - t.z;
          const ix = r.w * x - r.y * z + r.z * y;
          const iy = r.w * y - r.z * x + r.x * z;
          const iz = r.w * z - r.x * y + r.y * x;
          const iw = r.x * x + r.y * y + r.z * z;
          out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
          out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
          out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
          return out;
        }
        static rotateX(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x;
          const ry = y * cos - z * sin;
          const rz = y * sin + z * cos;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateY(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = z * sin + x * cos;
          const ry = y;
          const rz = z * cos - x * sin;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateZ(out, v, o, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x * cos - y * sin;
          const ry = x * sin + y * cos;
          const rz = z;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static rotateN(out, v, o, n, a) {
          const x = v.x - o.x;
          const y = v.y - o.y;
          const z = v.z - o.z;
          const nx = n.x;
          const ny = n.y;
          const nz = n.z;
          const cos = Math.cos(a);
          const sin = Math.sin(a);
          const rx = x * (nx * nx * (1.0 - cos) + cos) + y * (nx * ny * (1.0 - cos) - nz * sin) + z * (nx * nz * (1.0 - cos) + ny * sin);
          const ry = x * (nx * ny * (1.0 - cos) + nz * sin) + y * (ny * ny * (1.0 - cos) + cos) + z * (ny * nz * (1.0 - cos) - nx * sin);
          const rz = x * (nx * nz * (1.0 - cos) - ny * sin) + y * (ny * nz * (1.0 - cos) + nx * sin) + z * (nz * nz * (1.0 - cos) + cos);
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const {
            x: a0,
            y: a1,
            z: a2
          } = a;
          const {
            x: b0,
            y: b1,
            z: b2
          } = b;
          return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
        }
        static angle(a, b) {
          const magSqr1 = a.x * a.x + a.y * a.y + a.z * a.z;
          const magSqr2 = b.x * b.x + b.y * b.y + b.z * b.z;
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = a.x * b.x + a.y * b.y + a.z * b.z;
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        static projectOnPlane(out, a, n) {
          return Vec3.subtract(out, a, Vec3.project(out, a, n));
        }
        static project(out, a, b) {
          const sqrLen = Vec3.lengthSqr(b);
          if (sqrLen < 0.000001) {
            return Vec3.set(out, 0, 0, 0);
          } else {
            return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
          }
        }
        static moveTowards(out, current, target, maxStep) {
          const deltaX = target.x - current.x;
          const deltaY = target.y - current.y;
          const deltaZ = target.z - current.z;
          const distanceSqr = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
          if (distanceSqr === 0 || maxStep >= 0 && distanceSqr < maxStep * maxStep) {
            out.x = target.x;
            out.y = target.y;
            out.z = target.z;
            return out;
          }
          const distance = Math.sqrt(distanceSqr);
          const scale = maxStep / distance;
          out.x = current.x + deltaX * scale;
          out.y = current.y + deltaY * scale;
          out.z = current.z + deltaZ * scale;
          return out;
        }
        static generateOrthogonal(out, n) {
          const {
            x,
            y,
            z
          } = n;
          const absX = Math.abs(x);
          const absY = Math.abs(y);
          const absZ = Math.abs(z);
          if (absX < absY && absX < absZ) {
            Vec3.set(out, 0.0, z, -y);
          } else if (absY < absZ) {
            Vec3.set(out, z, 0.0, -x);
          } else {
            Vec3.set(out, y, -x, 0.0);
          }
          return Vec3.normalize(out, out);
        }
        constructor(x, y, z) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
        }
        clone() {
          return new Vec3(this.x, this.y, this.z);
        }
        set(x, y, z) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon && Math.abs(this.y - other.y) <= epsilon && Math.abs(this.z - other.z) <= epsilon;
        }
        equals3f(x, y, z, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon && Math.abs(this.y - y) <= epsilon && Math.abs(this.z - z) <= epsilon;
        }
        strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z;
        }
        strictEquals3f(x, y, z) {
          return this.x === x && this.y === y && this.z === z;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)})`;
        }
        lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          return this;
        }
        add3f(x, y, z) {
          this.x += x;
          this.y += y;
          this.z += z;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          return this;
        }
        subtract3f(x, y, z) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec3.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec3.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          return this;
        }
        multiply3f(x, y, z) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          return this;
        }
        divide3f(x, y, z) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp$1(this.z, minInclusive.z, maxInclusive.z);
          return this;
        }
        dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z;
        }
        cross(other) {
          const {
            x: ax,
            y: ay,
            z: az
          } = this;
          const {
            x: bx,
            y: by,
            z: bz
          } = other;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          let len = x * x + y * y + z * z;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
          }
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          let rhw = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15;
          rhw = rhw ? 1 / rhw : 1;
          this.x = (matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12) * rhw;
          this.y = (matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13) * rhw;
          this.z = (matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14) * rhw;
          return this;
        }
      } exports('Vec3', Vec3);
      _class$1R = Vec3;
      Vec3.UNIT_X = Object.freeze(new _class$1R(1, 0, 0));
      Vec3.UNIT_Y = Object.freeze(new _class$1R(0, 1, 0));
      Vec3.UNIT_Z = Object.freeze(new _class$1R(0, 0, 1));
      Vec3.RIGHT = Object.freeze(new _class$1R(1, 0, 0));
      Vec3.UP = Object.freeze(new _class$1R(0, 1, 0));
      Vec3.FORWARD = Object.freeze(new _class$1R(0, 0, -1));
      Vec3.ZERO = Object.freeze(new _class$1R(0, 0, 0));
      Vec3.ONE = Object.freeze(new _class$1R(1, 1, 1));
      Vec3.NEG_ONE = Object.freeze(new _class$1R(-1, -1, -1));
      Vec3.slerp = (() => {
        const cacheV1 = new _class$1R();
        const cacheV2 = new _class$1R();
        const cacheV3 = new _class$1R();
        return (out, from, to, t) => {
          const EPSILON = 1e-5;
          const lenFrom = _class$1R.len(from);
          const lenTo = _class$1R.len(to);
          if (lenFrom < EPSILON || lenTo < EPSILON) {
            return _class$1R.lerp(out, from, to, t);
          }
          const lenLerped = lerp(lenFrom, lenTo, t);
          const dot = _class$1R.dot(from, to) / (lenFrom * lenTo);
          if (dot > 1.0 - EPSILON) {
            return _class$1R.lerp(out, from, to, t);
          } else if (dot < -1.0 + EPSILON) {
            const fromNormalized = _class$1R.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
            const axis = _class$1R.generateOrthogonal(cacheV2, fromNormalized);
            const angle = Math.PI * t;
            rotateAxisAngle(cacheV3, fromNormalized, axis, angle);
            _class$1R.multiplyScalar(out, cacheV3, lenLerped);
            return out;
          } else {
            const dotClamped = dot;
            const theta = Math.acos(dotClamped) * t;
            const fromNormalized = _class$1R.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
            const toNormalized = _class$1R.multiplyScalar(cacheV2, to, 1.0 / lenTo);
            _class$1R.scaleAndAdd(cacheV3, toNormalized, fromNormalized, -dotClamped);
            _class$1R.normalize(cacheV3, cacheV3);
            _class$1R.multiplyScalar(cacheV3, cacheV3, Math.sin(theta));
            _class$1R.scaleAndAdd(cacheV3, cacheV3, fromNormalized, Math.cos(theta));
            _class$1R.multiplyScalar(out, cacheV3, lenLerped);
            return out;
          }
        };
      })();
      Vec3.signedAngle = (() => {
        const cacheCross = new _class$1R();
        return (a, b, normal) => {
          const angle = _class$1R.angle(a, b);
          const cross = _class$1R.cross(cacheCross, a, b);
          const dot = _class$1R.dot(cross, normal);
          return dot < 0 ? -angle : angle;
        };
      })();
      CCClass.fastDefine('cc.Vec3', Vec3, {
        x: 0,
        y: 0,
        z: 0
      });
      legacyCC.Vec3 = Vec3;
      function v3(x, y, z) {
        return new Vec3(x, y, z);
      }
      const rotateAxisAngle = (() => {
        const cacheQ = {
          x: 0.0,
          y: 0.0,
          z: 0.0,
          w: 0.0
        };
        return (out, input, axis, angle) => {
          const rad = angle * 0.5;
          const s = Math.sin(rad);
          cacheQ.x = s * axis.x;
          cacheQ.y = s * axis.y;
          cacheQ.z = s * axis.z;
          cacheQ.w = Math.cos(rad);
          Vec3.transformQuat(out, input, cacheQ);
          return out;
        };
      })();
      legacyCC.v3 = v3;

      var _class$1Q;
      const toFloat = 1 / 255;
      class Color$1 extends ValueType {
        static clone(a) {
          const out = new Color$1();
          if (a._val) {
            out._val = a._val;
          } else {
            out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
          }
          return out;
        }
        static copy(out, a) {
          out.r = a.r;
          out.g = a.g;
          out.b = a.b;
          out.a = a.a;
          return out;
        }
        static set(out, r, g, b, a) {
          out.r = r;
          out.g = g;
          out.b = b;
          out.a = a;
          return out;
        }
        static toVec4(color, out) {
          out = out !== undefined ? out : new Vec4();
          out.x = color.r * toFloat;
          out.y = color.g * toFloat;
          out.z = color.b * toFloat;
          out.w = color.a * toFloat;
          return out;
        }
        static fromVec4(value, out) {
          out = out === undefined ? new Color$1() : out;
          out.r = Math.floor(value.x / toFloat);
          out.g = Math.floor(value.y / toFloat);
          out.b = Math.floor(value.z / toFloat);
          out.a = Math.floor(value.w / toFloat);
          return out;
        }
        static fromHEX(out, hex) {
          let hexNumber;
          if (typeof hex === 'string') {
            hex = hex[0] === '#' ? hex.substring(1) : hex;
            if (hex.length === 6) {
              hex += 'FF';
            } else if (hex.length === 3) {
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + 'FF';
            } else if (hex.length === 4) {
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            }
            hexNumber = Number('0x' + hex);
          } else {
            if (hex < 0x1000000) {
              hex = (hex << 8) + 0xff;
            }
            hexNumber = hex;
          }
          out.r = hexNumber >>> 24;
          out.g = (hexNumber & 0x00ff0000) >>> 16;
          out.b = (hexNumber & 0x0000ff00) >>> 8;
          out.a = hexNumber & 0x000000ff;
          out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
          return out;
        }
        static add(out, a, b) {
          out.r = a.r + b.r;
          out.g = a.g + b.g;
          out.b = a.b + b.b;
          out.a = a.a + b.a;
          return out;
        }
        static subtract(out, a, b) {
          out.r = a.r - b.r;
          out.g = a.g - b.g;
          out.b = a.b - b.b;
          out.a = a.a - b.a;
          return out;
        }
        static multiply(out, a, b) {
          out.r = a.r * b.r;
          out.g = a.g * b.g;
          out.b = a.b * b.b;
          out.a = a.a * b.a;
          return out;
        }
        static divide(out, a, b) {
          out.r = a.r / b.r;
          out.g = a.g / b.g;
          out.b = a.b / b.b;
          out.a = a.a / b.a;
          return out;
        }
        static scale(out, a, b) {
          out.r = a.r * b;
          out.g = a.g * b;
          out.b = a.b * b;
          out.a = a.a * b;
          return out;
        }
        static lerp(out, from, to, ratio) {
          let r = from.r;
          let g = from.g;
          let b = from.b;
          let a = from.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return out;
        }
        static toArray(out, a, ofs = 0) {
          const scale = a instanceof Color$1 || a.a > 1 ? 1 / 255 : 1;
          out[ofs + 0] = a.r * scale;
          out[ofs + 1] = a.g * scale;
          out[ofs + 2] = a.b * scale;
          out[ofs + 3] = a.a * scale;
          return out;
        }
        static fromArray(arr, out, ofs = 0) {
          out.r = arr[ofs + 0] * 255;
          out.g = arr[ofs + 1] * 255;
          out.b = arr[ofs + 2] * 255;
          out.a = arr[ofs + 3] * 255;
          return out;
        }
        static fromUint32(out, uint32) {
          out._val = uint32;
          return out;
        }
        static toUint32(color) {
          return color._val;
        }
        static strictEquals(a, b) {
          return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          const hasInf = Math.abs(a.r) === Infinity || Math.abs(a.g) === Infinity || Math.abs(a.b) === Infinity || Math.abs(a.a) === Infinity;
          return !hasInf && Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
        }
        static hex(a) {
          return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
        }
        get r() {
          return this._val & 0x000000ff;
        }
        set r(red) {
          red = ~~clamp$1(red, 0, 255);
          this._val = (this._val & 0xffffff00 | red) >>> 0;
        }
        get g() {
          return (this._val & 0x0000ff00) >> 8;
        }
        set g(green) {
          green = ~~clamp$1(green, 0, 255);
          this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
        }
        get b() {
          return (this._val & 0x00ff0000) >> 16;
        }
        set b(blue) {
          blue = ~~clamp$1(blue, 0, 255);
          this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
        }
        get a() {
          return (this._val & 0xff000000) >>> 24;
        }
        set a(alpha) {
          alpha = ~~clamp$1(alpha, 0, 255);
          this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
        }
        get x() {
          return this.r * toFloat;
        }
        set x(value) {
          this.r = value * 255;
        }
        get y() {
          return this.g * toFloat;
        }
        set y(value) {
          this.g = value * 255;
        }
        get z() {
          return this.b * toFloat;
        }
        set z(value) {
          this.b = value * 255;
        }
        get w() {
          return this.a * toFloat;
        }
        set w(value) {
          this.a = value * 255;
        }
        constructor(r, g, b, a) {
          super();
          this._val = 0;
          if (typeof r === 'string') {
            this.fromHEX(r);
          } else if (g !== undefined) {
            this.set(r, g, b, a);
          } else {
            this.set(r);
          }
        }
        clone() {
          const ret = new Color$1();
          ret._val = this._val;
          return ret;
        }
        equals(other) {
          return other && this._val === other._val;
        }
        lerp(to, ratio) {
          let r = this.r;
          let g = this.g;
          let b = this.b;
          let a = this.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return this;
        }
        toString() {
          return `rgba(${this.r.toFixed()}, ${this.g.toFixed()}, ${this.b.toFixed()}, ${this.a.toFixed()})`;
        }
        toCSS(opt = 'rgba') {
          if (opt === 'rgba') {
            return `rgba(${this.r},${this.g},${this.b},${(this.a * toFloat).toFixed(2)})`;
          } else if (opt === 'rgb') {
            return `rgb(${this.r},${this.g},${this.b})`;
          } else {
            return `#${this.toHEX(opt)}`;
          }
        }
        fromHEX(hex) {
          let hexNumber;
          if (typeof hex === 'string') {
            hex = hex[0] === '#' ? hex.substring(1) : hex;
            if (hex.length === 6) {
              hex += 'FF';
            } else if (hex.length === 3) {
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + 'FF';
            } else if (hex.length === 4) {
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            }
            hexNumber = Number('0x' + hex);
          } else {
            if (hex < 0x1000000) {
              hex = (hex << 8) + 0xff;
            }
            hexNumber = hex;
          }
          const r = hexNumber >>> 24;
          const g = (hexNumber & 0x00ff0000) >>> 16;
          const b = (hexNumber & 0x0000ff00) >>> 8;
          const a = hexNumber & 0x000000ff;
          this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
          return this;
        }
        toHEX(fmt = '#rrggbb') {
          const prefix = '0';
          const hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];
          if (fmt === '#rgb') {
            hex[0] = hex[0][0];
            hex[1] = hex[1][0];
            hex[2] = hex[2][0];
          } else if (fmt === '#rrggbbaa') {
            hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
          }
          return hex.join('');
        }
        toRGBValue() {
          return this._val & 0x00ffffff;
        }
        fromHSV(h, s, v) {
          let r = 0;
          let g = 0;
          let b = 0;
          if (s === 0) {
            r = g = b = v;
          } else if (v === 0) {
            r = g = b = 0;
          } else {
            if (h === 1) {
              h = 0;
            }
            h *= 6;
            const i = Math.floor(h);
            const f = h - i;
            const p = v * (1 - s);
            const q = v * (1 - s * f);
            const t = v * (1 - s * (1 - f));
            switch (i) {
              default:
                assertIsTrue(false);
              case 0:
                r = v;
                g = t;
                b = p;
                break;
              case 1:
                r = q;
                g = v;
                b = p;
                break;
              case 2:
                r = p;
                g = v;
                b = t;
                break;
              case 3:
                r = p;
                g = q;
                b = v;
                break;
              case 4:
                r = t;
                g = p;
                b = v;
                break;
              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
          }
          r *= 255;
          g *= 255;
          b *= 255;
          this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          return this;
        }
        toHSV() {
          const r = this.r * toFloat;
          const g = this.g * toFloat;
          const b = this.b * toFloat;
          const hsv = {
            h: 0,
            s: 0,
            v: 0
          };
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let delta = 0;
          hsv.v = max;
          hsv.s = max ? (max - min) / max : 0;
          if (!hsv.s) {
            hsv.h = 0;
          } else {
            delta = max - min;
            if (r === max) {
              hsv.h = (g - b) / delta;
            } else if (g === max) {
              hsv.h = 2 + (b - r) / delta;
            } else {
              hsv.h = 4 + (r - g) / delta;
            }
            hsv.h /= 6;
            if (hsv.h < 0) {
              hsv.h += 1.0;
            }
          }
          return hsv;
        }
        set(r, g, b, a) {
          if (typeof r === 'object') {
            if (r._val != null) {
              this._val = r._val;
            } else {
              g = r.g || 0;
              b = r.b || 0;
              a = typeof r.a === 'number' ? r.a : 255;
              r = r.r || 0;
              this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
            }
          } else {
            r = r || 0;
            g = g || 0;
            b = b || 0;
            a = typeof a === 'number' ? a : 255;
            this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          }
          return this;
        }
        multiply(other) {
          const r = (this._val & 0x000000ff) * other.r >> 8;
          const g = (this._val & 0x0000ff00) * other.g >> 8;
          const b = (this._val & 0x00ff0000) * other.b >> 8;
          const a = ((this._val & 0xff000000) >>> 8) * other.a;
          this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
          return this;
        }
        _set_r_unsafe(red) {
          this._val = (this._val & 0xffffff00 | red) >>> 0;
          return this;
        }
        _set_g_unsafe(green) {
          this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
          return this;
        }
        _set_b_unsafe(blue) {
          this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
          return this;
        }
        _set_a_unsafe(alpha) {
          this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
          return this;
        }
      } exports('Color', Color$1);
      _class$1Q = Color$1;
      Color$1.WHITE = Object.freeze(new _class$1Q(255, 255, 255, 255));
      Color$1.GRAY = Object.freeze(new _class$1Q(127, 127, 127, 255));
      Color$1.BLACK = Object.freeze(new _class$1Q(0, 0, 0, 255));
      Color$1.TRANSPARENT = Object.freeze(new _class$1Q(0, 0, 0, 0));
      Color$1.RED = Object.freeze(new _class$1Q(255, 0, 0, 255));
      Color$1.GREEN = Object.freeze(new _class$1Q(0, 255, 0, 255));
      Color$1.BLUE = Object.freeze(new _class$1Q(0, 0, 255, 255));
      Color$1.CYAN = Object.freeze(new _class$1Q(0, 255, 255, 255));
      Color$1.MAGENTA = Object.freeze(new _class$1Q(255, 0, 255, 255));
      Color$1.YELLOW = Object.freeze(new _class$1Q(255, 255, 0, 255));
      CCClass.fastDefine('cc.Color', Color$1, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      legacyCC.Color = Color$1;
      function color(r, g, b, a) {
        return new Color$1(r, g, b, a);
      }
      legacyCC.color = color;

      var _class$1P;
      class Mat3 extends ValueType {
        static clone(a) {
          return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
        }
        static copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        }
        static set(out, m00, m01, m02, m03, m04, m05, m06, m07, m08) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m03;
          out.m04 = m04;
          out.m05 = m05;
          out.m06 = m06;
          out.m07 = m07;
          out.m08 = m08;
          return out;
        }
        static identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static transpose(out, a) {
          if (out === a) {
            const a01 = a.m01;
            const a02 = a.m02;
            const a12 = a.m05;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a01;
            out.m05 = a.m07;
            out.m06 = a02;
            out.m07 = a12;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a.m01;
            out.m04 = a.m04;
            out.m05 = a.m07;
            out.m06 = a.m02;
            out.m07 = a.m05;
            out.m08 = a.m08;
          }
          return out;
        }
        static invert(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            return out;
          }
          det = 1.0 / det;
          out.m00 = b01 * det;
          out.m01 = (-a22 * a01 + a02 * a21) * det;
          out.m02 = (a12 * a01 - a02 * a11) * det;
          out.m03 = b11 * det;
          out.m04 = (a22 * a00 - a02 * a20) * det;
          out.m05 = (-a12 * a00 + a02 * a10) * det;
          out.m06 = b21 * det;
          out.m07 = (-a21 * a00 + a01 * a20) * det;
          out.m08 = (a11 * a00 - a01 * a10) * det;
          return out;
        }
        static determinant(a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        static multiply(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b00 = b.m00;
          const b01 = b.m01;
          const b02 = b.m02;
          const b10 = b.m03;
          const b11 = b.m04;
          const b12 = b.m05;
          const b20 = b.m06;
          const b21 = b.m07;
          const b22 = b.m08;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        }
        static multiplyMat4(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const b00 = b.m00;
          const b01 = b.m01;
          const b02 = b.m02;
          const b10 = b.m04;
          const b11 = b.m05;
          const b12 = b.m06;
          const b20 = b.m08;
          const b21 = b.m09;
          const b22 = b.m10;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        }
        static transform(out, a, v) {
          this.translate(out, a, v);
        }
        static translate(out, a, v) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const x = v.x;
          const y = v.y;
          out.m00 = a00;
          out.m01 = a01;
          out.m02 = a02;
          out.m03 = a10;
          out.m04 = a11;
          out.m05 = a12;
          out.m06 = x * a00 + y * a10 + a20;
          out.m07 = x * a01 + y * a11 + a21;
          out.m08 = x * a02 + y * a12 + a22;
          return out;
        }
        static scale(out, a, v) {
          const x = v.x;
          const y = v.y;
          out.m00 = x * a.m00;
          out.m01 = x * a.m01;
          out.m02 = x * a.m02;
          out.m03 = y * a.m03;
          out.m04 = y * a.m04;
          out.m05 = y * a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        }
        static rotate(out, a, rad) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a10 = a.m03;
          const a11 = a.m04;
          const a12 = a.m05;
          const a20 = a.m06;
          const a21 = a.m07;
          const a22 = a.m08;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c * a00 + s * a10;
          out.m01 = c * a01 + s * a11;
          out.m02 = c * a02 + s * a12;
          out.m03 = c * a10 - s * a00;
          out.m04 = c * a11 - s * a01;
          out.m05 = c * a12 - s * a02;
          out.m06 = a20;
          out.m07 = a21;
          out.m08 = a22;
          return out;
        }
        static fromMat4(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m04;
          out.m04 = a.m05;
          out.m05 = a.m06;
          out.m06 = a.m08;
          out.m07 = a.m09;
          out.m08 = a.m10;
          return out;
        }
        static fromViewUp(out, view, up) {
          if (Vec3.lengthSqr(view) < EPSILON$2 * EPSILON$2) {
            Mat3.identity(out);
            return out;
          }
          up = up || Vec3.UNIT_Y;
          Vec3.normalize(v3_1$6, Vec3.cross(v3_1$6, up, view));
          if (Vec3.lengthSqr(v3_1$6) < EPSILON$2 * EPSILON$2) {
            Mat3.identity(out);
            return out;
          }
          Vec3.cross(v3_2$1, view, v3_1$6);
          Mat3.set(out, v3_1$6.x, v3_1$6.y, v3_1$6.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z);
          return out;
        }
        static fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = v.x;
          out.m07 = v.y;
          out.m08 = 1;
          return out;
        }
        static fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = v.y;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static fromRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = -s;
          out.m04 = c;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        }
        static fromQuat(out, q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m03 = yx - wz;
          out.m06 = zx + wy;
          out.m01 = yx + wz;
          out.m04 = 1 - xx - zz;
          out.m07 = zy - wx;
          out.m02 = zx - wy;
          out.m05 = zy + wx;
          out.m08 = 1 - xx - yy;
          return out;
        }
        static inverseTransposeMat4(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          return out;
        }
        static toArray(out, m, ofs = 0) {
          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          return out;
        }
        static add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          return out;
        }
        static subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          return out;
        }
        static multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = b.m00 * scale + a.m00;
          out.m01 = b.m01 * scale + a.m01;
          out.m02 = b.m02 * scale + a.m02;
          out.m03 = b.m03 * scale + a.m03;
          out.m04 = b.m04 * scale + a.m04;
          out.m05 = b.m05 * scale + a.m05;
          out.m06 = b.m06 * scale + a.m06;
          out.m07 = b.m07 * scale + a.m07;
          out.m08 = b.m08 * scale + a.m08;
          return out;
        }
        static strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
        }
        static toEuler(matrix, v) {
          const a00 = matrix.m00;
          const a01 = matrix.m01;
          matrix.m02;
          const a10 = matrix.m03;
          const a11 = matrix.m04;
          matrix.m05;
          const a20 = matrix.m06;
          const a21 = matrix.m07;
          const a22 = matrix.m08;
          if (a21 < 0.999) {
            if (a21 > -0.999) {
              v.x = Math.asin(-a21);
              v.y = Math.atan2(a20, a22);
              v.z = Math.atan2(a01, a11);
              return true;
            } else {
              v.x = HALF_PI;
              v.y = Math.atan2(a10, a00);
              v.z = 0.0;
              return false;
            }
          } else {
            v.x = -HALF_PI;
            v.y = Math.atan2(-a10, a00);
            v.z = 0.0;
            return false;
          }
        }
        constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
          super();
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
          }
        }
        clone() {
          const t = this;
          return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
        }
        set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08));
        }
        strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
        }
        toString() {
          const t = this;
          return `[\n${t.m00}, ${t.m01}, ${t.m02},\n${t.m03},\n${t.m04}, ${t.m05},\n${t.m06}, ${t.m07},\n${t.m08}\n` + `]`;
        }
        identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 1;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 1;
          return this;
        }
        transpose() {
          const a01 = this.m01;
          const a02 = this.m02;
          const a12 = this.m05;
          this.m01 = this.m03;
          this.m02 = this.m06;
          this.m03 = a01;
          this.m05 = this.m07;
          this.m06 = a02;
          this.m07 = a12;
          return this;
        }
        invert() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }
          det = 1.0 / det;
          this.m00 = b01 * det;
          this.m01 = (-a22 * a01 + a02 * a21) * det;
          this.m02 = (a12 * a01 - a02 * a11) * det;
          this.m03 = b11 * det;
          this.m04 = (a22 * a00 - a02 * a20) * det;
          this.m05 = (-a12 * a00 + a02 * a10) * det;
          this.m06 = b21 * det;
          this.m07 = (-a21 * a00 + a01 * a20) * det;
          this.m08 = (a11 * a00 - a01 * a10) * det;
          return this;
        }
        determinant() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          return this;
        }
        subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          return this;
        }
        multiply(mat) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const b00 = mat.m00;
          const b01 = mat.m01;
          const b02 = mat.m02;
          const b10 = mat.m03;
          const b11 = mat.m04;
          const b12 = mat.m05;
          const b20 = mat.m06;
          const b21 = mat.m07;
          const b22 = mat.m08;
          this.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          this.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          this.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          this.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          this.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          this.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          this.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          this.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          this.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return this;
        }
        multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          return this;
        }
        scale(vec) {
          const x = vec.x;
          const y = vec.y;
          this.m00 = x * this.m00;
          this.m01 = x * this.m01;
          this.m02 = x * this.m02;
          this.m03 = y * this.m03;
          this.m04 = y * this.m04;
          this.m05 = y * this.m05;
          this.m06 = this.m06;
          this.m07 = this.m07;
          this.m08 = this.m08;
          return this;
        }
        rotate(rad) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m03;
          const a11 = this.m04;
          const a12 = this.m05;
          const a20 = this.m06;
          const a21 = this.m07;
          const a22 = this.m08;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          this.m00 = c * a00 + s * a10;
          this.m01 = c * a01 + s * a11;
          this.m02 = c * a02 + s * a12;
          this.m03 = c * a10 - s * a00;
          this.m04 = c * a11 - s * a01;
          this.m05 = c * a12 - s * a02;
          this.m06 = a20;
          this.m07 = a21;
          this.m08 = a22;
          return this;
        }
        fromQuat(q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m03 = yx - wz;
          this.m06 = zx + wy;
          this.m01 = yx + wz;
          this.m04 = 1 - xx - zz;
          this.m07 = zy - wx;
          this.m02 = zx - wy;
          this.m05 = zy + wx;
          this.m08 = 1 - xx - yy;
          return this;
        }
      } exports('Mat3', Mat3);
      _class$1P = Mat3;
      Mat3.IDENTITY = Object.freeze(new _class$1P());
      const v3_1$6 = new Vec3();
      const v3_2$1 = new Vec3();
      CCClass.fastDefine('cc.Mat3', Mat3, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 1,
        m05: 0,
        m06: 0,
        m07: 0,
        m08: 1
      });
      legacyCC.Mat3 = Mat3;

      var _class$1O;
      class Quat extends ValueType {
        static clone(a) {
          return new Quat(a.x, a.y, a.z, a.w);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        }
        static set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static identity(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          out.w = 1;
          return out;
        }
        static rotationTo(out, a, b) {
          const dot = Vec3.dot(a, b);
          if (dot < -0.999999) {
            Vec3.cross(v3_1$5, Vec3.UNIT_X, a);
            if (v3_1$5.length() < 0.000001) {
              Vec3.cross(v3_1$5, Vec3.UNIT_Y, a);
            }
            Vec3.normalize(v3_1$5, v3_1$5);
            Quat.fromAxisAngle(out, v3_1$5, Math.PI);
            return out;
          } else if (dot > 0.999999) {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 1;
            return out;
          } else {
            Vec3.cross(v3_1$5, a, b);
            out.x = v3_1$5.x;
            out.y = v3_1$5.y;
            out.z = v3_1$5.z;
            out.w = 1 + dot;
            return Quat.normalize(out, out);
          }
        }
        static getAxisAngle(outAxis, q) {
          const rad = Math.acos(q.w) * 2.0;
          const s = Math.sin(rad / 2.0);
          if (s !== 0.0) {
            outAxis.x = q.x / s;
            outAxis.y = q.y / s;
            outAxis.z = q.z / s;
          } else {
            outAxis.x = 1;
            outAxis.y = 0;
            outAxis.z = 0;
          }
          return rad;
        }
        static multiply(out, a, b) {
          const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
          const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
          const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
          const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        }
        static rotateX(out, a, rad) {
          rad *= 0.5;
          const bx = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw + w * bx;
          out.y = y * bw + z * bx;
          out.z = z * bw - y * bx;
          out.w = w * bw - x * bx;
          return out;
        }
        static rotateY(out, a, rad) {
          rad *= 0.5;
          const by = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw - z * by;
          out.y = y * bw + w * by;
          out.z = z * bw + x * by;
          out.w = w * bw - y * by;
          return out;
        }
        static rotateZ(out, a, rad) {
          rad *= 0.5;
          const bz = Math.sin(rad);
          const bw = Math.cos(rad);
          const {
            x,
            y,
            z,
            w
          } = a;
          out.x = x * bw + y * bz;
          out.y = y * bw - x * bz;
          out.z = z * bw + w * bz;
          out.w = w * bw - z * bz;
          return out;
        }
        static rotateAround(out, rot, axis, rad) {
          Quat.invert(qt_1, rot);
          Vec3.transformQuat(v3_1$5, axis, qt_1);
          Quat.fromAxisAngle(qt_1, v3_1$5, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        }
        static rotateAroundLocal(out, rot, axis, rad) {
          Quat.fromAxisAngle(qt_1, axis, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        }
        static calculateW(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
        static lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        }
        static slerp(out, a, b, t) {
          let scale0 = 0;
          let scale1 = 0;
          let bx = b.x;
          let by = b.y;
          let bz = b.z;
          let bw = b.w;
          let cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
          if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          if (1.0 - cosom > 0.000001) {
            const omega = Math.acos(cosom);
            const sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          } else {
            scale0 = 1.0 - t;
            scale1 = t;
          }
          out.x = scale0 * a.x + scale1 * bx;
          out.y = scale0 * a.y + scale1 * by;
          out.z = scale0 * a.z + scale1 * bz;
          out.w = scale0 * a.w + scale1 * bw;
          return out;
        }
        static sqlerp(out, a, b, c, d, t) {
          Quat.slerp(qt_1, a, d, t);
          Quat.slerp(qt_2, b, c, t);
          Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
          return out;
        }
        static invert(out, a) {
          const dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
          const invDot = dot ? 1.0 / dot : 0;
          out.x = -a.x * invDot;
          out.y = -a.y * invDot;
          out.z = -a.z * invDot;
          out.w = a.w * invDot;
          return out;
        }
        static conjugate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = a.w;
          return out;
        }
        static len(a) {
          return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
        }
        static lengthSqr(a) {
          return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        }
        static normalize(out, a) {
          let len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = a.x * len;
            out.y = a.y * len;
            out.z = a.z * len;
            out.w = a.w * len;
          } else {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 0;
          }
          return out;
        }
        static fromAxes(out, xAxis, yAxis, zAxis) {
          Mat3.set(m3_1$1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1$1));
        }
        static fromViewUp(out, view, up) {
          Mat3.fromViewUp(m3_1$1, view, up);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1$1));
        }
        static fromAxisAngle(out, axis, rad) {
          rad *= 0.5;
          const s = Math.sin(rad);
          out.x = s * axis.x;
          out.y = s * axis.y;
          out.z = s * axis.z;
          out.w = Math.cos(rad);
          return out;
        }
        static fromMat3(out, m) {
          const {
            m00,
            m01,
            m02,
            m03: m10,
            m04: m11,
            m05: m12,
            m06: m20,
            m07: m21,
            m08: m22
          } = m;
          const fourXSquaredMinus1 = m00 - m11 - m22;
          const fourYSquaredMinus1 = m11 - m00 - m22;
          const fourZSquaredMinus1 = m22 - m00 - m11;
          const fourWSquaredMinus1 = m00 + m11 + m22;
          let biggestIndex = 0;
          let fourBiggestSquaredMinus1 = fourWSquaredMinus1;
          if (fourXSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourXSquaredMinus1;
            biggestIndex = 1;
          }
          if (fourYSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourYSquaredMinus1;
            biggestIndex = 2;
          }
          if (fourZSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourZSquaredMinus1;
            biggestIndex = 3;
          }
          const biggestVal = Math.sqrt(fourBiggestSquaredMinus1 + 1) * 0.5;
          const mult = 0.25 / biggestVal;
          switch (biggestIndex) {
            case 0:
              out.w = biggestVal;
              out.x = (m12 - m21) * mult;
              out.y = (m20 - m02) * mult;
              out.z = (m01 - m10) * mult;
              break;
            case 1:
              out.w = (m12 - m21) * mult;
              out.x = biggestVal;
              out.y = (m01 + m10) * mult;
              out.z = (m20 + m02) * mult;
              break;
            case 2:
              out.w = (m20 - m02) * mult;
              out.x = (m01 + m10) * mult;
              out.y = biggestVal;
              out.z = (m12 + m21) * mult;
              break;
            case 3:
              out.w = (m01 - m10) * mult;
              out.x = (m20 + m02) * mult;
              out.y = (m12 + m21) * mult;
              out.z = biggestVal;
              break;
            default:
              out.w = 1;
              out.x = 0;
              out.y = 0;
              out.z = 0;
              break;
          }
          return out;
        }
        static fromEuler(out, x, y, z) {
          x *= halfToRad;
          y *= halfToRad;
          z *= halfToRad;
          const sx = Math.sin(x);
          const cx = Math.cos(x);
          const sy = Math.sin(y);
          const cy = Math.cos(y);
          const sz = Math.sin(z);
          const cz = Math.cos(z);
          out.x = sx * cy * cz + cx * sy * sz;
          out.y = cx * sy * cz + sx * cy * sz;
          out.z = cx * cy * sz - sx * sy * cz;
          out.w = cx * cy * cz - sx * sy * sz;
          return out;
        }
        static fromAngleZ(out, z) {
          z *= halfToRad;
          out.x = out.y = 0;
          out.z = Math.sin(z);
          out.w = Math.cos(z);
          return out;
        }
        static toAxisX(out, q) {
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = 1.0 - fy * q.y - fz * q.z;
          out.y = fy * q.x + fz * q.w;
          out.z = fz * q.x - fy * q.w;
          return out;
        }
        static toAxisY(out, q) {
          const fx = 2.0 * q.x;
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = fy * q.x - fz * q.w;
          out.y = 1.0 - fx * q.x - fz * q.z;
          out.z = fz * q.y + fx * q.w;
          return out;
        }
        static toAxisZ(out, q) {
          const fx = 2.0 * q.x;
          const fy = 2.0 * q.y;
          const fz = 2.0 * q.z;
          out.x = fz * q.x + fy * q.w;
          out.y = fz * q.y - fx * q.w;
          out.z = 1.0 - fx * q.x - fy * q.y;
          return out;
        }
        static toEuler(out, q, outerZ) {
          const {
            x,
            y,
            z,
            w
          } = q;
          let bank = 0;
          let heading = 0;
          let attitude = 0;
          const test = x * y + z * w;
          if (test > 0.499999) {
            bank = 0;
            heading = toDegree(2 * Math.atan2(x, w));
            attitude = 90;
          } else if (test < -0.499999) {
            bank = 0;
            heading = -toDegree(2 * Math.atan2(x, w));
            attitude = -90;
          } else {
            const sqx = x * x;
            const sqy = y * y;
            const sqz = z * z;
            bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
            heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
            attitude = toDegree(Math.asin(2 * test));
            if (outerZ) {
              bank = -180 * Math.sign(bank + 1e-6) + bank;
              heading = -180 * Math.sign(heading + 1e-6) + heading;
              attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
            }
          }
          out.x = bank;
          out.y = heading;
          out.z = attitude;
          return out;
        }
        static toEulerInYXZOrder(out, q) {
          Mat3.fromQuat(m3_1$1, q);
          Mat3.toEuler(m3_1$1, out);
          out.x = toDegree(out.x);
          out.y = toDegree(out.y);
          out.z = toDegree(out.z);
        }
        static toArray(out, q, ofs = 0) {
          out[ofs + 0] = q.x;
          out[ofs + 1] = q.y;
          out[ofs + 2] = q.z;
          out[ofs + 3] = q.w;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        }
        static angle(a, b) {
          const dot = Math.min(Math.abs(Quat.dot(a, b)), 1.0);
          return Math.acos(dot) * 2.0;
        }
        static rotateTowards(out, from, to, maxStep) {
          const angle = Quat.angle(from, to);
          if (angle === 0) {
            out.x = to.x;
            out.y = to.y;
            out.z = to.z;
            out.w = to.w;
            return out;
          }
          const t = Math.min(maxStep / toDegree(angle), 1.0);
          return Quat.slerp(out, from, to, t);
        }
        constructor(x, y, z, w) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== null && w !== void 0 ? w : 1;
          }
        }
        clone() {
          return new Quat(this.x, this.y, this.z, this.w);
        }
        set(x, y, z, w) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== null && w !== void 0 ? w : 1;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        }
        strictEquals(other) {
          return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
        getEulerAngles(out) {
          return Quat.toEuler(out, this);
        }
        lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          this.w += ratio * (to.w - this.w);
          return this;
        }
        slerp(to, ratio) {
          return Quat.slerp(this, this, to, ratio);
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
      } exports('Quat', Quat);
      _class$1O = Quat;
      Quat.IDENTITY = Object.freeze(new _class$1O());
      const qt_1 = new Quat();
      const qt_2 = new Quat();
      const v3_1$5 = new Vec3();
      const m3_1$1 = new Mat3();
      const halfToRad = 0.5 * Math.PI / 180.0;
      CCClass.fastDefine('cc.Quat', Quat, {
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
      legacyCC.Quat = Quat;
      function quat(x = 0, y = 0, z = 0, w = 1) {
        return new Quat(x, y, z, w);
      }
      legacyCC.quat = quat;

      var _class$1N;
      const preTransforms = exports('preTransforms', Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]));
      class Mat4 extends ValueType {
        static clone(a) {
          return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
        }
        static copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          out.m09 = a.m09;
          out.m10 = a.m10;
          out.m11 = a.m11;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        }
        static set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m03;
          out.m04 = m10;
          out.m05 = m11;
          out.m06 = m12;
          out.m07 = m13;
          out.m08 = m20;
          out.m09 = m21;
          out.m10 = m22;
          out.m11 = m23;
          out.m12 = m30;
          out.m13 = m31;
          out.m14 = m32;
          out.m15 = m33;
          return out;
        }
        static identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static transpose(out, a) {
          if (out === a) {
            const a01 = a.m01;
            const a02 = a.m02;
            const a03 = a.m03;
            const a12 = a.m06;
            const a13 = a.m07;
            const a23 = a.m11;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a01;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a02;
            out.m09 = a12;
            out.m11 = a.m14;
            out.m12 = a03;
            out.m13 = a13;
            out.m14 = a23;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a.m01;
            out.m05 = a.m05;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a.m02;
            out.m09 = a.m06;
            out.m10 = a.m10;
            out.m11 = a.m14;
            out.m12 = a.m03;
            out.m13 = a.m07;
            out.m14 = a.m11;
            out.m15 = a.m15;
          }
          return out;
        }
        static invert(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            out.m09 = 0;
            out.m10 = 0;
            out.m11 = 0;
            out.m12 = 0;
            out.m13 = 0;
            out.m14 = 0;
            out.m15 = 0;
            return out;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        }
        static determinant(a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        }
        static multiply(out, a, b) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          let b0 = b.m00;
          let b1 = b.m01;
          let b2 = b.m02;
          let b3 = b.m03;
          out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m04;
          b1 = b.m05;
          b2 = b.m06;
          b3 = b.m07;
          out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m08;
          b1 = b.m09;
          b2 = b.m10;
          b3 = b.m11;
          out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m12;
          b1 = b.m13;
          b2 = b.m14;
          b3 = b.m15;
          out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        }
        static transform(out, a, v) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          if (a === out) {
            out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
            out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
            out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
            out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
          } else {
            const a00 = a.m00;
            const a01 = a.m01;
            const a02 = a.m02;
            const a03 = a.m03;
            const a10 = a.m04;
            const a11 = a.m05;
            const a12 = a.m06;
            const a13 = a.m07;
            const a20 = a.m08;
            const a21 = a.m09;
            const a22 = a.m10;
            const a23 = a.m11;
            out.m00 = a00;
            out.m01 = a01;
            out.m02 = a02;
            out.m03 = a03;
            out.m04 = a10;
            out.m05 = a11;
            out.m06 = a12;
            out.m07 = a13;
            out.m08 = a20;
            out.m09 = a21;
            out.m10 = a22;
            out.m11 = a23;
            out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
            out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
            out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
            out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
          }
          return out;
        }
        static translate(out, a, v) {
          if (a === out) {
            out.m12 += v.x;
            out.m13 += v.y;
            out.m14 += v.z;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 = a.m12 + v.x;
            out.m13 = a.m13 + v.y;
            out.m14 = a.m14 + v.z;
            out.m15 = a.m15;
          }
          return out;
        }
        static scale(out, a, v) {
          const x = v.x;
          const y = v.y;
          const z = v.z;
          out.m00 = a.m00 * x;
          out.m01 = a.m01 * x;
          out.m02 = a.m02 * x;
          out.m03 = a.m03 * x;
          out.m04 = a.m04 * y;
          out.m05 = a.m05 * y;
          out.m06 = a.m06 * y;
          out.m07 = a.m07 * y;
          out.m08 = a.m08 * z;
          out.m09 = a.m09 * z;
          out.m10 = a.m10 * z;
          out.m11 = a.m11 * z;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        }
        static rotate(out, a, rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const b00 = x * x * t + c;
          const b01 = y * x * t + z * s;
          const b02 = z * x * t - y * s;
          const b10 = x * y * t - z * s;
          const b11 = y * y * t + c;
          const b12 = z * y * t + x * s;
          const b20 = x * z * t + y * s;
          const b21 = y * z * t - x * s;
          const b22 = z * z * t + c;
          out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          out.m11 = a03 * b20 + a13 * b21 + a23 * b22;
          if (a !== out) {
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          return out;
        }
        static rotateX(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          if (a !== out) {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m04 = a10 * c + a20 * s;
          out.m05 = a11 * c + a21 * s;
          out.m06 = a12 * c + a22 * s;
          out.m07 = a13 * c + a23 * s;
          out.m08 = a20 * c - a10 * s;
          out.m09 = a21 * c - a11 * s;
          out.m10 = a22 * c - a12 * s;
          out.m11 = a23 * c - a13 * s;
          return out;
        }
        static rotateY(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          if (a !== out) {
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m00 = a00 * c - a20 * s;
          out.m01 = a01 * c - a21 * s;
          out.m02 = a02 * c - a22 * s;
          out.m03 = a03 * c - a23 * s;
          out.m08 = a00 * s + a20 * c;
          out.m09 = a01 * s + a21 * c;
          out.m10 = a02 * s + a22 * c;
          out.m11 = a03 * s + a23 * c;
          return out;
        }
        static rotateZ(out, a, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          if (a !== out) {
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }
          out.m00 = a00 * c + a10 * s;
          out.m01 = a01 * c + a11 * s;
          out.m02 = a02 * c + a12 * s;
          out.m03 = a03 * c + a13 * s;
          out.m04 = a10 * c - a00 * s;
          out.m05 = a11 * c - a01 * s;
          out.m06 = a12 * c - a02 * s;
          out.m07 = a13 * c - a03 * s;
          return out;
        }
        static fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = v.y;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = v.z;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromRotation(out, rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          out.m00 = x * x * t + c;
          out.m01 = y * x * t + z * s;
          out.m02 = z * x * t - y * s;
          out.m03 = 0;
          out.m04 = x * y * t - z * s;
          out.m05 = y * y * t + c;
          out.m06 = z * y * t + x * s;
          out.m07 = 0;
          out.m08 = x * z * t + y * s;
          out.m09 = y * z * t - x * s;
          out.m10 = z * z * t + c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromXRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = c;
          out.m06 = s;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = -s;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromYRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = 0;
          out.m02 = -s;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = s;
          out.m09 = 0;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromZRotation(out, rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = -s;
          out.m05 = c;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static fromRT(out, q, v) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - (yy + zz);
          out.m01 = xy + wz;
          out.m02 = xz - wy;
          out.m03 = 0;
          out.m04 = xy - wz;
          out.m05 = 1 - (xx + zz);
          out.m06 = yz + wx;
          out.m07 = 0;
          out.m08 = xz + wy;
          out.m09 = yz - wx;
          out.m10 = 1 - (xx + yy);
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static getTranslation(out, mat) {
          out.x = mat.m12;
          out.y = mat.m13;
          out.z = mat.m14;
          return out;
        }
        static getScaling(out, mat) {
          const m00 = m3_1.m00 = mat.m00;
          const m01 = m3_1.m01 = mat.m01;
          const m02 = m3_1.m02 = mat.m02;
          const m04 = m3_1.m03 = mat.m04;
          const m05 = m3_1.m04 = mat.m05;
          const m06 = m3_1.m05 = mat.m06;
          const m08 = m3_1.m06 = mat.m08;
          const m09 = m3_1.m07 = mat.m09;
          const m10 = m3_1.m08 = mat.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);
          if (Mat3.determinant(m3_1) < 0) {
            out.x *= -1;
          }
          return out;
        }
        static getRotation(out, mat) {
          const trace = mat.m00 + mat.m05 + mat.m10;
          let S = 0;
          if (trace > 0) {
            S = Math.sqrt(trace + 1.0) * 2;
            out.w = 0.25 * S;
            out.x = (mat.m06 - mat.m09) / S;
            out.y = (mat.m08 - mat.m02) / S;
            out.z = (mat.m01 - mat.m04) / S;
          } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
            out.w = (mat.m06 - mat.m09) / S;
            out.x = 0.25 * S;
            out.y = (mat.m01 + mat.m04) / S;
            out.z = (mat.m08 + mat.m02) / S;
          } else if (mat.m05 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
            out.w = (mat.m08 - mat.m02) / S;
            out.x = (mat.m01 + mat.m04) / S;
            out.y = 0.25 * S;
            out.z = (mat.m06 + mat.m09) / S;
          } else {
            S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
            out.w = (mat.m01 - mat.m04) / S;
            out.x = (mat.m08 + mat.m02) / S;
            out.y = (mat.m06 + mat.m09) / S;
            out.z = 0.25 * S;
          }
          return out;
        }
        static toRTS(m, q, v, s) {
          const sx = Vec3.set(v3_1$4, m.m00, m.m01, m.m02).length();
          const sy = Vec3.set(v3_1$4, m.m04, m.m05, m.m06).length();
          const sz = Vec3.set(v3_1$4, m.m08, m.m09, m.m10).length();
          m3_1.m00 = m.m00 / sx;
          m3_1.m01 = m.m01 / sx;
          m3_1.m02 = m.m02 / sx;
          m3_1.m03 = m.m04 / sy;
          m3_1.m04 = m.m05 / sy;
          m3_1.m05 = m.m06 / sy;
          m3_1.m06 = m.m08 / sz;
          m3_1.m07 = m.m09 / sz;
          m3_1.m08 = m.m10 / sz;
          const det = Mat3.determinant(m3_1);
          if (s) {
            Vec3.set(s, sx, sy, sz);
            if (det < 0) {
              s.x *= -1;
            }
          }
          if (v) {
            Vec3.set(v, m.m12, m.m13, m.m14);
          }
          if (q) {
            if (det < 0) {
              m3_1.m00 *= -1;
              m3_1.m01 *= -1;
              m3_1.m02 *= -1;
            }
            Quat.fromMat3(q, m3_1);
          }
        }
        static toSRT(m, q, v, s) {
          const sx = Vec3.set(v3_1$4, m.m00, m.m01, m.m02).length();
          const sy = Vec3.set(v3_1$4, m.m04, m.m05, m.m06).length();
          const sz = Vec3.set(v3_1$4, m.m08, m.m09, m.m10).length();
          if (s) {
            s.x = sx;
            s.y = sy;
            s.z = sz;
          }
          if (v) {
            Vec3.set(v, m.m12, m.m13, m.m14);
          }
          if (q) {
            m3_1.m00 = m.m00 / sx;
            m3_1.m01 = m.m01 / sx;
            m3_1.m02 = m.m02 / sx;
            m3_1.m03 = m.m04 / sy;
            m3_1.m04 = m.m05 / sy;
            m3_1.m05 = m.m06 / sy;
            m3_1.m06 = m.m08 / sz;
            m3_1.m07 = m.m09 / sz;
            m3_1.m08 = m.m10 / sz;
            const det = Mat3.determinant(m3_1);
            if (det < 0) {
              if (s) s.x *= -1;
              m3_1.m00 *= -1;
              m3_1.m01 *= -1;
              m3_1.m02 *= -1;
            }
            Quat.fromMat3(q, m3_1);
          }
        }
        static toEuler(m, v) {
          Mat3.set(m3_1, m.m00, m.m01, m.m02, m.m04, m.m05, m.m06, m.m08, m.m09, m.m10);
          return Mat3.toEuler(m3_1, v);
        }
        static fromRTS(out, q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromSRT(out, q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        }
        static fromRTSOrigin(out, q, v, s, o) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          const ox = o.x;
          const oy = o.y;
          const oz = o.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
          out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
          out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
          out.m15 = 1;
          return out;
        }
        static fromSRTOrigin(out, q, v, s, o) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          const ox = o.x;
          const oy = o.y;
          const oz = o.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
          out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
          out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
          out.m15 = 1;
          return out;
        }
        static fromQuat(out, q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m01 = yx + wz;
          out.m02 = zx - wy;
          out.m03 = 0;
          out.m04 = yx - wz;
          out.m05 = 1 - xx - zz;
          out.m06 = zy + wx;
          out.m07 = 0;
          out.m08 = zx + wy;
          out.m09 = zy - wx;
          out.m10 = 1 - xx - yy;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static frustum(out, left, right, bottom, top, near, far) {
          const rl = 1 / (right - left);
          const tb = 1 / (top - bottom);
          const nf = 1 / (near - far);
          out.m00 = near * 2 * rl;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = near * 2 * tb;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = (right + left) * rl;
          out.m09 = (top + bottom) * tb;
          out.m10 = (far + near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * 2 * nf;
          out.m15 = 0;
          return out;
        }
        static perspective(out, fov, aspect, near, far, isFOVY = true, minClipZ = -1, projectionSignY = 1, orientation = 0) {
          const f = 1.0 / Math.tan(fov / 2);
          const nf = 1 / (near - far);
          const x = isFOVY ? f / aspect : f;
          const y = (isFOVY ? f : f * aspect) * projectionSignY;
          const preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = (far - minClipZ * near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * nf * (1 - minClipZ);
          out.m15 = 0;
          return out;
        }
        static ortho(out, left, right, bottom, top, near, far, minClipZ = -1, projectionSignY = 1, orientation = 0) {
          const lr = 1 / (left - right);
          const bt = 1 / (bottom - top) * projectionSignY;
          const nf = 1 / (near - far);
          const x = -2 * lr;
          const y = -2 * bt;
          const dx = (left + right) * lr;
          const dy = (top + bottom) * bt;
          const preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = nf * (1 - minClipZ);
          out.m11 = 0;
          out.m12 = dx * preTransform[0] + dy * preTransform[2];
          out.m13 = dx * preTransform[1] + dy * preTransform[3];
          out.m14 = (near - minClipZ * far) * nf;
          out.m15 = 1;
          return out;
        }
        static lookAt(out, eye, center, up) {
          const eyex = eye.x;
          const eyey = eye.y;
          const eyez = eye.z;
          const upx = up.x;
          const upy = up.y;
          const upz = up.z;
          const centerx = center.x;
          const centery = center.y;
          const centerz = center.z;
          let z0 = eyex - centerx;
          let z1 = eyey - centery;
          let z2 = eyez - centerz;
          let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          let x0 = upy * z2 - upz * z1;
          let x1 = upz * z0 - upx * z2;
          let x2 = upx * z1 - upy * z0;
          len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          x0 *= len;
          x1 *= len;
          x2 *= len;
          const y0 = z1 * x2 - z2 * x1;
          const y1 = z2 * x0 - z0 * x2;
          const y2 = z0 * x1 - z1 * x0;
          out.m00 = x0;
          out.m01 = y0;
          out.m02 = z0;
          out.m03 = 0;
          out.m04 = x1;
          out.m05 = y1;
          out.m06 = z1;
          out.m07 = 0;
          out.m08 = x2;
          out.m09 = y2;
          out.m10 = z2;
          out.m11 = 0;
          out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
          out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
          out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
          out.m15 = 1;
          return out;
        }
        static inverseTranspose(out, a) {
          const a00 = a.m00;
          const a01 = a.m01;
          const a02 = a.m02;
          const a03 = a.m03;
          const a10 = a.m04;
          const a11 = a.m05;
          const a12 = a.m06;
          const a13 = a.m07;
          const a20 = a.m08;
          const a21 = a.m09;
          const a22 = a.m10;
          const a23 = a.m11;
          const a30 = a.m12;
          const a31 = a.m13;
          const a32 = a.m14;
          const a33 = a.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = 0;
          out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m07 = 0;
          out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        }
        static toArray(out, m, ofs = 0) {
          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          out[ofs + 9] = m.m09;
          out[ofs + 10] = m.m10;
          out[ofs + 11] = m.m11;
          out[ofs + 12] = m.m12;
          out[ofs + 13] = m.m13;
          out[ofs + 14] = m.m14;
          out[ofs + 15] = m.m15;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          out.m09 = arr[ofs + 9];
          out.m10 = arr[ofs + 10];
          out.m11 = arr[ofs + 11];
          out.m12 = arr[ofs + 12];
          out.m13 = arr[ofs + 13];
          out.m14 = arr[ofs + 14];
          out.m15 = arr[ofs + 15];
          return out;
        }
        static add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          out.m09 = a.m09 + b.m09;
          out.m10 = a.m10 + b.m10;
          out.m11 = a.m11 + b.m11;
          out.m12 = a.m12 + b.m12;
          out.m13 = a.m13 + b.m13;
          out.m14 = a.m14 + b.m14;
          out.m15 = a.m15 + b.m15;
          return out;
        }
        static subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          out.m09 = a.m09 - b.m09;
          out.m10 = a.m10 - b.m10;
          out.m11 = a.m11 - b.m11;
          out.m12 = a.m12 - b.m12;
          out.m13 = a.m13 - b.m13;
          out.m14 = a.m14 - b.m14;
          out.m15 = a.m15 - b.m15;
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          out.m09 = a.m09 * b;
          out.m10 = a.m10 * b;
          out.m11 = a.m11 * b;
          out.m12 = a.m12 * b;
          out.m13 = a.m13 * b;
          out.m14 = a.m14 * b;
          out.m15 = a.m15 * b;
          return out;
        }
        static multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = a.m00 + b.m00 * scale;
          out.m01 = a.m01 + b.m01 * scale;
          out.m02 = a.m02 + b.m02 * scale;
          out.m03 = a.m03 + b.m03 * scale;
          out.m04 = a.m04 + b.m04 * scale;
          out.m05 = a.m05 + b.m05 * scale;
          out.m06 = a.m06 + b.m06 * scale;
          out.m07 = a.m07 + b.m07 * scale;
          out.m08 = a.m08 + b.m08 * scale;
          out.m09 = a.m09 + b.m09 * scale;
          out.m10 = a.m10 + b.m10 * scale;
          out.m11 = a.m11 + b.m11 * scale;
          out.m12 = a.m12 + b.m12 * scale;
          out.m13 = a.m13 + b.m13 * scale;
          out.m14 = a.m14 + b.m14 * scale;
          out.m15 = a.m15 + b.m15 * scale;
          return out;
        }
        static strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
        }
        constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
          super();
          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
            this.m09 = m00.m09;
            this.m10 = m00.m10;
            this.m11 = m00.m11;
            this.m12 = m00.m12;
            this.m13 = m00.m13;
            this.m14 = m00.m14;
            this.m15 = m00.m15;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
            this.m09 = m09;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m14 = m14;
            this.m15 = m15;
          }
        }
        clone() {
          return new Mat4(this.m00, this.m01, this.m02, this.m03, this.m04, this.m05, this.m06, this.m07, this.m08, this.m09, this.m10, this.m11, this.m12, this.m13, this.m14, this.m15);
        }
        set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
          if (typeof m00 === 'object') {
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
            this.m09 = m00.m09;
            this.m10 = m00.m10;
            this.m11 = m00.m11;
            this.m12 = m00.m12;
            this.m13 = m00.m13;
            this.m14 = m00.m14;
            this.m15 = m00.m15;
            this.m00 = m00.m00;
          } else {
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
            this.m09 = m09;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m14 = m14;
            this.m15 = m15;
            this.m00 = m00;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          const hasInf = Math.abs(this.m00) === Infinity || Math.abs(this.m01) === Infinity || Math.abs(this.m02) === Infinity || Math.abs(this.m03) === Infinity || Math.abs(this.m04) === Infinity || Math.abs(this.m05) === Infinity || Math.abs(this.m06) === Infinity || Math.abs(this.m07) === Infinity || Math.abs(this.m08) === Infinity || Math.abs(this.m09) === Infinity || Math.abs(this.m10) === Infinity || Math.abs(this.m11) === Infinity || Math.abs(this.m12) === Infinity || Math.abs(this.m13) === Infinity || Math.abs(this.m14) === Infinity || Math.abs(this.m15) === Infinity;
          return !hasInf && Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1.0, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1.0, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1.0, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1.0, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1.0, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1.0, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1.0, Math.abs(this.m15), Math.abs(other.m15));
        }
        strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
        }
        toString() {
          return `[\n${this.m00}, ${this.m01}, ${this.m02}, ${this.m03},\n${this.m04}, ${this.m05}, ${this.m06}, ${this.m07},\n${this.m08}, ${this.m09}, ${this.m10}, ${this.m11},\n${this.m12}, ${this.m13}, ${this.m14}, ${this.m15}\n` + ']';
        }
        identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 1;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 1;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        }
        zero() {
          this.m00 = 0;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 0;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 0;
          return this;
        }
        transpose() {
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a12 = this.m06;
          const a13 = this.m07;
          const a23 = this.m11;
          this.m01 = this.m04;
          this.m02 = this.m08;
          this.m03 = this.m12;
          this.m04 = a01;
          this.m06 = this.m09;
          this.m07 = this.m13;
          this.m08 = a02;
          this.m09 = a12;
          this.m11 = this.m14;
          this.m12 = a03;
          this.m13 = a13;
          this.m14 = a23;
          return this;
        }
        invert() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }
          det = 1.0 / det;
          this.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          this.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          this.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          this.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          this.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          this.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          this.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          this.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          this.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          this.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          this.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          this.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          this.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          this.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          this.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          this.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return this;
        }
        determinant() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        }
        add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          this.m09 += mat.m09;
          this.m10 += mat.m10;
          this.m11 += mat.m11;
          this.m12 += mat.m12;
          this.m13 += mat.m13;
          this.m14 += mat.m14;
          this.m15 += mat.m15;
          return this;
        }
        subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          this.m09 -= mat.m09;
          this.m10 -= mat.m10;
          this.m11 -= mat.m11;
          this.m12 -= mat.m12;
          this.m13 -= mat.m13;
          this.m14 -= mat.m14;
          this.m15 -= mat.m15;
          return this;
        }
        multiply(mat) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const a30 = this.m12;
          const a31 = this.m13;
          const a32 = this.m14;
          const a33 = this.m15;
          let b0 = mat.m00;
          let b1 = mat.m01;
          let b2 = mat.m02;
          let b3 = mat.m03;
          this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m04;
          b1 = mat.m05;
          b2 = mat.m06;
          b3 = mat.m07;
          this.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m08;
          b1 = mat.m09;
          b2 = mat.m10;
          b3 = mat.m11;
          this.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m12;
          b1 = mat.m13;
          b2 = mat.m14;
          b3 = mat.m15;
          this.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
        }
        multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          this.m09 *= scalar;
          this.m10 *= scalar;
          this.m11 *= scalar;
          this.m12 *= scalar;
          this.m13 *= scalar;
          this.m14 *= scalar;
          this.m15 *= scalar;
          return this;
        }
        translate(vec) {
          this.m12 += vec.x;
          this.m13 += vec.y;
          this.m14 += vec.z;
          return this;
        }
        transform(vec) {
          const {
            x,
            y,
            z
          } = vec;
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          this.m12 = a00 * x + a10 * y + a20 * z + this.m12;
          this.m13 = a01 * x + a11 * y + a21 * z + this.m13;
          this.m14 = a02 * x + a12 * y + a22 * z + this.m14;
          this.m15 = a03 * x + a13 * y + a23 * z + this.m15;
          return this;
        }
        scale(vec) {
          const x = vec.x;
          const y = vec.y;
          const z = vec.z;
          this.m00 *= x;
          this.m01 *= x;
          this.m02 *= x;
          this.m03 *= x;
          this.m04 *= y;
          this.m05 *= y;
          this.m06 *= y;
          this.m07 *= y;
          this.m08 *= z;
          this.m09 *= z;
          this.m10 *= z;
          this.m11 *= z;
          return this;
        }
        rotate(rad, axis) {
          let x = axis.x;
          let y = axis.y;
          let z = axis.z;
          let len = Math.sqrt(x * x + y * y + z * z);
          if (Math.abs(len) < EPSILON$2) {
            return null;
          }
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m04;
          const a11 = this.m05;
          const a12 = this.m06;
          const a13 = this.m07;
          const a20 = this.m08;
          const a21 = this.m09;
          const a22 = this.m10;
          const a23 = this.m11;
          const b00 = x * x * t + c;
          const b01 = y * x * t + z * s;
          const b02 = z * x * t - y * s;
          const b10 = x * y * t - z * s;
          const b11 = y * y * t + c;
          const b12 = z * y * t + x * s;
          const b20 = x * z * t + y * s;
          const b21 = y * z * t - x * s;
          const b22 = z * z * t + c;
          this.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          this.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          this.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          this.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          this.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          this.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          this.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          this.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          this.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          this.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          this.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          this.m11 = a03 * b20 + a13 * b21 + a23 * b22;
          return this;
        }
        getTranslation(out) {
          out.x = this.m12;
          out.y = this.m13;
          out.z = this.m14;
          return out;
        }
        getScale(out) {
          const m00 = m3_1.m00 = this.m00;
          const m01 = m3_1.m01 = this.m01;
          const m02 = m3_1.m02 = this.m02;
          const m04 = m3_1.m03 = this.m04;
          const m05 = m3_1.m04 = this.m05;
          const m06 = m3_1.m05 = this.m06;
          const m08 = m3_1.m06 = this.m08;
          const m09 = m3_1.m07 = this.m09;
          const m10 = m3_1.m08 = this.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);
          if (Mat3.determinant(m3_1) < 0) {
            out.x *= -1;
          }
          return out;
        }
        getRotation(out) {
          const sx = Vec3.set(v3_1$4, this.m00, this.m01, this.m02).length();
          const sy = Vec3.set(v3_1$4, this.m04, this.m05, this.m06).length();
          const sz = Vec3.set(v3_1$4, this.m08, this.m09, this.m10).length();
          m3_1.m00 = this.m00 / sx;
          m3_1.m01 = this.m01 / sx;
          m3_1.m02 = this.m02 / sx;
          m3_1.m03 = this.m04 / sy;
          m3_1.m04 = this.m05 / sy;
          m3_1.m05 = this.m06 / sy;
          m3_1.m06 = this.m08 / sz;
          m3_1.m07 = this.m09 / sz;
          m3_1.m08 = this.m10 / sz;
          const det = Mat3.determinant(m3_1);
          if (det < 0) {
            m3_1.m00 *= -1;
            m3_1.m01 *= -1;
            m3_1.m02 *= -1;
          }
          return Quat.fromMat3(out, m3_1);
        }
        fromRTS(q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          this.m00 = (1 - (yy + zz)) * sx;
          this.m01 = (xy + wz) * sx;
          this.m02 = (xz - wy) * sx;
          this.m03 = 0;
          this.m04 = (xy - wz) * sy;
          this.m05 = (1 - (xx + zz)) * sy;
          this.m06 = (yz + wx) * sy;
          this.m07 = 0;
          this.m08 = (xz + wy) * sz;
          this.m09 = (yz - wx) * sz;
          this.m10 = (1 - (xx + yy)) * sz;
          this.m11 = 0;
          this.m12 = v.x;
          this.m13 = v.y;
          this.m14 = v.z;
          this.m15 = 1;
          return this;
        }
        fromSRT(q, v, s) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const xy = x * y2;
          const xz = x * z2;
          const yy = y * y2;
          const yz = y * z2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const sx = s.x;
          const sy = s.y;
          const sz = s.z;
          this.m00 = (1 - (yy + zz)) * sx;
          this.m01 = (xy + wz) * sx;
          this.m02 = (xz - wy) * sx;
          this.m03 = 0;
          this.m04 = (xy - wz) * sy;
          this.m05 = (1 - (xx + zz)) * sy;
          this.m06 = (yz + wx) * sy;
          this.m07 = 0;
          this.m08 = (xz + wy) * sz;
          this.m09 = (yz - wx) * sz;
          this.m10 = (1 - (xx + yy)) * sz;
          this.m11 = 0;
          this.m12 = v.x;
          this.m13 = v.y;
          this.m14 = v.z;
          this.m15 = 1;
          return this;
        }
        fromQuat(q) {
          const x = q.x;
          const y = q.y;
          const z = q.z;
          const w = q.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m01 = yx + wz;
          this.m02 = zx - wy;
          this.m03 = 0;
          this.m04 = yx - wz;
          this.m05 = 1 - xx - zz;
          this.m06 = zy + wx;
          this.m07 = 0;
          this.m08 = zx + wy;
          this.m09 = zy - wx;
          this.m10 = 1 - xx - yy;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        }
      } exports('Mat4', Mat4);
      _class$1N = Mat4;
      Mat4.IDENTITY = Object.freeze(new _class$1N());
      const v3_1$4 = new Vec3();
      const m3_1 = new Mat3();
      CCClass.fastDefine('cc.Mat4', Mat4, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1
      });
      legacyCC.Mat4 = Mat4;
      function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      legacyCC.mat4 = mat4;

      var _class$1M;
      class Vec2 extends ValueType {
        static clone(a) {
          return new Vec2(a.x, a.y);
        }
        static copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          return out;
        }
        static set(out, x, y) {
          out.x = x;
          out.y = y;
          return out;
        }
        static add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          return out;
        }
        static subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          return out;
        }
        static multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          return out;
        }
        static divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          return out;
        }
        static ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          return out;
        }
        static floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          return out;
        }
        static min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          return out;
        }
        static max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          return out;
        }
        static round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          return out;
        }
        static multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          return out;
        }
        static scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          return out;
        }
        static distance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          return Math.sqrt(x * x + y * y);
        }
        static squaredDistance(a, b) {
          const x = b.x - a.x;
          const y = b.y - a.y;
          return x * x + y * y;
        }
        static len(a) {
          const x = a.x;
          const y = a.y;
          return Math.sqrt(x * x + y * y);
        }
        static lengthSqr(a) {
          const x = a.x;
          const y = a.y;
          return x * x + y * y;
        }
        static negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          return out;
        }
        static inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          return out;
        }
        static inverseSafe(out, a) {
          const x = a.x;
          const y = a.y;
          if (Math.abs(x) < EPSILON$2) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }
          if (Math.abs(y) < EPSILON$2) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }
          return out;
        }
        static normalize(out, a) {
          const x = a.x;
          const y = a.y;
          let len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
          } else {
            out.x = 0;
            out.y = 0;
          }
          return out;
        }
        static dot(a, b) {
          return a.x * b.x + a.y * b.y;
        }
        static cross(out, a, b) {
          if (out instanceof Vec3) {
            out.x = out.y = 0;
            out.z = a.x * b.y - a.y * b.x;
            return out;
          } else {
            return out.x * a.y - out.y * a.x;
          }
        }
        static lerp(out, a, b, t) {
          const x = a.x;
          const y = a.y;
          out.x = x + t * (b.x - x);
          out.y = y + t * (b.y - y);
          return out;
        }
        static random(out, scale) {
          scale = scale || 1.0;
          const r = random() * 2.0 * Math.PI;
          out.x = Math.cos(r) * scale;
          out.y = Math.sin(r) * scale;
          return out;
        }
        static transformMat3(out, a, m) {
          const x = a.x;
          const y = a.y;
          out.x = m.m00 * x + m.m03 * y + m.m06;
          out.y = m.m01 * x + m.m04 * y + m.m07;
          return out;
        }
        static transformMat4(out, a, m) {
          const x = a.x;
          const y = a.y;
          out.x = m.m00 * x + m.m04 * y + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m13;
          return out;
        }
        static str(a) {
          return `Vec2(${a.x}, ${a.y})`;
        }
        static toArray(out, v, ofs = 0) {
          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          return out;
        }
        static fromArray(out, arr, ofs = 0) {
          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          return out;
        }
        static strictEquals(a, b) {
          return a.x === b.x && a.y === b.y;
        }
        static equals(a, b, epsilon = EPSILON$2) {
          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
        }
        static angle(a, b) {
          const magSqr1 = a.x * a.x + a.y * a.y;
          const magSqr2 = b.x * b.x + b.y * b.y;
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = a.x * b.x + a.y * b.y;
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        constructor(x, y) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
          } else {
            this.x = x || 0;
            this.y = y || 0;
          }
        }
        clone() {
          return new Vec2(this.x, this.y);
        }
        set(x, y) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
          } else {
            this.x = x || 0;
            this.y = y || 0;
          }
          return this;
        }
        equals(other, epsilon = EPSILON$2) {
          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y));
        }
        equals2f(x, y, epsilon = EPSILON$2) {
          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y));
        }
        strictEquals(other) {
          return other && this.x === other.x && this.y === other.y;
        }
        strictEquals2f(x, y) {
          return this.x === x && this.y === y;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          return this;
        }
        clampf(minInclusive, maxInclusive) {
          this.x = clamp$1(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp$1(this.y, minInclusive.y, maxInclusive.y);
          return this;
        }
        add(other) {
          this.x += other.x;
          this.y += other.y;
          return this;
        }
        add2f(x, y) {
          this.x += x;
          this.y += y;
          return this;
        }
        subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          return this;
        }
        subtract2f(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
        }
        multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec2.multiply for vector * vector operation');
          }
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec2.scale for vector * scalar operation');
          }
          this.x *= other.x;
          this.y *= other.y;
          return this;
        }
        multiply2f(x, y) {
          this.x *= x;
          this.y *= y;
          return this;
        }
        divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          return this;
        }
        divide2f(x, y) {
          this.x /= x;
          this.y /= y;
          return this;
        }
        negative() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(other) {
          return this.x * other.x + this.y * other.y;
        }
        cross(other) {
          return this.x * other.y - this.y * other.x;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        lengthSqr() {
          return this.x * this.x + this.y * this.y;
        }
        normalize() {
          const x = this.x;
          const y = this.y;
          let len = x * x + y * y;
          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x *= len;
            this.y *= len;
          }
          return this;
        }
        angle(other) {
          const magSqr1 = this.lengthSqr();
          const magSqr2 = other.lengthSqr();
          if (magSqr1 === 0 || magSqr2 === 0) {
            return 0.0;
          }
          const dot = this.dot(other);
          let cosine = dot / Math.sqrt(magSqr1 * magSqr2);
          cosine = clamp$1(cosine, -1.0, 1.0);
          return Math.acos(cosine);
        }
        signAngle(other) {
          const cross = this.cross(other);
          const dot = this.dot(other);
          return Math.atan2(cross, dot);
        }
        rotate(radians) {
          const x = this.x;
          const y = this.y;
          const sin = Math.sin(radians);
          const cos = Math.cos(radians);
          this.x = cos * x - sin * y;
          this.y = sin * x + cos * y;
          return this;
        }
        project(other) {
          const scalar = this.dot(other) / other.dot(other);
          this.x = other.x * scalar;
          this.y = other.y * scalar;
          return this;
        }
        transformMat4(matrix) {
          const x = this.x;
          const y = this.y;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
          return this;
        }
      } exports('Vec2', Vec2);
      _class$1M = Vec2;
      Vec2.ZERO = Object.freeze(new _class$1M(0, 0));
      Vec2.ONE = Object.freeze(new _class$1M(1, 1));
      Vec2.NEG_ONE = Object.freeze(new _class$1M(-1, -1));
      Vec2.UNIT_X = Object.freeze(new _class$1M(1, 0));
      Vec2.UNIT_Y = Object.freeze(new _class$1M(0, 1));
      CCClass.fastDefine('cc.Vec2', Vec2, {
        x: 0,
        y: 0
      });
      legacyCC.Vec2 = Vec2;
      function v2$1(x, y) {
        return new Vec2(x, y);
      }
      legacyCC.v2 = v2$1;

      replaceProperty(Vec2, 'Vec2', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec2.prototype, 'Vec2', [{
        name: 'mag',
        newName: 'length',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec3, 'Vec3', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec3.prototype, 'Vec3', [{
        name: 'mag',
        newName: 'length',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec4, 'Vec4', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4,
        targetName: 'Vec4'
      }]);
      replaceProperty(Vec4.prototype, 'Vec4', [{
        name: 'mag',
        newName: 'length',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }]);
      replaceProperty(Quat, 'Quat', [{
        name: 'mag',
        newName: 'len',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat,
        targetName: 'Quat'
      }]);
      replaceProperty(Quat.prototype, 'Quat', [{
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat.prototype,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat.prototype,
        targetName: 'Quat'
      }]);
      replaceProperty(Color$1, 'Color', [{
        name: 'sub',
        newName: 'subtract',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'div',
        newName: 'divide',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Color$1,
        targetName: 'Color'
      }, {
        name: 'fromHex',
        newName: 'fromHEX',
        customFunction(...args) {
          const arg1 = args[1].toString(16);
          return legacyCC.Color.fromHEX(args[0], arg1);
        }
      }]);
      replaceProperty(Mat3, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'transfrom',
        newName: 'transform',
        target: Mat3,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat3.prototype, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat4, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4,
        targetName: 'Mat4'
      }]);
      replaceProperty(Mat4.prototype, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }]);

      const defineAttr = (proto, name, offset) => {
        Object.defineProperty(proto, name, {
          configurable: true,
          enumerable: true,
          get() {
            return this._data()[offset];
          },
          set(v) {
            this._data()[offset] = v;
          }
        });
      };
      let MathType$1;
      (function (MathType) {
        MathType[MathType["VEC2"] = 0] = "VEC2";
        MathType[MathType["VEC3"] = 1] = "VEC3";
        MathType[MathType["VEC4"] = 2] = "VEC4";
        MathType[MathType["QUATERNION"] = 3] = "QUATERNION";
        MathType[MathType["MAT3"] = 4] = "MAT3";
        MathType[MathType["MAT4"] = 5] = "MAT4";
        MathType[MathType["SIZE"] = 6] = "SIZE";
        MathType[MathType["RECT"] = 7] = "RECT";
        MathType[MathType["COLOR"] = 8] = "COLOR";
      })(MathType$1 || (MathType$1 = {}));
      function extendType(proto, parentProto, typ) {
        proto._data = function () {
          if (!this.__data) {
            this.__data = new Float32Array(this.underlyingData());
          }
          return this.__data;
        };
        Object.setPrototypeOf(proto, parentProto);
        Object.defineProperty(proto, 'type', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: typ
        });
      }
      function inheritCCClass(ctor, parentCtor) {
        for (const attrName of ['__cid__', '__classname__']) {
          Object.defineProperty(ctor.prototype, attrName, {
            value: parentCtor.prototype[attrName],
            writable: false,
            enumerable: false,
            configurable: true
          });
        }
        for (const staticKey of ['__attrs__', '__props__', '__values__']) {
          ctor[staticKey] = parentCtor[staticKey];
        }
      }
      {
        extendType(jsb.Mat4.prototype, Mat4.prototype, MathType$1.MAT4);
        for (let i = 0; i < 16; i++) {
          const numb = `0${i}`;
          defineAttr(jsb.Mat4.prototype, `m${numb.substring(numb.length - 2)}`, i);
        }
        for (let i = 0; i < 9; i++) {
          const numb = `0${i}`;
          defineAttr(jsb.Mat3.prototype, `m${numb.substring(numb.length - 2)}`, i);
        }
        extendType(jsb.Mat3.prototype, Mat3.prototype, MathType$1.MAT3);
        defineAttr(jsb.Vec2.prototype, 'x', 0);
        defineAttr(jsb.Vec2.prototype, 'y', 1);
        extendType(jsb.Vec2.prototype, Vec2.prototype, MathType$1.VEC2);
        defineAttr(jsb.Vec3.prototype, 'x', 0);
        defineAttr(jsb.Vec3.prototype, 'y', 1);
        defineAttr(jsb.Vec3.prototype, 'z', 2);
        extendType(jsb.Vec3.prototype, Vec3.prototype, MathType$1.VEC3);
        defineAttr(jsb.Vec4.prototype, 'x', 0);
        defineAttr(jsb.Vec4.prototype, 'y', 1);
        defineAttr(jsb.Vec4.prototype, 'z', 2);
        defineAttr(jsb.Vec4.prototype, 'w', 3);
        extendType(jsb.Vec4.prototype, Vec4.prototype, MathType$1.VEC4);
        defineAttr(jsb.Quat.prototype, 'x', 0);
        defineAttr(jsb.Quat.prototype, 'y', 1);
        defineAttr(jsb.Quat.prototype, 'z', 2);
        defineAttr(jsb.Quat.prototype, 'w', 3);
        extendType(jsb.Quat.prototype, Quat.prototype, MathType$1.QUATERNION);
        Object.setPrototypeOf(jsb.Color.prototype, Color$1.prototype);
        Object.defineProperty(jsb.Color.prototype, 'type', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: MathType$1.COLOR
        });
        inheritCCClass(jsb.Vec4, Vec4);
        inheritCCClass(jsb.Vec3, Vec3);
        inheritCCClass(jsb.Vec2, Vec2);
        inheritCCClass(jsb.Mat4, Mat4);
        inheritCCClass(jsb.Mat3, Mat3);
        inheritCCClass(jsb.Color, Color$1);
        inheritCCClass(jsb.Quat, Quat);
      }

      class AffineTransform {
        static identity() {
          return new AffineTransform();
        }
        static clone(affineTransform) {
          return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
        }
        static concat(out, t1, t2) {
          const a = t1.a;
          const b = t1.b;
          const c = t1.c;
          const d = t1.d;
          const tx = t1.tx;
          const ty = t1.ty;
          out.a = a * t2.a + b * t2.c;
          out.b = a * t2.b + b * t2.d;
          out.c = c * t2.a + d * t2.c;
          out.d = c * t2.b + d * t2.d;
          out.tx = tx * t2.a + ty * t2.c + t2.tx;
          out.ty = tx * t2.b + ty * t2.d + t2.ty;
        }
        static invert(out, t) {
          const determinant = 1 / (t.a * t.d - t.b * t.c);
          out.a = determinant * t.d;
          out.b = -determinant * t.b;
          out.c = -determinant * t.c;
          out.d = determinant * t.a;
          out.tx = determinant * (t.c * t.ty - t.d * t.tx);
          out.ty = determinant * (t.b * t.tx - t.a * t.ty);
        }
        static fromMat4(out, mat) {
          out.a = mat.m00;
          out.b = mat.m01;
          out.c = mat.m04;
          out.d = mat.m05;
          out.tx = mat.m12;
          out.ty = mat.m13;
        }
        static transformVec2(out, point, transOrY, t) {
          let x;
          let y;
          if (!t) {
            t = transOrY;
            x = point.x;
            y = point.y;
          } else {
            x = point;
            y = transOrY;
          }
          out.x = t.a * x + t.c * y + t.tx;
          out.y = t.b * x + t.d * y + t.ty;
        }
        static transformSize(out, size, t) {
          out.width = t.a * size.width + t.c * size.height;
          out.height = t.b * size.width + t.d * size.height;
        }
        static transformRect(out, rect, t) {
          const or = rect.x + rect.width;
          const ot = rect.y + rect.height;
          const lbx = t.a * rect.x + t.c * rect.y + t.tx;
          const lby = t.b * rect.x + t.d * rect.y + t.ty;
          const rbx = t.a * or + t.c * rect.y + t.tx;
          const rby = t.b * or + t.d * rect.y + t.ty;
          const ltx = t.a * rect.x + t.c * ot + t.tx;
          const lty = t.b * rect.x + t.d * ot + t.ty;
          const rtx = t.a * or + t.c * ot + t.tx;
          const rty = t.b * or + t.d * ot + t.ty;
          const minX = Math.min(lbx, rbx, ltx, rtx);
          const maxX = Math.max(lbx, rbx, ltx, rtx);
          const minY = Math.min(lby, rby, lty, rty);
          const maxY = Math.max(lby, rby, lty, rty);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
        }
        static transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform, flipY = true) {
          const tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
          const ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
          const xa = anAffineTransform.a * rect.width;
          const xb = anAffineTransform.b * rect.width;
          const yc = anAffineTransform.c * rect.height;
          const yd = anAffineTransform.d * rect.height;
          if (flipY) {
            out_tl.x = tx;
            out_tl.y = ty;
            out_tr.x = xa + tx;
            out_tr.y = xb + ty;
            out_bl.x = yc + tx;
            out_bl.y = yd + ty;
            out_br.x = xa + yc + tx;
            out_br.y = xb + yd + ty;
          } else {
            out_bl.x = tx;
            out_bl.y = ty;
            out_br.x = xa + tx;
            out_br.y = xb + ty;
            out_tl.x = yc + tx;
            out_tl.y = yd + ty;
            out_tr.x = xa + yc + tx;
            out_tr.y = xb + yd + ty;
          }
        }
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
          this.tx = tx;
          this.ty = ty;
        }
      } exports('AffineTransform', AffineTransform);
      legacyCC.AffineTransform = AffineTransform;

      var _class$1L;
      class Size$1 extends ValueType {
        static lerp(out, from, to, ratio) {
          out.width = from.width + (to.width - from.width) * ratio;
          out.height = from.height + (to.height - from.height) * ratio;
          return out;
        }
        static equals(a, b) {
          return a.width === b.width && a.height === b.height;
        }
        set x(val) {
          this.width = val;
        }
        get x() {
          return this.width;
        }
        set y(val) {
          this.height = val;
        }
        get y() {
          return this.height;
        }
        constructor(width, height) {
          super();
          if (typeof width === 'object') {
            this.width = width.width;
            this.height = width.height;
          } else {
            this.width = width || 0;
            this.height = height || 0;
          }
        }
        clone() {
          return new Size$1(this.width, this.height);
        }
        set(width, height) {
          if (typeof width === 'object') {
            this.height = width.height;
            this.width = width.width;
          } else {
            this.width = width || 0;
            this.height = height || 0;
          }
          return this;
        }
        equals(other) {
          return this.width === other.width && this.height === other.height;
        }
        lerp(to, ratio) {
          this.width += (to.width - this.width) * ratio;
          this.height += (to.height - this.height) * ratio;
          return this;
        }
        toString() {
          return `(${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
      } exports('Size', Size$1);
      _class$1L = Size$1;
      Size$1.ZERO = Object.freeze(new _class$1L(0, 0));
      Size$1.ONE = Object.freeze(new _class$1L(1, 1));
      CCClass.fastDefine('cc.Size', Size$1, {
        width: 0,
        height: 0
      });
      function size(width = 0, height = 0) {
        return new Size$1(width, height);
      }
      legacyCC.size = size;
      legacyCC.Size = Size$1;

      class Rect$1 extends ValueType {
        static fromMinMax(out, v1, v2) {
          const minX = Math.min(v1.x, v2.x);
          const minY = Math.min(v1.y, v2.y);
          const maxX = Math.max(v1.x, v2.x);
          const maxY = Math.max(v1.y, v2.y);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
          return out;
        }
        static lerp(out, from, to, ratio) {
          const x = from.x;
          const y = from.y;
          const w = from.width;
          const h = from.height;
          out.x = x + (to.x - x) * ratio;
          out.y = y + (to.y - y) * ratio;
          out.width = w + (to.width - w) * ratio;
          out.height = h + (to.height - h) * ratio;
          return out;
        }
        static intersection(out, one, other) {
          const axMin = one.x;
          const ayMin = one.y;
          const axMax = one.x + one.width;
          const ayMax = one.y + one.height;
          const bxMin = other.x;
          const byMin = other.y;
          const bxMax = other.x + other.width;
          const byMax = other.y + other.height;
          out.x = Math.max(axMin, bxMin);
          out.y = Math.max(ayMin, byMin);
          out.width = Math.min(axMax, bxMax) - out.x;
          out.height = Math.min(ayMax, byMax) - out.y;
          return out;
        }
        static union(out, one, other) {
          const x = one.x;
          const y = one.y;
          const w = one.width;
          const h = one.height;
          const bx = other.x;
          const by = other.y;
          const bw = other.width;
          const bh = other.height;
          out.x = Math.min(x, bx);
          out.y = Math.min(y, by);
          out.width = Math.max(x + w, bx + bw) - out.x;
          out.height = Math.max(y + h, by + bh) - out.y;
          return out;
        }
        static equals(a, b) {
          return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
        }
        get xMin() {
          return this.x;
        }
        set xMin(value) {
          this.width += this.x - value;
          this.x = value;
        }
        get yMin() {
          return this.y;
        }
        set yMin(value) {
          this.height += this.y - value;
          this.y = value;
        }
        get xMax() {
          return this.x + this.width;
        }
        set xMax(value) {
          this.width = value - this.x;
        }
        get yMax() {
          return this.y + this.height;
        }
        set yMax(value) {
          this.height = value - this.y;
        }
        get center() {
          return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
        }
        set center(value) {
          this.x = value.x - this.width * 0.5;
          this.y = value.y - this.height * 0.5;
        }
        get origin() {
          return new Vec2(this.x, this.y);
        }
        set origin(value) {
          this.x = value.x;
          this.y = value.y;
        }
        get size() {
          return new Size$1(this.width, this.height);
        }
        set size(value) {
          this.width = value.width;
          this.height = value.height;
        }
        set z(val) {
          this.width = val;
        }
        get z() {
          return this.width;
        }
        set w(val) {
          this.height = val;
        }
        get w() {
          return this.height;
        }
        constructor(x, y, width, height) {
          super();
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
          }
        }
        clone() {
          return new Rect$1(this.x, this.y, this.width, this.height);
        }
        set(x, y, width, height) {
          if (typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
          }
          return this;
        }
        equals(other) {
          return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        }
        lerp(to, ratio) {
          const x = this.x;
          const y = this.y;
          const w = this.width;
          const h = this.height;
          this.x = x + (to.x - x) * ratio;
          this.y = y + (to.y - y) * ratio;
          this.width = w + (to.width - w) * ratio;
          this.height = h + (to.height - h) * ratio;
          return this;
        }
        toString() {
          return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
        }
        intersects(other) {
          const maxax = this.x + this.width;
          const maxay = this.y + this.height;
          const maxbx = other.x + other.width;
          const maxby = other.y + other.height;
          return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
        }
        contains(point) {
          return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        }
        containsRect(other) {
          return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
        }
        transformMat4(mat) {
          const ol = this.x;
          const ob = this.y;
          const or = ol + this.width;
          const ot = ob + this.height;
          const lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
          const lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
          const rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
          const rby = mat.m01 * or + mat.m05 * ob + mat.m13;
          const ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
          const lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
          const rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
          const rty = mat.m01 * or + mat.m05 * ot + mat.m13;
          const minX = Math.min(lbx, rbx, ltx, rtx);
          const maxX = Math.max(lbx, rbx, ltx, rtx);
          const minY = Math.min(lby, rby, lty, rty);
          const maxY = Math.max(lby, rby, lty, rty);
          this.x = minX;
          this.y = minY;
          this.width = maxX - minX;
          this.height = maxY - minY;
          return this;
        }
        transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
          const ol = this.x;
          const ob = this.y;
          const or = ol + this.width;
          const ot = ob + this.height;
          out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
          out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
          out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
          out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
          out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
          out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
          out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
          out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
        }
      } exports('Rect', Rect$1);
      CCClass.fastDefine('cc.Rect', Rect$1, {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      legacyCC.Rect = Rect$1;
      function rect(x = 0, y = 0, width = 0, height = 0) {
        return new Rect$1(x, y, width, height);
      }
      legacyCC.rect = rect;

      const MATH_FLOAT_ARRAY = exports('MATH_FLOAT_ARRAY', Float32Array );
      class MathBase extends ValueType {
        static createFloatArray(size) {
          return new MATH_FLOAT_ARRAY(size);
        }
        get array() {
          return this._array;
        }
      } exports('MathBase', MathBase);

      var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bits: bits,
        Vec2: Vec2,
        v2: v2$1,
        Vec3: Vec3,
        v3: v3,
        Vec4: Vec4,
        v4: v4,
        Quat: Quat,
        quat: quat,
        Mat3: Mat3,
        Mat4: Mat4,
        mat4: mat4,
        AffineTransform: AffineTransform,
        Size: Size$1,
        size: size,
        Rect: Rect$1,
        rect: rect,
        Color: Color$1,
        color: color,
        preTransforms: preTransforms,
        HALF_PI: HALF_PI,
        TWO_PI: TWO_PI,
        EPSILON: EPSILON$2,
        equals: equals$1,
        approx: approx,
        clamp: clamp$1,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        setRandGenerator: setRandGenerator,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        nextPow2: nextPow2,
        repeat: repeat$2,
        pingPong: pingPong,
        inverseLerp: inverseLerp,
        absMaxComponent: absMaxComponent,
        absMax: absMax,
        enumerableProps: enumerableProps,
        floatToHalf: floatToHalf,
        halfToFloat: halfToFloat,
        MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
        MathBase: MathBase
      });
      exports('math', math);

      const X = new Vec3();
      const Y = new Vec3();
      const Z = new Vec3();
      const d = new Vec3();
      const min$2 = new Vec3();
      const max$3 = new Vec3();
      const u = new Array(3);
      const e = new Array(3);
      function point_plane(point, plane_) {
        return Vec3.dot(plane_.n, point) - plane_.d;
      }
      function pt_point_plane(out, point, plane_) {
        const t = point_plane(point, plane_);
        return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
      }
      function pt_point_aabb(out, point, aabb_) {
        Vec3.copy(out, point);
        Vec3.subtract(min$2, aabb_.center, aabb_.halfExtents);
        Vec3.add(max$3, aabb_.center, aabb_.halfExtents);
        out.x = out.x < min$2.x ? min$2.x : out.x;
        out.y = out.y < min$2.y ? min$2.y : out.y;
        out.z = out.z < min$2.z ? min$2.z : out.z;
        out.x = out.x > max$3.x ? max$3.x : out.x;
        out.y = out.y > max$3.y ? max$3.y : out.y;
        out.z = out.z > max$3.z ? max$3.z : out.z;
        return out;
      }
      function pt_point_obb(out, point, obb_) {
        Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
        Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
        Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
        u[0] = X;
        u[1] = Y;
        u[2] = Z;
        e[0] = obb_.halfExtents.x;
        e[1] = obb_.halfExtents.y;
        e[2] = obb_.halfExtents.z;
        Vec3.subtract(d, point, obb_.center);
        Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
        for (let i = 0; i < 3; i++) {
          let dist = Vec3.dot(d, u[i]);
          if (dist > e[i]) {
            dist = e[i];
          }
          if (dist < -e[i]) {
            dist = -e[i];
          }
          out.x += dist * u[i].x;
          out.y += dist * u[i].y;
          out.z += dist * u[i].z;
        }
        return out;
      }
      function pt_point_line(out, point, linePointA, linePointB) {
        Vec3.subtract(X, linePointA, linePointB);
        const dir = X.clone();
        const dirSquaredLength = Vec3.lengthSqr(dir);
        if (dirSquaredLength === 0) {
          Vec3.copy(out, linePointA);
        } else {
          Vec3.subtract(X, point, linePointA);
          const t = Vec3.dot(X, dir) / dirSquaredLength;
          if (t < 0) {
            Vec3.copy(out, linePointA);
          } else if (t > 1) {
            Vec3.copy(out, linePointB);
          } else {
            Vec3.scaleAndAdd(out, linePointA, dir, t);
          }
        }
      }

      var distance = /*#__PURE__*/Object.freeze({
        __proto__: null,
        point_plane: point_plane,
        pt_point_plane: pt_point_plane,
        pt_point_aabb: pt_point_aabb,
        pt_point_obb: pt_point_obb,
        pt_point_line: pt_point_line
      });

      var enums = {
        SHAPE_RAY: 1 << 0,
        SHAPE_LINE: 1 << 1,
        SHAPE_SPHERE: 1 << 2,
        SHAPE_AABB: 1 << 3,
        SHAPE_OBB: 1 << 4,
        SHAPE_PLANE: 1 << 5,
        SHAPE_TRIANGLE: 1 << 6,
        SHAPE_FRUSTUM: 1 << 7,
        SHAPE_FRUSTUM_ACCURATE: 1 << 8,
        SHAPE_CAPSULE: 1 << 9,
        SHAPE_SPLINE: 1 << 10
      };

      class Line$1 {
        static create(sx, sy, sz, ex, ey, ez) {
          return new Line$1(sx, sy, sz, ex, ey, ez);
        }
        static clone(a) {
          return new Line$1(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
        }
        static copy(out, a) {
          Vec3.copy(out.s, a.s);
          Vec3.copy(out.e, a.e);
          return out;
        }
        static fromPoints(out, start, end) {
          Vec3.copy(out.s, start);
          Vec3.copy(out.e, end);
          return out;
        }
        static set(out, sx, sy, sz, ex, ey, ez) {
          out.s.x = sx;
          out.s.y = sy;
          out.s.z = sz;
          out.e.x = ex;
          out.e.y = ey;
          out.e.z = ez;
          return out;
        }
        static len(a) {
          return Vec3.distance(a.s, a.e);
        }
        get type() {
          return this._type;
        }
        constructor(sx = 0, sy = 0, sz = 0, ex = 0, ey = 0, ez = -1) {
          this.s = void 0;
          this.e = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_LINE;
          this.s = new Vec3(sx, sy, sz);
          this.e = new Vec3(ex, ey, ez);
        }
        length() {
          return Vec3.distance(this.s, this.e);
        }
      }

      class Ray {
        static create(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = 1) {
          return new Ray(ox, oy, oz, dx, dy, dz);
        }
        static clone(a) {
          return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
        }
        static copy(out, a) {
          Vec3.copy(out.o, a.o);
          Vec3.copy(out.d, a.d);
          return out;
        }
        static fromPoints(out, origin, target) {
          Vec3.copy(out.o, origin);
          Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
          return out;
        }
        static set(out, ox, oy, oz, dx, dy, dz) {
          out.o.x = ox;
          out.o.y = oy;
          out.o.z = oz;
          out.d.x = dx;
          out.d.y = dy;
          out.d.z = dz;
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = -1) {
          this.o = void 0;
          this.d = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_RAY;
          this.o = new Vec3(ox, oy, oz);
          this.d = new Vec3(dx, dy, dz);
        }
        computeHit(out, distance) {
          Vec3.normalize(out, this.d);
          Vec3.scaleAndAdd(out, this.o, out, distance);
        }
      }

      const _v3_tmp$2 = new Vec3();
      const _offset = new Vec3();
      const _min = new Vec3();
      const _max = new Vec3();
      function maxComponent$1(v) {
        return Math.max(Math.max(v.x, v.y), v.z);
      }
      class Sphere {
        static create(cx, cy, cz, r) {
          return new Sphere(cx, cy, cz, r);
        }
        static clone(p) {
          return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
        }
        static copy(out, p) {
          Vec3.copy(out.center, p.center);
          out.radius = p.radius;
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
          out.radius = Vec3.subtract(_v3_tmp$2, maxPos, minPos).length() * 0.5;
          return out;
        }
        static set(out, cx, cy, cz, r) {
          out.center.x = cx;
          out.center.y = cy;
          out.center.z = cz;
          out.radius = r;
          return out;
        }
        get center() {
          return this._center;
        }
        set center(val) {
          this._center = val;
        }
        get radius() {
          return this._radius;
        }
        set radius(val) {
          this._radius = val;
        }
        get type() {
          return this._type;
        }
        constructor(cx = 0, cy = 0, cz = 0, r = 1) {
          this._center = new Vec3(0, 0, 0);
          this._radius = 0;
          this._type = void 0;
          this._type = enums.SHAPE_SPHERE;
          this._center = new Vec3(cx, cy, cz);
          this._radius = r;
        }
        destroy() {}
        clone() {
          return Sphere.clone(this);
        }
        copy(a) {
          return Sphere.copy(this, a);
        }
        getBoundary(minPos, maxPos) {
          Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
          Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          out.radius = this.radius * maxComponent$1(scale);
        }
        translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
        }
        setScale(scale, out) {
          out.radius = this.radius * maxComponent$1(scale);
        }
        mergePoint(point) {
          if (this.radius < 0.0) {
            this.center.set(point);
            this.radius = 0.0;
          }
          Vec3.subtract(_offset, point, this.center);
          const dist = _offset.length();
          if (dist > this.radius) {
            const half = (dist - this.radius) * 0.5;
            this.radius += half;
            Vec3.multiplyScalar(_offset, _offset, half / dist);
            Vec3.add(this.center, this.center, _offset);
          }
        }
        mergePoints(points) {
          const length = points.length;
          if (length < 1) return;
          this.radius = -1.0;
          for (let i = 0; i < length; i++) {
            this.mergePoint(points[i]);
          }
        }
        mergeAABB(a) {
          a.getBoundary(_min, _max);
          this.mergePoint(_min);
          this.mergePoint(_max);
        }
      }

      const rayPlane = function () {
        return function (ray, plane) {
          const denom = Vec3.dot(ray.d, plane.n);
          if (Math.abs(denom) < Number.EPSILON) {
            return 0;
          }
          const d = point_plane(ray.o, plane);
          const t = -d / denom;
          if (t < 0) {
            return 0;
          }
          return t;
        };
      }();
      const rayTriangle = function () {
        const ab = new Vec3(0, 0, 0);
        const ac = new Vec3(0, 0, 0);
        const pvec = new Vec3(0, 0, 0);
        const tvec = new Vec3(0, 0, 0);
        const qvec = new Vec3(0, 0, 0);
        return function (ray, triangle, doubleSided) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.cross(pvec, ray.d, ac);
          const det = Vec3.dot(ab, pvec);
          if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
            return 0;
          }
          const inv_det = 1 / det;
          Vec3.subtract(tvec, ray.o, triangle.a);
          const u = Vec3.dot(tvec, pvec) * inv_det;
          if (u < 0 || u > 1) {
            return 0;
          }
          Vec3.cross(qvec, tvec, ab);
          const v = Vec3.dot(ray.d, qvec) * inv_det;
          if (v < 0 || u + v > 1) {
            return 0;
          }
          const t = Vec3.dot(ac, qvec) * inv_det;
          return t < 0 ? 0 : t;
        };
      }();
      const raySphere = function () {
        const e = new Vec3(0, 0, 0);
        return function (ray, sphere) {
          const r = sphere.radius;
          const c = sphere.center;
          const o = ray.o;
          const d = ray.d;
          const rSq = r * r;
          Vec3.subtract(e, c, o);
          const eSq = e.lengthSqr();
          const aLength = Vec3.dot(e, d);
          const fSq = rSq - (eSq - aLength * aLength);
          if (fSq < 0) {
            return 0;
          }
          const f = Math.sqrt(fSq);
          const t = eSq < rSq ? aLength + f : aLength - f;
          if (t < 0) {
            return 0;
          }
          return t;
        };
      }();
      const rayAABB = function () {
        const min = new Vec3();
        const max = new Vec3();
        return function (ray, aabb) {
          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          return rayAABB2$1(ray, min, max);
        };
      }();
      function rayAABB2$1(ray, min, max) {
        const o = ray.o;
        const d = ray.d;
        const ix = 1 / d.x;
        const iy = 1 / d.y;
        const iz = 1 / d.z;
        const t1 = (min.x - o.x) * ix;
        const t2 = (max.x - o.x) * ix;
        const t3 = (min.y - o.y) * iy;
        const t4 = (max.y - o.y) * iy;
        const t5 = (min.z - o.z) * iz;
        const t6 = (max.z - o.z) * iz;
        const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) {
          return 0;
        }
        return tmin > 0 ? tmin : tmax;
      }
      const rayOBB = function () {
        let center = new Vec3();
        let o = new Vec3();
        let d = new Vec3();
        const X = new Vec3();
        const Y = new Vec3();
        const Z = new Vec3();
        const p = new Vec3();
        const size = new Array(3);
        const f = new Array(3);
        const e = new Array(3);
        const t = new Array(6);
        return function (ray, obb) {
          size[0] = obb.halfExtents.x;
          size[1] = obb.halfExtents.y;
          size[2] = obb.halfExtents.z;
          center = obb.center;
          o = ray.o;
          d = ray.d;
          Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          Vec3.subtract(p, center, o);
          f[0] = Vec3.dot(X, d);
          f[1] = Vec3.dot(Y, d);
          f[2] = Vec3.dot(Z, d);
          e[0] = Vec3.dot(X, p);
          e[1] = Vec3.dot(Y, p);
          e[2] = Vec3.dot(Z, p);
          for (let i = 0; i < 3; ++i) {
            if (f[i] === 0) {
              if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                return 0;
              }
              f[i] = 0.0000001;
            }
            t[i * 2 + 0] = (e[i] + size[i]) / f[i];
            t[i * 2 + 1] = (e[i] - size[i]) / f[i];
          }
          const tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
          const tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
          if (tmax < 0 || tmin > tmax) {
            return 0;
          }
          return tmin > 0 ? tmin : tmax;
        };
      }();
      const rayCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_3 = new Vec3();
        const v3_4 = new Vec3();
        const v3_5 = new Vec3();
        const v3_6 = new Vec3();
        const sphere_0 = new Sphere();
        return function (ray, capsule) {
          const A = capsule.ellipseCenter0;
          const B = capsule.ellipseCenter1;
          const BA = Vec3.subtract(v3_1, B, A);
          if (BA.length() < EPSILON$2) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.raySphere(ray, sphere_0);
          }
          const O = ray.o;
          const OA = Vec3.subtract(v3_2, O, A);
          const vRayNorm = Vec3.normalize(v3_0, ray.d);
          const VxBA = Vec3.cross(v3_3, vRayNorm, BA);
          const a = VxBA.lengthSqr();
          if (a === 0) {
            sphere_0.radius = capsule.radius;
            const BO = Vec3.subtract(v3_4, B, O);
            if (OA.lengthSqr() < BO.lengthSqr()) {
              sphere_0.center.set(A);
            } else {
              sphere_0.center.set(B);
            }
            return intersect.raySphere(ray, sphere_0);
          }
          const OAxBA = Vec3.cross(v3_4, OA, BA);
          const ab2 = BA.lengthSqr();
          const b = 2 * Vec3.dot(VxBA, OAxBA);
          const radiusSqr = capsule.radius * capsule.radius;
          const c = OAxBA.lengthSqr() - radiusSqr * ab2;
          const d = b * b - 4 * a * c;
          if (d < 0) {
            return 0;
          }
          const t = (-b - Math.sqrt(d)) / (2 * a);
          if (t < 0) {
            sphere_0.radius = capsule.radius;
            const BO = Vec3.subtract(v3_5, B, O);
            if (OA.lengthSqr() < BO.lengthSqr()) {
              sphere_0.center.set(capsule.ellipseCenter0);
            } else {
              sphere_0.center.set(capsule.ellipseCenter1);
            }
            return intersect.raySphere(ray, sphere_0);
          } else {
            const iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
            const iPosLen = Vec3.subtract(v3_6, iPos, A);
            const tLimit = Vec3.dot(iPosLen, BA) / ab2;
            if (tLimit >= 0 && tLimit <= 1) {
              return t;
            } else if (tLimit < 0) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter0);
              return intersect.raySphere(ray, sphere_0);
            } else if (tLimit > 1) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter1);
              return intersect.raySphere(ray, sphere_0);
            } else {
              return 0;
            }
          }
        };
      }();
      const linePlane = function () {
        const ab = new Vec3(0, 0, 0);
        return function (line, plane) {
          Vec3.subtract(ab, line.e, line.s);
          const t = -point_plane(line.s, plane) / Vec3.dot(ab, plane.n);
          if (t < 0 || t > 1) {
            return 0;
          }
          return t;
        };
      }();
      const lineTriangle = function () {
        const ab = new Vec3(0, 0, 0);
        const ac = new Vec3(0, 0, 0);
        const qp = new Vec3(0, 0, 0);
        const ap = new Vec3(0, 0, 0);
        const n = new Vec3(0, 0, 0);
        const e = new Vec3(0, 0, 0);
        return function (line, triangle, outPt) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.subtract(qp, line.s, line.e);
          Vec3.cross(n, ab, ac);
          const det = Vec3.dot(qp, n);
          if (det <= 0.0) {
            return 0;
          }
          Vec3.subtract(ap, line.s, triangle.a);
          const t = Vec3.dot(ap, n);
          if (t < 0 || t > det) {
            return 0;
          }
          Vec3.cross(e, qp, ap);
          let v = Vec3.dot(ac, e);
          if (v < 0 || v > det) {
            return 0;
          }
          let w = -Vec3.dot(ab, e);
          if (w < 0.0 || v + w > det) {
            return 0;
          }
          if (outPt) {
            const invDet = 1.0 / det;
            v *= invDet;
            w *= invDet;
            const u = 1.0 - v - w;
            Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
          }
          return 1;
        };
      }();
      const r_t = new Ray();
      function lineAABB(line, aabb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = rayAABB(r_t, aabb);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      function lineOBB(line, obb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = rayOBB(r_t, obb);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      function lineSphere(line, sphere) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        const min = raySphere(r_t, sphere);
        const len = line.length();
        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }
      const aabbWithAABB = function () {
        const aMin = new Vec3();
        const aMax = new Vec3();
        const bMin = new Vec3();
        const bMax = new Vec3();
        return function (aabb1, aabb2) {
          Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
          Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
          Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
          Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
          return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
        };
      }();
      function getAABBVertices(min, max, out) {
        Vec3.set(out[0], min.x, max.y, max.z);
        Vec3.set(out[1], min.x, max.y, min.z);
        Vec3.set(out[2], min.x, min.y, max.z);
        Vec3.set(out[3], min.x, min.y, min.z);
        Vec3.set(out[4], max.x, max.y, max.z);
        Vec3.set(out[5], max.x, max.y, min.z);
        Vec3.set(out[6], max.x, min.y, max.z);
        Vec3.set(out[7], max.x, min.y, min.z);
      }
      function getOBBVertices(c, e, a1, a2, a3, out) {
        Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
        Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
      }
      function getInterval(vertices, axis) {
        let min = Vec3.dot(axis, vertices[0]);
        let max = min;
        for (let i = 1; i < 8; ++i) {
          const projection = Vec3.dot(axis, vertices[i]);
          min = projection < min ? projection : min;
          max = projection > max ? projection : max;
        }
        return [min, max];
      }
      const aabbWithOBB = function () {
        const test = new Array(15);
        for (let i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }
        const vertices = new Array(8);
        const vertices2 = new Array(8);
        for (let i = 0; i < 8; i++) {
          vertices[i] = new Vec3(0, 0, 0);
          vertices2[i] = new Vec3(0, 0, 0);
        }
        const min = new Vec3();
        const max = new Vec3();
        return function (aabb, obb) {
          Vec3.set(test[0], 1, 0, 0);
          Vec3.set(test[1], 0, 1, 0);
          Vec3.set(test[2], 0, 0, 1);
          Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          for (let i = 0; i < 3; ++i) {
            Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[5]);
          }
          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          getAABBVertices(min, max, vertices);
          getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
          for (let j = 0; j < 15; ++j) {
            const a = getInterval(vertices, test[j]);
            const b = getInterval(vertices2, test[j]);
            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }
          return 1;
        };
      }();
      const aabbPlane = function (aabb, plane) {
        const r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
        const dot = Vec3.dot(plane.n, aabb.center);
        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }
        return 1;
      };
      const aabbFrustum = function (aabb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (aabbPlane(aabb, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const aabbFrustumCompletelyInside = function (aabb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (aabbPlane(aabb, frustum.planes[i]) !== 0) {
            return 0;
          }
        }
        return 1;
      };
      const aabbFrustumAccurate = function () {
        const tmp = new Array(8);
        let out1 = 0;
        let out2 = 0;
        for (let i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }
        return function (aabb, frustum) {
          let result = 0;
          let intersects = false;
          for (let i = 0; i < frustum.planes.length; i++) {
            result = aabbPlane(aabb, frustum.planes[i]);
            if (result === -1) return 0;else if (result === 1) {
              intersects = true;
            }
          }
          if (!intersects) {
            return 1;
          }
          for (let i = 0; i < frustum.vertices.length; i++) {
            Vec3.subtract(tmp[i], frustum.vertices[i], aabb.center);
          }
          out1 = 0, out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].x > aabb.halfExtents.x) {
              out1++;
            } else if (tmp[i].x < -aabb.halfExtents.x) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].y > aabb.halfExtents.y) {
              out1++;
            } else if (tmp[i].y < -aabb.halfExtents.y) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            if (tmp[i].z > aabb.halfExtents.z) {
              out1++;
            } else if (tmp[i].z < -aabb.halfExtents.z) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          return 1;
        };
      }();
      const obbPoint = function () {
        const tmp = new Vec3(0, 0, 0);
        const m3 = new Mat3();
        const lessThan = function (a, b) {
          return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
        };
        return function (obb, point) {
          Vec3.subtract(tmp, point, obb.center);
          Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
          return lessThan(tmp, obb.halfExtents);
        };
      }();
      const obbPlane = function () {
        const absDot = function (n, x, y, z) {
          return Math.abs(n.x * x + n.y * y + n.z * z);
        };
        return function (obb, plane) {
          const r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          const dot = Vec3.dot(plane.n, obb.center);
          if (dot + r < plane.d) {
            return -1;
          } else if (dot - r > plane.d) {
            return 0;
          }
          return 1;
        };
      }();
      const obbFrustum = function (obb, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (obbPlane(obb, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const obbFrustumAccurate = function () {
        const tmp = new Array(8);
        let dist = 0;
        let out1 = 0;
        let out2 = 0;
        for (let i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }
        const dot = function (n, x, y, z) {
          return n.x * x + n.y * y + n.z * z;
        };
        return function (obb, frustum) {
          let result = 0;
          let intersects = false;
          for (let i = 0; i < frustum.planes.length; i++) {
            result = obbPlane(obb, frustum.planes[i]);
            if (result === -1) return 0;else if (result === 1) {
              intersects = true;
            }
          }
          if (!intersects) {
            return 1;
          }
          for (let i = 0; i < frustum.vertices.length; i++) {
            Vec3.subtract(tmp[i], frustum.vertices[i], obb.center);
          }
          out1 = 0, out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
            if (dist > obb.halfExtents.x) {
              out1++;
            } else if (dist < -obb.halfExtents.x) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
            if (dist > obb.halfExtents.y) {
              out1++;
            } else if (dist < -obb.halfExtents.y) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          out1 = 0;
          out2 = 0;
          for (let i = 0; i < frustum.vertices.length; i++) {
            dist = dot(tmp[i], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
            if (dist > obb.halfExtents.z) {
              out1++;
            } else if (dist < -obb.halfExtents.z) {
              out2++;
            }
          }
          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }
          return 1;
        };
      }();
      const obbWithOBB = function () {
        const test = new Array(15);
        for (let i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }
        const vertices = new Array(8);
        const vertices2 = new Array(8);
        for (let i = 0; i < 8; i++) {
          vertices[i] = new Vec3(0, 0, 0);
          vertices2[i] = new Vec3(0, 0, 0);
        }
        return function (obb1, obb2) {
          Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
          Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
          Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
          Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
          Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
          Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
          for (let i = 0; i < 3; ++i) {
            Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
            Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
            Vec3.cross(test[6 + i * 3 + 2], test[i], test[5]);
          }
          getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
          getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
          for (let i = 0; i < 15; ++i) {
            const a = getInterval(vertices, test[i]);
            const b = getInterval(vertices2, test[i]);
            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }
          return 1;
        };
      }();
      const obbCapsule = function () {
        const sphere_0 = new Sphere();
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_verts8 = new Array(8);
        for (let i = 0; i < 8; i++) {
          v3_verts8[i] = new Vec3();
        }
        const v3_axis8 = new Array(8);
        for (let i = 0; i < 8; i++) {
          v3_axis8[i] = new Vec3();
        }
        return function (obb, capsule) {
          const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
          if (h === 0) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.sphereOBB(sphere_0, obb);
          } else {
            v3_0.x = obb.orientation.m00;
            v3_0.y = obb.orientation.m01;
            v3_0.z = obb.orientation.m02;
            v3_1.x = obb.orientation.m03;
            v3_1.y = obb.orientation.m04;
            v3_1.z = obb.orientation.m05;
            v3_2.x = obb.orientation.m06;
            v3_2.y = obb.orientation.m07;
            v3_2.z = obb.orientation.m08;
            getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
            const axes = v3_axis8;
            const a0 = Vec3.copy(axes[0], v3_0);
            const a1 = Vec3.copy(axes[1], v3_1);
            const a2 = Vec3.copy(axes[2], v3_2);
            const C = Vec3.subtract(axes[3], capsule.center, obb.center);
            C.normalize();
            const B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
            B.normalize();
            Vec3.cross(axes[5], a0, B);
            Vec3.cross(axes[6], a1, B);
            Vec3.cross(axes[7], a2, B);
            for (let i = 0; i < 8; ++i) {
              const a = getInterval(v3_verts8, axes[i]);
              const d0 = Vec3.dot(axes[i], capsule.ellipseCenter0);
              const d1 = Vec3.dot(axes[i], capsule.ellipseCenter1);
              const max_d = Math.max(d0, d1);
              const min_d = Math.min(d0, d1);
              const d_min = min_d - capsule.radius;
              const d_max = max_d + capsule.radius;
              if (d_min > a[1] || a[0] > d_max) {
                return 0;
              }
            }
            return 1;
          }
        };
      }();
      const spherePlane = function (sphere, plane) {
        const dot = Vec3.dot(plane.n, sphere.center);
        const r = sphere.radius * plane.n.length();
        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }
        return 1;
      };
      const sphereFrustum = function (sphere, frustum) {
        for (let i = 0; i < frustum.planes.length; i++) {
          if (spherePlane(sphere, frustum.planes[i]) === -1) {
            return 0;
          }
        }
        return 1;
      };
      const sphereFrustumAccurate = function () {
        const pt = new Vec3(0, 0, 0);
        const map = [1, -1, 1, -1, 1, -1];
        return function (sphere, frustum) {
          for (let i = 0; i < 6; i++) {
            const plane = frustum.planes[i];
            const r = sphere.radius;
            const c = sphere.center;
            const n = plane.n;
            const d = plane.d;
            const dot = Vec3.dot(n, c);
            if (dot + r < d) return 0;else if (dot - r > d) {
              continue;
            }
            Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
            for (let j = 0; j < 6; j++) {
              if (j === i || j === i + map[i]) {
                continue;
              }
              const test = frustum.planes[j];
              if (Vec3.dot(test.n, pt) < test.d) {
                return 0;
              }
            }
          }
          return 1;
        };
      }();
      const sphereWithSphere = function (sphere0, sphere1) {
        const r = sphere0.radius + sphere1.radius;
        return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
      };
      const sphereAABB = function () {
        const pt = new Vec3();
        return function (sphere, aabb) {
          pt_point_aabb(pt, sphere.center, aabb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();
      const sphereOBB = function () {
        const pt = new Vec3();
        return function (sphere, obb) {
          pt_point_obb(pt, sphere.center, obb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();
      const sphereCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        return function (sphere, capsule) {
          const r = sphere.radius + capsule.radius;
          const squaredR = r * r;
          const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
          if (h === 0) {
            return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
          } else {
            Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
            Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
            const t = Vec3.dot(v3_0, v3_1) / h;
            if (t < 0) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
            } else if (t > 1) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
            } else {
              Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
              return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
            }
          }
        };
      }();
      const capsuleWithCapsule = function () {
        const v3_0 = new Vec3();
        const v3_1 = new Vec3();
        const v3_2 = new Vec3();
        const v3_3 = new Vec3();
        const v3_4 = new Vec3();
        const v3_5 = new Vec3();
        return function capsuleWithCapsule(capsuleA, capsuleB) {
          const u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
          const v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
          const w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
          const a = Vec3.dot(u, u);
          const b = Vec3.dot(u, v);
          const c = Vec3.dot(v, v);
          const d = Vec3.dot(u, w);
          const e = Vec3.dot(v, w);
          const D = a * c - b * b;
          let sN;
          let sD = D;
          let tN;
          let tD = D;
          if (D < EPSILON$2) {
            sN = 0.0;
            sD = 1.0;
            tN = e;
            tD = c;
          } else {
            sN = b * e - c * d;
            tN = a * e - b * d;
            if (sN < 0.0) {
              sN = 0.0;
              tN = e;
              tD = c;
            } else if (sN > sD) {
              sN = sD;
              tN = e + b;
              tD = c;
            }
          }
          if (tN < 0.0) {
            tN = 0.0;
            if (-d < 0.0) {
              sN = 0.0;
            } else if (-d > a) {
              sN = sD;
            } else {
              sN = -d;
              sD = a;
            }
          } else if (tN > tD) {
            tN = tD;
            if (-d + b < 0.0) {
              sN = 0;
            } else if (-d + b > a) {
              sN = sD;
            } else {
              sN = -d + b;
              sD = a;
            }
          }
          const sc = Math.abs(sN) < EPSILON$2 ? 0.0 : sN / sD;
          const tc = Math.abs(tN) < EPSILON$2 ? 0.0 : tN / tD;
          const dP = v3_3;
          dP.set(w);
          dP.add(Vec3.multiplyScalar(v3_4, u, sc));
          dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
          const radius = capsuleA.radius + capsuleB.radius;
          return dP.lengthSqr() < radius * radius;
        };
      }();
      const intersect = {
        raySphere,
        rayAABB,
        rayOBB,
        rayPlane,
        rayTriangle,
        rayCapsule,
        raySubMesh: null,
        rayMesh: null,
        rayModel: null,
        lineSphere,
        lineAABB,
        lineOBB,
        linePlane,
        lineTriangle,
        sphereWithSphere,
        sphereAABB,
        sphereOBB,
        spherePlane,
        sphereFrustum,
        sphereFrustumAccurate,
        sphereCapsule,
        aabbWithAABB,
        aabbWithOBB,
        aabbPlane,
        aabbFrustum,
        aabbFrustumAccurate,
        obbWithOBB,
        obbPlane,
        obbFrustum,
        obbFrustumAccurate,
        obbPoint,
        obbCapsule,
        aabbFrustumCompletelyInside,
        capsuleWithCapsule,
        resolve(g1, g2, outPt = null) {
          const type1 = g1._type;
          const type2 = g2._type;
          const resolver = this[type1 | type2];
          return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
        }
      };
      intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
      intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
      intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
      intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
      intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
      intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
      intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
      intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
      intersect[enums.SHAPE_AABB] = aabbWithAABB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
      intersect[enums.SHAPE_OBB] = obbWithOBB;
      intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
      intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
      intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

      replaceProperty(Line$1.prototype, 'line', [{
        name: 'mag',
        newName: 'len'
      }, {
        name: 'magnitude',
        newName: 'len'
      }]);
      removeProperty(intersect, 'intersect', [{
        name: 'line_quad'
      }]);

      const v1 = new Vec3(0, 0, 0);
      const v2 = new Vec3(0, 0, 0);
      const temp_mat = legacyCC.mat4();
      const temp_vec4 = legacyCC.v4();
      class Plane {
        static create(nx, ny, nz, d) {
          return new Plane(nx, ny, nz, d);
        }
        static clone(p) {
          return new Plane(p.n.x, p.n.y, p.n.z, p.d);
        }
        static copy(out, p) {
          Vec3.copy(out.n, p.n);
          out.d = p.d;
          return out;
        }
        static fromPoints(out, a, b, c) {
          Vec3.subtract(v1, b, a);
          Vec3.subtract(v2, c, a);
          Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2));
          out.d = Vec3.dot(out.n, a);
          return out;
        }
        static set(out, nx, ny, nz, d) {
          out.n.x = nx;
          out.n.y = ny;
          out.n.z = nz;
          out.d = d;
          return out;
        }
        static fromNormalAndPoint(out, normal, point) {
          Vec3.copy(out.n, normal);
          out.d = Vec3.dot(normal, point);
          return out;
        }
        static normalize(out, a) {
          const len = a.n.length();
          Vec3.normalize(out.n, a.n);
          if (len > 0) {
            out.d = a.d / len;
          }
          return out;
        }
        get type() {
          return this._type;
        }
        set x(val) {
          this.n.x = val;
        }
        get x() {
          return this.n.x;
        }
        set y(val) {
          this.n.y = val;
        }
        get y() {
          return this.n.y;
        }
        set z(val) {
          this.n.z = val;
        }
        get z() {
          return this.n.z;
        }
        set w(val) {
          this.d = val;
        }
        get w() {
          return this.d;
        }
        constructor(nx = 0, ny = 1, nz = 0, d = 0) {
          this.n = void 0;
          this._type = enums.SHAPE_PLANE;
          this.n = new Vec3(nx, ny, nz);
          this.d = d;
        }
        transform(mat) {
          Mat4.invert(temp_mat, mat);
          Mat4.transpose(temp_mat, temp_mat);
          Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, -this.d);
          Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
          Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
          this.d = -temp_vec4.w;
        }
      }

      class Triangle {
        static create(ax = 1, ay = 0, az = 0, bx = 0, by = 0, bz = 0, cx = 0, cy = 0, cz = 1) {
          return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
        }
        static clone(t) {
          return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
        }
        static copy(out, t) {
          Vec3.copy(out.a, t.a);
          Vec3.copy(out.b, t.b);
          Vec3.copy(out.c, t.c);
          return out;
        }
        static fromPoints(out, a, b, c) {
          Vec3.copy(out.a, a);
          Vec3.copy(out.b, b);
          Vec3.copy(out.c, c);
          return out;
        }
        static set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
          out.a.x = ax;
          out.a.y = ay;
          out.a.z = az;
          out.b.x = bx;
          out.b.y = by;
          out.b.z = bz;
          out.c.x = cx;
          out.c.y = cy;
          out.c.z = cz;
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(ax = 0, ay = 0, az = 0, bx = 1, by = 0, bz = 0, cx = 0, cy = 1, cz = 0) {
          this.a = void 0;
          this.b = void 0;
          this.c = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_TRIANGLE;
          this.a = new Vec3(ax, ay, az);
          this.b = new Vec3(bx, by, bz);
          this.c = new Vec3(cx, cy, cz);
        }
      }

      const _v3_tmp$1 = new Vec3();
      const _v3_tmp2$1 = new Vec3();
      const _v3_tmp3 = new Vec3();
      const _v3_tmp4 = new Vec3();
      const _m3_tmp$1 = new Mat3();
      const transform_extent_m4 = (out, extent, m4) => {
        _m3_tmp$1.m00 = Math.abs(m4.m00);
        _m3_tmp$1.m01 = Math.abs(m4.m01);
        _m3_tmp$1.m02 = Math.abs(m4.m02);
        _m3_tmp$1.m03 = Math.abs(m4.m04);
        _m3_tmp$1.m04 = Math.abs(m4.m05);
        _m3_tmp$1.m05 = Math.abs(m4.m06);
        _m3_tmp$1.m06 = Math.abs(m4.m08);
        _m3_tmp$1.m07 = Math.abs(m4.m09);
        _m3_tmp$1.m08 = Math.abs(m4.m10);
        Vec3.transformMat3(out, extent, _m3_tmp$1);
      };
      class AABB {
        static create(px, py, pz, hw, hh, hl) {
          return new AABB(px, py, pz, hw, hh, hl);
        }
        static clone(a) {
          return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
        }
        static copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.add(_v3_tmp$1, maxPos, minPos);
          Vec3.subtract(_v3_tmp2$1, maxPos, minPos);
          Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
          Vec3.multiplyScalar(out.halfExtents, _v3_tmp2$1, 0.5);
          return out;
        }
        static set(out, px, py, pz, hw, hh, hl) {
          out.center.set(px, py, pz);
          out.halfExtents.set(hw, hh, hl);
          return out;
        }
        static merge(out, a, b) {
          Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
          Vec3.subtract(_v3_tmp2$1, b.center, b.halfExtents);
          Vec3.add(_v3_tmp3, a.center, a.halfExtents);
          Vec3.add(_v3_tmp4, b.center, b.halfExtents);
          Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
          Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
          return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
        }
        static toBoundingSphere(out, a) {
          out.center.set(a.center);
          out.radius = a.halfExtents.length();
          return out;
        }
        static transform(out, a, matrix) {
          Vec3.transformMat4(out.center, a.center, matrix);
          transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(px = 0, py = 0, pz = 0, hw = 1, hh = 1, hl = 1) {
          this.center = void 0;
          this.halfExtents = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_AABB;
          this.center = new Vec3(px, py, pz);
          this.halfExtents = new Vec3(hw, hh, hl);
        }
        getBoundary(minPos, maxPos) {
          Vec3.subtract(minPos, this.center, this.halfExtents);
          Vec3.add(maxPos, this.center, this.halfExtents);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          transform_extent_m4(out.halfExtents, this.halfExtents, m);
        }
        clone() {
          return AABB.clone(this);
        }
        copy(a) {
          return AABB.copy(this, a);
        }
        mergePoint(point) {
          this.getBoundary(_v3_tmp$1, _v3_tmp2$1);
          if (point.x < _v3_tmp$1.x) {
            _v3_tmp$1.x = point.x;
          }
          if (point.y < _v3_tmp$1.y) {
            _v3_tmp$1.y = point.y;
          }
          if (point.z < _v3_tmp$1.z) {
            _v3_tmp$1.z = point.z;
          }
          if (point.x > _v3_tmp2$1.x) {
            _v3_tmp2$1.x = point.x;
          }
          if (point.y > _v3_tmp2$1.y) {
            _v3_tmp2$1.y = point.y;
          }
          if (point.z > _v3_tmp2$1.z) {
            _v3_tmp2$1.z = point.z;
          }
          Vec3.add(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
          this.center.set(Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, 0.5));
          this.halfExtents.set(_v3_tmp2$1.x - _v3_tmp3.x, _v3_tmp2$1.y - _v3_tmp3.y, _v3_tmp2$1.z - _v3_tmp3.z);
        }
        mergePoints(points) {
          if (points.length < 1) {
            return;
          }
          for (let i = 0; i < points.length; i++) {
            this.mergePoint(points[i]);
          }
        }
        mergeFrustum(frustum) {
          this.mergePoints(frustum.vertices);
        }
      }

      class Capsule {
        get type() {
          return this._type;
        }
        constructor(radius = 0.5, halfHeight = 0.5, axis = 1) {
          this._type = void 0;
          this.radius = void 0;
          this.halfHeight = void 0;
          this.axis = void 0;
          this.center = void 0;
          this.rotation = void 0;
          this.ellipseCenter0 = void 0;
          this.ellipseCenter1 = void 0;
          this._type = enums.SHAPE_CAPSULE;
          this.radius = radius;
          this.halfHeight = halfHeight;
          this.axis = axis;
          this.center = new Vec3();
          this.rotation = new Quat();
          this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
          this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
          this.updateCache();
        }
        transform(m, pos, rot, scale, out) {
          const ws = scale;
          const s = absMaxComponent(ws);
          out.radius = this.radius * Math.abs(s);
          const halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
          let halfWorldHeight = halfTotalWorldHeight - out.radius;
          if (halfWorldHeight < 0) halfWorldHeight = 0;
          out.halfHeight = halfWorldHeight;
          Vec3.transformMat4(out.center, this.center, m);
          Quat.multiply(out.rotation, this.rotation, rot);
          out.updateCache();
        }
        updateCache() {
          this.updateLocalCenter();
          Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
          Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
          this.ellipseCenter0.add(this.center);
          this.ellipseCenter1.add(this.center);
        }
        updateLocalCenter() {
          const halfHeight = this.halfHeight;
          const axis = this.axis;
          switch (axis) {
            case 0:
              this.ellipseCenter0.set(halfHeight, 0, 0);
              this.ellipseCenter1.set(-halfHeight, 0, 0);
              break;
            case 1:
              this.ellipseCenter0.set(0, halfHeight, 0);
              this.ellipseCenter1.set(0, -halfHeight, 0);
              break;
            case 2:
              this.ellipseCenter0.set(0, 0, halfHeight);
              this.ellipseCenter1.set(0, 0, -halfHeight);
              break;
          }
        }
      }

      const _v = new Array(8);
      _v[0] = new Vec3(1, 1, 1);
      _v[1] = new Vec3(-1, 1, 1);
      _v[2] = new Vec3(-1, -1, 1);
      _v[3] = new Vec3(1, -1, 1);
      _v[4] = new Vec3(1, 1, -1);
      _v[5] = new Vec3(-1, 1, -1);
      _v[6] = new Vec3(-1, -1, -1);
      _v[7] = new Vec3(1, -1, -1);
      const _nearTemp = new Vec3();
      const _farTemp = new Vec3();
      const _temp_v3$3 = new Vec3();
      class Frustum {
        static createOrthographic(out, width, height, near, far, transform) {
          const halfWidth = width / 2;
          const halfHeight = height / 2;
          Vec3.set(_temp_v3$3, halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[0], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, -halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[1], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, -halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[2], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[3], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[4], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, -halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[5], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, -halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[6], _temp_v3$3, transform);
          Vec3.set(_temp_v3$3, halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[7], _temp_v3$3, transform);
          out.updatePlanes();
        }
        static createOrtho(out, width, height, near, far, transform) {
          return Frustum.createOrthographic(out, width, height, near, far, transform);
        }
        static createPerspective(out, aspect, fov, near, far, transform) {
          const h = Math.tan(fov * 0.5);
          const w = h * aspect;
          _nearTemp.set(near * w, near * h, near);
          _farTemp.set(far * w, far * h, far);
          const vertexes = out.vertices;
          _temp_v3$3.set(_nearTemp.x, _nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[0], _temp_v3$3, transform);
          _temp_v3$3.set(-_nearTemp.x, _nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[1], _temp_v3$3, transform);
          _temp_v3$3.set(-_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[2], _temp_v3$3, transform);
          _temp_v3$3.set(_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
          Vec3.transformMat4(vertexes[3], _temp_v3$3, transform);
          _temp_v3$3.set(_farTemp.x, _farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[4], _temp_v3$3, transform);
          _temp_v3$3.set(-_farTemp.x, _farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[5], _temp_v3$3, transform);
          _temp_v3$3.set(-_farTemp.x, -_farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[6], _temp_v3$3, transform);
          _temp_v3$3.set(_farTemp.x, -_farTemp.y, -_farTemp.z);
          Vec3.transformMat4(vertexes[7], _temp_v3$3, transform);
          out.updatePlanes();
        }
        static createFromAABB(out, aabb) {
          const vec3_min = new Vec3();
          const vec3_max = new Vec3();
          Vec3.subtract(vec3_min, aabb.center, aabb.halfExtents);
          Vec3.add(vec3_max, aabb.center, aabb.halfExtents);
          out.vertices[0].set(vec3_max.x, vec3_max.y, -vec3_min.z);
          out.vertices[1].set(vec3_min.x, vec3_max.y, -vec3_min.z);
          out.vertices[2].set(vec3_min.x, vec3_min.y, -vec3_min.z);
          out.vertices[3].set(vec3_max.x, vec3_min.y, -vec3_min.z);
          out.vertices[4].set(vec3_max.x, vec3_max.y, -vec3_max.z);
          out.vertices[5].set(vec3_min.x, vec3_max.y, -vec3_max.z);
          out.vertices[6].set(vec3_min.x, vec3_min.y, -vec3_max.z);
          out.vertices[7].set(vec3_max.x, vec3_min.y, -vec3_max.z);
          out.updatePlanes();
          return out;
        }
        split(start, end, aspect, fov, m) {
          return Frustum.createPerspective(this, aspect, fov, start, end, m);
        }
        static create() {
          return new Frustum();
        }
        static clone(f) {
          return Frustum.copy(new Frustum(), f);
        }
        static copy(out, f) {
          out._type = f.type;
          for (let i = 0; i < 6; ++i) {
            Plane.copy(out.planes[i], f.planes[i]);
          }
          for (let i = 0; i < 8; ++i) {
            Vec3.copy(out.vertices[i], f.vertices[i]);
          }
          return out;
        }
        set accurate(b) {
          this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
        }
        get type() {
          return this._type;
        }
        constructor() {
          this.planes = void 0;
          this.vertices = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_FRUSTUM;
          this.planes = new Array(6);
          for (let i = 0; i < 6; ++i) {
            this.planes[i] = Plane.create(0, 0, 0, 0);
          }
          this.vertices = new Array(8);
          for (let i = 0; i < 8; ++i) {
            this.vertices[i] = new Vec3();
          }
        }
        update(m, inv) {
          Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
          this.planes[0].d = -(m.m15 + m.m12);
          Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
          this.planes[1].d = -(m.m15 - m.m12);
          Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
          this.planes[2].d = -(m.m15 + m.m13);
          Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
          this.planes[3].d = -(m.m15 - m.m13);
          Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
          this.planes[4].d = -(m.m15 + m.m14);
          Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
          this.planes[5].d = -(m.m15 - m.m14);
          for (let i = 0; i < 6; i++) {
            const pl = this.planes[i];
            const invDist = 1 / pl.n.length();
            Vec3.multiplyScalar(pl.n, pl.n, invDist);
            pl.d *= invDist;
          }
          for (let i = 0; i < 8; i++) {
            Vec3.transformMat4(this.vertices[i], _v[i], inv);
          }
        }
        transform(mat) {
          for (let i = 0; i < 8; i++) {
            Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
          }
          this.updatePlanes();
        }
        zero() {
          for (let i = 0; i < 8; i++) {
            this.vertices[i].set(0.0, 0.0, 0.0);
          }
          for (let i = 0; i < 6; i++) {
            Plane.set(this.planes[i], 0, 0, 0, 0);
          }
        }
        updatePlanes() {
          Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[6], this.vertices[5]);
          Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[4], this.vertices[7]);
          Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[3], this.vertices[7]);
          Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[5], this.vertices[4]);
          Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[0], this.vertices[3]);
          Plane.fromPoints(this.planes[5], this.vertices[7], this.vertices[5], this.vertices[6]);
        }
      }

      function cacheProperty(ctor, property) {
        const propDesc = Object.getOwnPropertyDescriptor(ctor.prototype, property);
        const propCacheKey = `_$cache_${property}`;
        const propRealKey = `_$_${property}`;
        Object.defineProperty(ctor.prototype, propRealKey, propDesc);
        Object.defineProperty(ctor.prototype, property, {
          get() {
            if (this[propCacheKey] === undefined) {
              this[propCacheKey] = this[propRealKey];
            }
            return this[propCacheKey];
          },
          set(value) {
            this[propRealKey] = value;
          },
          configurable: true,
          enumerable: true
        });
      }
      function cacheUnderlyingData(ctor) {
        ctor.prototype._arraybuffer = function () {
          if (!this.__data) {
            this.__data = this.underlyingData();
          }
          return this.__data;
        };
      }
      const defineAttrFloat = (kls, attr) => {
        const desc = kls.__nativeFields__[attr];
        const cacheKey = `_$_${attr}`;
        assert(desc.fieldSize === 4, `field ${attr} size ${desc.fieldSize}`);
        Object.defineProperty(kls.prototype, desc.fieldName, {
          configurable: true,
          enumerable: true,
          get() {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Float32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            return this[cacheKey][0];
          },
          set(v) {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Float32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            this[cacheKey][0] = v;
          }
        });
      };
      const defineAttrInt = (kls, attr) => {
        const desc = kls.__nativeFields__[attr];
        if (!desc) {
          console.error(`attr ${attr} not defined in class ${kls.toString()}`);
        }
        const cacheKey = `_$_${attr}`;
        assert(desc.fieldSize === 4, `field ${attr} size ${desc.fieldSize}`);
        Object.defineProperty(kls.prototype, desc.fieldName, {
          configurable: true,
          enumerable: true,
          get() {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Int32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            return this[cacheKey][0];
          },
          set(v) {
            if (this[cacheKey] === undefined) {
              this[cacheKey] = new Int32Array(this._arraybuffer(), desc.fieldOffset, 1);
            }
            this[cacheKey][0] = v;
          }
        });
      };
      {
        cacheProperty(ns.Line, 's');
        cacheProperty(ns.Line, 'e');
        Object.setPrototypeOf(ns.Line.prototype, Line$1.prototype);
        cacheUnderlyingData(ns.Plane);
        cacheProperty(ns.Plane, 'n');
        defineAttrFloat(ns.Plane, 'd');
        Object.setPrototypeOf(ns.Plane.prototype, Plane.prototype);
        cacheUnderlyingData(ns.Ray);
        cacheProperty(ns.Ray, 'o');
        cacheProperty(ns.Ray, 'd');
        Object.setPrototypeOf(ns.Ray.prototype, Ray.prototype);
        cacheUnderlyingData(ns.Triangle);
        cacheProperty(ns.Triangle, 'a');
        cacheProperty(ns.Triangle, 'b');
        cacheProperty(ns.Triangle, 'c');
        Object.setPrototypeOf(ns.Triangle.prototype, Triangle.prototype);
        cacheUnderlyingData(ns.Sphere);
        cacheProperty(ns.Sphere, '_center');
        defineAttrFloat(ns.Sphere, '_radius');
        Object.setPrototypeOf(ns.Sphere.prototype, Sphere.prototype);
        cacheUnderlyingData(ns.AABB);
        cacheProperty(ns.AABB, 'center');
        cacheProperty(ns.AABB, 'halfExtents');
        Object.setPrototypeOf(ns.AABB.prototype, AABB.prototype);
        cacheUnderlyingData(ns.Capsule);
        defineAttrFloat(ns.Capsule, 'radius');
        defineAttrFloat(ns.Capsule, 'halfHeight');
        defineAttrInt(ns.Capsule, 'axis');
        cacheProperty(ns.Capsule, 'center');
        cacheProperty(ns.Capsule, 'rotation');
        cacheProperty(ns.Capsule, 'ellipseCenter0');
        cacheProperty(ns.Capsule, 'ellipseCenter1');
        Object.setPrototypeOf(ns.Capsule.prototype, Capsule.prototype);
        cacheProperty(ns.Frustum, 'vertices');
        cacheProperty(ns.Frustum, 'planes');
        Object.setPrototypeOf(ns.Frustum.prototype, Frustum.prototype);
        const descOf_type = Object.getOwnPropertyDescriptor(ns.ShapeBase.prototype, '_type');
        for (const kls of [ns.Line, ns.Plane, ns.Ray, ns.Triangle, ns.Sphere, ns.AABB, ns.Capsule, ns.Frustum]) {
          Object.defineProperty(kls.prototype, '_type', descOf_type);
        }
      }

      const _v3_tmp = new Vec3();
      const _v3_tmp2 = new Vec3();
      const _m3_tmp = new Mat3();
      const transform_extent_m3 = (out, extent, m3) => {
        _m3_tmp.m00 = Math.abs(m3.m00);
        _m3_tmp.m01 = Math.abs(m3.m01);
        _m3_tmp.m02 = Math.abs(m3.m02);
        _m3_tmp.m03 = Math.abs(m3.m03);
        _m3_tmp.m04 = Math.abs(m3.m04);
        _m3_tmp.m05 = Math.abs(m3.m05);
        _m3_tmp.m06 = Math.abs(m3.m06);
        _m3_tmp.m07 = Math.abs(m3.m07);
        _m3_tmp.m08 = Math.abs(m3.m08);
        Vec3.transformMat3(out, extent, _m3_tmp);
      };
      class OBB {
        static create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        static clone(a) {
          return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
        }
        static copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          Mat3.copy(out.orientation, a.orientation);
          return out;
        }
        static fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
          Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2, maxPos, minPos), 0.5);
          Mat3.identity(out.orientation);
          return out;
        }
        static set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          Vec3.set(out.center, cx, cy, cz);
          Vec3.set(out.halfExtents, hw, hh, hl);
          Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
          return out;
        }
        get type() {
          return this._type;
        }
        constructor(cx = 0, cy = 0, cz = 0, hw = 1, hh = 1, hl = 1, ox_1 = 1, ox_2 = 0, ox_3 = 0, oy_1 = 0, oy_2 = 1, oy_3 = 0, oz_1 = 0, oz_2 = 0, oz_3 = 1) {
          this.center = void 0;
          this.halfExtents = void 0;
          this.orientation = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_OBB;
          this.center = new Vec3(cx, cy, cz);
          this.halfExtents = new Vec3(hw, hh, hl);
          this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
        getBoundary(minPos, maxPos) {
          transform_extent_m3(_v3_tmp, this.halfExtents, this.orientation);
          Vec3.subtract(minPos, this.center, _v3_tmp);
          Vec3.add(maxPos, this.center, _v3_tmp);
        }
        transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
        translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
        }
        setScale(scale, out) {
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
      }

      function binarySearch(array, value) {
        return binarySearchEpsilon(array, value, 0);
      }
      function binarySearchEpsilon(array, value, EPSILON = 1e-6) {
        let low = 0;
        let high = array.length - 1;
        let middle = high >>> 1;
        for (; low <= high; middle = low + high >>> 1) {
          const test = array[middle];
          if (test > value + EPSILON) {
            high = middle - 1;
          } else if (test < value - EPSILON) {
            low = middle + 1;
          } else {
            return middle;
          }
        }
        return ~low;
      }
      function binarySearchBy(array, value, lessThan) {
        let low = 0;
        let high = array.length - 1;
        let middle = high >>> 1;
        for (; low <= high; middle = low + high >>> 1) {
          const test = array[middle];
          if (lessThan(test, value) < 0) {
            high = middle - 1;
          } else if (lessThan(test, value) > 0) {
            low = middle + 1;
          } else {
            return middle;
          }
        }
        return ~low;
      }

      let _Symbol$iterator;
      _Symbol$iterator = Symbol.iterator;
      class KeyframeCurve {
        constructor() {
          this._times = [];
          this._values = [];
        }
        get keyFramesCount() {
          return this._times.length;
        }
        get rangeMin() {
          return this._times[0];
        }
        get rangeMax() {
          return this._times[this._values.length - 1];
        }
        [_Symbol$iterator]() {
          let index = 0;
          return {
            next: () => {
              if (index >= this._times.length) {
                return {
                  done: true,
                  value: undefined
                };
              } else {
                const value = [this._times[index], this._values[index]];
                ++index;
                return {
                  done: false,
                  value
                };
              }
            }
          };
        }
        keyframes() {
          return this;
        }
        times() {
          return this._times;
        }
        values() {
          return this._values;
        }
        getKeyframeTime(index) {
          return this._times[index];
        }
        getKeyframeValue(index) {
          return this._values[index];
        }
        addKeyFrame(time, keyframeValue) {
          return this._insertNewKeyframe(time, keyframeValue);
        }
        removeKeyframe(index) {
          this._times.splice(index, 1);
          this._values.splice(index, 1);
        }
        indexOfKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        }
        updateTime(index, time) {
          const value = this._values[index];
          this.removeKeyframe(index);
          this._insertNewKeyframe(time, value);
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.slice());
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => value));
          }
        }
        clear() {
          this._times.length = 0;
          this._values.length = 0;
        }
        searchKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        }
        setKeyframes(times, values) {
          assertIsTrue(times.length === values.length);
          assertIsTrue(isSorted(times));
          this._times = times;
          this._values = values;
        }
        _insertNewKeyframe(time, value) {
          const times = this._times;
          const values = this._values;
          const nFrames = times.length;
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return index;
          }
          const iNext = ~index;
          if (iNext === 0) {
            times.unshift(time);
            values.unshift(value);
          } else if (iNext === nFrames) {
            times.push(time);
            values.push(value);
          } else {
            assertIsTrue(nFrames > 1);
            times.splice(iNext - 1, 0, time);
            values.splice(iNext - 1, 0, value);
          }
          return iNext;
        }
      }
      CCClass.fastDefine('cc.KeyframeCurve', KeyframeCurve, {
        _times: [],
        _values: []
      });
      function isSorted(values) {
        return values.every((value, index, array) => index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6));
      }

      let RealInterpolationMode; exports('RealInterpolationMode', RealInterpolationMode);
      (function (RealInterpolationMode) {
        RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
        RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
        RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
      })(RealInterpolationMode || (exports('RealInterpolationMode', RealInterpolationMode = {})));
      let ExtrapolationMode; exports('ExtrapolationMode', ExtrapolationMode);
      (function (ExtrapolationMode) {
        ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
        ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
        ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
        ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
      })(ExtrapolationMode || (exports('ExtrapolationMode', ExtrapolationMode = {})));
      let TangentWeightMode; exports('TangentWeightMode', TangentWeightMode);
      (function (TangentWeightMode) {
        TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
        TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
        TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
        TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
      })(TangentWeightMode || (exports('TangentWeightMode', TangentWeightMode = {})));

      function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
        const a = coeff2 / coeff3;
        const b = coeff1 / coeff3;
        const c = coeff0 / coeff3;
        const sqrA = a * a;
        const p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
        const q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
        const cubicP = p * p * p;
        const d = q * q + cubicP;
        let nSolutions = 0;
        if (isZero(d)) {
          if (isZero(q)) {
            solutions[0] = 0;
            return 1;
          } else {
            const u = Math.cbrt(-q);
            solutions[0] = 2 * u;
            solutions[1] = -u;
            return 2;
          }
        } else if (d < 0) {
          const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
          const t = 2 * Math.sqrt(-p);
          solutions[0] = t * Math.cos(phi);
          solutions[1] = -t * Math.cos(phi + Math.PI / 3);
          solutions[2] = -t * Math.cos(phi - Math.PI / 3);
          nSolutions = 3;
        } else {
          const sqrtD = Math.sqrt(d);
          const u = Math.cbrt(sqrtD - q);
          const v = -Math.cbrt(sqrtD + q);
          solutions[0] = u + v;
          nSolutions = 1;
        }
        const sub = 1.0 / 3 * a;
        for (let i = 0; i < nSolutions; ++i) {
          solutions[i] -= sub;
        }
        return nSolutions;
      }
      const EQN_EPS = 1e-9;
      function isZero(x) {
        return x > -EQN_EPS && x < EQN_EPS;
      }

      function applyDecoratedInitializer(target, property, decorators, initializer) {
        return decorators.slice().reverse().reduce(function (decoratedInitializer, decorator) {
          return decorator(target, property, decoratedInitializer) || decoratedInitializer;
        }, initializer);
      }

      const emptyDecorator = () => {};
      const emptyDecoratorFn = () => emptyDecorator;
      const emptySmartClassDecorator = makeSmartClassDecorator(() => {});
      function makeSmartClassDecorator(decorate) {
        return proxyFn;
        function proxyFn(target) {
          if (typeof target === 'function') {
            return decorate(target);
          } else {
            return function (constructor) {
              return decorate(constructor, target);
            };
          }
        }
      }
      function writeEditorClassProperty(constructor, propertyName, value) {
        const cache = getClassCache(constructor);
        if (cache) {
          const proto = getSubDict(cache, 'proto');
          getSubDict(proto, 'editor')[propertyName] = value;
        }
      }
      function makeEditorClassDecoratorFn(propertyName) {
        return value => constructor => {
          writeEditorClassProperty(constructor, propertyName, value);
        };
      }
      const CACHE_KEY = '__ccclassCache__';
      function getClassCache(ctor, decoratorName) {
        return getSubDict(ctor, CACHE_KEY);
      }
      function getSubDict(obj, key) {
        return obj[key] || (obj[key] = {});
      }

      const ccclass$6 = makeSmartClassDecorator((constructor, name) => {
        let base = getSuper(constructor);
        if (base === Object) {
          base = null;
        }
        const proto = {
          name,
          extends: base,
          ctor: constructor
        };
        const cache = constructor[CACHE_KEY];
        if (cache) {
          const decoratedProto = cache.proto;
          if (decoratedProto) {
            mixin(proto, decoratedProto);
          }
          constructor[CACHE_KEY] = undefined;
        }
        const res = CCClass(proto);
        return res;
      });

      const requireComponent = makeEditorClassDecoratorFn('requireComponent');
      const executionOrder$1 = makeEditorClassDecoratorFn('executionOrder');
      const disallowMultiple$1 = emptySmartClassDecorator;

      function property$2(target, propertyKey, descriptorOrInitializer) {
        let options = null;
        function normalized(target, propertyKey, descriptorOrInitializer) {
          const classStash = getOrCreateClassStash(target);
          const propertyStash = getOrCreateEmptyPropertyStash(target, propertyKey);
          const classConstructor = target.constructor;
          mergePropertyOptions(classStash, propertyStash, classConstructor, propertyKey, options, descriptorOrInitializer);
        }
        if (target === undefined) {
          return property$2({
            type: undefined
          });
        } else if (typeof propertyKey === 'undefined') {
          options = target;
          return normalized;
        } else {
          normalized(target, propertyKey, descriptorOrInitializer);
          return undefined;
        }
      }
      function getDefaultFromInitializer(initializer) {
        let value;
        try {
          value = initializer();
        } catch (e) {
          return initializer;
        }
        if (typeof value !== 'object' || value === null) {
          return value;
        } else {
          return initializer;
        }
      }
      function extractActualDefaultValues(classConstructor) {
        let dummyObj;
        try {
          dummyObj = new classConstructor();
        } catch (e) {
          return {};
        }
        return dummyObj;
      }
      function getOrCreateClassStash(target) {
        const cache = getClassCache(target.constructor);
        return cache;
      }
      function getOrCreateEmptyPropertyStash(target, propertyKey) {
        var _ref, _properties$_ref;
        const classStash = getClassCache(target.constructor);
        const ccclassProto = getSubDict(classStash, 'proto');
        const properties = getSubDict(ccclassProto, 'properties');
        const propertyStash = (_properties$_ref = properties[_ref = propertyKey]) !== null && _properties$_ref !== void 0 ? _properties$_ref : properties[_ref] = {};
        return propertyStash;
      }
      function getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer) {
        var _ref2, _properties$_ref2;
        const classStash = getClassCache(target.constructor);
        const ccclassProto = getSubDict(classStash, 'proto');
        const properties = getSubDict(ccclassProto, 'properties');
        const propertyStash = (_properties$_ref2 = properties[_ref2 = propertyKey]) !== null && _properties$_ref2 !== void 0 ? _properties$_ref2 : properties[_ref2] = {};
        propertyStash.__internalFlags |= PropertyStashInternalFlag.STANDALONE;
        if (descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set)) {
          if (descriptorOrInitializer.get) {
            propertyStash.get = descriptorOrInitializer.get;
          }
          if (descriptorOrInitializer.set) {
            propertyStash.set = descriptorOrInitializer.set;
          }
        } else {
          setDefaultValue(classStash, propertyStash, target.constructor, propertyKey, descriptorOrInitializer);
        }
        return propertyStash;
      }
      function mergePropertyOptions(cache, propertyStash, ctor, propertyKey, options, descriptorOrInitializer) {
        let fullOptions;
        const isGetset = descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set);
        if (options) {
          fullOptions = getFullFormOfProperty(options, isGetset);
        }
        const propertyRecord = mixin(propertyStash, fullOptions || options || {});
        if (isGetset) {
          if (descriptorOrInitializer.get) {
            propertyRecord.get = descriptorOrInitializer.get;
          }
          if (descriptorOrInitializer.set) {
            propertyRecord.set = descriptorOrInitializer.set;
          }
        } else {
          setDefaultValue(cache, propertyRecord, ctor, propertyKey, descriptorOrInitializer);
        }
      }
      function setDefaultValue(classStash, propertyStash, classConstructor, propertyKey, descriptorOrInitializer) {
        if (descriptorOrInitializer !== undefined) {
          if (typeof descriptorOrInitializer === 'function') {
            propertyStash.default = getDefaultFromInitializer(descriptorOrInitializer);
          } else if (descriptorOrInitializer === null) ; else if (descriptorOrInitializer.initializer) {
            propertyStash.default = getDefaultFromInitializer(descriptorOrInitializer.initializer);
          }
        } else {
          const actualDefaultValues = classStash.default || (classStash.default = extractActualDefaultValues(classConstructor));
          if (actualDefaultValues.hasOwnProperty(propertyKey)) {
            propertyStash.default = actualDefaultValues[propertyKey];
          }
        }
      }

      const sMetadataTag = Symbol('cc:SerializationMetadata');
      function getSerializationMetadata(constructor) {
        return constructor[sMetadataTag];
      }
      function getOrCreateSerializationMetadata(constructor) {
        var _ref, _ref$sMetadataTag;
        return (_ref$sMetadataTag = (_ref = constructor)[sMetadataTag]) !== null && _ref$sMetadataTag !== void 0 ? _ref$sMetadataTag : _ref[sMetadataTag] = {};
      }

      const serializable$6 = exports('serializable', (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        setImplicitSerializable(propertyStash);
      });
      function formerlySerializedAs$3(name) {
        return (target, propertyKey, descriptorOrInitializer) => {
          const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
          propertyStash.formerlySerializedAs = name;
          setImplicitSerializable(propertyStash);
        };
      }
      const editorOnly = (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        propertyStash.editorOnly = true;
        setImplicitSerializable(propertyStash);
      };
      function setImplicitSerializable(propertyStash) {
        propertyStash.__internalFlags |= PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE;
      }
      const uniquelyReferenced = emptyDecorator ;

      const executeInEditMode$3 = emptySmartClassDecorator;
      const menu$3 = emptyDecoratorFn;
      const playOnFocus = emptySmartClassDecorator;
      const inspector = emptyDecoratorFn;
      const icon = emptyDecoratorFn;
      const help$3 = emptyDecoratorFn;
      const editable$3 = exports('editable', emptyDecorator );
      const visible$5 = exports('visible', emptyDecoratorFn );
      const readOnly = emptyDecorator ;
      const displayName$1 = exports('displayName', emptyDecoratorFn );
      const tooltip$2 = exports('tooltip', emptyDecoratorFn );
      const range$3 = exports('range', emptyDecoratorFn );
      const rangeMin = emptyDecoratorFn ;
      const rangeStep = exports('rangeStep', emptyDecoratorFn );
      const slide$3 = exports('slide', emptyDecorator );
      const displayOrder$3 = exports('displayOrder', emptyDecoratorFn );
      const disallowAnimation$1 = exports('disallowAnimation', emptyDecorator );

      const integer = type$6(CCInteger);
      const float = type$6(CCFloat);
      const boolean = type$6(CCBoolean);
      const string = type$6(CCString);
      function type$6(type) {
        return property$2({
          type
        });
      }

      const override = exports('override', (target, propertyKey, descriptorOrInitializer) => {
        const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
        propertyStash.override = true;
      });

      const editorExtrasTag = exports('editorExtrasTag', '__editorExtras__');

      class Empty$1 {}
      const EditorExtendable = exports('EditorExtendable', editorExtendableInternal());
      assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');
      function editorExtendableInternal(Base, className) {
        {
          return Base !== null && Base !== void 0 ? Base : Empty$1;
        }
      }

      var _decorator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        uniquelyReferenced: uniquelyReferenced,
        ccclass: ccclass$6,
        property: property$2,
        requireComponent: requireComponent,
        executionOrder: executionOrder$1,
        disallowMultiple: disallowMultiple$1,
        executeInEditMode: executeInEditMode$3,
        menu: menu$3,
        playOnFocus: playOnFocus,
        inspector: inspector,
        icon: icon,
        help: help$3,
        type: type$6,
        integer: integer,
        float: float,
        boolean: boolean,
        string: string,
        editable: editable$3,
        tooltip: tooltip$2,
        visible: visible$5,
        displayName: displayName$1,
        displayOrder: displayOrder$3,
        range: range$3,
        rangeStep: rangeStep,
        slide: slide$3,
        disallowAnimation: disallowAnimation$1,
        override: override,
        formerlySerializedAs: formerlySerializedAs$3,
        serializable: serializable$6
      });
      exports('_decorator', _decorator);

      const Destroyed$2 = 1 << 0;
      const ToDestroy = 1 << 2;
      const DontSave$1 = 1 << 3;
      const EditorOnly = 1 << 4;
      const Dirty = 1 << 5;
      const DontDestroy = 1 << 6;
      const Destroying$1 = 1 << 7;
      const Deactivating$1 = 1 << 8;
      const LockedInEditor = 1 << 9;
      const HideInHierarchy$1 = 1 << 10;
      const IsOnEnableCalled$2 = 1 << 11;
      const IsEditorOnEnableCalled = 1 << 12;
      const IsPreloadStarted$1 = 1 << 13;
      const IsOnLoadCalled$2 = 1 << 14;
      const IsOnLoadStarted$1 = 1 << 15;
      const IsStartCalled$1 = 1 << 16;
      const IsRotationLocked = 1 << 17;
      const IsScaleLocked = 1 << 18;
      const IsAnchorLocked = 1 << 19;
      const IsSizeLocked = 1 << 20;
      const IsPositionLocked = 1 << 21;
      const PersistentMask$2 = ~(ToDestroy | Dirty | Destroying$1 | DontDestroy | Deactivating$1 | IsPreloadStarted$1 | IsOnLoadStarted$1 | IsOnLoadCalled$2 | IsStartCalled$1 | IsOnEnableCalled$2 | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
      const AllHideMasks = DontSave$1 | EditorOnly | LockedInEditor | HideInHierarchy$1;
      const objectsToDestroy = [];
      function compileDestruct(obj, ctor) {
        const shouldSkipId = obj instanceof legacyCC.Node || obj instanceof legacyCC.Component;
        const idToSkip = shouldSkipId ? '_id' : null;
        let key;
        const propsToReset = {};
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (key === idToSkip) {
              continue;
            }
            switch (typeof obj[key]) {
              case 'string':
                propsToReset[key] = '';
                break;
              case 'object':
              case 'function':
                propsToReset[key] = null;
                break;
            }
          }
        }
        if (CCClass._isCCClass(ctor)) {
          const attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
          const propList = ctor.__props__;
          for (let i = 0; i < propList.length; i++) {
            key = propList[i];
            const attrKey = `${key}`;
            if (attrKey in attrs) {
              if (shouldSkipId && key === '_id') {
                continue;
              }
              switch (typeof attrs[attrKey]) {
                case 'string':
                  propsToReset[key] = '';
                  break;
                case 'object':
                case 'function':
                  propsToReset[key] = null;
                  break;
                case 'undefined':
                  propsToReset[key] = undefined;
                  break;
              }
            }
          }
        }
        {
          let func = '';
          for (key in propsToReset) {
            let statement;
            if (CCClass.IDENTIFIER_RE.test(key)) {
              statement = `o.${key}=`;
            } else {
              statement = `o[${CCClass.escapeForJS(key)}]=`;
            }
            let val = propsToReset[key];
            if (val === '') {
              val = '""';
            }
            func += `${statement + val};\n`;
          }
          return Function('o', func);
        }
      }
      class CCObject {
        static _deferredDestroy() {
          const deleteCount = objectsToDestroy.length;
          for (let i = 0; i < deleteCount; ++i) {
            const obj = objectsToDestroy[i];
            if (!(obj._objFlags & Destroyed$2)) {
              obj._destroyImmediate();
            }
          }
          if (deleteCount === objectsToDestroy.length) {
            objectsToDestroy.length = 0;
          } else {
            objectsToDestroy.splice(0, deleteCount);
          }
        }
        constructor(name = '') {
          this._objFlags = void 0;
          this._name = void 0;
          this._name = name;
          this._objFlags = 0;
        }
        get name() {
          return this._name;
        }
        set name(value) {
          this._name = value;
        }
        set hideFlags(hideFlags) {
          const flags = hideFlags & CCObject.Flags.AllHideMasks;
          this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
        }
        get hideFlags() {
          return this._objFlags & CCObject.Flags.AllHideMasks;
        }
        get isValid() {
          return !(this._objFlags & Destroyed$2);
        }
        destroy() {
          if (this._objFlags & Destroyed$2) {
            warnID(5000);
            return false;
          }
          if (this._objFlags & ToDestroy) {
            return false;
          }
          this._objFlags |= ToDestroy;
          objectsToDestroy.push(this);
          {
            this._destroy();
          }
          return true;
        }
        _destruct() {
          const ctor = this.constructor;
          let destruct;
          if (Object.prototype.hasOwnProperty.call(ctor, '__destruct__')) {
            destruct = ctor.__destruct__;
          } else {
            destruct = compileDestruct(this, ctor);
            value(ctor, '__destruct__', destruct, true);
          }
          destruct(this);
        }
        _destroyImmediate() {
          var _onPreDestroy, _ref;
          if (this._objFlags & Destroyed$2) {
            errorID(5000);
            return;
          }
          (_onPreDestroy = (_ref = this)._onPreDestroy) === null || _onPreDestroy === void 0 ? void 0 : _onPreDestroy.call(_ref);
          {
            if (this.destruct) {
              this.destruct();
            }
            this._destruct();
          }
          this._objFlags |= Destroyed$2;
        }
      } exports('CCObject', CCObject);
      const prototype = CCObject.prototype;
      prototype._deserialize = null;
      {
        CCClass.fastDefine('cc.Object', CCObject, {
          _name: '',
          _objFlags: 0
        });
      }
      value(CCObject, 'Flags', {
        Destroyed: Destroyed$2,
        DontSave: DontSave$1,
        EditorOnly,
        Dirty,
        DontDestroy,
        PersistentMask: PersistentMask$2,
        Destroying: Destroying$1,
        Deactivating: Deactivating$1,
        LockedInEditor,
        HideInHierarchy: HideInHierarchy$1,
        AllHideMasks,
        IsPreloadStarted: IsPreloadStarted$1,
        IsOnLoadStarted: IsOnLoadStarted$1,
        IsOnLoadCalled: IsOnLoadCalled$2,
        IsOnEnableCalled: IsOnEnableCalled$2,
        IsStartCalled: IsStartCalled$1,
        IsEditorOnEnableCalled,
        IsPositionLocked,
        IsRotationLocked,
        IsScaleLocked,
        IsAnchorLocked,
        IsSizeLocked
      });
      function isCCObject(object) {
        return object instanceof CCObject;
      }
      function isValid(value, strictMode) {
        if (typeof value === 'object') {
          return !!value && !(value._objFlags & (strictMode ? Destroyed$2 | ToDestroy : Destroyed$2));
        } else {
          return typeof value !== 'undefined';
        }
      }
      legacyCC.isValid = isValid;
      {
        copyAllProperties(CCObject, jsb.CCObject, ['prototype', 'length', 'name']);
        copyAllProperties(CCObject.prototype, jsb.CCObject.prototype, ['constructor', 'name', 'hideFlags', 'isValid']);
        exports('CCObject', CCObject = jsb.CCObject);
      }
      legacyCC.Object = CCObject;

      var _dec$1M, _class$1K, _class2$1A, _initializer$1u, _initializer2$1h, _initializer3$11, _initializer4$U, _class3$G;
      let StorageUnit;
      (function (StorageUnit) {
        StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
        StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
        StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
        StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
        StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
        StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
        StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
        StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
      })(StorageUnit || (StorageUnit = {}));
      let ElementType;
      (function (ElementType) {
        ElementType[ElementType["Scalar"] = 0] = "Scalar";
        ElementType[ElementType["Vec2"] = 1] = "Vec2";
        ElementType[ElementType["Vec3"] = 2] = "Vec3";
        ElementType[ElementType["Vec4"] = 3] = "Vec4";
        ElementType[ElementType["Quat"] = 4] = "Quat";
        ElementType[ElementType["Mat4"] = 5] = "Mat4";
      })(ElementType || (ElementType = {}));
      const elementTypeBits = 3;
      function combineStorageUnitElementType(unit, elementType) {
        return (elementType << elementTypeBits) + unit;
      }
      function extractStorageUnitElementType(combined) {
        return {
          storageUnit: ~(-1 << elementTypeBits) & combined,
          elementType: combined >> elementTypeBits
        };
      }
      let CompactValueTypeArray = exports('CompactValueTypeArray', (_dec$1M = ccclass$6('cc.CompactValueTypeArray'), _dec$1M(_class$1K = (_class2$1A = (_class3$G = class CompactValueTypeArray {
        constructor() {
          this._byteOffset = _initializer$1u && _initializer$1u();
          this._unitCount = _initializer2$1h && _initializer2$1h();
          this._unitElement = _initializer3$11 && _initializer3$11();
          this._length = _initializer4$U && _initializer4$U();
        }
        static lengthFor(values, elementType, unit) {
          const elementTraits = getElementTraits(elementType);
          return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
        }
        static compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
          const elementTraits = getElementTraits(elementType);
          const storageConstructor = getStorageConstructor(unit);
          const unitCount = elementTraits.requiredUnits * values.length;
          const storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);
          for (let i = 0; i < values.length; ++i) {
            elementTraits.compress(storage, i, values[i]);
          }
          const result = new CompactValueTypeArray();
          result._unitElement = combineStorageUnitElementType(unit, elementType);
          result._byteOffset = presumedByteOffset;
          result._unitCount = unitCount;
          result._length = values.length;
          return result;
        }
        decompress(arrayBuffer) {
          const {
            storageUnit,
            elementType
          } = extractStorageUnitElementType(this._unitElement);
          const elementTraits = getElementTraits(elementType);
          const storageConstructor = getStorageConstructor(storageUnit);
          const storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
          const result = new Array(this._length);
          for (let i = 0; i < this._length; ++i) {
            result[i] = elementTraits.decompress(storage, i);
          }
          return result;
        }
      }, _class3$G.StorageUnit = StorageUnit, _class3$G.ElementType = ElementType, _class3$G), (_initializer$1u = applyDecoratedInitializer(_class2$1A.prototype, "_byteOffset", [serializable$6], function () {
        return 0;
      }), _initializer2$1h = applyDecoratedInitializer(_class2$1A.prototype, "_unitCount", [serializable$6], function () {
        return 0;
      }), _initializer3$11 = applyDecoratedInitializer(_class2$1A.prototype, "_unitElement", [serializable$6], function () {
        return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
      }), _initializer4$U = applyDecoratedInitializer(_class2$1A.prototype, "_length", [serializable$6], function () {
        return 0;
      })), _class2$1A)) || _class$1K));
      function getElementTraits(elementType) {
        return BuiltinElementTypeTraits[elementType];
      }
      function getStorageConstructor(unit) {
        switch (unit) {
          case StorageUnit.Uint8:
            return Uint8Array;
          case StorageUnit.Uint16:
            return Uint16Array;
          case StorageUnit.Uint32:
            return Uint32Array;
          case StorageUnit.Int8:
            return Int8Array;
          case StorageUnit.Int16:
            return Int16Array;
          case StorageUnit.Int32:
            return Int32Array;
          case StorageUnit.Float32:
            return Float32Array;
          case StorageUnit.Float64:
            return Float64Array;
        }
      }
      const BuiltinElementTypeTraits = {
        [ElementType.Scalar]: {
          requiredUnits: 1,
          compress(storage, index, value) {
            storage[index] = value;
          },
          decompress(storage, index) {
            return storage[index];
          }
        },
        [ElementType.Vec2]: {
          requiredUnits: 2,
          compress(storage, index, value) {
            storage[index * 2] = value.x;
            storage[index * 2 + 1] = value.y;
          },
          decompress(storage, index) {
            return new Vec3(storage[index * 2], storage[index * 2 + 1]);
          }
        },
        [ElementType.Vec3]: {
          requiredUnits: 3,
          compress(storage, index, value) {
            storage[index * 3] = value.x;
            storage[index * 3 + 1] = value.y;
            storage[index * 3 + 2] = value.z;
          },
          decompress(storage, index) {
            return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
          }
        },
        [ElementType.Vec4]: {
          requiredUnits: 4,
          compress(storage, index, value) {
            storage[index * 4] = value.x;
            storage[index * 4 + 1] = value.y;
            storage[index * 4 + 2] = value.z;
            storage[index * 4 + 3] = value.w;
          },
          decompress(storage, index) {
            return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
          }
        },
        [ElementType.Quat]: {
          requiredUnits: 4,
          compress(storage, index, value) {
            storage[index * 4] = value.x;
            storage[index * 4 + 1] = value.y;
            storage[index * 4 + 2] = value.z;
            storage[index * 4 + 3] = value.w;
          },
          decompress(storage, index) {
            return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
          }
        },
        [ElementType.Mat4]: {
          requiredUnits: 16,
          compress(storage, index, value) {
            Mat4.toArray(storage, value, index * 16);
          },
          decompress(storage, index) {
            return Mat4.fromArray(new Mat4(), storage, index * 16);
          }
        }
      };

      const serializeTag = exports('serializeTag', Symbol('[[Serialize]]'));
      const deserializeTag = exports('deserializeTag', Symbol('[[Deserialize]]'));

      legacyCC._decorator = _decorator;

      function constant() {
        return 0;
      }
      function linear(k) {
        return k;
      }
      function quadIn(k) {
        return k * k;
      }
      function quadOut(k) {
        return k * (2 - k);
      }
      function quadInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      }
      function cubicIn(k) {
        return k * k * k;
      }
      function cubicOut(k) {
        return --k * k * k + 1;
      }
      function cubicInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      }
      function quartIn(k) {
        return k * k * k * k;
      }
      function quartOut(k) {
        return 1 - --k * k * k * k;
      }
      function quartInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      }
      function quintIn(k) {
        return k * k * k * k * k;
      }
      function quintOut(k) {
        return --k * k * k * k * k + 1;
      }
      function quintInOut(k) {
        k *= 2;
        if (k < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      }
      function sineIn(k) {
        if (k === 1) {
          return 1;
        }
        return 1 - Math.cos(k * Math.PI / 2);
      }
      function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
      }
      function sineInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
      function expoIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      }
      function expoOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      }
      function expoInOut(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        k *= 2;
        if (k < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      }
      function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
      }
      function circOut(k) {
        return Math.sqrt(1 - --k * k);
      }
      function circInOut(k) {
        k *= 2;
        if (k < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      }
      function elasticIn(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      function elasticOut(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      }
      function elasticInOut(k) {
        let s;
        let a = 0.1;
        const p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        k *= 2;
        if (k < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      }
      function backIn(k) {
        if (k === 1) {
          return 1;
        }
        const s = 1.70158;
        return k * k * ((s + 1) * k - s);
      }
      function backOut(k) {
        if (k === 0) {
          return 0;
        }
        const s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      }
      function backInOut(k) {
        const s = 1.70158 * 1.525;
        k *= 2;
        if (k < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      }
      function bounceIn(k) {
        return 1 - bounceOut(1 - k);
      }
      function bounceOut(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      }
      function bounceInOut(k) {
        if (k < 0.5) {
          return bounceIn(k * 2) * 0.5;
        }
        return bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
      function smooth(k) {
        if (k <= 0) {
          return 0;
        }
        if (k >= 1) {
          return 1;
        }
        return k * k * (3 - 2 * k);
      }
      function fade(k) {
        if (k <= 0) {
          return 0;
        }
        if (k >= 1) {
          return 1;
        }
        return k * k * k * (k * (k * 6 - 15) + 10);
      }
      const quadOutIn = _makeOutIn(quadIn, quadOut);
      const cubicOutIn = _makeOutIn(cubicIn, cubicOut);
      const quartOutIn = _makeOutIn(quartIn, quartOut);
      const quintOutIn = _makeOutIn(quintIn, quintOut);
      const sineOutIn = _makeOutIn(sineIn, sineOut);
      const expoOutIn = _makeOutIn(expoIn, expoOut);
      const circOutIn = _makeOutIn(circIn, circOut);
      const elasticOutIn = _makeOutIn(elasticIn, elasticOut);
      const backOutIn = _makeOutIn(backIn, backOut);
      const bounceOutIn = _makeOutIn(bounceIn, bounceOut);
      function _makeOutIn(fnIn, fnOut) {
        return k => {
          if (k < 0.5) {
            return fnOut(k * 2) / 2;
          }
          return fnIn(2 * k - 1) / 2 + 0.5;
        };
      }

      var easing = /*#__PURE__*/Object.freeze({
        __proto__: null,
        constant: constant,
        linear: linear,
        quadIn: quadIn,
        quadOut: quadOut,
        quadInOut: quadInOut,
        cubicIn: cubicIn,
        cubicOut: cubicOut,
        cubicInOut: cubicInOut,
        quartIn: quartIn,
        quartOut: quartOut,
        quartInOut: quartInOut,
        quintIn: quintIn,
        quintOut: quintOut,
        quintInOut: quintInOut,
        sineIn: sineIn,
        sineOut: sineOut,
        sineInOut: sineInOut,
        expoIn: expoIn,
        expoOut: expoOut,
        expoInOut: expoInOut,
        circIn: circIn,
        circOut: circOut,
        circInOut: circInOut,
        elasticIn: elasticIn,
        elasticOut: elasticOut,
        elasticInOut: elasticInOut,
        backIn: backIn,
        backOut: backOut,
        backInOut: backInOut,
        bounceIn: bounceIn,
        bounceOut: bounceOut,
        bounceInOut: bounceInOut,
        smooth: smooth,
        fade: fade,
        quadOutIn: quadOutIn,
        cubicOutIn: cubicOutIn,
        quartOutIn: quartOutIn,
        quintOutIn: quintOutIn,
        sineOutIn: sineOutIn,
        expoOutIn: expoOutIn,
        circOutIn: circOutIn,
        elasticOutIn: elasticOutIn,
        backOutIn: backOutIn,
        bounceOutIn: bounceOutIn
      });
      exports('easing', easing);

      let EasingMethod; exports('EasingMethod', EasingMethod);
      (function (EasingMethod) {
        EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
        EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
        EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
        EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
        EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
        EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
        EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
        EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
        EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
        EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
        EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
        EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
        EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
        EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
        EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
        EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
        EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
        EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
        EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
        EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
        EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
        EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
        EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
        EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
        EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
        EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
        EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
        EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
        EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
        EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
        EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
        EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
        EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
        EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
        EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
        EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
        EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
        EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
        EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
        EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
        EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
        EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
        EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
        EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
      })(EasingMethod || (exports('EasingMethod', EasingMethod = {})));
      const easingMethodFnMap = {
        [EasingMethod.CONSTANT]: constant,
        [EasingMethod.LINEAR]: linear,
        [EasingMethod.QUAD_IN]: quadIn,
        [EasingMethod.QUAD_OUT]: quadOut,
        [EasingMethod.QUAD_IN_OUT]: quadInOut,
        [EasingMethod.QUAD_OUT_IN]: quadOutIn,
        [EasingMethod.CUBIC_IN]: cubicIn,
        [EasingMethod.CUBIC_OUT]: cubicOut,
        [EasingMethod.CUBIC_IN_OUT]: cubicInOut,
        [EasingMethod.CUBIC_OUT_IN]: cubicOutIn,
        [EasingMethod.QUART_IN]: quartIn,
        [EasingMethod.QUART_OUT]: quartOut,
        [EasingMethod.QUART_IN_OUT]: quartInOut,
        [EasingMethod.QUART_OUT_IN]: quartOutIn,
        [EasingMethod.QUINT_IN]: quintIn,
        [EasingMethod.QUINT_OUT]: quintOut,
        [EasingMethod.QUINT_IN_OUT]: quintInOut,
        [EasingMethod.QUINT_OUT_IN]: quintOutIn,
        [EasingMethod.SINE_IN]: sineIn,
        [EasingMethod.SINE_OUT]: sineOut,
        [EasingMethod.SINE_IN_OUT]: sineInOut,
        [EasingMethod.SINE_OUT_IN]: sineOutIn,
        [EasingMethod.EXPO_IN]: expoIn,
        [EasingMethod.EXPO_OUT]: expoOut,
        [EasingMethod.EXPO_IN_OUT]: expoInOut,
        [EasingMethod.EXPO_OUT_IN]: expoOutIn,
        [EasingMethod.CIRC_IN]: circIn,
        [EasingMethod.CIRC_OUT]: circOut,
        [EasingMethod.CIRC_IN_OUT]: circInOut,
        [EasingMethod.CIRC_OUT_IN]: circOutIn,
        [EasingMethod.ELASTIC_IN]: elasticIn,
        [EasingMethod.ELASTIC_OUT]: elasticOut,
        [EasingMethod.ELASTIC_IN_OUT]: elasticInOut,
        [EasingMethod.ELASTIC_OUT_IN]: elasticOutIn,
        [EasingMethod.BACK_IN]: backIn,
        [EasingMethod.BACK_OUT]: backOut,
        [EasingMethod.BACK_IN_OUT]: backInOut,
        [EasingMethod.BACK_OUT_IN]: backOutIn,
        [EasingMethod.BOUNCE_IN]: bounceIn,
        [EasingMethod.BOUNCE_OUT]: bounceOut,
        [EasingMethod.BOUNCE_IN_OUT]: bounceInOut,
        [EasingMethod.BOUNCE_OUT_IN]: bounceOutIn,
        [EasingMethod.SMOOTH]: smooth,
        [EasingMethod.FADE]: fade
      };
      function getEasingFn(easingMethod) {
        assertIsTrue(easingMethod in easingMethodFnMap);
        return easingMethodFnMap[easingMethod];
      }

      const REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START = 0;
      const REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
      const REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START = 8;
      const REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
      const REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START = 16;
      const REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START === REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK));
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START === REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK));
      const REAL_KEYFRAME_VALUE_DEFAULT_FLAGS = RealInterpolationMode.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START | TangentWeightMode.NONE << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START | EasingMethod.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
      class RealKeyframeValue extends EditorExtendable {
        constructor(...args) {
          super(...args);
          this.value = 0.0;
          this.rightTangent = 0.0;
          this.rightTangentWeight = 0.0;
          this.leftTangent = 0.0;
          this.leftTangentWeight = 0.0;
          this._flags = REAL_KEYFRAME_VALUE_DEFAULT_FLAGS;
        }
        get interpolationMode() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
        }
        set interpolationMode(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
        }
        get tangentWeightMode() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
        }
        set tangentWeightMode(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
        }
        get easingMethod() {
          return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
        }
        set easingMethod(value) {
          this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK;
          this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
        }
      }
      CCClass.fastDefine('cc.RealKeyframeValue', RealKeyframeValue, {
        interpolationMode: RealInterpolationMode.LINEAR,
        tangentWeightMode: TangentWeightMode.NONE,
        value: 0.0,
        rightTangent: 0.0,
        rightTangentWeight: 0.0,
        leftTangent: 0.0,
        leftTangentWeight: 0.0,
        easingMethod: EasingMethod.LINEAR,
        [editorExtrasTag]: undefined
      });
      CCClass.Attr.setClassAttr(RealKeyframeValue, editorExtrasTag, 'editorOnly', true);
      getOrCreateSerializationMetadata(RealKeyframeValue).uniquelyReferenced = true;
      function createRealKeyframeValue(params) {
        const realKeyframeValue = new RealKeyframeValue();
        if (typeof params === 'number') {
          realKeyframeValue.value = params;
        } else {
          const {
            interpolationMode,
            tangentWeightMode,
            value,
            rightTangent,
            rightTangentWeight,
            leftTangent,
            leftTangentWeight,
            easingMethod,
            [editorExtrasTag]: editorExtras
          } = params;
          realKeyframeValue.value = value !== null && value !== void 0 ? value : realKeyframeValue.value;
          realKeyframeValue.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : realKeyframeValue.rightTangent;
          realKeyframeValue.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : realKeyframeValue.rightTangentWeight;
          realKeyframeValue.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : realKeyframeValue.leftTangent;
          realKeyframeValue.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : realKeyframeValue.leftTangentWeight;
          realKeyframeValue.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : realKeyframeValue.interpolationMode;
          realKeyframeValue.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : realKeyframeValue.tangentWeightMode;
          realKeyframeValue.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : realKeyframeValue.easingMethod;
          if (editorExtras) {
            realKeyframeValue[editorExtrasTag] = editorExtras;
          }
        }
        return realKeyframeValue;
      }
      class RealCurve extends KeyframeCurve {
        constructor(...args) {
          super(...args);
          this.preExtrapolation = ExtrapolationMode.CLAMP;
          this.postExtrapolation = ExtrapolationMode.CLAMP;
        }
        evaluate(time) {
          const {
            _times: times,
            _values: values
          } = this;
          const nFrames = times.length;
          if (nFrames === 0) {
            return 0.0;
          }
          const firstTime = times[0];
          const lastTime = times[nFrames - 1];
          if (time < firstTime) {
            const {
              preExtrapolation
            } = this;
            const preValue = values[0];
            if (preExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return preValue.value;
            }
            switch (preExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);
              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;
              default:
                return preValue.value;
            }
          } else if (time > lastTime) {
            const {
              postExtrapolation
            } = this;
            const preFrame = values[nFrames - 1];
            if (postExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return preFrame.value;
            }
            switch (postExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);
              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;
              default:
                return preFrame.value;
            }
          }
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return values[index].value;
          }
          const iNext = ~index;
          {
            assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          }
          const iPre = iNext - 1;
          const preTime = times[iPre];
          const preValue = values[iPre];
          const nextTime = times[iNext];
          const nextValue = values[iNext];
          {
            assertIsTrue(nextTime > time && time > preTime);
          }
          const dt = nextTime - preTime;
          const ratio = (time - preTime) / dt;
          return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
        }
        addKeyFrame(time, value) {
          return super.addKeyFrame(time, createRealKeyframeValue(value));
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(value => createRealKeyframeValue(value)));
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createRealKeyframeValue(value)));
          }
        }
        isConstant(tolerance) {
          if (this._values.length <= 1) {
            return true;
          }
          const firstVal = this._values[0].value;
          return this._values.every(frame => approx(frame.value, firstVal, tolerance));
        }
        [serializeTag](output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }
          const {
            _times: times,
            _values: keyframeValues
          } = this;
          const nKeyframes = times.length;
          const dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
          const dataView = new DataView(new ArrayBuffer(dataSize));
          let currentOffset = 0;
          dataView.setUint8(currentOffset, this.preExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint8(currentOffset, this.postExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint32(currentOffset, nKeyframes, true);
          currentOffset += FRAME_COUNT_BYTES$1;
          times.forEach((time, index) => dataView.setFloat32(currentOffset + TIME_BYTES$1 * index, time, true));
          currentOffset += TIME_BYTES$1 * nKeyframes;
          for (const keyframeValue of keyframeValues) {
            currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
          }
          const bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
          output.writeProperty('bytes', bytes);
          const keyframeValueEditorExtras = keyframeValues.map(keyframeValue => keyframeValue[editorExtrasTag]);
          if (keyframeValueEditorExtras.some(extras => extras !== undefined)) {
            output.writeProperty(`keyframeValueEditorExtras`, keyframeValueEditorExtras);
          }
        }
        [deserializeTag](input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }
          const bytes = input.readProperty('bytes');
          const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          let currentOffset = 0;
          this.preExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          this.postExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          const nKeyframes = dataView.getUint32(currentOffset, true);
          currentOffset += FRAME_COUNT_BYTES$1;
          const times = Array.from({
            length: nKeyframes
          }, (_, index) => dataView.getFloat32(currentOffset + TIME_BYTES$1 * index, true));
          currentOffset += TIME_BYTES$1 * nKeyframes;
          const keyframeValues = new Array(nKeyframes);
          for (let iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
            const keyframeValue = createRealKeyframeValue({});
            currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
            keyframeValues[iKeyFrame] = keyframeValue;
          }
          assertIsTrue(currentOffset === bytes.byteLength);
          const keyframeValueEditorExtras = input.readProperty(`keyframeValueEditorExtras`);
          if (keyframeValueEditorExtras) {
            assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
            keyframeValueEditorExtras.forEach((extras, index) => keyframeValues[index][editorExtrasTag] = extras);
          }
          this._times = times;
          this._values = keyframeValues;
        }
      } exports('RealCurve', RealCurve);
      CCClass.fastDefine('cc.RealCurve', RealCurve, {
        _times: [],
        _values: [],
        preExtrapolation: ExtrapolationMode.CLAMP,
        postExtrapolation: ExtrapolationMode.CLAMP
      });
      const FLAGS_EASING_METHOD_BITS_START = 8;
      const FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
      var KeyframeValueFlagMask$1;
      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
      })(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));
      const OVERFLOW_BYTES = 1;
      const FRAME_COUNT_BYTES$1 = 4;
      const TIME_BYTES$1 = 4;
      const KEY_FRAME_VALUE_FLAGS_BYTES = 4;
      const VALUE_BYTES$1 = 4;
      const INTERPOLATION_MODE_BYTES$1 = 1;
      const TANGENT_WEIGHT_MODE_BYTES = 1;
      const LEFT_TANGENT_BYTES = 4;
      const LEFT_TANGENT_WEIGHT_BYTES = 4;
      const RIGHT_TANGENT_BYTES = 4;
      const RIGHT_TANGENT_WEIGHT_BYTES = 4;
      const {
        interpolationMode: DEFAULT_INTERPOLATION_MODE,
        tangentWeightMode: DEFAULT_TANGENT_WEIGHT_MODE,
        leftTangent: DEFAULT_LEFT_TANGENT,
        leftTangentWeight: DEFAULT_LEFT_TANGENT_WEIGHT,
        rightTangent: DEFAULT_RIGHT_TANGENT,
        rightTangentWeight: DEFAULT_RIGHT_TANGENT_WEIGHT
      } = createRealKeyframeValue({});
      const REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES$1 + INTERPOLATION_MODE_BYTES$1 + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;
      function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
        let flags = 0;
        let currentOffset = offset;
        const pFlags = currentOffset;
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        const {
          value,
          interpolationMode,
          tangentWeightMode,
          rightTangent,
          rightTangentWeight,
          leftTangent,
          leftTangentWeight,
          easingMethod
        } = keyframeValue;
        dataView.setFloat32(currentOffset, value, true);
        currentOffset += VALUE_BYTES$1;
        if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
          flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
          dataView.setUint8(currentOffset, interpolationMode);
          currentOffset += INTERPOLATION_MODE_BYTES$1;
        }
        if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
          flags |= KeyframeValueFlagMask$1.TANGENT_WEIGHT_MODE;
          dataView.setUint8(currentOffset, tangentWeightMode);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }
        if (leftTangent !== DEFAULT_LEFT_TANGENT) {
          flags |= KeyframeValueFlagMask$1.LEFT_TANGENT;
          dataView.setFloat32(currentOffset, leftTangent, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }
        if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask$1.LEFT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, leftTangentWeight, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }
        if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
          flags |= KeyframeValueFlagMask$1.RIGHT_TANGENT;
          dataView.setFloat32(currentOffset, rightTangent, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }
        if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask$1.RIGHT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, rightTangentWeight, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }
        flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
        dataView.setUint32(pFlags, flags, true);
        return currentOffset;
      }
      function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
        let currentOffset = offset;
        const flags = dataView.getUint32(currentOffset, true);
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        keyframeValue.value = dataView.getFloat32(currentOffset, true);
        currentOffset += VALUE_BYTES$1;
        if (flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE) {
          keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
          currentOffset += INTERPOLATION_MODE_BYTES$1;
        }
        if (flags & KeyframeValueFlagMask$1.TANGENT_WEIGHT_MODE) {
          keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.LEFT_TANGENT) {
          keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.LEFT_TANGENT_WEIGHT) {
          keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.RIGHT_TANGENT) {
          keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }
        if (flags & KeyframeValueFlagMask$1.RIGHT_TANGENT_WEIGHT) {
          keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }
        const easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
        keyframeValue.easingMethod = easingMethod;
        return currentOffset;
      }
      function wrapRepeat(time, prevTime, nextTime) {
        return prevTime + repeat$2(time - prevTime, nextTime - prevTime);
      }
      function wrapPingPong(time, prevTime, nextTime) {
        return prevTime + pingPong(time - prevTime, nextTime - prevTime);
      }
      function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
        const slope = (nextValue - prevValue) / (nextTime - prevTime);
        return prevValue + (time - prevTime) * slope;
      }
      function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
        const dt = nextTime - prevTime;
        switch (prevValue.interpolationMode) {
          default:
          case RealInterpolationMode.CONSTANT:
            return prevValue.value;
          case RealInterpolationMode.LINEAR:
            {
              const transformedRatio = prevValue.easingMethod === EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
              return lerp(prevValue.value, nextValue.value, transformedRatio);
            }
          case RealInterpolationMode.CUBIC:
            {
              const ONE_THIRD = 1.0 / 3.0;
              const {
                rightTangent: prevTangent,
                rightTangentWeight: prevTangentWeightSpecified
              } = prevValue;
              const prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
              const {
                leftTangent: nextTangent,
                leftTangentWeight: nextTangentWeightSpecified
              } = nextValue;
              const nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);
              if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                const p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                const p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
              } else {
                let prevTangentWeight = 0.0;
                if (prevTangentWeightEnabled) {
                  prevTangentWeight = prevTangentWeightSpecified;
                } else {
                  const x = dt;
                  const y = dt * prevTangent;
                  prevTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                }
                const angle0 = Math.atan(prevTangent);
                const tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                const ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                let nextTangentWeight = 0.0;
                if (nextTangentWeightEnabled) {
                  nextTangentWeight = nextTangentWeightSpecified;
                } else {
                  const x = dt;
                  const y = dt * nextTangent;
                  nextTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                }
                const angle1 = Math.atan(nextTangent);
                const tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                const ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                const dx = dt;
                const u0x = (tx0 - prevTime) / dx;
                const u1x = (tx1 - prevTime) / dx;
                const u0y = ty0;
                const u1y = ty1;
                const coeff0 = 0.0;
                const coeff1 = 3.0 * u0x;
                const coeff2 = 3.0 * u1x - 6.0 * u0x;
                const coeff3 = 3.0 * (u0x - u1x) + 1.0;
                const solutions = [0.0, 0.0, 0.0];
                const nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                const param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                const y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                return y;
              }
            }
        }
      }
      function isLeftTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.LEFT) !== 0;
      }
      function isRightTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.RIGHT) !== 0;
      }
      function bezierInterpolate(p0, p1, p2, p3, t) {
        const u = 1 - t;
        const coeff0 = u * u * u;
        const coeff1 = 3 * u * u * t;
        const coeff2 = 3 * u * t * t;
        const coeff3 = t * t * t;
        return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
      }
      function getParamFromCubicSolution(solutions, solutionsCount, x) {
        let param = x;
        if (solutionsCount === 1) {
          param = solutions[0];
        } else {
          param = -Infinity;
          for (let iSolution = 0; iSolution < solutionsCount; ++iSolution) {
            const solution = solutions[iSolution];
            if (solution >= 0.0 && solution <= 1.0) {
              if (solution > param) {
                param = solution;
              }
            }
          }
          if (param === -Infinity) {
            param = 0.0;
          }
        }
        return param;
      }

      function bezier(C1, C2, C3, C4, t) {
        const t1 = 1 - t;
        return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
      }
      legacyCC.bezier = bezier;
      const cos$2 = Math.cos;
      const acos$1 = Math.acos;
      const max$2 = Math.max;
      const pi = Math.PI;
      const tau = 2 * pi;
      const sqrt = Math.sqrt;
      function crt(v) {
        if (v < 0) {
          return -Math.pow(-v, 1 / 3);
        } else {
          return Math.pow(v, 1 / 3);
        }
      }
      function cardano(curve, x) {
        const pa = x - 0;
        const pb = x - curve[0];
        const pc = x - curve[2];
        const pd = x - 1;
        const pa3 = pa * 3;
        const pb3 = pb * 3;
        const pc3 = pc * 3;
        const d = -pa + pb3 - pc3 + pd;
        const rd = 1 / d;
        const r3 = 1 / 3;
        const a = (pa3 - 6 * pb + pc3) * rd;
        const a3 = a * r3;
        const b = (-pa3 + pb3) * rd;
        const c = pa * rd;
        const p = (3 * b - a * a) * r3;
        const p3 = p * r3;
        const q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
        const q2 = q / 2;
        const discriminant = q2 * q2 + p3 * p3 * p3;
        let u1;
        let v1;
        let x1;
        let x2;
        let x3;
        if (discriminant < 0) {
          const mp3 = -p * r3;
          const mp33 = mp3 * mp3 * mp3;
          const r = sqrt(mp33);
          const t = -q / (2 * r);
          const cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
          const phi = acos$1(cosphi);
          const crtr = crt(r);
          const t1 = 2 * crtr;
          x1 = t1 * cos$2(phi * r3) - a3;
          x2 = t1 * cos$2((phi + tau) * r3) - a3;
          x3 = t1 * cos$2((phi + 2 * tau) * r3) - a3;
          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              if (x3 >= 0 && x3 <= 1) {
                return max$2(x1, x2, x3);
              } else {
                return max$2(x1, x2);
              }
            } else if (x3 >= 0 && x3 <= 1) {
              return max$2(x1, x3);
            } else {
              return x1;
            }
          } else if (x2 >= 0 && x2 <= 1) {
            if (x3 >= 0 && x3 <= 1) {
              return max$2(x2, x3);
            } else {
              return x2;
            }
          } else {
            return x3;
          }
        } else if (discriminant === 0) {
          u1 = q2 < 0 ? crt(-q2) : -crt(q2);
          x1 = 2 * u1 - a3;
          x2 = -u1 - a3;
          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              return max$2(x1, x2);
            } else {
              return x1;
            }
          } else {
            return x2;
          }
        } else {
          const sd = sqrt(discriminant);
          u1 = crt(-q2 + sd);
          v1 = crt(q2 + sd);
          x1 = u1 - v1 - a3;
          return x1;
        }
      }
      function bezierByTime(controlPoints, x) {
        const percent = cardano(controlPoints, x);
        const p1y = controlPoints[1];
        const p2y = controlPoints[3];
        return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
      }
      legacyCC.bezierByTime = bezierByTime;

      var _dec$1L, _class$1J, _class2$1z, _initializer$1t, _initializer2$1g, _initializer3$10, _dec2$1r, _class4$9, _class5$a, _initializer4$T, _initializer5$K;
      let QuatInterpolationMode; exports('QuatInterpolationMode', QuatInterpolationMode);
      (function (QuatInterpolationMode) {
        QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
        QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
      })(QuatInterpolationMode || (exports('QuatInterpolationMode', QuatInterpolationMode = {})));
      let QuatKeyframeValue = (_dec$1L = ccclass$6('cc.QuatKeyframeValue'), _dec$1L(_class$1J = uniquelyReferenced(_class$1J = (_class2$1z = class QuatKeyframeValue {
        constructor({
          value,
          interpolationMode,
          easingMethod
        } = {}) {
          this.interpolationMode = _initializer$1t && _initializer$1t();
          this.value = _initializer2$1g && _initializer2$1g();
          this.easingMethod = _initializer3$10 && _initializer3$10();
          this.value = value ? Quat.clone(value) : this.value;
          this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
          this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;
        }
      }, (_initializer$1t = applyDecoratedInitializer(_class2$1z.prototype, "interpolationMode", [serializable$6], function () {
        return QuatInterpolationMode.SLERP;
      }), _initializer2$1g = applyDecoratedInitializer(_class2$1z.prototype, "value", [serializable$6], function () {
        return Quat.clone(Quat.IDENTITY);
      }), _initializer3$10 = applyDecoratedInitializer(_class2$1z.prototype, "easingMethod", [serializable$6], function () {
        return EasingMethod.LINEAR;
      })), _class2$1z)) || _class$1J) || _class$1J);
      function createQuatKeyframeValue(params) {
        return new QuatKeyframeValue(params);
      }
      let QuatCurve = exports('QuatCurve', (_dec2$1r = ccclass$6('cc.QuatCurve'), _dec2$1r(_class4$9 = (_class5$a = class QuatCurve extends KeyframeCurve {
        constructor(...args) {
          super(...args);
          this.preExtrapolation = _initializer4$T && _initializer4$T();
          this.postExtrapolation = _initializer5$K && _initializer5$K();
        }
        evaluate(time, quat) {
          var _quat;
          (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
          const {
            _times: times,
            _values: values,
            postExtrapolation,
            preExtrapolation
          } = this;
          const nFrames = times.length;
          if (nFrames === 0) {
            return quat;
          }
          const firstTime = times[0];
          const lastTime = times[nFrames - 1];
          if (time < firstTime) {
            const preValue = values[0];
            switch (preExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat$2(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, preValue.value);
            }
          } else if (time > lastTime) {
            const preValue = values[nFrames - 1];
            switch (postExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat$2(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;
              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, preValue.value);
            }
          }
          const index = binarySearchEpsilon(times, time);
          if (index >= 0) {
            return Quat.copy(quat, values[index].value);
          }
          const iNext = ~index;
          assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          const iPre = iNext - 1;
          const preTime = times[iPre];
          const preValue = values[iPre];
          const nextTime = times[iNext];
          const nextValue = values[iNext];
          assertIsTrue(nextTime > time && time > preTime);
          const dt = nextTime - preTime;
          const ratio = (time - preTime) / dt;
          switch (preValue.interpolationMode) {
            default:
            case QuatInterpolationMode.CONSTANT:
              return Quat.copy(quat, preValue.value);
            case QuatInterpolationMode.SLERP:
              {
                const {
                  easingMethod
                } = preValue;
                const transformedRatio = easingMethod === EasingMethod.LINEAR ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
              }
          }
        }
        addKeyFrame(time, value) {
          const keyframeValue = new QuatKeyframeValue(value);
          return super.addKeyFrame(time, keyframeValue);
        }
        assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(value => createQuatKeyframeValue(value)));
          } else {
            const keyframes = Array.from(times);
            this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createQuatKeyframeValue(value)));
          }
        }
        [serializeTag](output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }
          const {
            _times: times,
            _values: keyframeValues
          } = this;
          let interpolationModeRepeated = true;
          keyframeValues.forEach((keyframeValue, _index, [firstKeyframeValue]) => {
            if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
              interpolationModeRepeated = false;
            }
          });
          const nKeyframes = times.length;
          const nFrames = nKeyframes;
          const interpolationModesSize = INTERPOLATION_MODE_BYTES * (interpolationModeRepeated ? 1 : nFrames);
          const easingMethodsSize = keyframeValues.reduce((result, {
            easingMethod
          }) => result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES, 0);
          let dataSize = 0;
          dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nFrames + VALUE_BYTES * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
          const dataView = new DataView(new ArrayBuffer(dataSize));
          let P = 0;
          let flags = 0;
          if (interpolationModeRepeated) {
            flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
          }
          dataView.setUint32(P, flags, true);
          P += FLAGS_BYTES;
          dataView.setUint32(P, nFrames, true);
          P += FRAME_COUNT_BYTES;
          times.forEach((time, index) => dataView.setFloat32(P + TIME_BYTES * index, time, true));
          P += TIME_BYTES * nFrames;
          keyframeValues.forEach(({
            value: {
              x,
              y,
              z,
              w
            }
          }, index) => {
            const pQuat = P + VALUE_BYTES * 4 * index;
            dataView.setFloat32(pQuat + VALUE_BYTES * 0, x, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 1, y, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 2, z, true);
            dataView.setFloat32(pQuat + VALUE_BYTES * 3, w, true);
          });
          P += VALUE_BYTES * 4 * nFrames;
          keyframeValues.forEach(({
            easingMethod
          }, index) => {
            if (!Array.isArray(easingMethod)) {
              dataView.setUint8(P, easingMethod);
              ++P;
            } else {
              dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
              ++P;
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }
          });
          const INTERPOLATION_MODES_START = P;
          P += interpolationModesSize;
          let pInterpolationMode = INTERPOLATION_MODES_START;
          keyframeValues.forEach(({
            interpolationMode
          }) => {
            dataView.setUint8(pInterpolationMode, interpolationMode);
            if (!interpolationModeRepeated) {
              pInterpolationMode += INTERPOLATION_MODE_BYTES;
            }
          });
          const bytes = new Uint8Array(dataView.buffer);
          output.writeProperty('bytes', bytes);
        }
        [deserializeTag](input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }
          const bytes = input.readProperty('bytes');
          const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          let P = 0;
          const flags = dataView.getUint32(P, true);
          P += FLAGS_BYTES;
          const interpolationModeRepeated = flags & KeyframeValueFlagMask.INTERPOLATION_MODE;
          const nFrames = dataView.getUint32(P, true);
          P += FRAME_COUNT_BYTES;
          const times = Array.from({
            length: nFrames
          }, (_, index) => dataView.getFloat32(P + TIME_BYTES * index, true));
          P += TIME_BYTES * nFrames;
          const P_VALUES = P;
          P += VALUE_BYTES * 4 * nFrames;
          const keyframeValues = Array.from({
            length: nFrames
          }, (_, index) => {
            const pQuat = P_VALUES + VALUE_BYTES * 4 * index;
            const x = dataView.getFloat32(pQuat + VALUE_BYTES * 0, true);
            const y = dataView.getFloat32(pQuat + VALUE_BYTES * 1, true);
            const z = dataView.getFloat32(pQuat + VALUE_BYTES * 2, true);
            const w = dataView.getFloat32(pQuat + VALUE_BYTES * 3, true);
            const easingMethod = dataView.getUint8(P);
            ++P;
            const keyframeValue = createQuatKeyframeValue({
              value: {
                x,
                y,
                z,
                w
              }
            });
            if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
              keyframeValue.easingMethod = easingMethod;
            } else {
              keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }
            return keyframeValue;
          });
          if (interpolationModeRepeated) {
            const interpolationMode = dataView.getUint8(P);
            ++P;
            for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
              keyframeValues[iKeyframe].interpolationMode = interpolationMode;
            }
          } else {
            for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
              const interpolationMode = dataView.getUint8(P + iKeyframe);
              keyframeValues[iKeyframe].interpolationMode = interpolationMode;
            }
            P += nFrames;
          }
          this._times = times;
          this._values = keyframeValues;
        }
      }, (_initializer4$T = applyDecoratedInitializer(_class5$a.prototype, "preExtrapolation", [serializable$6], function () {
        return ExtrapolationMode.CLAMP;
      }), _initializer5$K = applyDecoratedInitializer(_class5$a.prototype, "postExtrapolation", [serializable$6], function () {
        return ExtrapolationMode.CLAMP;
      })), _class5$a)) || _class4$9));
      var KeyframeValueFlagMask;
      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
      })(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));
      const FLAGS_BYTES = 1;
      const FRAME_COUNT_BYTES = 4;
      const TIME_BYTES = 4;
      const VALUE_BYTES = 4;
      const INTERPOLATION_MODE_BYTES = 1;
      const EASING_METHOD_BYTES = 1;
      const EASING_METHOD_BEZIER_TAG = 255;
      const EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

      var _dec$1K, _class$1I;
      let ObjectCurve = exports('ObjectCurve', (_dec$1K = ccclass$6('cc.ObjectCurve'), _dec$1K(_class$1I = class ObjectCurve extends KeyframeCurve {
        evaluate(time) {
          const iSearch = this.searchKeyframe(time);
          if (iSearch >= 0) {
            return this._values[iSearch];
          }
          const iPrev = clamp$1(~iSearch - 1, 0, this._values.length - 1);
          return this._values[iPrev];
        }
      }) || _class$1I));

      const Mode$4 = Enum({
        Blend: 0,
        Fixed: 1
      });
      class ColorKey {
        constructor() {
          this.color = Color$1.WHITE.clone();
          this.time = 0;
        }
      } exports('ColorKey', ColorKey);
      CCClass.fastDefine('cc.ColorKey', ColorKey, {
        color: Color$1.WHITE.clone(),
        time: 0
      });
      CCClass.Attr.setClassAttr(ColorKey, 'color', 'visible', true);
      CCClass.Attr.setClassAttr(ColorKey, 'time', 'visible', true);
      class AlphaKey {
        constructor() {
          this.alpha = 1;
          this.time = 0;
        }
      } exports('AlphaKey', AlphaKey);
      CCClass.fastDefine('cc.AlphaKey', AlphaKey, {
        alpha: 1,
        time: 0
      });
      CCClass.Attr.setClassAttr(AlphaKey, 'alpha', 'visible', true);
      CCClass.Attr.setClassAttr(AlphaKey, 'time', 'visible', true);
      class Gradient {
        constructor() {
          this.colorKeys = [];
          this.alphaKeys = [];
          this.mode = Mode$4.Blend;
        }
        setKeys(colorKeys, alphaKeys) {
          this.colorKeys = colorKeys;
          this.alphaKeys = alphaKeys;
        }
        sortKeys() {
          if (this.colorKeys.length > 1) {
            this.colorKeys.sort((a, b) => a.time - b.time);
          }
          if (this.alphaKeys.length > 1) {
            this.alphaKeys.sort((a, b) => a.time - b.time);
          }
        }
        evaluate(time) {
          return this.evaluateFast(new Color$1(), time);
        }
        evaluateFast(out, time) {
          this.getRGB(out, time);
          out._set_a_unsafe(this.getAlpha(time));
          return out;
        }
        randomColor() {
          return this.getRandomColor(new Color$1());
        }
        getRandomColor(out) {
          const c = this.colorKeys[Math.trunc(random() * this.colorKeys.length)];
          const a = this.alphaKeys[Math.trunc(random() * this.alphaKeys.length)];
          out.set(c.color);
          out._set_a_unsafe(a.alpha);
          return out;
        }
        getRGB(out, time) {
          const colorKeys = this.colorKeys;
          const length = colorKeys.length;
          if (length > 1) {
            time = repeat$2(time, 1.0 + EPSILON$2);
            for (let i = 1; i < length; ++i) {
              const preTime = colorKeys[i - 1].time;
              const curTime = colorKeys[i].time;
              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$4.Fixed) {
                  Color$1.copy(out, colorKeys[i].color);
                  return out;
                }
                const factor = (time - preTime) / (curTime - preTime);
                Color$1.lerp(out, colorKeys[i - 1].color, colorKeys[i].color, factor);
                return out;
              }
            }
            const lastIndex = length - 1;
            if (approx(time, colorKeys[lastIndex].time, EPSILON$2)) {
              Color$1.copy(out, colorKeys[lastIndex].color);
            } else if (time < colorKeys[0].time) {
              Color$1.lerp(out, Color$1.BLACK, colorKeys[0].color, time / colorKeys[0].time);
            } else if (time > colorKeys[lastIndex].time) {
              Color$1.lerp(out, colorKeys[lastIndex].color, Color$1.BLACK, (time - colorKeys[lastIndex].time) / (1 - colorKeys[lastIndex].time));
            }
          } else if (length === 1) {
            Color$1.copy(out, colorKeys[0].color);
          } else {
            Color$1.copy(out, Color$1.WHITE);
          }
          return out;
        }
        getAlpha(time) {
          const basicAlpha = 0;
          const alphaKeys = this.alphaKeys;
          const length = alphaKeys.length;
          if (length > 1) {
            time = repeat$2(time, 1.0 + EPSILON$2);
            for (let i = 1; i < length; ++i) {
              const preTime = alphaKeys[i - 1].time;
              const curTime = alphaKeys[i].time;
              if (time >= preTime && time < curTime) {
                if (this.mode === Mode$4.Fixed) {
                  return alphaKeys[i].alpha;
                }
                const factor = (time - preTime) / (curTime - preTime);
                return lerp(alphaKeys[i - 1].alpha, alphaKeys[i].alpha, factor);
              }
            }
            const lastIndex = length - 1;
            if (approx(time, alphaKeys[lastIndex].time, EPSILON$2)) {
              return alphaKeys[lastIndex].alpha;
            } else if (time < alphaKeys[0].time) {
              return lerp(basicAlpha, alphaKeys[0].alpha, time / alphaKeys[0].time);
            } else if (time > alphaKeys[lastIndex].time) {
              return lerp(alphaKeys[lastIndex].alpha, basicAlpha, (time - alphaKeys[lastIndex].time) / (1 - alphaKeys[lastIndex].time));
            }
            return 255;
          } else if (length === 1) {
            return alphaKeys[0].alpha;
          } else {
            return 255;
          }
        }
      } exports('Gradient', Gradient);
      Gradient.Mode = Mode$4;
      CCClass.fastDefine('cc.Gradient', Gradient, {
        colorKeys: [],
        alphaKeys: [],
        mode: Mode$4.Blend
      });
      CCClass.Attr.setClassAttr(Gradient, 'colorKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'alphaKeys', 'visible', true);
      CCClass.Attr.setClassAttr(Gradient, 'mode', 'visible', true);

      const LOOK_FORWARD = 3;
      class Keyframe {
        constructor() {
          this.time = 0;
          this.value = 0;
          this.inTangent = 0;
          this.outTangent = 0;
        }
      }
      CCClass.fastDefine('cc.Keyframe', Keyframe, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0
      });
      class OptimizedKey {
        constructor() {
          this.index = void 0;
          this.time = void 0;
          this.endTime = void 0;
          this.coefficient = void 0;
          this.index = -1;
          this.time = 0;
          this.endTime = 0;
          this.coefficient = new Float32Array(4);
        }
        evaluate(T) {
          const t = T - this.time;
          return evalOptCurve(t, this.coefficient);
        }
      }
      function evalOptCurve(t, coefs) {
        return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
      }
      class AnimationCurve {
        get _internalCurve() {
          return this._curve;
        }
        get keyFrames() {
          return Array.from(this._curve.keyframes()).map(([time, value]) => {
            const legacyKeyframe = new Keyframe();
            legacyKeyframe.time = time;
            legacyKeyframe.value = value.value;
            legacyKeyframe.inTangent = value.leftTangent;
            legacyKeyframe.outTangent = value.rightTangent;
            return legacyKeyframe;
          });
        }
        set keyFrames(value) {
          this._curve.assignSorted(value.map(legacyCurve => [legacyCurve.time, {
            interpolationMode: RealInterpolationMode.CUBIC,
            value: legacyCurve.value,
            leftTangent: legacyCurve.inTangent,
            rightTangent: legacyCurve.outTangent
          }]));
        }
        get preWrapMode() {
          return toLegacyWrapMode(this._curve.preExtrapolation);
        }
        set preWrapMode(value) {
          this._curve.preExtrapolation = fromLegacyWrapMode(value);
        }
        get postWrapMode() {
          return toLegacyWrapMode(this._curve.postExtrapolation);
        }
        set postWrapMode(value) {
          this._curve.postExtrapolation = fromLegacyWrapMode(value);
        }
        constructor(keyFrames = null) {
          this._curve = void 0;
          this.cachedKey = void 0;
          if (keyFrames instanceof RealCurve) {
            this._curve = keyFrames;
          } else {
            const curve = new RealCurve();
            this._curve = curve;
            curve.preExtrapolation = ExtrapolationMode.LOOP;
            curve.postExtrapolation = ExtrapolationMode.CLAMP;
            if (!keyFrames) {
              curve.assignSorted([[0.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }], [1.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }]]);
            } else {
              curve.assignSorted(keyFrames.map(legacyKeyframe => [legacyKeyframe.time, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: legacyKeyframe.value,
                leftTangent: legacyKeyframe.inTangent,
                rightTangent: legacyKeyframe.outTangent
              }]));
            }
          }
          this.cachedKey = new OptimizedKey();
        }
        addKey(keyFrame) {
          if (!keyFrame) {
            this._curve.clear();
          } else {
            this._curve.addKeyFrame(keyFrame.time, {
              interpolationMode: RealInterpolationMode.CUBIC,
              value: keyFrame.value,
              leftTangent: keyFrame.inTangent,
              rightTangent: keyFrame.outTangent
            });
          }
        }
        evaluate_slow(time) {
          return this._curve.evaluate(time);
        }
        evaluate(time) {
          const {
            cachedKey,
            _curve: curve
          } = this;
          const nKeyframes = curve.keyFramesCount;
          const lastKeyframeIndex = nKeyframes - 1;
          let wrappedTime = time;
          const extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
          const startTime = curve.getKeyframeTime(0);
          const endTime = curve.getKeyframeTime(lastKeyframeIndex);
          switch (extrapolationMode) {
            case ExtrapolationMode.LOOP:
              wrappedTime = repeat$2(time - startTime, endTime - startTime) + startTime;
              break;
            case ExtrapolationMode.PING_PONG:
              wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
              break;
            case ExtrapolationMode.CLAMP:
            default:
              wrappedTime = clamp$1(time, startTime, endTime);
              break;
          }
          if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
            return cachedKey.evaluate(wrappedTime);
          }
          const leftIndex = this.findIndex(cachedKey, wrappedTime);
          const rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
          this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
          return cachedKey.evaluate(wrappedTime);
        }
        calcOptimizedKey(optKey, leftIndex, rightIndex) {
          const lhsTime = this._curve.getKeyframeTime(leftIndex);
          const rhsTime = this._curve.getKeyframeTime(rightIndex);
          const {
            value: lhsValue,
            leftTangent: lhsOutTangent
          } = this._curve.getKeyframeValue(leftIndex);
          const {
            value: rhsValue,
            rightTangent: rhsInTangent
          } = this._curve.getKeyframeValue(rightIndex);
          optKey.index = leftIndex;
          optKey.time = lhsTime;
          optKey.endTime = rhsTime;
          const dx = rhsTime - lhsTime;
          const dy = rhsValue - lhsValue;
          const length = 1 / (dx * dx);
          const d1 = lhsOutTangent * dx;
          const d2 = rhsInTangent * dx;
          optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
          optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
          optKey.coefficient[2] = lhsOutTangent;
          optKey.coefficient[3] = lhsValue;
        }
        findIndex(optKey, t) {
          const {
            _curve: curve
          } = this;
          const nKeyframes = curve.keyFramesCount;
          const cachedIndex = optKey.index;
          if (cachedIndex !== -1) {
            const cachedTime = curve.getKeyframeTime(cachedIndex);
            if (t > cachedTime) {
              for (let i = 0; i < LOOK_FORWARD; i++) {
                const currIndex = cachedIndex + i;
                if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                  return currIndex;
                }
              }
            } else {
              for (let i = 0; i < LOOK_FORWARD; i++) {
                const currIndex = cachedIndex - i;
                if (currIndex >= 0 && curve.getKeyframeTime(currIndex - 1) <= t) {
                  return currIndex - 1;
                }
              }
            }
          }
          let left = 0;
          let right = nKeyframes;
          let mid;
          while (right - left > 1) {
            mid = Math.floor((left + right) / 2);
            if (curve.getKeyframeTime(mid) >= t) {
              right = mid;
            } else {
              left = mid;
            }
          }
          return left;
        }
      }
      AnimationCurve.defaultKF = [{
        time: 0,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }, {
        time: 1,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }];
      CCClass.fastDefine('cc.AnimationCurve', AnimationCurve, {
        _curve: null
      });
      let WrapModeMask;
      (function (WrapModeMask) {
        WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
        WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
        WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
        WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
        WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
        WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
        WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
      })(WrapModeMask || (WrapModeMask = {}));
      function fromLegacyWrapMode(legacyWrapMode) {
        switch (legacyWrapMode) {
          default:
          case WrapModeMask.Default:
          case WrapModeMask.Normal:
          case WrapModeMask.Clamp:
            return ExtrapolationMode.CLAMP;
          case WrapModeMask.PingPong:
            return ExtrapolationMode.PING_PONG;
          case WrapModeMask.Loop:
            return ExtrapolationMode.LOOP;
        }
      }
      function toLegacyWrapMode(extrapolationMode) {
        switch (extrapolationMode) {
          default:
          case ExtrapolationMode.LINEAR:
          case ExtrapolationMode.CLAMP:
            return WrapModeMask.Clamp;
          case ExtrapolationMode.PING_PONG:
            return WrapModeMask.PingPong;
          case ExtrapolationMode.LOOP:
            return WrapModeMask.Loop;
        }
      }
      function constructLegacyCurveAndConvert() {
        const curve = new RealCurve();
        curve.assignSorted([[0.0, {
          interpolationMode: RealInterpolationMode.CUBIC,
          value: 1.0
        }], [1.0, {
          interpolationMode: RealInterpolationMode.CUBIC,
          value: 1.0
        }]]);
        return curve;
      }

      let SplineMode;
      (function (SplineMode) {
        SplineMode[SplineMode["LINEAR"] = 0] = "LINEAR";
        SplineMode[SplineMode["BEZIER"] = 1] = "BEZIER";
        SplineMode[SplineMode["CATMULL_ROM"] = 2] = "CATMULL_ROM";
      })(SplineMode || (SplineMode = {}));
      const SPLINE_WHOLE_INDEX = 0xffffffff;
      const _v0 = new Vec3();
      const _v1 = new Vec3();
      const _v2 = new Vec3();
      const _v3 = new Vec3();
      class Spline {
        constructor(mode = SplineMode.CATMULL_ROM, knots = []) {
          this._type = void 0;
          this._mode = SplineMode.CATMULL_ROM;
          this._knots = [];
          this._type = enums.SHAPE_SPLINE;
          this._mode = mode;
          for (let i = 0; i < knots.length; i++) {
            this._knots[i] = new Vec3(knots[i]);
          }
        }
        static create(mode, knots = []) {
          return new Spline(mode, knots);
        }
        static clone(s) {
          return new Spline(s.mode, s.knots);
        }
        static copy(out, s) {
          out._mode = s.mode;
          out._knots.length = 0;
          const knots = s.knots;
          const length = knots.length;
          for (let i = 0; i < length; i++) {
            out._knots[i] = new Vec3(knots[i]);
          }
          return out;
        }
        get type() {
          return this._type;
        }
        get mode() {
          return this._mode;
        }
        get knots() {
          return this._knots;
        }
        setModeAndKnots(mode, knots) {
          this._mode = mode;
          this._knots.length = 0;
          for (let i = 0; i < knots.length; i++) {
            this._knots[i] = new Vec3(knots[i]);
          }
        }
        clearKnots() {
          this._knots.length = 0;
        }
        getKnotCount() {
          return this._knots.length;
        }
        addKnot(knot) {
          this._knots.push(new Vec3(knot));
        }
        insertKnot(index, knot) {
          const item = new Vec3(knot);
          if (index >= this._knots.length) {
            this._knots.push(item);
            return;
          }
          this._knots.splice(index, 0, item);
        }
        removeKnot(index) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          this._knots.splice(index, 1);
        }
        setKnot(index, knot) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          this._knots[index].set(knot);
        }
        getKnot(index) {
          assertIsTrue(index >= 0 && index < this._knots.length, 'Spline: invalid index');
          return this._knots[index];
        }
        getPoint(t, index = SPLINE_WHOLE_INDEX) {
          t = clamp$1(t, 0.0, 1.0);
          const segments = this.getSegments();
          if (segments === 0) {
            return new Vec3(0.0, 0.0, 0.0);
          }
          if (index === SPLINE_WHOLE_INDEX) {
            const deltaT = 1.0 / segments;
            index = Math.floor(t / deltaT);
            t = t % deltaT / deltaT;
          }
          if (index >= segments) {
            return new Vec3(this._knots[this._knots.length - 1]);
          }
          switch (this._mode) {
            case SplineMode.LINEAR:
              return Spline.calcLinear(this._knots[index], this._knots[index + 1], t);
            case SplineMode.BEZIER:
              return Spline.calcBezier(this._knots[index * 4], this._knots[index * 4 + 1], this._knots[index * 4 + 2], this._knots[index * 4 + 3], t);
            case SplineMode.CATMULL_ROM:
              {
                const v0 = index > 0 ? this._knots[index - 1] : this._knots[index];
                const v3 = index + 2 < this._knots.length ? this._knots[index + 2] : this._knots[index + 1];
                return Spline.calcCatmullRom(v0, this._knots[index], this._knots[index + 1], v3, t);
              }
            default:
              return new Vec3(0.0, 0.0, 0.0);
          }
        }
        getPoints(num, index = SPLINE_WHOLE_INDEX) {
          if (num === 0) {
            return [];
          }
          if (num === 1) {
            const point = this.getPoint(0.0, index);
            return [point];
          }
          const points = [];
          const deltaT = 1.0 / (num - 1.0);
          for (let i = 0; i < num; i++) {
            const t = i * deltaT;
            const point = this.getPoint(t, index);
            points.push(point);
          }
          return points;
        }
        getSegments() {
          const count = this._knots.length;
          switch (this._mode) {
            case SplineMode.LINEAR:
            case SplineMode.CATMULL_ROM:
              if (count < 2) {
                warnID(14300);
                return 0;
              }
              return count - 1;
            case SplineMode.BEZIER:
              if (count < 4 || count % 4 != 0) {
                warnID(14301);
                return 0;
              }
              return count / 4;
            default:
              assertIsTrue(false, 'Spline error: invalid mode');
          }
        }
        static calcLinear(v0, v1, t) {
          const result = new Vec3();
          Vec3.multiplyScalar(_v0, v0, 1.0 - t);
          Vec3.multiplyScalar(_v1, v1, t);
          Vec3.add(result, _v0, _v1);
          return result;
        }
        static calcBezier(v0, v1, v2, v3, t) {
          const result = new Vec3();
          const s = 1.0 - t;
          Vec3.multiplyScalar(_v0, v0, s * s * s);
          Vec3.multiplyScalar(_v1, v1, 3.0 * t * s * s);
          Vec3.multiplyScalar(_v2, v2, 3.0 * t * t * s);
          Vec3.multiplyScalar(_v3, v3, t * t * t);
          Vec3.add(_v0, _v0, _v1);
          Vec3.add(_v2, _v2, _v3);
          Vec3.add(result, _v0, _v2);
          return result;
        }
        static calcCatmullRom(v0, v1, v2, v3, t) {
          const result = new Vec3();
          const t2 = t * t;
          const t3 = t2 * t;
          Vec3.multiplyScalar(_v0, v0, -0.5 * t3 + t2 - 0.5 * t);
          Vec3.multiplyScalar(_v1, v1, 1.5 * t3 - 2.5 * t2 + 1.0);
          Vec3.multiplyScalar(_v2, v2, -1.5 * t3 + 2.0 * t2 + 0.5 * t);
          Vec3.multiplyScalar(_v3, v3, 0.5 * t3 - 0.5 * t2);
          Vec3.add(_v0, _v0, _v1);
          Vec3.add(_v2, _v2, _v3);
          Vec3.add(result, _v0, _v2);
          return result;
        }
      }

      let ERaycastMode;
      (function (ERaycastMode) {
        ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
        ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
        ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
      })(ERaycastMode || (ERaycastMode = {}));

      replaceProperty(intersect, 'intersect', [{
        name: 'ray_aabb',
        newName: 'rayAABB'
      }, {
        name: 'ray_plane',
        newName: 'rayPlane'
      }, {
        name: 'ray_triangle',
        newName: 'rayTriangle'
      }, {
        name: 'ray_sphere',
        newName: 'raySphere'
      }, {
        name: 'ray_obb',
        newName: 'rayOBB'
      }, {
        name: 'ray_capsule',
        newName: 'rayCapsule'
      }, {
        name: 'ray_subMesh',
        newName: 'raySubMesh'
      }, {
        name: 'ray_mesh',
        newName: 'rayMesh'
      }, {
        name: 'ray_model',
        newName: 'rayModel'
      }, {
        name: 'line_plane',
        newName: 'linePlane'
      }, {
        name: 'line_triangle',
        newName: 'lineTriangle'
      }, {
        name: 'line_aabb',
        newName: 'lineAABB'
      }, {
        name: 'line_obb',
        newName: 'lineOBB'
      }, {
        name: 'line_sphere',
        newName: 'lineSphere'
      }, {
        name: 'aabb_aabb',
        newName: 'aabbWithAABB'
      }, {
        name: 'aabb_obb',
        newName: 'aabbWithOBB'
      }, {
        name: 'aabb_plane',
        newName: 'aabbPlane'
      }, {
        name: 'aabb_frustum',
        newName: 'aabbFrustum'
      }, {
        name: 'aabbFrustum_accurate',
        newName: 'aabbFrustumAccurate'
      }, {
        name: 'obb_point',
        newName: 'obbPoint'
      }, {
        name: 'obb_plane',
        newName: 'obbPlane'
      }, {
        name: 'obb_frustum',
        newName: 'obbFrustum'
      }, {
        name: 'obbFrustum_accurate',
        newName: 'obbFrustumAccurate'
      }, {
        name: 'obb_obb',
        newName: 'obbWithOBB'
      }, {
        name: 'obb_capsule',
        newName: 'obbCapsule'
      }, {
        name: 'sphere_plane',
        newName: 'spherePlane'
      }, {
        name: 'sphere_frustum',
        newName: 'sphereFrustum'
      }, {
        name: 'sphereFrustum_accurate',
        newName: 'sphereFrustumAccurate'
      }, {
        name: 'sphere_sphere',
        newName: 'sphereWithSphere'
      }, {
        name: 'sphere_aabb',
        newName: 'sphereAABB'
      }, {
        name: 'sphere_obb',
        newName: 'sphereOBB'
      }, {
        name: 'sphere_capsule',
        newName: 'sphereCapsule'
      }, {
        name: 'capsule_capsule',
        newName: 'capsuleWithCapsule'
      }]);
      function deprecatedClassMessage(oldClassName, newClassName) {
        console.warn(`${oldClassName} is deprecated, please use ${newClassName} instead.`);
      }
      class line extends Line$1 {
        constructor() {
          super();
          deprecatedClassMessage('line', 'Line');
        }
      }
      class plane$1 extends Plane {
        constructor() {
          super();
          deprecatedClassMessage('plane', 'Plane');
        }
      }
      class ray extends Ray {
        constructor() {
          super();
          deprecatedClassMessage('ray', 'Ray');
        }
      }
      class triangle extends Triangle {
        constructor() {
          super();
          deprecatedClassMessage('triangle', 'Triangle');
        }
      }
      class sphere$1 extends Sphere {
        constructor() {
          super();
          deprecatedClassMessage('sphere', 'Sphere');
        }
      }
      class aabb extends AABB {
        constructor() {
          super();
          deprecatedClassMessage('aabb', 'AABB');
        }
      }
      class obb extends OBB {
        constructor() {
          super();
          deprecatedClassMessage('obb', 'OBB');
        }
      }
      class capsule$1 extends Capsule {
        constructor() {
          super();
          deprecatedClassMessage('capsule', 'Capsule');
        }
      }
      class frustum extends Frustum {
        constructor() {
          super();
          deprecatedClassMessage('frustum', 'Frustum');
        }
      }

      var geometry = /*#__PURE__*/Object.freeze({
        __proto__: null,
        distance: distance,
        enums: enums,
        intersect: intersect,
        Line: Line$1,
        Plane: Plane,
        Ray: Ray,
        Triangle: Triangle,
        Sphere: Sphere,
        AABB: AABB,
        OBB: OBB,
        Capsule: Capsule,
        Frustum: Frustum,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve,
        get WrapModeMask () { return WrapModeMask; },
        get SplineMode () { return SplineMode; },
        Spline: Spline,
        constructLegacyCurveAndConvert: constructLegacyCurveAndConvert,
        OptimizedKey: OptimizedKey,
        evalOptCurve: evalOptCurve,
        get ERaycastMode () { return ERaycastMode; },
        line: line,
        plane: plane$1,
        ray: ray,
        triangle: triangle,
        sphere: sphere$1,
        aabb: aabb,
        obb: obb,
        capsule: capsule$1,
        frustum: frustum
      });
      exports('geometry', geometry);

      class ScalableContainer {
        constructor() {
          this._poolHandle = -1;
          scalableContainerManager.addContainer(this);
        }
        destroy() {
          scalableContainerManager.removeContainer(this);
        }
      }
      class ScalableContainerManager {
        constructor() {
          this._pools = [];
          this._lastShrinkPassed = 0;
          this.shrinkTimeSpan = 5;
        }
        addContainer(pool) {
          if (pool._poolHandle !== -1) return;
          pool._poolHandle = this._pools.length;
          this._pools.push(pool);
        }
        removeContainer(pool) {
          if (pool._poolHandle === -1) return;
          this._pools[this._pools.length - 1]._poolHandle = pool._poolHandle;
          fastRemoveAt$2(this._pools, pool._poolHandle);
          pool._poolHandle = -1;
        }
        tryShrink() {
          for (let i = 0; i < this._pools.length; i++) {
            this._pools[i].tryShrink();
          }
        }
        update(dt) {
          this._lastShrinkPassed += dt;
          if (this._lastShrinkPassed > this.shrinkTimeSpan) {
            this.tryShrink();
            this._lastShrinkPassed -= this.shrinkTimeSpan;
          }
        }
      }
      const scalableContainerManager = new ScalableContainerManager();

      class Pool extends ScalableContainer {
        constructor(ctor, elementsPerBatch, dtor) {
          super();
          this._ctor = void 0;
          this._elementsPerBatch = void 0;
          this._nextAvail = void 0;
          this._freePool = [];
          this._dtor = void 0;
          this._ctor = ctor;
          this._dtor = dtor || null;
          this._elementsPerBatch = Math.max(elementsPerBatch, 1);
          this._nextAvail = this._elementsPerBatch - 1;
          for (let i = 0; i < this._elementsPerBatch; ++i) {
            this._freePool.push(ctor());
          }
        }
        alloc() {
          if (this._nextAvail < 0) {
            this._freePool.length = this._elementsPerBatch;
            for (let i = 0; i < this._elementsPerBatch; i++) {
              this._freePool[i] = this._ctor();
            }
            this._nextAvail = this._elementsPerBatch - 1;
          }
          return this._freePool[this._nextAvail--];
        }
        free(obj) {
          this._freePool[++this._nextAvail] = obj;
        }
        freeArray(objs) {
          this._freePool.length = this._nextAvail + 1;
          Array.prototype.push.apply(this._freePool, objs);
          this._nextAvail += objs.length;
        }
        tryShrink() {
          if (this._nextAvail >> 1 > this._elementsPerBatch) {
            if (this._dtor) {
              for (let i = this._nextAvail >> 1; i <= this._nextAvail; i++) {
                this._dtor(this._freePool[i]);
              }
            }
            this._freePool.length = this._nextAvail >> 1;
            this._nextAvail = this._freePool.length - 1;
          }
        }
        destroy() {
          const dtor = arguments.length > 0 ? arguments[0] : null;
          if (dtor) {
            warnID(14100);
          }
          const readDtor = dtor || this._dtor;
          if (readDtor) {
            for (let i = 0; i <= this._nextAvail; i++) {
              readDtor(this._freePool[i]);
            }
          }
          this._freePool.length = 0;
          this._nextAvail = -1;
          super.destroy();
        }
      } exports('Pool', Pool);

      class RecyclePool extends ScalableContainer {
        constructor(fn, size, dtor) {
          super();
          this._fn = void 0;
          this._dtor = null;
          this._count = 0;
          this._data = void 0;
          this._initSize = 0;
          this._fn = fn;
          this._dtor = dtor || null;
          this._data = new Array(size);
          this._initSize = size;
          for (let i = 0; i < size; ++i) {
            this._data[i] = fn();
          }
        }
        get length() {
          return this._count;
        }
        get data() {
          return this._data;
        }
        reset() {
          this._count = 0;
        }
        resize(size) {
          if (size > this._data.length) {
            for (let i = this._data.length; i < size; ++i) {
              this._data[i] = this._fn();
            }
          }
        }
        add() {
          if (this._count >= this._data.length) {
            this.resize(this._data.length << 1);
          }
          return this._data[this._count++];
        }
        destroy() {
          if (this._dtor) {
            for (let i = 0; i < this._data.length; i++) {
              this._dtor(this._data[i]);
            }
          }
          this._data.length = 0;
          this._count = 0;
          super.destroy();
        }
        tryShrink() {
          if (this._data.length >> 2 > this._count) {
            const length = Math.max(this._initSize, this._data.length >> 1);
            if (this._dtor) {
              for (let i = length; i < this._data.length; i++) {
                this._dtor(this._data[i]);
              }
            }
            this._data.length = length;
          }
        }
        removeAt(idx) {
          if (idx >= this._count) {
            return;
          }
          const last = this._count - 1;
          const tmp = this._data[idx];
          this._data[idx] = this._data[last];
          this._data[last] = tmp;
          this._count -= 1;
        }
      } exports('RecyclePool', RecyclePool);

      class CachedArray extends ScalableContainer {
        constructor(length, compareFn) {
          super();
          this.array = void 0;
          this.length = 0;
          this._compareFn = void 0;
          this._initSize = 0;
          this.array = new Array(length);
          this._initSize = length;
          this.length = 0;
          this._compareFn = compareFn;
        }
        push(item) {
          this.array[this.length++] = item;
        }
        pop() {
          return this.array[--this.length];
        }
        get(idx) {
          return this.array[idx];
        }
        clear() {
          this.length = 0;
        }
        destroy() {
          this.length = 0;
          this.array.length = 0;
          super.destroy();
        }
        tryShrink() {
          if (this.array.length >> 2 > this.length) {
            this.array.length = Math.max(this._initSize, this.array.length >> 1);
          }
        }
        sort() {
          this.array.length = this.length;
          this.array.sort(this._compareFn);
        }
        concat(array) {
          for (let i = 0; i < array.length; ++i) {
            this.array[this.length++] = array[i];
          }
        }
        fastRemove(idx) {
          if (idx >= this.length || idx < 0) {
            return;
          }
          const last = --this.length;
          this.array[idx] = this.array[last];
        }
        indexOf(val) {
          for (let i = 0, len = this.length; i < len; ++i) {
            if (this.array[i] === val) {
              return i;
            }
          }
          return -1;
        }
      } exports('CachedArray', CachedArray);

      var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Pool: Pool,
        RecyclePool: RecyclePool,
        CachedArray: CachedArray
      });
      exports('memop', index$2);

      class System {
        constructor() {
          this._id = '';
          this._priority = 0;
          this._executeInEditMode = false;
        }
        set priority(value) {
          this._priority = value;
        }
        get priority() {
          return this._priority;
        }
        set id(id) {
          this._id = id;
        }
        get id() {
          return this._id;
        }
        static sortByPriority(a, b) {
          if (a._priority < b._priority) {
            return 1;
          } else if (a._priority > b.priority) {
            return -1;
          } else {
            return 0;
          }
        }
        init() {}
        update(dt) {}
        postUpdate(dt) {}
        destroy() {}
      } exports('System', System);
      System.Priority = Enum({
        LOW: 0,
        MEDIUM: 100,
        HIGH: 200,
        SCHEDULER: 1 << 31 >>> 0
      });

      const MAX_POOL_SIZE$1 = 20;
      const idGenerator$1 = new IDGenerator('Scheduler');
      class ListEntry {
        static get(target, priority, paused, markedForDeletion) {
          let result = ListEntry._listEntries.pop();
          if (result) {
            result.target = target;
            result.priority = priority;
            result.paused = paused;
            result.markedForDeletion = markedForDeletion;
          } else {
            result = new ListEntry(target, priority, paused, markedForDeletion);
          }
          return result;
        }
        static put(entry) {
          if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
            entry.target = null;
            ListEntry._listEntries.push(entry);
          }
        }
        constructor(target, priority, paused, markedForDeletion) {
          this.target = void 0;
          this.priority = void 0;
          this.paused = void 0;
          this.markedForDeletion = void 0;
          this.target = target;
          this.priority = priority;
          this.paused = paused;
          this.markedForDeletion = markedForDeletion;
        }
      }
      ListEntry._listEntries = [];
      class HashUpdateEntry {
        static get(list, entry, target, callback) {
          let result = HashUpdateEntry._hashUpdateEntries.pop();
          if (result) {
            result.list = list;
            result.entry = entry;
            result.target = target;
            result.callback = callback;
          } else {
            result = new HashUpdateEntry(list, entry, target, callback);
          }
          return result;
        }
        static put(entry) {
          if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
            entry.list = entry.entry = entry.target = entry.callback = null;
            HashUpdateEntry._hashUpdateEntries.push(entry);
          }
        }
        constructor(list, entry, target, callback) {
          this.list = void 0;
          this.entry = void 0;
          this.target = void 0;
          this.callback = void 0;
          this.list = list;
          this.entry = entry;
          this.target = target;
          this.callback = callback;
        }
      }
      HashUpdateEntry._hashUpdateEntries = [];
      class HashTimerEntry {
        static get(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
          let result = HashTimerEntry._hashTimerEntries.pop();
          if (result) {
            result.timers = timers;
            result.target = target;
            result.timerIndex = timerIndex;
            result.currentTimer = currentTimer;
            result.currentTimerSalvaged = currentTimerSalvaged;
            result.paused = paused;
          } else {
            result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
          }
          return result;
        }
        static put(entry) {
          if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
            entry.timers = entry.target = entry.currentTimer = null;
            HashTimerEntry._hashTimerEntries.push(entry);
          }
        }
        constructor(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
          this.timers = void 0;
          this.target = void 0;
          this.timerIndex = void 0;
          this.currentTimer = void 0;
          this.currentTimerSalvaged = void 0;
          this.paused = void 0;
          this.timers = timers;
          this.target = target;
          this.timerIndex = timerIndex;
          this.currentTimer = currentTimer;
          this.currentTimerSalvaged = currentTimerSalvaged;
          this.paused = paused;
        }
      }
      HashTimerEntry._hashTimerEntries = [];
      class CallbackTimer {
        static get() {
          return CallbackTimer._timers.pop() || new CallbackTimer();
        }
        static put(timer) {
          if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
            timer._scheduler = timer._target = timer._callback = null;
            CallbackTimer._timers.push(timer);
          }
        }
        constructor() {
          this._lock = void 0;
          this._scheduler = void 0;
          this._elapsed = void 0;
          this._runForever = void 0;
          this._useDelay = void 0;
          this._timesExecuted = void 0;
          this._repeat = void 0;
          this._delay = void 0;
          this._interval = void 0;
          this._target = void 0;
          this._callback = void 0;
          this._lock = false;
          this._scheduler = null;
          this._elapsed = -1;
          this._runForever = false;
          this._useDelay = false;
          this._timesExecuted = 0;
          this._repeat = 0;
          this._delay = 0;
          this._interval = 0;
          this._target = null;
        }
        initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
          this._lock = false;
          this._scheduler = scheduler;
          this._target = target;
          this._callback = callback;
          this._timesExecuted = 0;
          this._elapsed = -1;
          this._interval = seconds;
          this._delay = delay;
          this._useDelay = this._delay > 0;
          this._repeat = repeat;
          this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
          return true;
        }
        getInterval() {
          return this._interval;
        }
        setInterval(interval) {
          this._interval = interval;
        }
        update(dt) {
          if (this._elapsed === -1) {
            this._elapsed = 0;
            this._timesExecuted = 0;
          } else {
            this._elapsed += dt;
            if (this._runForever && !this._useDelay) {
              if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
              }
            } else {
              if (this._useDelay) {
                if (this._elapsed >= this._delay) {
                  this.trigger();
                  this._elapsed -= this._delay;
                  this._timesExecuted += 1;
                  this._useDelay = false;
                }
              } else if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
                this._timesExecuted += 1;
              }
              if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                this.cancel();
              }
            }
          }
        }
        getCallback() {
          return this._callback;
        }
        trigger() {
          if (this._target && this._callback) {
            this._lock = true;
            this._callback.call(this._target, this._elapsed);
            this._lock = false;
          }
        }
        cancel() {
          if (this._scheduler && this._callback && this._target) {
            this._scheduler.unscheduleForTimer(this, this._target);
          }
        }
      }
      CallbackTimer._timers = [];
      class Scheduler extends System {
        static enableForTarget(target) {
          let found = false;
          if (target.uuid) {
            found = true;
          } else if (target.id) {
            found = true;
          }
          if (!found) {
            target.id = idGenerator$1.getNewId();
          }
        }
        constructor() {
          super();
          this._timeScale = void 0;
          this._updatesNegList = void 0;
          this._updates0List = void 0;
          this._updatesPosList = void 0;
          this._hashForUpdates = void 0;
          this._hashForTimers = void 0;
          this._currentTarget = void 0;
          this._currentTargetSalvaged = void 0;
          this._updateHashLocked = void 0;
          this._arrayForTimers = void 0;
          this._timeScale = 1.0;
          this._updatesNegList = [];
          this._updates0List = [];
          this._updatesPosList = [];
          this._hashForUpdates = createMap(true);
          this._hashForTimers = createMap(true);
          this._currentTarget = null;
          this._currentTargetSalvaged = false;
          this._updateHashLocked = false;
          this._arrayForTimers = [];
        }
        setTimeScale(timeScale) {
          this._timeScale = timeScale;
        }
        getTimeScale() {
          return this._timeScale;
        }
        update(dt) {
          this._updateHashLocked = true;
          if (this._timeScale !== 1) {
            dt *= this._timeScale;
          }
          let i;
          let list;
          let len;
          let entry;
          for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update, _entry$target;
              (_entry$target$update = (_entry$target = entry.target).update) === null || _entry$target$update === void 0 ? void 0 : _entry$target$update.call(_entry$target, dt);
            }
          }
          for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update2, _entry$target2;
              (_entry$target$update2 = (_entry$target2 = entry.target).update) === null || _entry$target$update2 === void 0 ? void 0 : _entry$target$update2.call(_entry$target2, dt);
            }
          }
          for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
            entry = list[i];
            if (!entry.paused && !entry.markedForDeletion && entry.target) {
              var _entry$target$update3, _entry$target3;
              (_entry$target$update3 = (_entry$target3 = entry.target).update) === null || _entry$target$update3 === void 0 ? void 0 : _entry$target$update3.call(_entry$target3, dt);
            }
          }
          let elt;
          const arr = this._arrayForTimers;
          for (i = 0; i < arr.length; i++) {
            var _this$_currentTarget$;
            elt = arr[i];
            this._currentTarget = elt;
            this._currentTargetSalvaged = false;
            if (!elt.paused && elt.timers) {
              for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                elt.currentTimer = elt.timers[elt.timerIndex];
                elt.currentTimerSalvaged = false;
                elt.currentTimer.update(dt);
                elt.currentTimer = null;
              }
            }
            if (this._currentTargetSalvaged && ((_this$_currentTarget$ = this._currentTarget.timers) === null || _this$_currentTarget$ === void 0 ? void 0 : _this$_currentTarget$.length) === 0) {
              this._removeHashElement(this._currentTarget);
              --i;
            }
          }
          for (i = 0, list = this._updatesNegList; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          for (i = 0, list = this._updates0List; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          for (i = 0, list = this._updatesPosList; i < list.length;) {
            entry = list[i];
            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }
          this._updateHashLocked = false;
          this._currentTarget = null;
        }
        schedule(callbackTmp, targetTmp, interval, repeat, delay, paused) {
          var _repeat, _delay;
          let callback;
          let target;
          if (typeof callbackTmp !== 'function') {
            warnID(1514);
            callback = targetTmp;
            target = callbackTmp;
          } else {
            callback = callbackTmp;
            target = targetTmp;
          }
          if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
            paused = !!repeat;
            repeat = legacyCC.macro.REPEAT_FOREVER;
            delay = 0;
          }
          assertID(Boolean(target), 1502);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          let element = this._hashForTimers[targetId];
          if (!element) {
            element = HashTimerEntry.get(null, target, 0, null, false, Boolean(paused));
            this._arrayForTimers.push(element);
            this._hashForTimers[targetId] = element;
          } else if (element.paused !== paused) {
            warnID(1511);
          }
          let timer;
          let i;
          if (element.timers == null) {
            element.timers = [];
          } else {
            for (i = 0; i < element.timers.length; ++i) {
              timer = element.timers[i];
              if (timer && callback === timer.getCallback()) {
                logID(1507, timer.getInterval(), interval);
                timer.setInterval(interval);
                return;
              }
            }
          }
          timer = CallbackTimer.get();
          timer.initWithCallback(this, callback, target, interval, (_repeat = repeat) !== null && _repeat !== void 0 ? _repeat : 0, (_delay = delay) !== null && _delay !== void 0 ? _delay : 0);
          element.timers.push(timer);
          if (this._currentTarget === element && this._currentTargetSalvaged) {
            this._currentTargetSalvaged = false;
          }
        }
        scheduleUpdate(target, priority, paused) {
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const hashElement = this._hashForUpdates[targetId];
          if (hashElement && hashElement.entry) {
            if (hashElement.entry.priority !== priority) {
              if (this._updateHashLocked) {
                logID(1506);
                hashElement.entry.markedForDeletion = false;
                hashElement.entry.paused = paused;
                return;
              } else {
                this.unscheduleUpdate(target);
              }
            } else {
              hashElement.entry.markedForDeletion = false;
              hashElement.entry.paused = paused;
              return;
            }
          }
          const listElement = ListEntry.get(target, priority, paused, false);
          let ppList;
          if (priority === 0) {
            ppList = this._updates0List;
            this._appendIn(ppList, listElement);
          } else {
            ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
            this._priorityIn(ppList, listElement, priority);
          }
          this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
        }
        unschedule(callback, target) {
          if (!target || !callback) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            const timers = element.timers;
            if (!timers) {
              return;
            }
            for (let i = 0, li = timers.length; i < li; i++) {
              const timer = timers[i];
              if (callback === timer.getCallback()) {
                if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                  element.currentTimerSalvaged = true;
                }
                timers.splice(i, 1);
                CallbackTimer.put(timer);
                if (element.timerIndex >= i) {
                  element.timerIndex--;
                }
                if (timers.length === 0) {
                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }
                return;
              }
            }
          }
        }
        unscheduleForTimer(timerToUnschedule, target) {
          const targetId = target.uuid || target.id;
          const element = this._hashForTimers[targetId];
          const timers = element.timers;
          if (!timers) {
            return;
          }
          for (let i = 0, li = timers.length; i < li; i++) {
            const timer = timers[i];
            if (timer === timerToUnschedule) {
              timers.splice(i, 1);
              if (timers.length === 0) {
                this._currentTargetSalvaged = true;
              }
              return;
            }
          }
        }
        unscheduleUpdate(target) {
          if (!target) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForUpdates[targetId];
          if (element !== null && element !== void 0 && element.entry) {
            if (this._updateHashLocked) {
              element.entry.markedForDeletion = true;
            } else {
              this._removeUpdateFromHash(element.entry);
            }
          }
        }
        unscheduleAllForTarget(target) {
          if (!target) {
            return;
          }
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element !== null && element !== void 0 && element.timers) {
            const timers = element.timers;
            if (element.currentTimer && timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
              element.currentTimerSalvaged = true;
            }
            for (let i = 0, l = timers.length; i < l; i++) {
              CallbackTimer.put(timers[i]);
            }
            timers.length = 0;
            if (this._currentTarget === element) {
              this._currentTargetSalvaged = true;
            } else {
              this._removeHashElement(element);
            }
          }
          this.unscheduleUpdate(target);
        }
        unscheduleAll() {
          this.unscheduleAllWithMinPriority(System.Priority.SCHEDULER);
        }
        unscheduleAllWithMinPriority(minPriority) {
          let i;
          let element;
          const arr = this._arrayForTimers;
          for (i = arr.length - 1; i >= 0; i--) {
            element = arr[i];
            if (element.target) {
              this.unscheduleAllForTarget(element.target);
            }
          }
          let entry;
          let temp_length = 0;
          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length;) {
              var _entry;
              temp_length = this._updatesNegList.length;
              entry = this._updatesNegList[i];
              if ((_entry = entry) !== null && _entry !== void 0 && _entry.target && entry.priority >= minPriority) {
                this.unscheduleUpdate(entry.target);
              }
              if (temp_length === this._updatesNegList.length) {
                i++;
              }
            }
          }
          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length;) {
              var _entry2;
              temp_length = this._updates0List.length;
              entry = this._updates0List[i];
              if ((_entry2 = entry) !== null && _entry2 !== void 0 && _entry2.target) {
                this.unscheduleUpdate(entry.target);
              }
              if (temp_length === this._updates0List.length) {
                i++;
              }
            }
          }
          for (i = 0; i < this._updatesPosList.length;) {
            var _entry3;
            temp_length = this._updatesPosList.length;
            entry = this._updatesPosList[i];
            if ((_entry3 = entry) !== null && _entry3 !== void 0 && _entry3.target && entry.priority >= minPriority) {
              this.unscheduleUpdate(entry.target);
            }
            if (temp_length === this._updatesPosList.length) {
              i++;
            }
          }
        }
        isScheduled(callback, target) {
          assertID(Boolean(callback), 1508);
          assertID(Boolean(target), 1509);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return false;
          }
          const element = this._hashForTimers[targetId];
          if (!element) {
            return false;
          }
          if (element.timers == null) {
            return false;
          } else {
            const timers = element.timers;
            for (let i = 0; i < timers.length; ++i) {
              const timer = timers[i];
              if (callback === timer.getCallback()) {
                return true;
              }
            }
            return false;
          }
        }
        pauseAllTargets() {
          return this.pauseAllTargetsWithMinPriority(System.Priority.SCHEDULER);
        }
        pauseAllTargetsWithMinPriority(minPriority) {
          const idsWithSelectors = [];
          let element;
          const locArrayForTimers = this._arrayForTimers;
          let i;
          let li;
          for (i = 0, li = locArrayForTimers.length; i < li; i++) {
            var _element;
            element = locArrayForTimers[i];
            if ((_element = element) !== null && _element !== void 0 && _element.target) {
              element.paused = true;
              idsWithSelectors.push(element.target);
            }
          }
          let entry;
          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length; i++) {
              var _entry4;
              entry = this._updatesNegList[i];
              if ((_entry4 = entry) !== null && _entry4 !== void 0 && _entry4.target) {
                if (entry.priority >= minPriority) {
                  entry.paused = true;
                  idsWithSelectors.push(entry.target);
                }
              }
            }
          }
          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length; i++) {
              var _entry5;
              entry = this._updates0List[i];
              if ((_entry5 = entry) !== null && _entry5 !== void 0 && _entry5.target) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }
          for (i = 0; i < this._updatesPosList.length; i++) {
            var _entry6;
            entry = this._updatesPosList[i];
            if ((_entry6 = entry) !== null && _entry6 !== void 0 && _entry6.target) {
              if (entry.priority >= minPriority) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }
          return idsWithSelectors;
        }
        resumeTargets(targetsToResume) {
          if (!targetsToResume) {
            return;
          }
          for (let i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
          }
        }
        pauseTarget(target) {
          assertID(Boolean(target), 1503);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            element.paused = true;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            elementUpdate.entry.paused = true;
          }
        }
        resumeTarget(target) {
          assertID(Boolean(target), 1504);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            element.paused = false;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            elementUpdate.entry.paused = false;
          }
        }
        isTargetPaused(target) {
          assertID(Boolean(target), 1505);
          const targetId = target.uuid || target.id;
          if (!targetId) {
            errorID(1510);
            return false;
          }
          const element = this._hashForTimers[targetId];
          if (element) {
            return element.paused;
          }
          const elementUpdate = this._hashForUpdates[targetId];
          if (elementUpdate !== null && elementUpdate !== void 0 && elementUpdate.entry) {
            return elementUpdate.entry.paused;
          }
          return false;
        }
        _removeHashElement(element) {
          if (!element.target) {
            return;
          }
          const targetId = element.target.uuid || element.target.id;
          if (typeof targetId === 'undefined') {
            return;
          }
          delete this._hashForTimers[targetId];
          const arr = this._arrayForTimers;
          for (let i = 0, l = arr.length; i < l; i++) {
            if (arr[i] === element) {
              arr.splice(i, 1);
              break;
            }
          }
          HashTimerEntry.put(element);
        }
        _removeUpdateFromHash(entry) {
          if (!entry.target) {
            return;
          }
          const targetId = entry.target.uuid || entry.target.id;
          if (typeof targetId === 'undefined') {
            return;
          }
          const element = this._hashForUpdates[targetId];
          if (element) {
            const list = element.list;
            const listEntry = element.entry;
            if (list) {
              for (let i = 0, l = list.length; i < l; i++) {
                if (list[i] === listEntry) {
                  list.splice(i, 1);
                  break;
                }
              }
            }
            delete this._hashForUpdates[targetId];
            if (listEntry) {
              ListEntry.put(listEntry);
            }
            HashUpdateEntry.put(element);
          }
        }
        _priorityIn(ppList, listElement, priority) {
          for (let i = 0; i < ppList.length; i++) {
            if (priority < ppList[i].priority) {
              ppList.splice(i, 0, listElement);
              return;
            }
          }
          ppList.push(listElement);
        }
        _appendIn(ppList, listElement) {
          ppList.push(listElement);
        }
      } exports('Scheduler', Scheduler);
      Scheduler.ID = 'scheduler';
      legacyCC.Scheduler = Scheduler;

      const vmath = {};
      replaceProperty(vmath, 'vmath', [{
        name: 'vec2',
        newName: 'Vec2',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec3',
        newName: 'Vec3',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec4',
        newName: 'Vec4',
        target: math,
        targetName: 'math'
      }, {
        name: 'quat',
        newName: 'Quat',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat3',
        newName: 'Mat3',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat4',
        newName: 'Mat4',
        target: math,
        targetName: 'math'
      }, {
        name: 'color4',
        newName: 'Color',
        target: math,
        targetName: 'math'
      }, {
        name: 'rect',
        newName: 'Rect',
        target: math,
        targetName: 'math'
      }, {
        name: 'approx',
        newName: 'approx',
        target: math,
        targetName: 'math'
      }, {
        name: 'EPSILON',
        newName: 'EPSILON',
        target: math,
        targetName: 'math'
      }, {
        name: 'equals',
        newName: 'equals',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp',
        newName: 'clamp',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp01',
        newName: 'clamp01',
        target: math,
        targetName: 'math'
      }, {
        name: 'lerp',
        newName: 'lerp',
        target: math,
        targetName: 'math'
      }, {
        name: 'toRadian',
        newName: 'toRadian',
        target: math,
        targetName: 'math'
      }, {
        name: 'toDegree',
        newName: 'toDegree',
        target: math,
        targetName: 'math'
      }, {
        name: 'random',
        newName: 'random',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRange',
        newName: 'randomRange',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRangeInt',
        newName: 'randomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandom',
        newName: 'pseudoRandom',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandomRangeInt',
        newName: 'pseudoRandomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'nextPow2',
        newName: 'nextPow2',
        target: math,
        targetName: 'math'
      }, {
        name: 'repeat',
        newName: 'repeat',
        target: math,
        targetName: 'math'
      }, {
        name: 'pingPong',
        newName: 'pingPong',
        target: math,
        targetName: 'math'
      }, {
        name: 'inverseLerp',
        newName: 'inverseLerp',
        target: math,
        targetName: 'math'
      }]);
      legacyCC.vmath = vmath;
      replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
        name: 'enableForTarget',
        newName: 'enableForTarget',
        target: Scheduler,
        targetName: 'Scheduler'
      }]);
      replaceProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_SYSTEM',
        newName: 'System.Priority.SCHEDULER',
        customGetter() {
          return System.Priority.SCHEDULER;
        }
      }]);
      removeProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_NON_SYSTEM',
        suggest: 'Use enum` System.Priority` instead'
      }]);

      deprecateModuleExportedName({
        replaceProperty: {
          since: '3.6.0',
          removed: false
        },
        removeProperty: {
          since: '3.6.0',
          removed: false
        },
        markAsWarning: {
          since: '3.6.0',
          removed: false
        },
        setDefaultLogTimes: {
          since: '3.6.0',
          removed: false
        }
      });

      const fastRemoveAt$1 = fastRemoveAt$2;
      function empty() {}
      class CallbackInfo {
        constructor() {
          this.callback = empty;
          this.target = undefined;
          this.once = false;
        }
        set(callback, target, once) {
          this.callback = callback || empty;
          this.target = target;
          this.once = !!once;
        }
        reset() {
          this.target = undefined;
          this.callback = empty;
          this.once = false;
        }
        check() {
          if (isCCObject(this.target) && !isValid(this.target, true)) {
            return false;
          } else {
            return true;
          }
        }
      }
      const callbackInfoPool = new Pool(() => new CallbackInfo(), 32);
      class CallbackList {
        constructor() {
          this.callbackInfos = [];
          this.isInvoking = false;
          this.containCanceled = false;
        }
        removeByCallback(cb) {
          for (let i = 0; i < this.callbackInfos.length; ++i) {
            const info = this.callbackInfos[i];
            if (info && info.callback === cb) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        }
        removeByTarget(target) {
          for (let i = 0; i < this.callbackInfos.length; ++i) {
            const info = this.callbackInfos[i];
            if (info && info.target === target) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        }
        cancel(index) {
          const info = this.callbackInfos[index];
          if (info) {
            info.reset();
            if (this.isInvoking) {
              this.callbackInfos[index] = null;
            } else {
              fastRemoveAt$1(this.callbackInfos, index);
            }
            callbackInfoPool.free(info);
          }
          this.containCanceled = true;
        }
        cancelAll() {
          for (let i = 0; i < this.callbackInfos.length; i++) {
            const info = this.callbackInfos[i];
            if (info) {
              info.reset();
              callbackInfoPool.free(info);
              this.callbackInfos[i] = null;
            }
          }
          this.containCanceled = true;
        }
        purgeCanceled() {
          for (let i = this.callbackInfos.length - 1; i >= 0; --i) {
            const info = this.callbackInfos[i];
            if (!info) {
              fastRemoveAt$1(this.callbackInfos, i);
            }
          }
          this.containCanceled = false;
        }
        clear() {
          this.cancelAll();
          this.callbackInfos.length = 0;
          this.isInvoking = false;
          this.containCanceled = false;
        }
      }
      const MAX_SIZE$1 = 16;
      const callbackListPool = new Pool(() => new CallbackList(), MAX_SIZE$1);
      class CallbacksInvoker {
        constructor() {
          this._callbackTable = createMap(true);
          this._offCallback = void 0;
        }
        on(key, callback, target, once) {
          if (!this.hasEventListener(key, callback, target)) {
            let list = this._callbackTable[key];
            if (!list) {
              list = this._callbackTable[key] = callbackListPool.alloc();
            }
            const info = callbackInfoPool.alloc();
            info.set(callback, target, once);
            list.callbackInfos.push(info);
          }
          return callback;
        }
        hasEventListener(key, callback, target) {
          const list = this._callbackTable && this._callbackTable[key];
          if (!list) {
            return false;
          }
          const infos = list.callbackInfos;
          if (!callback) {
            if (list.isInvoking) {
              for (let i = 0; i < infos.length; ++i) {
                if (infos[i]) {
                  return true;
                }
              }
              return false;
            } else {
              return infos.length > 0;
            }
          }
          for (let i = 0; i < infos.length; ++i) {
            const info = infos[i];
            if (info && info.check() && info.callback === callback && info.target === target) {
              return true;
            }
          }
          return false;
        }
        removeAll(keyOrTarget) {
          const type = typeof keyOrTarget;
          if (type === 'string' || type === 'number') {
            const list = this._callbackTable && this._callbackTable[keyOrTarget];
            if (list) {
              if (list.isInvoking) {
                list.cancelAll();
              } else {
                list.clear();
                callbackListPool.free(list);
                delete this._callbackTable[keyOrTarget];
              }
            }
          } else if (keyOrTarget) {
            for (const key in this._callbackTable) {
              const list = this._callbackTable[key];
              if (list.isInvoking) {
                const infos = list.callbackInfos;
                for (let i = 0; i < infos.length; ++i) {
                  const info = infos[i];
                  if (info && info.target === keyOrTarget) {
                    list.cancel(i);
                  }
                }
              } else {
                list.removeByTarget(keyOrTarget);
              }
            }
          }
        }
        off(key, callback, target) {
          var _this$_offCallback;
          const list = this._callbackTable && this._callbackTable[key];
          if (list) {
            const infos = list.callbackInfos;
            if (callback) {
              for (let i = 0; i < infos.length; ++i) {
                const info = infos[i];
                if (info && info.callback === callback && info.target === target) {
                  list.cancel(i);
                  break;
                }
              }
            } else {
              this.removeAll(key);
            }
          }
          (_this$_offCallback = this._offCallback) === null || _this$_offCallback === void 0 ? void 0 : _this$_offCallback.call(this);
        }
        emit(key, arg0, arg1, arg2, arg3, arg4) {
          const list = this._callbackTable && this._callbackTable[key];
          if (list) {
            const rootInvoker = !list.isInvoking;
            list.isInvoking = true;
            const infos = list.callbackInfos;
            for (let i = 0, len = infos.length; i < len; ++i) {
              const info = infos[i];
              if (info) {
                const callback = info.callback;
                const target = info.target;
                if (info.once) {
                  this.off(key, callback, target);
                }
                if (!info.check()) {
                  this.off(key, callback, target);
                } else if (target) {
                  callback.call(target, arg0, arg1, arg2, arg3, arg4);
                } else {
                  callback(arg0, arg1, arg2, arg3, arg4);
                }
              }
            }
            if (rootInvoker) {
              list.isInvoking = false;
              if (list.containCanceled) {
                list.purgeCanceled();
              }
            }
          }
        }
        clear() {
          for (const key in this._callbackTable) {
            const list = this._callbackTable[key];
            if (list) {
              list.clear();
              callbackListPool.free(list);
              delete this._callbackTable[key];
            }
          }
        }
        _registerOffCallback(cb) {
          this._offCallback = cb;
        }
      } exports('CallbacksInvoker', CallbacksInvoker);

      function Eventify(base) {
        class Eventified extends base {
          constructor(...args) {
            super(...args);
            this._callbackTable = createMap(true);
          }
          once(type, callback, target) {
            return this.on(type, callback, target, true);
          }
          targetOff(typeOrTarget) {
            this.removeAll(typeOrTarget);
          }
        }
        const callbacksInvokerPrototype = CallbacksInvoker.prototype;
        const propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));
        for (let iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
          const propertyKey = propertyKeys[iPropertyKey];
          if (!(propertyKey in Eventified.prototype)) {
            const propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);
            if (propertyDescriptor) {
              Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
            }
          }
        }
        return Eventified;
      }

      class Empty {}
      const EventTarget = exports('EventTarget', Eventify(Empty));
      legacyCC.EventTarget = EventTarget;

      class AsyncDelegate {
        constructor() {
          this._delegates = [];
        }
        add(callback) {
          if (!this._delegates.includes(callback)) {
            this._delegates.push(callback);
          }
        }
        hasListener(callback) {
          return this._delegates.includes(callback);
        }
        remove(callback) {
          fastRemove(this._delegates, callback);
        }
        dispatch(...args) {
          return Promise.all(this._delegates.map(func => func(...arguments)).filter(Boolean));
        }
      } exports('AsyncDelegate', AsyncDelegate);

      let BrowserType;
      (function (BrowserType) {
        BrowserType["UNKNOWN"] = "unknown";
        BrowserType["WECHAT"] = "wechat";
        BrowserType["ANDROID"] = "androidbrowser";
        BrowserType["IE"] = "ie";
        BrowserType["EDGE"] = "edge";
        BrowserType["QQ"] = "qqbrowser";
        BrowserType["MOBILE_QQ"] = "mqqbrowser";
        BrowserType["UC"] = "ucbrowser";
        BrowserType["UCBS"] = "ucbs";
        BrowserType["BROWSER_360"] = "360browser";
        BrowserType["BAIDU_APP"] = "baiduboxapp";
        BrowserType["BAIDU"] = "baidubrowser";
        BrowserType["MAXTHON"] = "maxthon";
        BrowserType["OPERA"] = "opera";
        BrowserType["OUPENG"] = "oupeng";
        BrowserType["MIUI"] = "miuibrowser";
        BrowserType["FIREFOX"] = "firefox";
        BrowserType["SAFARI"] = "safari";
        BrowserType["CHROME"] = "chrome";
        BrowserType["LIEBAO"] = "liebao";
        BrowserType["QZONE"] = "qzone";
        BrowserType["SOUGOU"] = "sogou";
        BrowserType["HUAWEI"] = "huawei";
      })(BrowserType || (BrowserType = {}));

      let Language;
      (function (Language) {
        Language["UNKNOWN"] = "unknown";
        Language["ENGLISH"] = "en";
        Language["CHINESE"] = "zh";
        Language["FRENCH"] = "fr";
        Language["ITALIAN"] = "it";
        Language["GERMAN"] = "de";
        Language["SPANISH"] = "es";
        Language["DUTCH"] = "du";
        Language["RUSSIAN"] = "ru";
        Language["KOREAN"] = "ko";
        Language["JAPANESE"] = "ja";
        Language["HUNGARIAN"] = "hu";
        Language["PORTUGUESE"] = "pt";
        Language["ARABIC"] = "ar";
        Language["NORWEGIAN"] = "no";
        Language["POLISH"] = "pl";
        Language["TURKISH"] = "tr";
        Language["UKRAINIAN"] = "uk";
        Language["ROMANIAN"] = "ro";
        Language["BULGARIAN"] = "bg";
        Language["HINDI"] = "hi";
      })(Language || (Language = {}));

      let NetworkType;
      (function (NetworkType) {
        NetworkType[NetworkType["NONE"] = 0] = "NONE";
        NetworkType[NetworkType["LAN"] = 1] = "LAN";
        NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
      })(NetworkType || (NetworkType = {}));

      let OS;
      (function (OS) {
        OS["UNKNOWN"] = "Unknown";
        OS["IOS"] = "iOS";
        OS["ANDROID"] = "Android";
        OS["WINDOWS"] = "Windows";
        OS["LINUX"] = "Linux";
        OS["OSX"] = "OS X";
        OS["OHOS"] = "OHOS";
        OS["OPENHARMONY"] = "OpenHarmony";
      })(OS || (OS = {}));

      let Platform;
      (function (Platform) {
        Platform["UNKNOWN"] = "UNKNOWN";
        Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
        Platform["EDITOR_CORE"] = "EDITOR_CORE";
        Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
        Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
        Platform["WIN32"] = "WIN32";
        Platform["ANDROID"] = "ANDROID";
        Platform["IOS"] = "IOS";
        Platform["MACOS"] = "MACOS";
        Platform["OHOS"] = "OHOS";
        Platform["OPENHARMONY"] = "OPENHARMONY";
        Platform["WECHAT_GAME"] = "WECHAT_GAME";
        Platform["WECHAT_MINI_PROGRAM"] = "WECHAT_MINI_PROGRAM";
        Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
        Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
        Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
        Platform["TAOBAO_CREATIVE_APP"] = "TAOBAO_CREATIVE_APP";
        Platform["TAOBAO_MINI_GAME"] = "TAOBAO_MINI_GAME";
        Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
        Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
        Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
        Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
        Platform["COCOSPLAY"] = "COCOSPLAY";
        Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
        Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
      })(Platform || (Platform = {}));

      let Feature$1;
      (function (Feature) {
        Feature["WEBP"] = "WEBP";
        Feature["IMAGE_BITMAP"] = "IMAGE_BITMAP";
        Feature["WEB_VIEW"] = "WEB_VIEW";
        Feature["VIDEO_PLAYER"] = "VIDEO_PLAYER";
        Feature["SAFE_AREA"] = "SAFE_AREA";
        Feature["HPE"] = "HPE";
        Feature["INPUT_TOUCH"] = "INPUT_TOUCH";
        Feature["EVENT_KEYBOARD"] = "EVENT_KEYBOARD";
        Feature["EVENT_MOUSE"] = "EVENT_MOUSE";
        Feature["EVENT_TOUCH"] = "EVENT_TOUCH";
        Feature["EVENT_ACCELEROMETER"] = "EVENT_ACCELEROMETER";
        Feature["EVENT_GAMEPAD"] = "EVENT_GAMEPAD";
        Feature["EVENT_HANDLE"] = "EVENT_HANDLE";
        Feature["EVENT_HMD"] = "EVENT_HMD";
        Feature["EVENT_HANDHELD"] = "EVENT_HANDHELD";
        Feature["WASM"] = "WASM";
      })(Feature$1 || (Feature$1 = {}));

      const networkTypeMap = {
        0: NetworkType.NONE,
        1: NetworkType.LAN,
        2: NetworkType.WWAN
      };
      const platformMap = {
        0: Platform.WIN32,
        2: Platform.MACOS,
        3: Platform.ANDROID,
        4: Platform.IOS,
        5: Platform.IOS,
        6: Platform.OHOS,
        7: Platform.OPENHARMONY
      };
      class SystemInfo extends EventTarget {
        get networkType() {
          return networkTypeMap[jsb.device.getNetworkType()];
        }
        constructor() {
          super();
          this.isNative = void 0;
          this.isBrowser = void 0;
          this.isMobile = void 0;
          this.isLittleEndian = void 0;
          this.platform = void 0;
          this.language = void 0;
          this.nativeLanguage = void 0;
          this.os = void 0;
          this.osVersion = void 0;
          this.osMainVersion = void 0;
          this.browserType = void 0;
          this.browserVersion = void 0;
          this.isXR = void 0;
          this._featureMap = void 0;
          this._initPromise = void 0;
          this.isNative = true;
          this.isBrowser = false;
          this.platform = platformMap[__getPlatform()];
          this.isMobile = this.platform === Platform.ANDROID || this.platform === Platform.IOS || this.platform === Platform.OHOS || this.platform === Platform.OPENHARMONY;
          this.isLittleEndian = (() => {
            const buffer = new ArrayBuffer(2);
            new DataView(buffer).setInt16(0, 256, true);
            return new Int16Array(buffer)[0] === 256;
          })();
          const currLanguage = __getCurrentLanguageCode();
          this.nativeLanguage = currLanguage ? currLanguage.toLowerCase() : Language.UNKNOWN;
          this.language = __getCurrentLanguage();
          this.os = __getOS();
          this.osVersion = __getOSVersion();
          this.osMainVersion = parseInt(this.osVersion);
          this.browserType = BrowserType.UNKNOWN;
          this.browserVersion = '';
          this.isXR = typeof xr !== 'undefined' && typeof xr.XrEntry !== 'undefined';
          const isHPE = typeof __supportHPE === 'function' ? __supportHPE() : false;
          this._featureMap = {
            [Feature$1.WEBP]: true,
            [Feature$1.IMAGE_BITMAP]: false,
            [Feature$1.WEB_VIEW]: this.isMobile,
            [Feature$1.VIDEO_PLAYER]: this.isMobile,
            [Feature$1.SAFE_AREA]: this.isMobile,
            [Feature$1.HPE]: isHPE,
            [Feature$1.INPUT_TOUCH]: this.isMobile,
            [Feature$1.EVENT_KEYBOARD]: true,
            [Feature$1.EVENT_MOUSE]: isHPE || !this.isMobile,
            [Feature$1.EVENT_TOUCH]: true,
            [Feature$1.EVENT_ACCELEROMETER]: this.isMobile,
            [Feature$1.EVENT_GAMEPAD]: true,
            [Feature$1.EVENT_HANDLE]: this.isXR,
            [Feature$1.EVENT_HMD]: this.isXR,
            [Feature$1.EVENT_HANDHELD]: typeof xr !== 'undefined' && typeof xr.ARModule !== 'undefined',
            [Feature$1.WASM]: !OPEN_HARMONY
          };
          this._initPromise = [];
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onPause = () => {
            this.emit('hide');
          };
          jsb.onResume = () => {
            this.emit('show');
          };
          jsb.onClose = () => {
            this.emit('close');
          };
        }
        _setFeature(feature, value) {
          return this._featureMap[feature] = value;
        }
        init() {
          return Promise.all(this._initPromise);
        }
        hasFeature(feature) {
          return this._featureMap[feature];
        }
        getBatteryLevel() {
          return jsb.device.getBatteryLevel();
        }
        triggerGC() {
          jsb.garbageCollect();
        }
        openURL(url) {
          jsb.openURL(url);
        }
        now() {
          if (Date.now) {
            return Date.now();
          }
          return +new Date();
        }
        restartJSVM() {
          __restartVM();
        }
        close() {
          __close();
        }
        exit() {
          __exit();
        }
      }
      const systemInfo = new SystemInfo();

      const EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
      const DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
      const NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
      function join(...segments) {
        let result = '';
        for (const segment of segments) {
          result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
        }
        return result;
      }
      function extname(path) {
        const temp = EXTNAME_RE.exec(path);
        return temp ? temp[1] : '';
      }
      function mainFileName(fileName) {
        if (fileName) {
          const idx = fileName.lastIndexOf('.');
          if (idx !== -1) {
            return fileName.substring(0, idx);
          }
        }
        return fileName;
      }
      function basename(path, extName) {
        const index = path.indexOf('?');
        if (index > 0) {
          path = path.substring(0, index);
        }
        const reg = /(\/|\\)([^\/\\]+)$/g;
        const result = reg.exec(path.replace(/(\/|\\)$/, ''));
        if (!result) {
          return path;
        }
        const baseName = result[2];
        if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
          return baseName.substring(0, baseName.length - extName.length);
        }
        return baseName;
      }
      function dirname(path) {
        const temp = DIRNAME_RE.exec(path);
        return temp ? temp[2] : '';
      }
      function changeExtname(path, extName) {
        extName = extName || '';
        let index = path.indexOf('?');
        let tempStr = '';
        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }
        index = path.lastIndexOf('.');
        if (index < 0) {
          return path + extName + tempStr;
        }
        return path.substring(0, index) + extName + tempStr;
      }
      function changeBasename(path, newBaseName, keepExt) {
        if (newBaseName.indexOf('.') === 0) {
          return changeExtname(path, newBaseName);
        }
        let index = path.indexOf('?');
        let tempStr = '';
        const ext = keepExt ? extname(path) : '';
        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }
        index = path.lastIndexOf('/');
        index = index <= 0 ? 0 : index + 1;
        return path.substring(0, index) + newBaseName + ext + tempStr;
      }
      function _normalize(url) {
        let oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, '');
        } while (oldUrl.length !== url.length);
        return url;
      }
      function stripSep(path) {
        return path.replace(/[\/\\]$/, '');
      }
      function getSeperator() {
        return systemInfo.os === OS.WINDOWS ? '\\' : '/';
      }

      var path = /*#__PURE__*/Object.freeze({
        __proto__: null,
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        getSeperator: getSeperator
      });
      exports('path', path);

      const _vec3$1 = new Vec3();
      function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
        if (!out) {
          out = new Vec3();
        }
        mainCamera.convertToUINode(wpos, uiNode, out);
        const pos = uiNode.position;
        out.add(pos);
        return out;
      }
      function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
        if (!out) {
          out = new Vec3();
        }
        mainCamera.worldToScreen(wpos, out);
        out.x /= legacyCC.view.getScaleX();
        out.y /= legacyCC.view.getScaleY();
        return out;
      }
      const convertUtils = exports('convertUtils', {
        WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI
      });
      legacyCC.pipelineUtils = convertUtils;
      replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
        name: 'WorldNode3DToLocalNodeUI',
        newName: 'convertToUINode',
        targetName: 'cc.Camera.prototype',
        customFunction(...args) {
          const camera = args[0];
          const out = args[3] || _vec3$1;
          camera.convertToUINode(args[1], args[2], out);
          out.add(args[2].position);
          return args[3] || out.clone();
        }
      }]);

      markAsWarning(js$1, 'js', [{
        name: 'js',
        suggest: `'js.js' is deprecated since v3.7.0, please access 'js' directly instead.`
      }]);

      const orientationMap$1 = {
        0: Orientation.PORTRAIT,
        '-90': Orientation.LANDSCAPE_LEFT,
        90: Orientation.LANDSCAPE_RIGHT,
        180: Orientation.PORTRAIT_UPSIDE_DOWN
      };
      class ScreenAdapter extends EventTarget {
        get supportFullScreen() {
          return false;
        }
        get isFullScreen() {
          return false;
        }
        get devicePixelRatio() {
          return jsb.device.getDevicePixelRatio() || 1;
        }
        get windowSize() {
          const dpr = this.devicePixelRatio;
          const width = jsb.window.innerWidth;
          const height = jsb.window.innerHeight;
          const roundWidth = Math.round(width);
          const roundHeight = Math.round(height);
          return new Size$1(roundWidth * dpr, roundHeight * dpr);
        }
        set windowSize(size) {
          console.warn('Setting window size is not supported yet.');
        }
        get resolution() {
          const windowSize = this.windowSize;
          const resolutionScale = this.resolutionScale;
          return new Size$1(windowSize.width * resolutionScale, windowSize.height * resolutionScale);
        }
        get resolutionScale() {
          return this._resolutionScale;
        }
        set resolutionScale(v) {
          var _this$_cbToUpdateFram;
          if (v === this._resolutionScale) {
            return;
          }
          this._resolutionScale = v;
          (_this$_cbToUpdateFram = this._cbToUpdateFrameBuffer) === null || _this$_cbToUpdateFram === void 0 ? void 0 : _this$_cbToUpdateFram.call(this);
        }
        get orientation() {
          return orientationMap$1[jsb.device.getDeviceOrientation()];
        }
        set orientation(value) {
          console.warn('Setting orientation is not supported yet.');
        }
        get safeAreaEdge() {
          const nativeSafeArea = jsb.device.getSafeAreaEdge();
          const dpr = this.devicePixelRatio;
          let topEdge = nativeSafeArea.x * dpr;
          let bottomEdge = nativeSafeArea.z * dpr;
          let leftEdge = nativeSafeArea.y * dpr;
          let rightEdge = nativeSafeArea.w * dpr;
          const orientation = this.orientation;
          if (orientation === Orientation.PORTRAIT) {
            if (topEdge < bottomEdge) {
              topEdge = bottomEdge;
            } else {
              bottomEdge = topEdge;
            }
          } else if (leftEdge < rightEdge) {
            leftEdge = rightEdge;
          } else {
            rightEdge = leftEdge;
          }
          return {
            top: topEdge,
            bottom: bottomEdge,
            left: leftEdge,
            right: rightEdge
          };
        }
        get isProportionalToFrame() {
          return this._isProportionalToFrame;
        }
        set isProportionalToFrame(v) {}
        constructor() {
          super();
          this.isFrameRotated = false;
          this.handleResizeEvent = true;
          this._cbToUpdateFrameBuffer = void 0;
          this._resolutionScale = 1;
          this._isProportionalToFrame = false;
          this._registerEvent();
        }
        init(options, cbToRebuildFrameBuffer) {
          this._cbToUpdateFrameBuffer = cbToRebuildFrameBuffer;
          {
            this._cbToUpdateFrameBuffer();
          }
        }
        requestFullScreen() {
          return Promise.reject(new Error('request fullscreen has not been supported yet on this platform.'));
        }
        exitFullScreen() {
          return Promise.reject(new Error('exit fullscreen has not been supported yet on this platform.'));
        }
        _registerEvent() {
          jsb.onResize = event => {
            if (event.width === 0 || event.height === 0) return;
            window.resize(event.width / this.devicePixelRatio, event.height / this.devicePixelRatio);
            this.emit('window-resize', event.width, event.height, event.windowId);
          };
          jsb.onOrientationChanged = event => {
            this.emit('orientation-change', this.orientation);
          };
        }
      }
      const screenAdapter = new ScreenAdapter();

      class Screen {
        init() {
          var _settings$querySettin, _settings$querySettin2;
          const exactFitScreen = (_settings$querySettin = settings.querySettings(Settings.Category.SCREEN, 'exactFitScreen')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : true;
          const orientation = (_settings$querySettin2 = settings.querySettings(Settings.Category.SCREEN, 'orientation')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 'auto';
          const isHeadlessMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode') === 3;
          screenAdapter.init({
            exactFitScreen,
            configOrientation: orientation,
            isHeadlessMode
          }, () => {
            var _director$root;
            const director = legacyCC.director;
            if (!((_director$root = director.root) !== null && _director$root !== void 0 && _director$root.pipeline)) {
              warnID(1220);
              return;
            }
            director.root.pipeline.shadingScale = screenAdapter.resolutionScale;
          });
        }
        get devicePixelRatio() {
          return screenAdapter.devicePixelRatio;
        }
        get windowSize() {
          return screenAdapter.windowSize;
        }
        set windowSize(size) {
          screenAdapter.windowSize = size;
        }
        get resolution() {
          return screenAdapter.resolution;
        }
        get supportsFullScreen() {
          return screenAdapter.supportFullScreen;
        }
        fullScreen() {
          return screenAdapter.isFullScreen;
        }
        requestFullScreen(element, onFullScreenChange, onFullScreenError) {
          if (arguments.length > 0) {
            warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
          }
          return screenAdapter.requestFullScreen().then(() => {
            onFullScreenChange === null || onFullScreenChange === void 0 ? void 0 : onFullScreenChange.call(document);
          }).catch(err => {
            error(err);
            onFullScreenError === null || onFullScreenError === void 0 ? void 0 : onFullScreenError.call(document);
          });
        }
        exitFullScreen() {
          return screenAdapter.exitFullScreen();
        }
        autoFullScreen(element, onFullScreenChange) {
          var _this$requestFullScre;
          (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) === null || _this$requestFullScre === void 0 ? void 0 : _this$requestFullScre.catch(e => {
            warn(e);
          });
        }
        disableAutoFullScreen(element) {}
        on(type, callback, target) {
          screenAdapter.on(type, callback, target);
        }
        once(type, callback, target) {
          screenAdapter.once(type, callback, target);
        }
        off(type, callback, target) {
          screenAdapter.off(type, callback, target);
        }
      }
      const screen = exports('screen', new Screen());
      legacyCC.screen = screen;

      const sys = exports('sys', {
        Feature: Feature$1,
        hasFeature(feature) {
          return systemInfo.hasFeature(feature);
        },
        NetworkType,
        Language,
        OS,
        Platform,
        BrowserType,
        isNative: systemInfo.isNative,
        isBrowser: systemInfo.isBrowser,
        isMobile: systemInfo.isMobile,
        isLittleEndian: systemInfo.isLittleEndian,
        platform: systemInfo.platform,
        language: systemInfo.language,
        languageCode: systemInfo.nativeLanguage,
        os: systemInfo.os,
        osVersion: systemInfo.osVersion,
        osMainVersion: systemInfo.osMainVersion,
        browserType: systemInfo.browserType,
        browserVersion: systemInfo.browserVersion,
        isXR: systemInfo.isXR,
        windowPixelResolution: screen.windowSize,
        capabilities: {
          canvas: true,
          opengl: true,
          webp: systemInfo.hasFeature(Feature$1.WEBP),
          imageBitmap: systemInfo.hasFeature(Feature$1.IMAGE_BITMAP),
          touches: systemInfo.hasFeature(Feature$1.INPUT_TOUCH),
          mouse: systemInfo.hasFeature(Feature$1.EVENT_MOUSE),
          keyboard: systemInfo.hasFeature(Feature$1.EVENT_KEYBOARD),
          accelerometer: systemInfo.hasFeature(Feature$1.EVENT_ACCELEROMETER)
        },
        localStorage: {},
        getNetworkType() {
          return systemInfo.networkType;
        },
        getBatteryLevel() {
          return systemInfo.getBatteryLevel();
        },
        garbageCollect() {
          systemInfo.triggerGC();
        },
        isObjectValid(obj) {
          if (obj === null || obj === undefined) {
            return false;
          }
          return true;
        },
        __isWebIOS14OrIPadOS14Env: false,
        dump() {
          let str = '';
          str += `isMobile : ${this.isMobile}\r\n`;
          str += `language : ${this.language}\r\n`;
          str += `browserType : ${this.browserType}\r\n`;
          str += `browserVersion : ${this.browserVersion}\r\n`;
          str += `supports webp: ${sys.hasFeature(Feature$1.WEBP)}\r\n`;
          str += `supports bitmap: ${sys.hasFeature(Feature$1.IMAGE_BITMAP)}\r\n`;
          str += `supports touches: ${sys.hasFeature(Feature$1.INPUT_TOUCH)}\r\n`;
          str += `supports mouse: ${sys.hasFeature(Feature$1.EVENT_MOUSE)}\r\n`;
          str += `supports keyboard: ${sys.hasFeature(Feature$1.EVENT_KEYBOARD)}\r\n`;
          str += `supports accelerometer: ${sys.hasFeature(Feature$1.EVENT_ACCELEROMETER)}\r\n`;
          str += `os : ${this.os}\r\n`;
          str += `osVersion : ${this.osVersion}\r\n`;
          str += `platform : ${this.platform}\r\n`;
          str += `Using ${legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS'} renderer.\r\n`;
          log(str);
        },
        openURL(url) {
          systemInfo.openURL(url);
        },
        init() {
          return Promise.resolve().then(() => systemInfo.init()).then(() => {
            try {
              let localStorage = sys.localStorage = window.localStorage;
              localStorage.setItem('storage', '');
              localStorage.removeItem('storage');
              localStorage = null;
            } catch (e) {
              const warn = function (...args) {
                warnID(5200);
              };
              this.localStorage = {
                getItem: warn,
                setItem: warn,
                clear: warn,
                removeItem: warn,
                key: warn,
                length: 0
              };
            }
            {
              this.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 14)|(Version\/14)/.test(window.navigator.userAgent);
            }
          });
        },
        now() {
          return systemInfo.now();
        },
        restartVM() {
          systemInfo.restartJSVM();
        },
        getSafeAreaRect() {
          const locView = legacyCC.view;
          const edge = screenAdapter.safeAreaEdge;
          const windowSize = screenAdapter.windowSize;
          const leftBottom = new Vec2(edge.left, edge.bottom);
          const rightTop = new Vec2(windowSize.width - edge.right, windowSize.height - edge.top);
          locView._convertToUISpace(leftBottom);
          locView._convertToUISpace(rightTop);
          const x = leftBottom.x;
          const y = leftBottom.y;
          const width = rightTop.x - leftBottom.x;
          const height = rightTop.y - leftBottom.y;
          return new Rect$1(x, y, width, height);
        }
      });
      legacyCC.sys = sys;

      markAsWarning(legacyCC, 'cc', [{
        name: 'winSize',
        suggest: 'please use view.getVisibleSize() instead.'
      }]);
      markAsWarning(sys, 'sys', [{
        name: 'capabilities',
        suggest: 'please use sys.hasFeature() method instead.'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(item => ({
        name: `LANGUAGE_${item}`,
        newName: item,
        target: sys.Language,
        targetName: 'sys.Language'
      })));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(item => ({
        name: `OS_${item}`,
        newName: item,
        target: sys.OS,
        targetName: 'sys.OS'
      })));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(item => ({
        name: `BROWSER_TYPE_${item}`,
        newName: item,
        target: sys.BrowserType,
        targetName: 'sys.BrowserType'
      })));
      replaceProperty(sys, 'sys', [{
        name: 'BROWSER_TYPE_360',
        newName: 'BROWSER_360',
        target: sys.BrowserType,
        targetName: 'sys.BrowserType'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'BAIDU_MINI_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME', 'COCOSPLAY', 'LINKSURE_MINI_GAME', 'QTT_MINI_GAME'].map(item => ({
        name: item,
        target: sys.Platform,
        targetName: 'sys.Platform'
      })));
      replaceProperty(sys, 'sys', [{
        name: 'IPHONE',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }, {
        name: 'IPAD',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }]);
      removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(item => ({
        name: item
      })));
      replaceProperty(sys, 'sys', [{
        name: 'windowPixelResolution',
        target: screen,
        targetName: 'screen',
        newName: 'windowSize'
      }]);
      markAsWarning(screen, 'screen', [{
        name: 'autoFullScreen',
        suggest: 'please use screen.requestFullScreen() instead.'
      }, {
        name: 'disableAutoFullScreen'
      }]);

      const visibleRect = exports('visibleRect', {
        topLeft: legacyCC.v2(0, 0),
        topRight: legacyCC.v2(0, 0),
        top: legacyCC.v2(0, 0),
        bottomLeft: legacyCC.v2(0, 0),
        bottomRight: legacyCC.v2(0, 0),
        bottom: legacyCC.v2(0, 0),
        center: legacyCC.v2(0, 0),
        left: legacyCC.v2(0, 0),
        right: legacyCC.v2(0, 0),
        width: 0,
        height: 0,
        init(visibleRect_) {
          const w = this.width = visibleRect_.width;
          const h = this.height = visibleRect_.height;
          const l = visibleRect_.x;
          const b = visibleRect_.y;
          const t = b + h;
          const r = l + w;
          this.topLeft.x = l;
          this.topLeft.y = t;
          this.topRight.x = r;
          this.topRight.y = t;
          this.top.x = l + w / 2;
          this.top.y = t;
          this.bottomLeft.x = l;
          this.bottomLeft.y = b;
          this.bottomRight.x = r;
          this.bottomRight.y = b;
          this.bottom.x = l + w / 2;
          this.bottom.y = b;
          this.center.x = l + w / 2;
          this.center.y = b + h / 2;
          this.left.x = l;
          this.left.y = b + h / 2;
          this.right.x = r;
          this.right.y = b + h / 2;
        }
      });
      legacyCC.visibleRect = visibleRect;

      const getUint8ForString = String.prototype.charCodeAt;
      function getUint8ForArray(idx) {
        return this[idx];
      }
      function murmurhash2_32_gc(input, seed) {
        let l = input.length;
        let h = seed ^ l;
        let i = 0;
        const getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;
        while (l >= 4) {
          let k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          k ^= k >>> 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
          l -= 4;
          ++i;
        }
        switch (l) {
          case 3:
            h ^= (getUint8.call(input, i + 2) & 0xff) << 16;
          case 2:
            h ^= (getUint8.call(input, i + 1) & 0xff) << 8;
          case 1:
            h ^= getUint8.call(input, i) & 0xff;
            h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
            break;
        }
        h ^= h >>> 13;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        h ^= h >>> 15;
        return h >>> 0;
      }

      legacyCC.easing = easing;

      function syncNodeValues(node) {
        const lpos = node._lpos;
        node.setPositionForJS(lpos.x, lpos.y, lpos.z);
        const lscale = node._lscale;
        node.setScaleForJS(lscale.x, lscale.y, lscale.z);
        const lrot = node._lrot;
        node.setRotationForJS(lrot.x, lrot.y, lrot.z, lrot.w);
        const euler = node._euler;
        node.setRotationFromEulerForJS(euler.x, euler.y, euler.z);
      }
      function updateChildrenForDeserialize(node) {
        if (!node) {
          return;
        }
        const children = node.children;
        if (!children) {
          return;
        }
        const len = children.length;
        if (!len) {
          return;
        }
        node._setChildren(children);
        for (let i = 0; i < len; ++i) {
          const child = children[i];
          updateChildrenForDeserialize(child);
        }
      }
      function ExtraEventMethods() {}
      ExtraEventMethods.prototype.once = function once(type, callback, target) {
        return this.on(type, callback, target, true);
      };
      ExtraEventMethods.prototype.targetOff = function targetOff(typeOrTarget) {
        this.removeAll(typeOrTarget);
      };

      var jsbUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        syncNodeValues: syncNodeValues,
        updateChildrenForDeserialize: updateChildrenForDeserialize,
        ExtraEventMethods: ExtraEventMethods
      });
      exports('jsbUtils', jsbUtils);

      function shift(array, first, last) {
        assertsArrayIndex(array, first);
        assertsArrayIndex(array, last);
        if (first === last) {
          return array;
        }
        const element = array[first];
        if (first < last) {
          for (let iElement = first + 1; iElement <= last; ++iElement) {
            array[iElement - 1] = array[iElement];
          }
        } else {
          for (let iElement = first; iElement !== last; --iElement) {
            array[iElement] = array[iElement - 1];
          }
        }
        array[last] = element;
        return array;
      }

      class GarbageCollectionManager {
        constructor() {
          this._finalizationRegistry = null;
          this._gcObjects = new WeakMap();
        }
        registerGCObject(gcObject) {
          {
            return gcObject;
          }
        }
        init() {}
        finalizationRegistryCallback(token) {
          const gcObject = this._gcObjects.get(token);
          if (gcObject) {
            this._gcObjects.delete(token);
            gcObject.destroy();
          }
          this._finalizationRegistry.unregister(token);
        }
        destroy() {}
      }
      const garbageCollectionManager = exports('garbageCollectionManager', new GarbageCollectionManager());

      class GCObject {
        constructor() {
          return garbageCollectionManager.registerGCObject(this);
        }
        destroy() {}
      } exports('GCObject', GCObject);

      function deepFlatten(strList, array) {
        for (const item of array) {
          if (Array.isArray(item)) {
            deepFlatten(strList, item);
          } else {
            strList.push(item);
          }
        }
      }
      function flattenCodeArray(array) {
        const separator = '';
        const strList = [];
        deepFlatten(strList, array);
        return strList.join(separator);
      }

      function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(baseCtor => {
          Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            if (name !== 'constructor') {
              Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
          });
        });
      }

      legacyCC.math = math;
      legacyCC.geometry = geometry;

      const deepCopy = (target, source, Ctor) => {
        for (let i = 0; i < source.length; ++i) {
          if (target.length <= i) target.push(new Ctor());
          target[i].copy(source[i]);
        }
        target.length = source.length;
      };
      let ObjectType;
      (function (ObjectType) {
        ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
        ObjectType[ObjectType["SWAPCHAIN"] = 1] = "SWAPCHAIN";
        ObjectType[ObjectType["BUFFER"] = 2] = "BUFFER";
        ObjectType[ObjectType["TEXTURE"] = 3] = "TEXTURE";
        ObjectType[ObjectType["RENDER_PASS"] = 4] = "RENDER_PASS";
        ObjectType[ObjectType["FRAMEBUFFER"] = 5] = "FRAMEBUFFER";
        ObjectType[ObjectType["SAMPLER"] = 6] = "SAMPLER";
        ObjectType[ObjectType["SHADER"] = 7] = "SHADER";
        ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 8] = "DESCRIPTOR_SET_LAYOUT";
        ObjectType[ObjectType["PIPELINE_LAYOUT"] = 9] = "PIPELINE_LAYOUT";
        ObjectType[ObjectType["PIPELINE_STATE"] = 10] = "PIPELINE_STATE";
        ObjectType[ObjectType["DESCRIPTOR_SET"] = 11] = "DESCRIPTOR_SET";
        ObjectType[ObjectType["INPUT_ASSEMBLER"] = 12] = "INPUT_ASSEMBLER";
        ObjectType[ObjectType["COMMAND_BUFFER"] = 13] = "COMMAND_BUFFER";
        ObjectType[ObjectType["QUEUE"] = 14] = "QUEUE";
        ObjectType[ObjectType["QUERY_POOL"] = 15] = "QUERY_POOL";
        ObjectType[ObjectType["GLOBAL_BARRIER"] = 16] = "GLOBAL_BARRIER";
        ObjectType[ObjectType["TEXTURE_BARRIER"] = 17] = "TEXTURE_BARRIER";
        ObjectType[ObjectType["BUFFER_BARRIER"] = 18] = "BUFFER_BARRIER";
        ObjectType[ObjectType["COUNT"] = 19] = "COUNT";
      })(ObjectType || (ObjectType = {}));
      let Status;
      (function (Status) {
        Status[Status["UNREADY"] = 0] = "UNREADY";
        Status[Status["FAILED"] = 1] = "FAILED";
        Status[Status["SUCCESS"] = 2] = "SUCCESS";
      })(Status || (Status = {}));
      let API;
      (function (API) {
        API[API["UNKNOWN"] = 0] = "UNKNOWN";
        API[API["GLES2"] = 1] = "GLES2";
        API[API["GLES3"] = 2] = "GLES3";
        API[API["METAL"] = 3] = "METAL";
        API[API["VULKAN"] = 4] = "VULKAN";
        API[API["NVN"] = 5] = "NVN";
        API[API["WEBGL"] = 6] = "WEBGL";
        API[API["WEBGL2"] = 7] = "WEBGL2";
        API[API["WEBGPU"] = 8] = "WEBGPU";
      })(API || (API = {}));
      let SurfaceTransform;
      (function (SurfaceTransform) {
        SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
        SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
        SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
        SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
      })(SurfaceTransform || (SurfaceTransform = {}));
      let Feature;
      (function (Feature) {
        Feature[Feature["ELEMENT_INDEX_UINT"] = 0] = "ELEMENT_INDEX_UINT";
        Feature[Feature["INSTANCED_ARRAYS"] = 1] = "INSTANCED_ARRAYS";
        Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 2] = "MULTIPLE_RENDER_TARGETS";
        Feature[Feature["BLEND_MINMAX"] = 3] = "BLEND_MINMAX";
        Feature[Feature["COMPUTE_SHADER"] = 4] = "COMPUTE_SHADER";
        Feature[Feature["INPUT_ATTACHMENT_BENEFIT"] = 5] = "INPUT_ATTACHMENT_BENEFIT";
        Feature[Feature["SUBPASS_COLOR_INPUT"] = 6] = "SUBPASS_COLOR_INPUT";
        Feature[Feature["SUBPASS_DEPTH_STENCIL_INPUT"] = 7] = "SUBPASS_DEPTH_STENCIL_INPUT";
        Feature[Feature["RASTERIZATION_ORDER_COHERENT"] = 8] = "RASTERIZATION_ORDER_COHERENT";
        Feature[Feature["MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL"] = 9] = "MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL";
        Feature[Feature["COUNT"] = 10] = "COUNT";
      })(Feature || (Feature = {}));
      let Format;
      (function (Format) {
        Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
        Format[Format["A8"] = 1] = "A8";
        Format[Format["L8"] = 2] = "L8";
        Format[Format["LA8"] = 3] = "LA8";
        Format[Format["R8"] = 4] = "R8";
        Format[Format["R8SN"] = 5] = "R8SN";
        Format[Format["R8UI"] = 6] = "R8UI";
        Format[Format["R8I"] = 7] = "R8I";
        Format[Format["R16F"] = 8] = "R16F";
        Format[Format["R16UI"] = 9] = "R16UI";
        Format[Format["R16I"] = 10] = "R16I";
        Format[Format["R32F"] = 11] = "R32F";
        Format[Format["R32UI"] = 12] = "R32UI";
        Format[Format["R32I"] = 13] = "R32I";
        Format[Format["RG8"] = 14] = "RG8";
        Format[Format["RG8SN"] = 15] = "RG8SN";
        Format[Format["RG8UI"] = 16] = "RG8UI";
        Format[Format["RG8I"] = 17] = "RG8I";
        Format[Format["RG16F"] = 18] = "RG16F";
        Format[Format["RG16UI"] = 19] = "RG16UI";
        Format[Format["RG16I"] = 20] = "RG16I";
        Format[Format["RG32F"] = 21] = "RG32F";
        Format[Format["RG32UI"] = 22] = "RG32UI";
        Format[Format["RG32I"] = 23] = "RG32I";
        Format[Format["RGB8"] = 24] = "RGB8";
        Format[Format["SRGB8"] = 25] = "SRGB8";
        Format[Format["RGB8SN"] = 26] = "RGB8SN";
        Format[Format["RGB8UI"] = 27] = "RGB8UI";
        Format[Format["RGB8I"] = 28] = "RGB8I";
        Format[Format["RGB16F"] = 29] = "RGB16F";
        Format[Format["RGB16UI"] = 30] = "RGB16UI";
        Format[Format["RGB16I"] = 31] = "RGB16I";
        Format[Format["RGB32F"] = 32] = "RGB32F";
        Format[Format["RGB32UI"] = 33] = "RGB32UI";
        Format[Format["RGB32I"] = 34] = "RGB32I";
        Format[Format["RGBA8"] = 35] = "RGBA8";
        Format[Format["BGRA8"] = 36] = "BGRA8";
        Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
        Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
        Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
        Format[Format["RGBA8I"] = 40] = "RGBA8I";
        Format[Format["RGBA16F"] = 41] = "RGBA16F";
        Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
        Format[Format["RGBA16I"] = 43] = "RGBA16I";
        Format[Format["RGBA32F"] = 44] = "RGBA32F";
        Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
        Format[Format["RGBA32I"] = 46] = "RGBA32I";
        Format[Format["R5G6B5"] = 47] = "R5G6B5";
        Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
        Format[Format["RGB5A1"] = 49] = "RGB5A1";
        Format[Format["RGBA4"] = 50] = "RGBA4";
        Format[Format["RGB10A2"] = 51] = "RGB10A2";
        Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
        Format[Format["RGB9E5"] = 53] = "RGB9E5";
        Format[Format["DEPTH"] = 54] = "DEPTH";
        Format[Format["DEPTH_STENCIL"] = 55] = "DEPTH_STENCIL";
        Format[Format["BC1"] = 56] = "BC1";
        Format[Format["BC1_ALPHA"] = 57] = "BC1_ALPHA";
        Format[Format["BC1_SRGB"] = 58] = "BC1_SRGB";
        Format[Format["BC1_SRGB_ALPHA"] = 59] = "BC1_SRGB_ALPHA";
        Format[Format["BC2"] = 60] = "BC2";
        Format[Format["BC2_SRGB"] = 61] = "BC2_SRGB";
        Format[Format["BC3"] = 62] = "BC3";
        Format[Format["BC3_SRGB"] = 63] = "BC3_SRGB";
        Format[Format["BC4"] = 64] = "BC4";
        Format[Format["BC4_SNORM"] = 65] = "BC4_SNORM";
        Format[Format["BC5"] = 66] = "BC5";
        Format[Format["BC5_SNORM"] = 67] = "BC5_SNORM";
        Format[Format["BC6H_UF16"] = 68] = "BC6H_UF16";
        Format[Format["BC6H_SF16"] = 69] = "BC6H_SF16";
        Format[Format["BC7"] = 70] = "BC7";
        Format[Format["BC7_SRGB"] = 71] = "BC7_SRGB";
        Format[Format["ETC_RGB8"] = 72] = "ETC_RGB8";
        Format[Format["ETC2_RGB8"] = 73] = "ETC2_RGB8";
        Format[Format["ETC2_SRGB8"] = 74] = "ETC2_SRGB8";
        Format[Format["ETC2_RGB8_A1"] = 75] = "ETC2_RGB8_A1";
        Format[Format["ETC2_SRGB8_A1"] = 76] = "ETC2_SRGB8_A1";
        Format[Format["ETC2_RGBA8"] = 77] = "ETC2_RGBA8";
        Format[Format["ETC2_SRGB8_A8"] = 78] = "ETC2_SRGB8_A8";
        Format[Format["EAC_R11"] = 79] = "EAC_R11";
        Format[Format["EAC_R11SN"] = 80] = "EAC_R11SN";
        Format[Format["EAC_RG11"] = 81] = "EAC_RG11";
        Format[Format["EAC_RG11SN"] = 82] = "EAC_RG11SN";
        Format[Format["PVRTC_RGB2"] = 83] = "PVRTC_RGB2";
        Format[Format["PVRTC_RGBA2"] = 84] = "PVRTC_RGBA2";
        Format[Format["PVRTC_RGB4"] = 85] = "PVRTC_RGB4";
        Format[Format["PVRTC_RGBA4"] = 86] = "PVRTC_RGBA4";
        Format[Format["PVRTC2_2BPP"] = 87] = "PVRTC2_2BPP";
        Format[Format["PVRTC2_4BPP"] = 88] = "PVRTC2_4BPP";
        Format[Format["ASTC_RGBA_4X4"] = 89] = "ASTC_RGBA_4X4";
        Format[Format["ASTC_RGBA_5X4"] = 90] = "ASTC_RGBA_5X4";
        Format[Format["ASTC_RGBA_5X5"] = 91] = "ASTC_RGBA_5X5";
        Format[Format["ASTC_RGBA_6X5"] = 92] = "ASTC_RGBA_6X5";
        Format[Format["ASTC_RGBA_6X6"] = 93] = "ASTC_RGBA_6X6";
        Format[Format["ASTC_RGBA_8X5"] = 94] = "ASTC_RGBA_8X5";
        Format[Format["ASTC_RGBA_8X6"] = 95] = "ASTC_RGBA_8X6";
        Format[Format["ASTC_RGBA_8X8"] = 96] = "ASTC_RGBA_8X8";
        Format[Format["ASTC_RGBA_10X5"] = 97] = "ASTC_RGBA_10X5";
        Format[Format["ASTC_RGBA_10X6"] = 98] = "ASTC_RGBA_10X6";
        Format[Format["ASTC_RGBA_10X8"] = 99] = "ASTC_RGBA_10X8";
        Format[Format["ASTC_RGBA_10X10"] = 100] = "ASTC_RGBA_10X10";
        Format[Format["ASTC_RGBA_12X10"] = 101] = "ASTC_RGBA_12X10";
        Format[Format["ASTC_RGBA_12X12"] = 102] = "ASTC_RGBA_12X12";
        Format[Format["ASTC_SRGBA_4X4"] = 103] = "ASTC_SRGBA_4X4";
        Format[Format["ASTC_SRGBA_5X4"] = 104] = "ASTC_SRGBA_5X4";
        Format[Format["ASTC_SRGBA_5X5"] = 105] = "ASTC_SRGBA_5X5";
        Format[Format["ASTC_SRGBA_6X5"] = 106] = "ASTC_SRGBA_6X5";
        Format[Format["ASTC_SRGBA_6X6"] = 107] = "ASTC_SRGBA_6X6";
        Format[Format["ASTC_SRGBA_8X5"] = 108] = "ASTC_SRGBA_8X5";
        Format[Format["ASTC_SRGBA_8X6"] = 109] = "ASTC_SRGBA_8X6";
        Format[Format["ASTC_SRGBA_8X8"] = 110] = "ASTC_SRGBA_8X8";
        Format[Format["ASTC_SRGBA_10X5"] = 111] = "ASTC_SRGBA_10X5";
        Format[Format["ASTC_SRGBA_10X6"] = 112] = "ASTC_SRGBA_10X6";
        Format[Format["ASTC_SRGBA_10X8"] = 113] = "ASTC_SRGBA_10X8";
        Format[Format["ASTC_SRGBA_10X10"] = 114] = "ASTC_SRGBA_10X10";
        Format[Format["ASTC_SRGBA_12X10"] = 115] = "ASTC_SRGBA_12X10";
        Format[Format["ASTC_SRGBA_12X12"] = 116] = "ASTC_SRGBA_12X12";
        Format[Format["COUNT"] = 117] = "COUNT";
      })(Format || (Format = {}));
      let FormatType;
      (function (FormatType) {
        FormatType[FormatType["NONE"] = 0] = "NONE";
        FormatType[FormatType["UNORM"] = 1] = "UNORM";
        FormatType[FormatType["SNORM"] = 2] = "SNORM";
        FormatType[FormatType["UINT"] = 3] = "UINT";
        FormatType[FormatType["INT"] = 4] = "INT";
        FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
        FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
      })(FormatType || (FormatType = {}));
      let Type$1;
      (function (Type) {
        Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
        Type[Type["BOOL"] = 1] = "BOOL";
        Type[Type["BOOL2"] = 2] = "BOOL2";
        Type[Type["BOOL3"] = 3] = "BOOL3";
        Type[Type["BOOL4"] = 4] = "BOOL4";
        Type[Type["INT"] = 5] = "INT";
        Type[Type["INT2"] = 6] = "INT2";
        Type[Type["INT3"] = 7] = "INT3";
        Type[Type["INT4"] = 8] = "INT4";
        Type[Type["UINT"] = 9] = "UINT";
        Type[Type["UINT2"] = 10] = "UINT2";
        Type[Type["UINT3"] = 11] = "UINT3";
        Type[Type["UINT4"] = 12] = "UINT4";
        Type[Type["FLOAT"] = 13] = "FLOAT";
        Type[Type["FLOAT2"] = 14] = "FLOAT2";
        Type[Type["FLOAT3"] = 15] = "FLOAT3";
        Type[Type["FLOAT4"] = 16] = "FLOAT4";
        Type[Type["MAT2"] = 17] = "MAT2";
        Type[Type["MAT2X3"] = 18] = "MAT2X3";
        Type[Type["MAT2X4"] = 19] = "MAT2X4";
        Type[Type["MAT3X2"] = 20] = "MAT3X2";
        Type[Type["MAT3"] = 21] = "MAT3";
        Type[Type["MAT3X4"] = 22] = "MAT3X4";
        Type[Type["MAT4X2"] = 23] = "MAT4X2";
        Type[Type["MAT4X3"] = 24] = "MAT4X3";
        Type[Type["MAT4"] = 25] = "MAT4";
        Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
        Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
        Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
        Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
        Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
        Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
        Type[Type["SAMPLER"] = 32] = "SAMPLER";
        Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
        Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
        Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
        Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
        Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
        Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
        Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
        Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
        Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
        Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
        Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
        Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
        Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
        Type[Type["COUNT"] = 46] = "COUNT";
      })(Type$1 || (Type$1 = {}));
      let BufferUsageBit;
      (function (BufferUsageBit) {
        BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
        BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
        BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
        BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
        BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
        BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
      })(BufferUsageBit || (BufferUsageBit = {}));
      let BufferFlagBit;
      (function (BufferFlagBit) {
        BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
      })(BufferFlagBit || (BufferFlagBit = {}));
      let MemoryAccessBit;
      (function (MemoryAccessBit) {
        MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
        MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
        MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
        MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
      })(MemoryAccessBit || (MemoryAccessBit = {}));
      let MemoryUsageBit;
      (function (MemoryUsageBit) {
        MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
        MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
        MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
      })(MemoryUsageBit || (MemoryUsageBit = {}));
      let TextureType;
      (function (TextureType) {
        TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
        TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
        TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
        TextureType[TextureType["CUBE"] = 3] = "CUBE";
        TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
        TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
      })(TextureType || (TextureType = {}));
      let TextureUsageBit;
      (function (TextureUsageBit) {
        TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
        TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
        TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
        TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
      })(TextureUsageBit || (TextureUsageBit = {}));
      let TextureFlagBit;
      (function (TextureFlagBit) {
        TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
        TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
        TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 2] = "GENERAL_LAYOUT";
        TextureFlagBit[TextureFlagBit["EXTERNAL_OES"] = 4] = "EXTERNAL_OES";
        TextureFlagBit[TextureFlagBit["EXTERNAL_NORMAL"] = 8] = "EXTERNAL_NORMAL";
        TextureFlagBit[TextureFlagBit["LAZILY_ALLOCATED"] = 16] = "LAZILY_ALLOCATED";
        TextureFlagBit[TextureFlagBit["MUTABLE_VIEW_FORMAT"] = 64] = "MUTABLE_VIEW_FORMAT";
        TextureFlagBit[TextureFlagBit["MUTABLE_STORAGE"] = 128] = "MUTABLE_STORAGE";
      })(TextureFlagBit || (TextureFlagBit = {}));
      let FormatFeatureBit;
      (function (FormatFeatureBit) {
        FormatFeatureBit[FormatFeatureBit["NONE"] = 0] = "NONE";
        FormatFeatureBit[FormatFeatureBit["RENDER_TARGET"] = 1] = "RENDER_TARGET";
        FormatFeatureBit[FormatFeatureBit["SAMPLED_TEXTURE"] = 2] = "SAMPLED_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["LINEAR_FILTER"] = 4] = "LINEAR_FILTER";
        FormatFeatureBit[FormatFeatureBit["STORAGE_TEXTURE"] = 8] = "STORAGE_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["VERTEX_ATTRIBUTE"] = 16] = "VERTEX_ATTRIBUTE";
      })(FormatFeatureBit || (FormatFeatureBit = {}));
      let SampleCount;
      (function (SampleCount) {
        SampleCount[SampleCount["X1"] = 1] = "X1";
        SampleCount[SampleCount["X2"] = 2] = "X2";
        SampleCount[SampleCount["X4"] = 4] = "X4";
        SampleCount[SampleCount["X8"] = 8] = "X8";
        SampleCount[SampleCount["X16"] = 16] = "X16";
        SampleCount[SampleCount["X32"] = 32] = "X32";
        SampleCount[SampleCount["X64"] = 64] = "X64";
      })(SampleCount || (SampleCount = {}));
      let VsyncMode;
      (function (VsyncMode) {
        VsyncMode[VsyncMode["OFF"] = 0] = "OFF";
        VsyncMode[VsyncMode["ON"] = 1] = "ON";
        VsyncMode[VsyncMode["RELAXED"] = 2] = "RELAXED";
        VsyncMode[VsyncMode["MAILBOX"] = 3] = "MAILBOX";
        VsyncMode[VsyncMode["HALF"] = 4] = "HALF";
      })(VsyncMode || (VsyncMode = {}));
      let Filter$1;
      (function (Filter) {
        Filter[Filter["NONE"] = 0] = "NONE";
        Filter[Filter["POINT"] = 1] = "POINT";
        Filter[Filter["LINEAR"] = 2] = "LINEAR";
        Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
      })(Filter$1 || (Filter$1 = {}));
      let Address;
      (function (Address) {
        Address[Address["WRAP"] = 0] = "WRAP";
        Address[Address["MIRROR"] = 1] = "MIRROR";
        Address[Address["CLAMP"] = 2] = "CLAMP";
        Address[Address["BORDER"] = 3] = "BORDER";
      })(Address || (Address = {}));
      let ComparisonFunc;
      (function (ComparisonFunc) {
        ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
        ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
        ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
        ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
        ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
      })(ComparisonFunc || (ComparisonFunc = {}));
      let StencilOp;
      (function (StencilOp) {
        StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
        StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
        StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
        StencilOp[StencilOp["INCR"] = 3] = "INCR";
        StencilOp[StencilOp["DECR"] = 4] = "DECR";
        StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
        StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
        StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
      })(StencilOp || (StencilOp = {}));
      let BlendFactor;
      (function (BlendFactor) {
        BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
        BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
        BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
        BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
        BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
        BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
        BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
        BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
        BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
      })(BlendFactor || (BlendFactor = {}));
      let BlendOp;
      (function (BlendOp) {
        BlendOp[BlendOp["ADD"] = 0] = "ADD";
        BlendOp[BlendOp["SUB"] = 1] = "SUB";
        BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
        BlendOp[BlendOp["MIN"] = 3] = "MIN";
        BlendOp[BlendOp["MAX"] = 4] = "MAX";
      })(BlendOp || (BlendOp = {}));
      let ColorMask;
      (function (ColorMask) {
        ColorMask[ColorMask["NONE"] = 0] = "NONE";
        ColorMask[ColorMask["R"] = 1] = "R";
        ColorMask[ColorMask["G"] = 2] = "G";
        ColorMask[ColorMask["B"] = 4] = "B";
        ColorMask[ColorMask["A"] = 8] = "A";
        ColorMask[ColorMask["ALL"] = 15] = "ALL";
      })(ColorMask || (ColorMask = {}));
      let ShaderStageFlagBit;
      (function (ShaderStageFlagBit) {
        ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
        ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
        ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
        ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
        ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
        ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
        ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
        ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
      })(ShaderStageFlagBit || (ShaderStageFlagBit = {}));
      let LoadOp;
      (function (LoadOp) {
        LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
        LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
        LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
      })(LoadOp || (LoadOp = {}));
      let StoreOp;
      (function (StoreOp) {
        StoreOp[StoreOp["STORE"] = 0] = "STORE";
        StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
      })(StoreOp || (StoreOp = {}));
      let AccessFlagBit;
      (function (AccessFlagBit) {
        AccessFlagBit[AccessFlagBit["NONE"] = 0] = "NONE";
        AccessFlagBit[AccessFlagBit["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
        AccessFlagBit[AccessFlagBit["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_BUFFER"] = 4] = "VERTEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 8] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_TEXTURE"] = 16] = "VERTEX_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_OTHER"] = 32] = "VERTEX_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 64] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_TEXTURE"] = 128] = "FRAGMENT_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 256] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 512] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_OTHER"] = 1024] = "FRAGMENT_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_READ"] = 2048] = "COLOR_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_READ"] = 4096] = "DEPTH_STENCIL_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 8192] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_TEXTURE"] = 16384] = "COMPUTE_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_OTHER"] = 32768] = "COMPUTE_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["TRANSFER_READ"] = 65536] = "TRANSFER_READ";
        AccessFlagBit[AccessFlagBit["HOST_READ"] = 131072] = "HOST_READ";
        AccessFlagBit[AccessFlagBit["PRESENT"] = 262144] = "PRESENT";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_WRITE"] = 524288] = "VERTEX_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_WRITE"] = 1048576] = "FRAGMENT_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_WRITE"] = 2097152] = "COLOR_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 4194304] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_WRITE"] = 8388608] = "COMPUTE_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["TRANSFER_WRITE"] = 16777216] = "TRANSFER_WRITE";
        AccessFlagBit[AccessFlagBit["HOST_PREINITIALIZED"] = 33554432] = "HOST_PREINITIALIZED";
        AccessFlagBit[AccessFlagBit["HOST_WRITE"] = 67108864] = "HOST_WRITE";
      })(AccessFlagBit || (AccessFlagBit = {}));
      let ResolveMode;
      (function (ResolveMode) {
        ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
        ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
        ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
        ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
        ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
      })(ResolveMode || (ResolveMode = {}));
      let PipelineBindPoint;
      (function (PipelineBindPoint) {
        PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
        PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
        PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
      })(PipelineBindPoint || (PipelineBindPoint = {}));
      let PrimitiveMode;
      (function (PrimitiveMode) {
        PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
        PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
        PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
        PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
        PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
        PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
        PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
      })(PrimitiveMode || (PrimitiveMode = {}));
      let PolygonMode;
      (function (PolygonMode) {
        PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
        PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
        PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
      })(PolygonMode || (PolygonMode = {}));
      let ShadeModel;
      (function (ShadeModel) {
        ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
        ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
      })(ShadeModel || (ShadeModel = {}));
      let CullMode;
      (function (CullMode) {
        CullMode[CullMode["NONE"] = 0] = "NONE";
        CullMode[CullMode["FRONT"] = 1] = "FRONT";
        CullMode[CullMode["BACK"] = 2] = "BACK";
      })(CullMode || (CullMode = {}));
      let DynamicStateFlagBit;
      (function (DynamicStateFlagBit) {
        DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
        DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 1] = "LINE_WIDTH";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 2] = "DEPTH_BIAS";
        DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 4] = "BLEND_CONSTANTS";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 8] = "DEPTH_BOUNDS";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 16] = "STENCIL_WRITE_MASK";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 32] = "STENCIL_COMPARE_MASK";
      })(DynamicStateFlagBit || (DynamicStateFlagBit = {}));
      let StencilFace;
      (function (StencilFace) {
        StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
        StencilFace[StencilFace["BACK"] = 2] = "BACK";
        StencilFace[StencilFace["ALL"] = 3] = "ALL";
      })(StencilFace || (StencilFace = {}));
      let DescriptorType;
      (function (DescriptorType) {
        DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
        DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
        DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
        DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
        DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
        DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
        DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
        DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
      })(DescriptorType || (DescriptorType = {}));
      let QueueType;
      (function (QueueType) {
        QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
        QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
        QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
      })(QueueType || (QueueType = {}));
      let QueryType;
      (function (QueryType) {
        QueryType[QueryType["OCCLUSION"] = 0] = "OCCLUSION";
        QueryType[QueryType["PIPELINE_STATISTICS"] = 1] = "PIPELINE_STATISTICS";
        QueryType[QueryType["TIMESTAMP"] = 2] = "TIMESTAMP";
      })(QueryType || (QueryType = {}));
      let CommandBufferType;
      (function (CommandBufferType) {
        CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
        CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
      })(CommandBufferType || (CommandBufferType = {}));
      let ClearFlagBit;
      (function (ClearFlagBit) {
        ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
        ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
        ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
        ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
        ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
        ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
      })(ClearFlagBit || (ClearFlagBit = {}));
      let BarrierType;
      (function (BarrierType) {
        BarrierType[BarrierType["FULL"] = 0] = "FULL";
        BarrierType[BarrierType["SPLIT_BEGIN"] = 1] = "SPLIT_BEGIN";
        BarrierType[BarrierType["SPLIT_END"] = 2] = "SPLIT_END";
      })(BarrierType || (BarrierType = {}));
      let PassType;
      (function (PassType) {
        PassType[PassType["RASTER"] = 0] = "RASTER";
        PassType[PassType["COMPUTE"] = 1] = "COMPUTE";
        PassType[PassType["COPY"] = 2] = "COPY";
        PassType[PassType["MOVE"] = 3] = "MOVE";
        PassType[PassType["RAYTRACE"] = 4] = "RAYTRACE";
        PassType[PassType["PRESENT"] = 5] = "PRESENT";
      })(PassType || (PassType = {}));
      class Size {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        }
      }
      class DeviceCaps {
        constructor(maxVertexAttributes = 0, maxVertexUniformVectors = 0, maxFragmentUniformVectors = 0, maxTextureUnits = 0, maxImageUnits = 0, maxVertexTextureUnits = 0, maxColorRenderTargets = 0, maxShaderStorageBufferBindings = 0, maxShaderStorageBlockSize = 0, maxUniformBufferBindings = 0, maxUniformBlockSize = 0, maxTextureSize = 0, maxCubeMapTextureSize = 0, maxArrayTextureLayers = 0, max3DTextureSize = 0, uboOffsetAlignment = 1, maxComputeSharedMemorySize = 0, maxComputeWorkGroupInvocations = 0, maxComputeWorkGroupSize = new Size(), maxComputeWorkGroupCount = new Size(), supportQuery = false, clipSpaceMinZ = -1, screenSpaceSignY = 1, clipSpaceSignY = 1) {
          this.maxVertexAttributes = maxVertexAttributes;
          this.maxVertexUniformVectors = maxVertexUniformVectors;
          this.maxFragmentUniformVectors = maxFragmentUniformVectors;
          this.maxTextureUnits = maxTextureUnits;
          this.maxImageUnits = maxImageUnits;
          this.maxVertexTextureUnits = maxVertexTextureUnits;
          this.maxColorRenderTargets = maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = maxUniformBufferBindings;
          this.maxUniformBlockSize = maxUniformBlockSize;
          this.maxTextureSize = maxTextureSize;
          this.maxCubeMapTextureSize = maxCubeMapTextureSize;
          this.maxArrayTextureLayers = maxArrayTextureLayers;
          this.max3DTextureSize = max3DTextureSize;
          this.uboOffsetAlignment = uboOffsetAlignment;
          this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
          this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
          this.supportQuery = supportQuery;
          this.clipSpaceMinZ = clipSpaceMinZ;
          this.screenSpaceSignY = screenSpaceSignY;
          this.clipSpaceSignY = clipSpaceSignY;
        }
        copy(info) {
          this.maxVertexAttributes = info.maxVertexAttributes;
          this.maxVertexUniformVectors = info.maxVertexUniformVectors;
          this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
          this.maxTextureUnits = info.maxTextureUnits;
          this.maxImageUnits = info.maxImageUnits;
          this.maxVertexTextureUnits = info.maxVertexTextureUnits;
          this.maxColorRenderTargets = info.maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = info.maxUniformBufferBindings;
          this.maxUniformBlockSize = info.maxUniformBlockSize;
          this.maxTextureSize = info.maxTextureSize;
          this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
          this.maxArrayTextureLayers = info.maxArrayTextureLayers;
          this.max3DTextureSize = info.max3DTextureSize;
          this.uboOffsetAlignment = info.uboOffsetAlignment;
          this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
          this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
          this.supportQuery = info.supportQuery;
          this.clipSpaceMinZ = info.clipSpaceMinZ;
          this.screenSpaceSignY = info.screenSpaceSignY;
          this.clipSpaceSignY = info.clipSpaceSignY;
          return this;
        }
      }
      class DeviceOptions {
        constructor(enableBarrierDeduce = true) {
          this.enableBarrierDeduce = enableBarrierDeduce;
        }
        copy(info) {
          this.enableBarrierDeduce = info.enableBarrierDeduce;
          return this;
        }
      }
      class Offset {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        }
      }
      class Rect {
        constructor(x = 0, y = 0, width = 0, height = 0) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.width = info.width;
          this.height = info.height;
          return this;
        }
      }
      class Extent {
        constructor(width = 0, height = 0, depth = 1) {
          this.width = width;
          this.height = height;
          this.depth = depth;
        }
        copy(info) {
          this.width = info.width;
          this.height = info.height;
          this.depth = info.depth;
          return this;
        }
      }
      class TextureSubresLayers {
        constructor(mipLevel = 0, baseArrayLayer = 0, layerCount = 1) {
          this.mipLevel = mipLevel;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.mipLevel = info.mipLevel;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class TextureSubresRange {
        constructor(baseMipLevel = 0, levelCount = 1, baseArrayLayer = 0, layerCount = 1) {
          this.baseMipLevel = baseMipLevel;
          this.levelCount = levelCount;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.baseMipLevel = info.baseMipLevel;
          this.levelCount = info.levelCount;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class TextureCopy {
        constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), extent = new Extent()) {
          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.extent = extent;
        }
        copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.extent.copy(info.extent);
          return this;
        }
      }
      class TextureBlit {
        constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), srcExtent = new Extent(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), dstExtent = new Extent()) {
          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.srcExtent = srcExtent;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.dstExtent = dstExtent;
        }
        copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.srcExtent.copy(info.srcExtent);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.dstExtent.copy(info.dstExtent);
          return this;
        }
      }
      class BufferTextureCopy {
        constructor(buffOffset = 0, buffStride = 0, buffTexHeight = 0, texOffset = new Offset(), texExtent = new Extent(), texSubres = new TextureSubresLayers()) {
          this.buffOffset = buffOffset;
          this.buffStride = buffStride;
          this.buffTexHeight = buffTexHeight;
          this.texOffset = texOffset;
          this.texExtent = texExtent;
          this.texSubres = texSubres;
        }
        copy(info) {
          this.buffOffset = info.buffOffset;
          this.buffStride = info.buffStride;
          this.buffTexHeight = info.buffTexHeight;
          this.texOffset.copy(info.texOffset);
          this.texExtent.copy(info.texExtent);
          this.texSubres.copy(info.texSubres);
          return this;
        }
      }
      class Viewport {
        constructor(left = 0, top = 0, width = 0, height = 0, minDepth = 0, maxDepth = 1) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
          this.minDepth = minDepth;
          this.maxDepth = maxDepth;
        }
        copy(info) {
          this.left = info.left;
          this.top = info.top;
          this.width = info.width;
          this.height = info.height;
          this.minDepth = info.minDepth;
          this.maxDepth = info.maxDepth;
          return this;
        }
        reset() {
          this.left = 0;
          this.top = 0;
          this.width = 0;
          this.height = 0;
          this.minDepth = 0;
          this.maxDepth = 1;
        }
      }
      class Color {
        constructor(x = 0, y = 0, z = 0, w = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          this.w = info.w;
          return this;
        }
        set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
        reset() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        }
      }
      class BindingMappingInfo {
        constructor(maxBlockCounts = [0], maxSamplerTextureCounts = [0], maxSamplerCounts = [0], maxTextureCounts = [0], maxBufferCounts = [0], maxImageCounts = [0], maxSubpassInputCounts = [0], setIndices = [0]) {
          this.maxBlockCounts = maxBlockCounts;
          this.maxSamplerTextureCounts = maxSamplerTextureCounts;
          this.maxSamplerCounts = maxSamplerCounts;
          this.maxTextureCounts = maxTextureCounts;
          this.maxBufferCounts = maxBufferCounts;
          this.maxImageCounts = maxImageCounts;
          this.maxSubpassInputCounts = maxSubpassInputCounts;
          this.setIndices = setIndices;
        }
        copy(info) {
          this.maxBlockCounts = info.maxBlockCounts.slice();
          this.maxSamplerTextureCounts = info.maxSamplerTextureCounts.slice();
          this.maxSamplerCounts = info.maxSamplerCounts.slice();
          this.maxTextureCounts = info.maxTextureCounts.slice();
          this.maxBufferCounts = info.maxBufferCounts.slice();
          this.maxImageCounts = info.maxImageCounts.slice();
          this.maxSubpassInputCounts = info.maxSubpassInputCounts.slice();
          this.setIndices = info.setIndices.slice();
          return this;
        }
      }
      class SwapchainInfo {
        constructor(windowId = 0, windowHandle = null, vsyncMode = VsyncMode.ON, width = 0, height = 0) {
          this.windowId = windowId;
          this.windowHandle = windowHandle;
          this.vsyncMode = vsyncMode;
          this.width = width;
          this.height = height;
        }
        copy(info) {
          this.windowId = info.windowId;
          this.windowHandle = info.windowHandle;
          this.vsyncMode = info.vsyncMode;
          this.width = info.width;
          this.height = info.height;
          return this;
        }
      }
      class DeviceInfo {
        constructor(bindingMappingInfo = new BindingMappingInfo()) {
          this.bindingMappingInfo = bindingMappingInfo;
        }
        copy(info) {
          this.bindingMappingInfo.copy(info.bindingMappingInfo);
          return this;
        }
      }
      class BufferInfo {
        constructor(usage = BufferUsageBit.NONE, memUsage = MemoryUsageBit.NONE, size = 0, stride = 1, flags = BufferFlagBit.NONE) {
          this.usage = usage;
          this.memUsage = memUsage;
          this.size = size;
          this.stride = stride;
          this.flags = flags;
        }
        copy(info) {
          this.usage = info.usage;
          this.memUsage = info.memUsage;
          this.size = info.size;
          this.stride = info.stride;
          this.flags = info.flags;
          return this;
        }
      }
      class BufferViewInfo {
        constructor(buffer = null, offset = 0, range = 0) {
          this.buffer = buffer;
          this.offset = offset;
          this.range = range;
        }
        copy(info) {
          this.buffer = info.buffer;
          this.offset = info.offset;
          this.range = info.range;
          return this;
        }
      }
      class DrawInfo {
        constructor(vertexCount = 0, firstVertex = 0, indexCount = 0, firstIndex = 0, vertexOffset = 0, instanceCount = 0, firstInstance = 0) {
          this.vertexCount = vertexCount;
          this.firstVertex = firstVertex;
          this.indexCount = indexCount;
          this.firstIndex = firstIndex;
          this.vertexOffset = vertexOffset;
          this.instanceCount = instanceCount;
          this.firstInstance = firstInstance;
        }
        copy(info) {
          this.vertexCount = info.vertexCount;
          this.firstVertex = info.firstVertex;
          this.indexCount = info.indexCount;
          this.firstIndex = info.firstIndex;
          this.vertexOffset = info.vertexOffset;
          this.instanceCount = info.instanceCount;
          this.firstInstance = info.firstInstance;
          return this;
        }
      }
      class DispatchInfo {
        constructor(groupCountX = 0, groupCountY = 0, groupCountZ = 0, indirectBuffer = null, indirectOffset = 0) {
          this.groupCountX = groupCountX;
          this.groupCountY = groupCountY;
          this.groupCountZ = groupCountZ;
          this.indirectBuffer = indirectBuffer;
          this.indirectOffset = indirectOffset;
        }
        copy(info) {
          this.groupCountX = info.groupCountX;
          this.groupCountY = info.groupCountY;
          this.groupCountZ = info.groupCountZ;
          this.indirectBuffer = info.indirectBuffer;
          this.indirectOffset = info.indirectOffset;
          return this;
        }
      }
      class IndirectBuffer {
        constructor(drawInfos = []) {
          this.drawInfos = drawInfos;
        }
        copy(info) {
          deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
          return this;
        }
      }
      class TextureInfo {
        constructor(type = TextureType.TEX2D, usage = TextureUsageBit.NONE, format = Format.UNKNOWN, width = 0, height = 0, flags = TextureFlagBit.NONE, layerCount = 1, levelCount = 1, samples = SampleCount.X1, depth = 1, externalRes = 0) {
          this.type = type;
          this.usage = usage;
          this.format = format;
          this.width = width;
          this.height = height;
          this.flags = flags;
          this.layerCount = layerCount;
          this.levelCount = levelCount;
          this.samples = samples;
          this.depth = depth;
          this.externalRes = externalRes;
        }
        copy(info) {
          this.type = info.type;
          this.usage = info.usage;
          this.format = info.format;
          this.width = info.width;
          this.height = info.height;
          this.flags = info.flags;
          this.layerCount = info.layerCount;
          this.levelCount = info.levelCount;
          this.samples = info.samples;
          this.depth = info.depth;
          this.externalRes = info.externalRes;
          return this;
        }
      }
      class TextureViewInfo {
        constructor(texture = null, type = TextureType.TEX2D, format = Format.UNKNOWN, baseLevel = 0, levelCount = 1, baseLayer = 0, layerCount = 1) {
          this.texture = texture;
          this.type = type;
          this.format = format;
          this.baseLevel = baseLevel;
          this.levelCount = levelCount;
          this.baseLayer = baseLayer;
          this.layerCount = layerCount;
        }
        copy(info) {
          this.texture = info.texture;
          this.type = info.type;
          this.format = info.format;
          this.baseLevel = info.baseLevel;
          this.levelCount = info.levelCount;
          this.baseLayer = info.baseLayer;
          this.layerCount = info.layerCount;
          return this;
        }
      }
      class SamplerInfo {
        constructor(minFilter = Filter$1.LINEAR, magFilter = Filter$1.LINEAR, mipFilter = Filter$1.NONE, addressU = Address.WRAP, addressV = Address.WRAP, addressW = Address.WRAP, maxAnisotropy = 0, cmpFunc = ComparisonFunc.ALWAYS) {
          this.minFilter = minFilter;
          this.magFilter = magFilter;
          this.mipFilter = mipFilter;
          this.addressU = addressU;
          this.addressV = addressV;
          this.addressW = addressW;
          this.maxAnisotropy = maxAnisotropy;
          this.cmpFunc = cmpFunc;
        }
        copy(info) {
          this.minFilter = info.minFilter;
          this.magFilter = info.magFilter;
          this.mipFilter = info.mipFilter;
          this.addressU = info.addressU;
          this.addressV = info.addressV;
          this.addressW = info.addressW;
          this.maxAnisotropy = info.maxAnisotropy;
          this.cmpFunc = info.cmpFunc;
          return this;
        }
      }
      class Uniform {
        constructor(name = '', type = Type$1.UNKNOWN, count = 0) {
          this.name = name;
          this.type = type;
          this.count = count;
        }
        copy(info) {
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          return this;
        }
      }
      class UniformBlock {
        constructor(set = 0, binding = 0, name = '', members = [], count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.members = members;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          deepCopy(this.members, info.members, Uniform);
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformSamplerTexture {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformSampler {
        constructor(set = 0, binding = 0, name = '', count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformTexture {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformStorageImage {
        constructor(set = 0, binding = 0, name = '', type = Type$1.UNKNOWN, count = 0, memoryAccess = MemoryAccessBit.READ_WRITE, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.memoryAccess = memoryAccess;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformStorageBuffer {
        constructor(set = 0, binding = 0, name = '', count = 0, memoryAccess = MemoryAccessBit.READ_WRITE, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.memoryAccess = memoryAccess;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          this.flattened = info.flattened;
          return this;
        }
      }
      class UniformInputAttachment {
        constructor(set = 0, binding = 0, name = '', count = 0, flattened = 0) {
          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.flattened = flattened;
        }
        copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.flattened = info.flattened;
          return this;
        }
      }
      class ShaderStage {
        constructor(stage = ShaderStageFlagBit.NONE, source = '') {
          this.stage = stage;
          this.source = source;
        }
        copy(info) {
          this.stage = info.stage;
          this.source = info.source;
          return this;
        }
      }
      class Attribute {
        constructor(name = '', format = Format.UNKNOWN, isNormalized = false, stream = 0, isInstanced = false, location = 0) {
          this.name = name;
          this.format = format;
          this.isNormalized = isNormalized;
          this.stream = stream;
          this.isInstanced = isInstanced;
          this.location = location;
        }
        copy(info) {
          this.name = info.name;
          this.format = info.format;
          this.isNormalized = info.isNormalized;
          this.stream = info.stream;
          this.isInstanced = info.isInstanced;
          this.location = info.location;
          return this;
        }
      }
      class ShaderInfo {
        constructor(name = '', stages = [], attributes = [], blocks = [], buffers = [], samplerTextures = [], samplers = [], textures = [], images = [], subpassInputs = []) {
          this.name = name;
          this.stages = stages;
          this.attributes = attributes;
          this.blocks = blocks;
          this.buffers = buffers;
          this.samplerTextures = samplerTextures;
          this.samplers = samplers;
          this.textures = textures;
          this.images = images;
          this.subpassInputs = subpassInputs;
        }
        copy(info) {
          this.name = info.name;
          deepCopy(this.stages, info.stages, ShaderStage);
          deepCopy(this.attributes, info.attributes, Attribute);
          deepCopy(this.blocks, info.blocks, UniformBlock);
          deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
          deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
          deepCopy(this.samplers, info.samplers, UniformSampler);
          deepCopy(this.textures, info.textures, UniformTexture);
          deepCopy(this.images, info.images, UniformStorageImage);
          deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
          return this;
        }
      }
      class InputAssemblerInfo {
        constructor(attributes = [], vertexBuffers = [], indexBuffer = null, indirectBuffer = null) {
          this.attributes = attributes;
          this.vertexBuffers = vertexBuffers;
          this.indexBuffer = indexBuffer;
          this.indirectBuffer = indirectBuffer;
        }
        copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          this.vertexBuffers = info.vertexBuffers.slice();
          this.indexBuffer = info.indexBuffer;
          this.indirectBuffer = info.indirectBuffer;
          return this;
        }
      }
      class ColorAttachment {
        constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, loadOp = LoadOp.CLEAR, storeOp = StoreOp.STORE, barrier = null) {
          this.format = format;
          this.sampleCount = sampleCount;
          this.loadOp = loadOp;
          this.storeOp = storeOp;
          this.barrier = barrier;
        }
        copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.loadOp = info.loadOp;
          this.storeOp = info.storeOp;
          this.barrier = info.barrier;
          return this;
        }
      }
      class DepthStencilAttachment {
        constructor(format = Format.UNKNOWN, sampleCount = SampleCount.X1, depthLoadOp = LoadOp.CLEAR, depthStoreOp = StoreOp.STORE, stencilLoadOp = LoadOp.CLEAR, stencilStoreOp = StoreOp.STORE, barrier = null) {
          this.format = format;
          this.sampleCount = sampleCount;
          this.depthLoadOp = depthLoadOp;
          this.depthStoreOp = depthStoreOp;
          this.stencilLoadOp = stencilLoadOp;
          this.stencilStoreOp = stencilStoreOp;
          this.barrier = barrier;
        }
        copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.depthLoadOp = info.depthLoadOp;
          this.depthStoreOp = info.depthStoreOp;
          this.stencilLoadOp = info.stencilLoadOp;
          this.stencilStoreOp = info.stencilStoreOp;
          this.barrier = info.barrier;
          return this;
        }
      }
      class SubpassInfo {
        constructor(inputs = [], colors = [], resolves = [], preserves = [], depthStencil = -1, depthStencilResolve = -1, depthResolveMode = ResolveMode.NONE, stencilResolveMode = ResolveMode.NONE) {
          this.inputs = inputs;
          this.colors = colors;
          this.resolves = resolves;
          this.preserves = preserves;
          this.depthStencil = depthStencil;
          this.depthStencilResolve = depthStencilResolve;
          this.depthResolveMode = depthResolveMode;
          this.stencilResolveMode = stencilResolveMode;
        }
        copy(info) {
          this.inputs = info.inputs.slice();
          this.colors = info.colors.slice();
          this.resolves = info.resolves.slice();
          this.preserves = info.preserves.slice();
          this.depthStencil = info.depthStencil;
          this.depthStencilResolve = info.depthStencilResolve;
          this.depthResolveMode = info.depthResolveMode;
          this.stencilResolveMode = info.stencilResolveMode;
          return this;
        }
      }
      class SubpassDependency {
        constructor(srcSubpass = 0, dstSubpass = 0, generalBarrier = null, prevAccesses = [AccessFlagBit.NONE], nextAccesses = [AccessFlagBit.NONE]) {
          this.srcSubpass = srcSubpass;
          this.dstSubpass = dstSubpass;
          this.generalBarrier = generalBarrier;
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
        }
        copy(info) {
          this.srcSubpass = info.srcSubpass;
          this.dstSubpass = info.dstSubpass;
          this.generalBarrier = info.generalBarrier;
          this.prevAccesses = info.prevAccesses.slice();
          this.nextAccesses = info.nextAccesses.slice();
          return this;
        }
      }
      class RenderPassInfo {
        constructor(colorAttachments = [], depthStencilAttachment = new DepthStencilAttachment(), depthStencilResolveAttachment = new DepthStencilAttachment(), subpasses = [], dependencies = []) {
          this.colorAttachments = colorAttachments;
          this.depthStencilAttachment = depthStencilAttachment;
          this.depthStencilResolveAttachment = depthStencilResolveAttachment;
          this.subpasses = subpasses;
          this.dependencies = dependencies;
        }
        copy(info) {
          deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
          this.depthStencilAttachment.copy(info.depthStencilAttachment);
          this.depthStencilResolveAttachment.copy(info.depthStencilResolveAttachment);
          deepCopy(this.subpasses, info.subpasses, SubpassInfo);
          deepCopy(this.dependencies, info.dependencies, SubpassDependency);
          return this;
        }
      }
      class GeneralBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          return this;
        }
      }
      class TextureBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL, baseMipLevel = 0, levelCount = 1, baseSlice = 0, sliceCount = 1, discardContents = false, srcQueue = null, dstQueue = null) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
          this.baseMipLevel = baseMipLevel;
          this.levelCount = levelCount;
          this.baseSlice = baseSlice;
          this.sliceCount = sliceCount;
          this.discardContents = discardContents;
          this.srcQueue = srcQueue;
          this.dstQueue = dstQueue;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          this.baseMipLevel = info.baseMipLevel;
          this.levelCount = info.levelCount;
          this.baseSlice = info.baseSlice;
          this.sliceCount = info.sliceCount;
          this.discardContents = info.discardContents;
          this.srcQueue = info.srcQueue;
          this.dstQueue = info.dstQueue;
          return this;
        }
      }
      class BufferBarrierInfo {
        constructor(prevAccesses = AccessFlagBit.NONE, nextAccesses = AccessFlagBit.NONE, type = BarrierType.FULL, offset = 0, size = 0, discardContents = false, srcQueue = null, dstQueue = null) {
          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.type = type;
          this.offset = offset;
          this.size = size;
          this.discardContents = discardContents;
          this.srcQueue = srcQueue;
          this.dstQueue = dstQueue;
        }
        copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.type = info.type;
          this.offset = info.offset;
          this.size = info.size;
          this.discardContents = info.discardContents;
          this.srcQueue = info.srcQueue;
          this.dstQueue = info.dstQueue;
          return this;
        }
      }
      class FramebufferInfo {
        constructor(renderPass = null, colorTextures = [], depthStencilTexture = null, depthStencilResolveTexture = null) {
          this.renderPass = renderPass;
          this.colorTextures = colorTextures;
          this.depthStencilTexture = depthStencilTexture;
          this.depthStencilResolveTexture = depthStencilResolveTexture;
        }
        copy(info) {
          this.renderPass = info.renderPass;
          this.colorTextures = info.colorTextures.slice();
          this.depthStencilTexture = info.depthStencilTexture;
          this.depthStencilResolveTexture = info.depthStencilResolveTexture;
          return this;
        }
      }
      class DescriptorSetLayoutBinding {
        constructor(binding = -1, descriptorType = DescriptorType.UNKNOWN, count = 0, stageFlags = ShaderStageFlagBit.NONE, immutableSamplers = []) {
          this.binding = binding;
          this.descriptorType = descriptorType;
          this.count = count;
          this.stageFlags = stageFlags;
          this.immutableSamplers = immutableSamplers;
        }
        copy(info) {
          this.binding = info.binding;
          this.descriptorType = info.descriptorType;
          this.count = info.count;
          this.stageFlags = info.stageFlags;
          this.immutableSamplers = info.immutableSamplers.slice();
          return this;
        }
      }
      class DescriptorSetLayoutInfo {
        constructor(bindings = []) {
          this.bindings = bindings;
        }
        copy(info) {
          deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
          return this;
        }
        reset() {
          this.bindings.length = 0;
        }
      }
      class DescriptorSetInfo {
        constructor(layout = null) {
          this.layout = layout;
        }
        copy(info) {
          this.layout = info.layout;
          return this;
        }
      }
      class PipelineLayoutInfo {
        constructor(setLayouts = []) {
          this.setLayouts = setLayouts;
        }
        copy(info) {
          this.setLayouts = info.setLayouts.slice();
          return this;
        }
      }
      class InputState {
        constructor(attributes = []) {
          this.attributes = attributes;
        }
        copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          return this;
        }
      }
      class CommandBufferInfo {
        constructor(queue = null, type = CommandBufferType.PRIMARY) {
          this.queue = queue;
          this.type = type;
        }
        copy(info) {
          this.queue = info.queue;
          this.type = info.type;
          return this;
        }
      }
      class QueueInfo {
        constructor(type = QueueType.GRAPHICS) {
          this.type = type;
        }
        copy(info) {
          this.type = info.type;
          return this;
        }
      }
      class QueryPoolInfo {
        constructor(type = QueryType.OCCLUSION, maxQueryObjects = 32767, forceWait = true) {
          this.type = type;
          this.maxQueryObjects = maxQueryObjects;
          this.forceWait = forceWait;
        }
        copy(info) {
          this.type = info.type;
          this.maxQueryObjects = info.maxQueryObjects;
          this.forceWait = info.forceWait;
          return this;
        }
      }
      class FormatInfo {
        constructor(name = '', size = 0, count = 0, type = FormatType.NONE, hasAlpha = false, hasDepth = false, hasStencil = false, isCompressed = false) {
          this.name = name;
          this.size = size;
          this.count = count;
          this.type = type;
          this.hasAlpha = hasAlpha;
          this.hasDepth = hasDepth;
          this.hasStencil = hasStencil;
          this.isCompressed = isCompressed;
        }
      }
      class MemoryStatus {
        constructor(bufferSize = 0, textureSize = 0) {
          this.bufferSize = bufferSize;
          this.textureSize = textureSize;
        }
        copy(info) {
          this.bufferSize = info.bufferSize;
          this.textureSize = info.textureSize;
          return this;
        }
      }
      class DynamicStencilStates {
        constructor(writeMask = 0, compareMask = 0, reference = 0) {
          this.writeMask = writeMask;
          this.compareMask = compareMask;
          this.reference = reference;
        }
        copy(info) {
          this.writeMask = info.writeMask;
          this.compareMask = info.compareMask;
          this.reference = info.reference;
          return this;
        }
      }
      class DynamicStates {
        constructor(viewport = new Viewport(), scissor = new Rect(), blendConstant = new Color(), lineWidth = 1, depthBiasConstant = 0, depthBiasClamp = 0, depthBiasSlope = 0, depthMinBounds = 0, depthMaxBounds = 0, stencilStatesFront = new DynamicStencilStates(), stencilStatesBack = new DynamicStencilStates()) {
          this.viewport = viewport;
          this.scissor = scissor;
          this.blendConstant = blendConstant;
          this.lineWidth = lineWidth;
          this.depthBiasConstant = depthBiasConstant;
          this.depthBiasClamp = depthBiasClamp;
          this.depthBiasSlope = depthBiasSlope;
          this.depthMinBounds = depthMinBounds;
          this.depthMaxBounds = depthMaxBounds;
          this.stencilStatesFront = stencilStatesFront;
          this.stencilStatesBack = stencilStatesBack;
        }
        copy(info) {
          this.viewport.copy(info.viewport);
          this.scissor.copy(info.scissor);
          this.blendConstant.copy(info.blendConstant);
          this.lineWidth = info.lineWidth;
          this.depthBiasConstant = info.depthBiasConstant;
          this.depthBiasClamp = info.depthBiasClamp;
          this.depthBiasSlope = info.depthBiasSlope;
          this.depthMinBounds = info.depthMinBounds;
          this.depthMaxBounds = info.depthMaxBounds;
          this.stencilStatesFront.copy(info.stencilStatesFront);
          this.stencilStatesBack.copy(info.stencilStatesBack);
          return this;
        }
      }
      class GFXObject extends GCObject {
        get objectType() {
          return this._objectType;
        }
        get objectID() {
          return this._objectID;
        }
        get typedID() {
          return this._typedID;
        }
        constructor(objectType) {
          super();
          this._objectType = ObjectType.UNKNOWN;
          this._objectID = 0;
          this._typedID = 0;
          this._objectType = objectType;
          this._objectID = GFXObject._idTable[ObjectType.UNKNOWN]++;
          this._typedID = GFXObject._idTable[objectType]++;
        }
      }
      GFXObject._idTable = Array(ObjectType.COUNT).fill(1 << 16);
      let AttributeName;
      (function (AttributeName) {
        AttributeName["ATTR_POSITION"] = "a_position";
        AttributeName["ATTR_NORMAL"] = "a_normal";
        AttributeName["ATTR_TANGENT"] = "a_tangent";
        AttributeName["ATTR_BITANGENT"] = "a_bitangent";
        AttributeName["ATTR_WEIGHTS"] = "a_weights";
        AttributeName["ATTR_JOINTS"] = "a_joints";
        AttributeName["ATTR_COLOR"] = "a_color";
        AttributeName["ATTR_COLOR1"] = "a_color1";
        AttributeName["ATTR_COLOR2"] = "a_color2";
        AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
        AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
        AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
        AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
        AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
        AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
        AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
        AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
        AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
        AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
        AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
      })(AttributeName || (AttributeName = {}));
      const FormatInfos = Object.freeze([new FormatInfo('UNKNOWN', 0, 0, FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('DEPTH', 4, 1, FormatType.FLOAT, false, true, false, false), new FormatInfo('DEPTH_STENCIL', 5, 2, FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true)]);
      const DESCRIPTOR_BUFFER_TYPE = DescriptorType.UNIFORM_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER | DescriptorType.STORAGE_BUFFER | DescriptorType.DYNAMIC_STORAGE_BUFFER;
      const DESCRIPTOR_SAMPLER_TYPE = DescriptorType.SAMPLER_TEXTURE | DescriptorType.SAMPLER | DescriptorType.TEXTURE | DescriptorType.STORAGE_IMAGE | DescriptorType.INPUT_ATTACHMENT;
      const DESCRIPTOR_DYNAMIC_TYPE = DescriptorType.DYNAMIC_STORAGE_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER;
      const DRAW_INFO_SIZE = 28;
      function IsPowerOf2(x) {
        return x > 0 && (x & x - 1) === 0;
      }
      function FormatSize(format, width, height, depth) {
        if (!FormatInfos[format].isCompressed) {
          return width * height * depth * FormatInfos[format].size;
        } else {
          switch (format) {
            case Format.BC1:
            case Format.BC1_ALPHA:
            case Format.BC1_SRGB:
            case Format.BC1_SRGB_ALPHA:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.BC2:
            case Format.BC2_SRGB:
            case Format.BC3:
            case Format.BC3_SRGB:
            case Format.BC4:
            case Format.BC4_SNORM:
            case Format.BC6H_SF16:
            case Format.BC6H_UF16:
            case Format.BC7:
            case Format.BC7_SRGB:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.BC5:
            case Format.BC5_SNORM:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;
            case Format.ETC_RGB8:
            case Format.ETC2_RGB8:
            case Format.ETC2_SRGB8:
            case Format.ETC2_RGB8_A1:
            case Format.EAC_R11:
            case Format.EAC_R11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.ETC2_RGBA8:
            case Format.ETC2_SRGB8_A1:
            case Format.EAC_RG11:
            case Format.EAC_RG11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.PVRTC_RGB2:
            case Format.PVRTC_RGBA2:
            case Format.PVRTC2_2BPP:
              return Math.ceil(width / 8) * Math.ceil(height / 4) * 8 * depth;
            case Format.PVRTC_RGB4:
            case Format.PVRTC_RGBA4:
            case Format.PVRTC2_4BPP:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;
            case Format.ASTC_RGBA_4X4:
            case Format.ASTC_SRGBA_4X4:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;
            case Format.ASTC_RGBA_5X4:
            case Format.ASTC_SRGBA_5X4:
              return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;
            case Format.ASTC_RGBA_5X5:
            case Format.ASTC_SRGBA_5X5:
              return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_6X5:
            case Format.ASTC_SRGBA_6X5:
              return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_6X6:
            case Format.ASTC_SRGBA_6X6:
              return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_8X5:
            case Format.ASTC_SRGBA_8X5:
              return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_8X6:
            case Format.ASTC_SRGBA_8X6:
              return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_8X8:
            case Format.ASTC_SRGBA_8X8:
              return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;
            case Format.ASTC_RGBA_10X5:
            case Format.ASTC_SRGBA_10X5:
              return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;
            case Format.ASTC_RGBA_10X6:
            case Format.ASTC_SRGBA_10X6:
              return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;
            case Format.ASTC_RGBA_10X8:
            case Format.ASTC_SRGBA_10X8:
              return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;
            case Format.ASTC_RGBA_10X10:
            case Format.ASTC_SRGBA_10X10:
              return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;
            case Format.ASTC_RGBA_12X10:
            case Format.ASTC_SRGBA_12X10:
              return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;
            case Format.ASTC_RGBA_12X12:
            case Format.ASTC_SRGBA_12X12:
              return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;
            default:
              {
                return 0;
              }
          }
        }
      }
      function FormatSurfaceSize(format, width, height, depth, mips) {
        let size = 0;
        for (let i = 0; i < mips; ++i) {
          size += FormatSize(format, width, height, depth);
          width = Math.max(width >> 1, 1);
          height = Math.max(height >> 1, 1);
        }
        return size;
      }
      const _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
      function GetTypeSize(type) {
        return _type2size[type] || 0;
      }
      function getTypedArrayConstructor(info) {
        if (info.isCompressed) {
          return Uint8Array;
        }
        const stride = info.size / info.count;
        switch (info.type) {
          case FormatType.UNORM:
          case FormatType.UINT:
            {
              switch (stride) {
                case 1:
                  return Uint8Array;
                case 2:
                  return Uint16Array;
                case 4:
                  return Uint32Array;
                default:
                  return Uint8Array;
              }
            }
          case FormatType.SNORM:
          case FormatType.INT:
            {
              switch (stride) {
                case 1:
                  return Int8Array;
                case 2:
                  return Int16Array;
                case 4:
                  return Int32Array;
                default:
                  return Int8Array;
              }
            }
          case FormatType.FLOAT:
            {
              switch (stride) {
                case 2:
                  return Uint16Array;
                case 4:
                  return Float32Array;
                default:
                  return Float32Array;
              }
            }
        }
        return Float32Array;
      }
      function formatAlignment(format) {
        switch (format) {
          case Format.BC1:
          case Format.BC1_ALPHA:
          case Format.BC1_SRGB:
          case Format.BC1_SRGB_ALPHA:
          case Format.BC2:
          case Format.BC2_SRGB:
          case Format.BC3:
          case Format.BC3_SRGB:
          case Format.BC4:
          case Format.BC4_SNORM:
          case Format.BC6H_SF16:
          case Format.BC6H_UF16:
          case Format.BC7:
          case Format.BC7_SRGB:
          case Format.BC5:
          case Format.BC5_SNORM:
          case Format.ETC_RGB8:
          case Format.ETC2_RGB8:
          case Format.ETC2_SRGB8:
          case Format.ETC2_RGB8_A1:
          case Format.EAC_R11:
          case Format.EAC_R11SN:
          case Format.ETC2_RGBA8:
          case Format.ETC2_SRGB8_A1:
          case Format.EAC_RG11:
          case Format.EAC_RG11SN:
            return {
              width: 4,
              height: 4
            };
          case Format.PVRTC_RGB2:
          case Format.PVRTC_RGBA2:
          case Format.PVRTC2_2BPP:
            return {
              width: 8,
              height: 4
            };
          case Format.PVRTC_RGB4:
          case Format.PVRTC_RGBA4:
          case Format.PVRTC2_4BPP:
            return {
              width: 4,
              height: 4
            };
          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_SRGBA_4X4:
            return {
              width: 4,
              height: 4
            };
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_SRGBA_5X4:
            return {
              width: 5,
              height: 4
            };
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_SRGBA_5X5:
            return {
              width: 5,
              height: 5
            };
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_SRGBA_6X5:
            return {
              width: 6,
              height: 5
            };
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_SRGBA_6X6:
            return {
              width: 6,
              height: 6
            };
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_SRGBA_8X5:
            return {
              width: 8,
              height: 5
            };
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_SRGBA_8X6:
            return {
              width: 8,
              height: 6
            };
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_SRGBA_8X8:
            return {
              width: 8,
              height: 8
            };
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_SRGBA_10X5:
            return {
              width: 10,
              height: 5
            };
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_SRGBA_10X6:
            return {
              width: 10,
              height: 6
            };
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_SRGBA_10X8:
            return {
              width: 10,
              height: 8
            };
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_SRGBA_10X10:
            return {
              width: 10,
              height: 10
            };
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_SRGBA_12X10:
            return {
              width: 12,
              height: 10
            };
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_12X12:
            return {
              width: 12,
              height: 12
            };
          default:
            return {
              width: 1,
              height: 1
            };
        }
      }
      function alignTo(size, alignment) {
        return Math.ceil(size / alignment) * alignment;
      }

      var defines = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type$1; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter$1; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        get BarrierType () { return BarrierType; },
        get PassType () { return PassType; },
        Size: Size,
        DeviceCaps: DeviceCaps,
        DeviceOptions: DeviceOptions,
        Offset: Offset,
        Rect: Rect,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        BufferBarrierInfo: BufferBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        formatAlignment: formatAlignment,
        alignTo: alignTo
      });

      function watchArrayElementsField(self, list, eleField, cachedFieldName, callback) {
        for (let i = 0, l = list.length; i < l; i++) {
          let ele = list[i];
          let originField = ele[eleField][cachedFieldName] || ele[eleField];
          ele[eleField] = new Proxy(originField, {
            get: (originTarget, key) => {
              if (key === cachedFieldName) {
                return originTarget;
              }
              return Reflect.get(originTarget, key);
            },
            set: (originTarget, prop, value) => {
              Reflect.set(originTarget, prop, value);
              callback(self, i, originTarget, prop, value);
              return true;
            }
          });
        }
      }
      class RasterizerState {
        constructor(isDiscard = false, polygonMode = PolygonMode.FILL, shadeModel = ShadeModel.GOURAND, cullMode = CullMode.BACK, isFrontFaceCCW = true, depthBiasEnabled = false, depthBias = 0, depthBiasClamp = 0.0, depthBiasSlop = 0.0, isDepthClip = true, isMultisample = false, lineWidth = 1.0) {
          this._nativeObj = void 0;
          this._isDiscard = false;
          this._polygonMode = PolygonMode.FILL;
          this._shadeModel = ShadeModel.GOURAND;
          this._cullMode = CullMode.BACK;
          this._isFrontFaceCCW = true;
          this._depthBiasEnabled = false;
          this._depthBias = 0;
          this._depthBiasClamp = 0.0;
          this._depthBiasSlop = 0.0;
          this._isDepthClip = true;
          this._isMultisample = false;
          this._lineWidth = 1.0;
          this._nativeObj = new gfx.RasterizerState();
          this.assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth);
        }
        get native() {
          return this._nativeObj;
        }
        get isDiscard() {
          return this._isDiscard;
        }
        set isDiscard(val) {
          this._isDiscard = val;
          this._nativeObj.isDiscard = val;
        }
        get polygonMode() {
          return this._polygonMode;
        }
        set polygonMode(val) {
          this._polygonMode = val;
          this._nativeObj.polygonMode = val;
        }
        get shadeModel() {
          return this._shadeModel;
        }
        set shadeModel(val) {
          this._shadeModel = val;
          this._nativeObj.shadeModel = val;
        }
        get cullMode() {
          return this._cullMode;
        }
        set cullMode(val) {
          this._cullMode = val;
          this._nativeObj.cullMode = val;
        }
        get isFrontFaceCCW() {
          return this._isFrontFaceCCW;
        }
        set isFrontFaceCCW(val) {
          this._isFrontFaceCCW = val;
          this._nativeObj.isFrontFaceCCW = val;
        }
        get depthBiasEnabled() {
          return this._depthBiasEnabled;
        }
        set depthBiasEnabled(val) {
          this._depthBiasEnabled = val;
          this._nativeObj.depthBiasEnabled = val;
        }
        get depthBias() {
          return this._depthBias;
        }
        set depthBias(val) {
          this._depthBias = val;
          this._nativeObj.depthBias = val;
        }
        get depthBiasClamp() {
          return this._depthBiasClamp;
        }
        set depthBiasClamp(val) {
          this._depthBiasClamp = val;
          this._nativeObj.depthBiasClamp = val;
        }
        get depthBiasSlop() {
          return this._depthBiasSlop;
        }
        set depthBiasSlop(val) {
          this._depthBiasSlop = val;
          this._nativeObj.depthBiasSlop = val;
        }
        get isDepthClip() {
          return this._isDepthClip;
        }
        set isDepthClip(val) {
          this._isDepthClip = val;
          this._nativeObj.isDepthClip = val;
        }
        get isMultisample() {
          return this._isMultisample;
        }
        set isMultisample(val) {
          this._isMultisample = val;
          this._nativeObj.isMultisample = val;
        }
        get lineWidth() {
          return this._lineWidth;
        }
        set lineWidth(val) {
          this._lineWidth = val;
          this._nativeObj.lineWidth = val;
        }
        reset() {
          this.assignProperties(false, PolygonMode.FILL, ShadeModel.GOURAND, CullMode.BACK, true, false, 0, 0.0, 0.0, true, false, 1.0);
        }
        assign(rs) {
          if (!rs) return;
          this.assignProperties(rs.isDiscard, rs.polygonMode, rs.shadeModel, rs.cullMode, rs.isFrontFaceCCW, rs.depthBiasEnabled, rs.depthBias, rs.depthBiasClamp, rs.depthBiasSlop, rs.isDepthClip, rs.isMultisample, rs.lineWidth);
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
          if (isDiscard !== undefined) this.isDiscard = isDiscard;
          if (polygonMode !== undefined) this.polygonMode = polygonMode;
          if (shadeModel !== undefined) this.shadeModel = shadeModel;
          if (cullMode !== undefined) this.cullMode = cullMode;
          if (isFrontFaceCCW !== undefined) this.isFrontFaceCCW = isFrontFaceCCW;
          if (depthBiasEnabled !== undefined) this.depthBiasEnabled = depthBiasEnabled;
          if (depthBias !== undefined) this.depthBias = depthBias;
          if (depthBiasClamp !== undefined) this.depthBiasClamp = depthBiasClamp;
          if (depthBiasSlop !== undefined) this.depthBiasSlop = depthBiasSlop;
          if (isDepthClip !== undefined) this.isDepthClip = isDepthClip;
          if (isMultisample !== undefined) this.isMultisample = isMultisample;
          if (lineWidth !== undefined) this.lineWidth = lineWidth;
        }
      }
      class DepthStencilState {
        constructor(depthTest = true, depthWrite = true, depthFunc = ComparisonFunc.LESS, stencilTestFront = false, stencilFuncFront = ComparisonFunc.ALWAYS, stencilReadMaskFront = 0xffff, stencilWriteMaskFront = 0xffff, stencilFailOpFront = StencilOp.KEEP, stencilZFailOpFront = StencilOp.KEEP, stencilPassOpFront = StencilOp.KEEP, stencilRefFront = 1, stencilTestBack = false, stencilFuncBack = ComparisonFunc.ALWAYS, stencilReadMaskBack = 0xffff, stencilWriteMaskBack = 0xffff, stencilFailOpBack = StencilOp.KEEP, stencilZFailOpBack = StencilOp.KEEP, stencilPassOpBack = StencilOp.KEEP, stencilRefBack = 1) {
          this._nativeObj = void 0;
          this._depthTest = true;
          this._depthWrite = true;
          this._depthFunc = ComparisonFunc.LESS;
          this._stencilTestFront = false;
          this._stencilFuncFront = ComparisonFunc.ALWAYS;
          this._stencilReadMaskFront = 0xffff;
          this._stencilWriteMaskFront = 0xffff;
          this._stencilFailOpFront = StencilOp.KEEP;
          this._stencilZFailOpFront = StencilOp.KEEP;
          this._stencilPassOpFront = StencilOp.KEEP;
          this._stencilRefFront = 1;
          this._stencilTestBack = false;
          this._stencilFuncBack = ComparisonFunc.ALWAYS;
          this._stencilReadMaskBack = 0xffff;
          this._stencilWriteMaskBack = 0xffff;
          this._stencilFailOpBack = StencilOp.KEEP;
          this._stencilZFailOpBack = StencilOp.KEEP;
          this._stencilPassOpBack = StencilOp.KEEP;
          this._stencilRefBack = 1;
          this._nativeObj = new gfx.DepthStencilState();
          this.assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack);
        }
        get native() {
          return this._nativeObj;
        }
        get depthTest() {
          return this._depthTest;
        }
        set depthTest(val) {
          this._depthTest = val;
          this._nativeObj.depthTest = val;
        }
        get depthWrite() {
          return this._depthWrite;
        }
        set depthWrite(val) {
          this._depthWrite = val;
          this._nativeObj.depthWrite = val;
        }
        get depthFunc() {
          return this._depthFunc;
        }
        set depthFunc(val) {
          this._depthFunc = val;
          this._nativeObj.depthFunc = val;
        }
        get stencilTestFront() {
          return this._stencilTestFront;
        }
        set stencilTestFront(val) {
          this._stencilTestFront = val;
          this._nativeObj.stencilTestFront = val;
        }
        get stencilFuncFront() {
          return this._stencilFuncFront;
        }
        set stencilFuncFront(val) {
          this._stencilFuncFront = val;
          this._nativeObj.stencilFuncFront = val;
        }
        get stencilReadMaskFront() {
          return this._stencilReadMaskFront;
        }
        set stencilReadMaskFront(val) {
          this._stencilReadMaskFront = val;
          this._nativeObj.stencilReadMaskFront = val;
        }
        get stencilWriteMaskFront() {
          return this._stencilWriteMaskFront;
        }
        set stencilWriteMaskFront(val) {
          this._stencilWriteMaskFront = val;
          this._nativeObj.stencilWriteMaskFront = val;
        }
        get stencilFailOpFront() {
          return this._stencilFailOpFront;
        }
        set stencilFailOpFront(val) {
          this._stencilFailOpFront = val;
          this._nativeObj.stencilFailOpFront = val;
        }
        get stencilZFailOpFront() {
          return this._stencilZFailOpFront;
        }
        set stencilZFailOpFront(val) {
          this._stencilZFailOpFront = val;
          this._nativeObj.stencilZFailOpFront = val;
        }
        get stencilPassOpFront() {
          return this._stencilPassOpFront;
        }
        set stencilPassOpFront(val) {
          this._stencilPassOpFront = val;
          this._nativeObj.stencilPassOpFront = val;
        }
        get stencilRefFront() {
          return this._stencilRefFront;
        }
        set stencilRefFront(val) {
          this._stencilRefFront = val;
          this._nativeObj.stencilRefFront = val;
        }
        get stencilTestBack() {
          return this._stencilTestBack;
        }
        set stencilTestBack(val) {
          this._stencilTestBack = val;
          this._nativeObj.stencilTestBack = val;
        }
        get stencilFuncBack() {
          return this._stencilFuncBack;
        }
        set stencilFuncBack(val) {
          this._stencilFuncBack = val;
          this._nativeObj.stencilFuncBack = val;
        }
        get stencilReadMaskBack() {
          return this._stencilReadMaskBack;
        }
        set stencilReadMaskBack(val) {
          this._stencilReadMaskBack = val;
          this._nativeObj.stencilReadMaskBack = val;
        }
        get stencilWriteMaskBack() {
          return this._stencilWriteMaskBack;
        }
        set stencilWriteMaskBack(val) {
          this._stencilWriteMaskBack = val;
          this._nativeObj.stencilWriteMaskBack = val;
        }
        get stencilFailOpBack() {
          return this._stencilFailOpBack;
        }
        set stencilFailOpBack(val) {
          this._stencilFailOpBack = val;
          this._nativeObj.stencilFailOpBack = val;
        }
        get stencilZFailOpBack() {
          return this._stencilZFailOpBack;
        }
        set stencilZFailOpBack(val) {
          this._stencilZFailOpBack = val;
          this._nativeObj.stencilZFailOpBack = val;
        }
        get stencilPassOpBack() {
          return this._stencilPassOpBack;
        }
        set stencilPassOpBack(val) {
          this._stencilPassOpBack = val;
          this._nativeObj.stencilPassOpBack = val;
        }
        get stencilRefBack() {
          return this._stencilRefBack;
        }
        set stencilRefBack(val) {
          this._stencilRefBack = val;
          this._nativeObj.stencilRefBack = val;
        }
        reset() {
          this.assignProperties(true, true, ComparisonFunc.LESS, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1);
        }
        assign(dss) {
          if (!dss) return;
          this.assignProperties(dss.depthTest, dss.depthWrite, dss.depthFunc, dss.stencilTestFront, dss.stencilFuncFront, dss.stencilReadMaskFront, dss.stencilWriteMaskFront, dss.stencilFailOpFront, dss.stencilZFailOpFront, dss.stencilPassOpFront, dss.stencilRefFront, dss.stencilTestBack, dss.stencilFuncBack, dss.stencilReadMaskBack, dss.stencilWriteMaskBack, dss.stencilFailOpBack, dss.stencilZFailOpBack, dss.stencilPassOpBack, dss.stencilRefBack);
        }
        destroy() {
          this._nativeObj = null;
        }
        assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
          if (depthTest !== undefined) this.depthTest = depthTest;
          if (depthWrite !== undefined) this.depthWrite = depthWrite;
          if (depthFunc !== undefined) this.depthFunc = depthFunc;
          if (stencilTestFront !== undefined) this.stencilTestFront = stencilTestFront;
          if (stencilFuncFront !== undefined) this.stencilFuncFront = stencilFuncFront;
          if (stencilReadMaskFront !== undefined) this.stencilReadMaskFront = stencilReadMaskFront;
          if (stencilWriteMaskFront !== undefined) this.stencilWriteMaskFront = stencilWriteMaskFront;
          if (stencilFailOpFront !== undefined) this.stencilFailOpFront = stencilFailOpFront;
          if (stencilZFailOpFront !== undefined) this.stencilZFailOpFront = stencilZFailOpFront;
          if (stencilPassOpFront !== undefined) this.stencilPassOpFront = stencilPassOpFront;
          if (stencilRefFront !== undefined) this.stencilRefFront = stencilRefFront;
          if (stencilTestBack !== undefined) this.stencilTestBack = stencilTestBack;
          if (stencilFuncBack !== undefined) this.stencilFuncBack = stencilFuncBack;
          if (stencilReadMaskBack !== undefined) this.stencilReadMaskBack = stencilReadMaskBack;
          if (stencilWriteMaskBack !== undefined) this.stencilWriteMaskBack = stencilWriteMaskBack;
          if (stencilFailOpBack !== undefined) this.stencilFailOpBack = stencilFailOpBack;
          if (stencilZFailOpBack !== undefined) this.stencilZFailOpBack = stencilZFailOpBack;
          if (stencilPassOpBack !== undefined) this.stencilPassOpBack = stencilPassOpBack;
          if (stencilRefBack !== undefined) this.stencilRefBack = stencilRefBack;
        }
      }
      class BlendTarget {
        get native() {
          return this._nativeObj;
        }
        constructor(blend = false, blendSrc = BlendFactor.ONE, blendDst = BlendFactor.ZERO, blendEq = BlendOp.ADD, blendSrcAlpha = BlendFactor.ONE, blendDstAlpha = BlendFactor.ZERO, blendAlphaEq = BlendOp.ADD, blendColorMask = ColorMask.ALL) {
          this._nativeObj = void 0;
          this._blend = false;
          this._blendSrc = BlendFactor.ONE;
          this._blendDst = BlendFactor.ZERO;
          this._blendEq = BlendOp.ADD;
          this._blendSrcAlpha = BlendFactor.ONE;
          this._blendDstAlpha = BlendFactor.ZERO;
          this._blendAlphaEq = BlendOp.ADD;
          this._blendColorMask = ColorMask.ALL;
          this._nativeObj = new gfx.BlendTarget();
          this.assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask);
        }
        get blend() {
          return this._blend;
        }
        set blend(val) {
          this._blend = val;
          this._nativeObj.blend = val;
        }
        get blendSrc() {
          return this._blendSrc;
        }
        set blendSrc(val) {
          this._blendSrc = val;
          this._nativeObj.blendSrc = val;
        }
        get blendDst() {
          return this._blendDst;
        }
        set blendDst(val) {
          this._blendDst = val;
          this._nativeObj.blendDst = val;
        }
        get blendEq() {
          return this._blendEq;
        }
        set blendEq(val) {
          this._blendEq = val;
          this._nativeObj.blendEq = val;
        }
        get blendSrcAlpha() {
          return this._blendSrcAlpha;
        }
        set blendSrcAlpha(val) {
          this._blendSrcAlpha = val;
          this._nativeObj.blendSrcAlpha = val;
        }
        get blendDstAlpha() {
          return this._blendDstAlpha;
        }
        set blendDstAlpha(val) {
          this._blendDstAlpha = val;
          this._nativeObj.blendDstAlpha = val;
        }
        get blendAlphaEq() {
          return this._blendAlphaEq;
        }
        set blendAlphaEq(val) {
          this._blendAlphaEq = val;
          this._nativeObj.blendAlphaEq = val;
        }
        get blendColorMask() {
          return this._blendColorMask;
        }
        set blendColorMask(val) {
          this._blendColorMask = val;
          this._nativeObj.blendColorMask = val;
        }
        reset() {
          this.assignProperties(false, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, ColorMask.ALL);
        }
        destroy() {
          this._nativeObj = null;
        }
        assign(target) {
          if (!target) return;
          this.assignProperties(target.blend, target.blendSrc, target.blendDst, target.blendEq, target.blendSrcAlpha, target.blendDstAlpha, target.blendAlphaEq, target.blendColorMask);
        }
        assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
          if (blend !== undefined) this.blend = blend;
          if (blendSrc !== undefined) this.blendSrc = blendSrc;
          if (blendDst !== undefined) this.blendDst = blendDst;
          if (blendEq !== undefined) this.blendEq = blendEq;
          if (blendSrcAlpha !== undefined) this.blendSrcAlpha = blendSrcAlpha;
          if (blendDstAlpha !== undefined) this.blendDstAlpha = blendDstAlpha;
          if (blendAlphaEq !== undefined) this.blendAlphaEq = blendAlphaEq;
          if (blendColorMask !== undefined) this.blendColorMask = blendColorMask;
        }
      }
      class BlendState {
        _setTargets(targets) {
          this.targets = targets;
          const CACHED_FIELD_NAME = `$__nativeObj`;
          this._syncTargetsToNativeObj(CACHED_FIELD_NAME);
          watchArrayElementsField(this, this.targets, "_nativeObj", CACHED_FIELD_NAME, (self, _idx, _originTarget, _prop, _value) => {
            self._syncTargetsToNativeObj(CACHED_FIELD_NAME);
          });
        }
        _syncTargetsToNativeObj(cachedFieldName) {
          const nativeTars = this.targets.map(target => {
            return target.native[cachedFieldName] || target.native;
          });
          this._nativeObj.targets = nativeTars;
        }
        get native() {
          return this._nativeObj;
        }
        constructor(isA2C = false, isIndepend = false, blendColor = new Color(), targets = [new BlendTarget()]) {
          this.targets = void 0;
          this._blendColor = void 0;
          this._nativeObj = void 0;
          this._isA2C = false;
          this._isIndepend = false;
          this._nativeObj = new gfx.BlendState();
          this._setTargets(targets);
          this.blendColor = blendColor;
          this.isA2C = isA2C;
          this.isIndepend = isIndepend;
        }
        get isA2C() {
          return this._isA2C;
        }
        set isA2C(val) {
          this._isA2C = val;
          this._nativeObj.isA2C = val;
        }
        get isIndepend() {
          return this._isIndepend;
        }
        set isIndepend(val) {
          this._isIndepend = val;
          this._nativeObj.isIndepend = val;
        }
        get blendColor() {
          return this._blendColor;
        }
        set blendColor(color) {
          this._blendColor = color;
          this._nativeObj.blendColor = color;
        }
        setTarget(index, target) {
          let tg = this.targets[index];
          if (!tg) {
            tg = this.targets[index] = new BlendTarget();
          }
          tg.assign(target);
          this._setTargets(this.targets);
        }
        reset() {
          this.isA2C = false;
          this.isIndepend = false;
          this.blendColor = new Color(0, 0, 0, 0);
          const targets = this.targets;
          for (let i = 1, len = targets.length; i < len; ++i) {
            targets[i].destroy();
          }
          targets.length = 1;
          targets[0].reset();
          this._setTargets(targets);
        }
        destroy() {
          for (let i = 0, len = this.targets.length; i < len; ++i) {
            this.targets[i].destroy();
          }
          this.targets = null;
          this._nativeObj = null;
        }
      }

      gfx.PipelineState;
      const PipelineStateInfo = gfx.PipelineStateInfo;

      let LegacyRenderMode;
      (function (LegacyRenderMode) {
        LegacyRenderMode[LegacyRenderMode["AUTO"] = 0] = "AUTO";
        LegacyRenderMode[LegacyRenderMode["CANVAS"] = 1] = "CANVAS";
        LegacyRenderMode[LegacyRenderMode["WEBGL"] = 2] = "WEBGL";
        LegacyRenderMode[LegacyRenderMode["HEADLESS"] = 3] = "HEADLESS";
      })(LegacyRenderMode || (LegacyRenderMode = {}));
      let RenderType;
      (function (RenderType) {
        RenderType[RenderType["UNKNOWN"] = -1] = "UNKNOWN";
        RenderType[RenderType["CANVAS"] = 0] = "CANVAS";
        RenderType[RenderType["WEBGL"] = 1] = "WEBGL";
        RenderType[RenderType["OPENGL"] = 2] = "OPENGL";
        RenderType[RenderType["HEADLESS"] = 3] = "HEADLESS";
      })(RenderType || (RenderType = {}));
      class DeviceManager {
        constructor() {
          this.initialized = false;
          this._gfxDevice = void 0;
          this._canvas = null;
          this._swapchain = void 0;
          this._renderType = RenderType.UNKNOWN;
        }
        get gfxDevice() {
          return this._gfxDevice;
        }
        get swapchain() {
          return this._swapchain;
        }
        init(canvas, bindingMappingInfo) {
          if (this.initialized) {
            return;
          }
          const renderMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode');
          this._canvas = canvas;
          this._renderType = this._determineRenderType(renderMode);
          if (this._renderType === RenderType.WEBGL) {
            const deviceInfo = new DeviceInfo(bindingMappingInfo);
            if (globalThis.gfx) {
              this._gfxDevice = gfx.DeviceManager.create(deviceInfo);
            } else {
              let useWebGL2 = !!globalThis.WebGL2RenderingContext;
              globalThis.navigator.userAgent.toLowerCase();
              if (sys.browserType === BrowserType.UC) {
                useWebGL2 = false;
              }
              const deviceCtors = [];
              if (useWebGL2 && legacyCC.WebGL2Device) {
                deviceCtors.push(legacyCC.WebGL2Device);
              }
              if (legacyCC.WebGLDevice) {
                deviceCtors.push(legacyCC.WebGLDevice);
              }
              if (legacyCC.EmptyDevice) {
                deviceCtors.push(legacyCC.EmptyDevice);
              }
              for (let i = 0; i < deviceCtors.length; i++) {
                this._gfxDevice = new deviceCtors[i]();
                if (this._gfxDevice.initialize(deviceInfo)) {
                  break;
                }
              }
              this._initSwapchain();
            }
          } else if (this._renderType === RenderType.HEADLESS && legacyCC.EmptyDevice) {
            this._gfxDevice = new legacyCC.EmptyDevice();
            this._gfxDevice.initialize(new DeviceInfo(bindingMappingInfo));
            this._initSwapchain();
          }
          if (!this._gfxDevice) {
            error('can not support canvas rendering in 3D');
            this._renderType = RenderType.UNKNOWN;
            return;
          }
          if (this._canvas) {
            this._canvas.oncontextmenu = () => false;
          }
        }
        _initSwapchain() {
          const swapchainInfo = new SwapchainInfo(1, this._canvas);
          const windowSize = screen.windowSize;
          swapchainInfo.width = windowSize.width;
          swapchainInfo.height = windowSize.height;
          this._swapchain = this._gfxDevice.createSwapchain(swapchainInfo);
        }
        _determineRenderType(renderMode) {
          if (typeof renderMode !== 'number' || renderMode > RenderType.HEADLESS || renderMode < LegacyRenderMode.AUTO) {
            renderMode = LegacyRenderMode.AUTO;
          }
          let renderType = RenderType.CANVAS;
          let supportRender = false;
          if (renderMode === LegacyRenderMode.CANVAS) {
            renderType = RenderType.CANVAS;
            supportRender = true;
          } else if (renderMode === LegacyRenderMode.AUTO || renderMode === LegacyRenderMode.WEBGL) {
            renderType = RenderType.WEBGL;
            supportRender = true;
          } else if (renderMode === LegacyRenderMode.HEADLESS) {
            renderType = RenderType.HEADLESS;
            supportRender = true;
          }
          if (!supportRender) {
            throw new Error(getError(3820, renderMode));
          }
          return renderType;
        }
      }
      const deviceManager = new DeviceManager();

      const polyfills = {
        GFXDevice: true,
        GFXBuffer: true,
        GFXTexture: true,
        GFXSampler: true,
        GFXShader: true,
        GFXInputAssembler: true,
        GFXRenderPass: true,
        GFXFramebuffer: true,
        GFXPipelineState: true,
        GFXCommandBuffer: true,
        GFXQueue: true,
        GFXObjectType: true,
        GFXObject: false,
        GFXAttributeName: true,
        GFXType: true,
        GFXFormat: true,
        GFXBufferUsageBit: true,
        GFXMemoryUsageBit: true,
        GFXBufferFlagBit: true,
        GFXBufferAccessBit: 'MemoryAccessBit',
        GFXPrimitiveMode: true,
        GFXPolygonMode: true,
        GFXShadeModel: true,
        GFXCullMode: true,
        GFXComparisonFunc: true,
        GFXStencilOp: true,
        GFXBlendOp: true,
        GFXBlendFactor: true,
        GFXColorMask: true,
        GFXFilter: true,
        GFXAddress: true,
        GFXTextureType: true,
        GFXTextureUsageBit: true,
        GFXSampleCount: true,
        GFXTextureFlagBit: true,
        GFXShaderStageFlagBit: true,
        GFXDescriptorType: true,
        GFXCommandBufferType: true,
        GFXLoadOp: true,
        GFXStoreOp: true,
        GFXPipelineBindPoint: true,
        GFXDynamicStateFlagBit: true,
        GFXStencilFace: true,
        GFXQueueType: true,
        GFXRect: true,
        GFXViewport: true,
        GFXColor: true,
        GFXClearFlag: true,
        GFXOffset: true,
        GFXExtent: true,
        GFXTextureSubres: 'TextureSubresLayers',
        GFXTextureCopy: true,
        GFXBufferTextureCopy: true,
        GFXFormatType: true,
        GFXFormatInfo: true,
        GFXMemoryStatus: true,
        GFXFormatInfos: true,
        GFXFormatSize: true,
        GFXFormatSurfaceSize: true,
        GFXGetTypeSize: true,
        getTypedArrayConstructor: false
      };
      for (const name in polyfills) {
        let newName = polyfills[name];
        if (newName === true) {
          newName = name.slice(3);
        } else if (newName === false) {
          newName = name;
        }
        replaceProperty(legacyCC, 'cc', [{
          name,
          newName,
          target: legacyCC.gfx,
          targetName: 'cc.gfx'
        }]);
      }
      removeProperty(legacyCC, 'cc', [{
        name: 'GFX_MAX_VERTEX_ATTRIBUTES'
      }, {
        name: 'GFX_MAX_TEXTURE_UNITS'
      }, {
        name: 'GFX_MAX_ATTACHMENTS'
      }, {
        name: 'GFX_MAX_BUFFER_BINDINGS'
      }, {
        name: 'GFXTextureLayout'
      }]);

      const DescriptorSet = gfx.DescriptorSet;
      const Buffer = gfx.Buffer;
      const CommandBuffer = gfx.CommandBuffer;
      const Device = gfx.Device;
      const Swapchain = gfx.Swapchain;
      const Framebuffer = gfx.Framebuffer;
      const InputAssembler = gfx.InputAssembler;
      const DescriptorSetLayout = gfx.DescriptorSetLayout;
      const PipelineLayout = gfx.PipelineLayout;
      const PipelineState = gfx.PipelineState;
      const Queue = gfx.Queue;
      const RenderPass = gfx.RenderPass;
      const Shader = gfx.Shader;
      const Texture = gfx.Texture;
      const Sampler = gfx.Sampler;
      const GeneralBarrier = gfx.GeneralBarrier;
      const TextureBarrier = gfx.TextureBarrier;
      const polyfillCC = Object.assign({}, defines);
      polyfillCC.GFXObject = gfx.GFXObject;
      polyfillCC.Device = gfx.Device;
      polyfillCC.Swapchain = gfx.Swapchain;
      polyfillCC.Buffer = gfx.Buffer;
      polyfillCC.Texture = gfx.Texture;
      polyfillCC.Sampler = gfx.Sampler;
      polyfillCC.Shader = gfx.Shader;
      polyfillCC.InputAssembler = gfx.InputAssembler;
      polyfillCC.RenderPass = gfx.RenderPass;
      polyfillCC.Framebuffer = gfx.Framebuffer;
      polyfillCC.DescriptorSet = gfx.DescriptorSet;
      polyfillCC.DescriptorSetLayout = gfx.DescriptorSetLayout;
      polyfillCC.PipelineLayout = gfx.PipelineLayout;
      polyfillCC.PipelineState = gfx.PipelineState;
      polyfillCC.CommandBuffer = gfx.CommandBuffer;
      polyfillCC.Queue = gfx.Queue;
      polyfillCC.GeneralBarrier = gfx.GeneralBarrier;
      polyfillCC.TextureBarrier = gfx.TextureBarrier;
      legacyCC.gfx = polyfillCC;
      polyfillCC.BlendTarget = BlendTarget;
      polyfillCC.BlendState = BlendState;
      polyfillCC.RasterizerState = RasterizerState;
      polyfillCC.DepthStencilState = DepthStencilState;
      polyfillCC.PipelineStateInfo = PipelineStateInfo;

      var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BlendState: BlendState,
        BlendTarget: BlendTarget,
        RasterizerState: RasterizerState,
        DepthStencilState: DepthStencilState,
        PipelineState: PipelineState,
        PipelineStateInfo: PipelineStateInfo,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type$1; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter$1; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        get BarrierType () { return BarrierType; },
        get PassType () { return PassType; },
        Size: Size,
        DeviceCaps: DeviceCaps,
        DeviceOptions: DeviceOptions,
        Offset: Offset,
        Rect: Rect,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        BufferBarrierInfo: BufferBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        formatAlignment: formatAlignment,
        alignTo: alignTo,
        get LegacyRenderMode () { return LegacyRenderMode; },
        get RenderType () { return RenderType; },
        DeviceManager: DeviceManager,
        deviceManager: deviceManager,
        DescriptorSet: DescriptorSet,
        Buffer: Buffer,
        CommandBuffer: CommandBuffer,
        Device: Device,
        Swapchain: Swapchain,
        Framebuffer: Framebuffer,
        InputAssembler: InputAssembler,
        DescriptorSetLayout: DescriptorSetLayout,
        PipelineLayout: PipelineLayout,
        Queue: Queue,
        RenderPass: RenderPass,
        Shader: Shader,
        Texture: Texture,
        Sampler: Sampler,
        GeneralBarrier: GeneralBarrier,
        TextureBarrier: TextureBarrier
      });
      exports('gfx', index$1);

      const m$4 = new Mat4();
      function fillMeshVertices3D(node, renderer, renderData, color) {
        const chunk = renderData.chunk;
        const dataList = renderData.data;
        const vData = chunk.vb;
        const vertexCount = renderData.vertexCount;
        node.getWorldMatrix(m$4);
        let vertexOffset = 0;
        for (let i = 0; i < vertexCount; i++) {
          const vert = dataList[i];
          const x = vert.x;
          const y = vert.y;
          let rhw = m$4.m03 * x + m$4.m07 * y + m$4.m15;
          rhw = rhw ? 1 / rhw : 1;
          vData[vertexOffset + 0] = (m$4.m00 * x + m$4.m04 * y + m$4.m12) * rhw;
          vData[vertexOffset + 1] = (m$4.m01 * x + m$4.m05 * y + m$4.m13) * rhw;
          vData[vertexOffset + 2] = (m$4.m02 * x + m$4.m06 * y + m$4.m14) * rhw;
          Color$1.toArray(vData, color, vertexOffset + 5);
          vertexOffset += 9;
        }
        chunk.bufferId;
        const vid = chunk.vertexOffset;
        const meshBuffer = chunk.meshBuffer;
        const ib = chunk.meshBuffer.iData;
        let indexOffset = meshBuffer.indexOffset;
        for (let i = 0, count = vertexCount / 4; i < count; i++) {
          const start = vid + i * 4;
          ib[indexOffset++] = start;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 2;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 3;
          ib[indexOffset++] = start + 2;
        }
        meshBuffer.indexOffset += renderData.indexCount;
        meshBuffer.setDirty();
      }
      function updateOpacity(renderData, opacity) {
        const vfmt = renderData.vertexFormat;
        const vb = renderData.chunk.vb;
        let attr;
        let format;
        let stride;
        let offset = 0;
        for (let i = 0; i < vfmt.length; ++i) {
          attr = vfmt[i];
          format = FormatInfos[attr.format];
          if (format.hasAlpha) {
            stride = renderData.floatStride;
            if (format.size / format.count === 1) {
              const alpha = ~~clamp$1(Math.round(opacity * 255), 0, 255);
              for (let color = offset; color < vb.length; color += stride) {
                vb[color] = (vb[color] & 0xffffff00 | alpha) >>> 0;
              }
            } else if (format.size / format.count === 4) {
              for (let alpha = offset + 3; alpha < vb.length; alpha += stride) {
                vb[alpha] = opacity;
              }
            }
          }
          offset += format.size >> 2;
        }
      }

      const minigame = {};

      class Cache {
        get map() {
          return this._map;
        }
        constructor(map) {
          this._map = null;
          this._count = 0;
          if (map) {
            this._map = map;
            this._count = Object.keys(map).length;
          } else {
            this._map = createMap(true);
            this._count = 0;
          }
        }
        add(key, val) {
          if (!(key in this._map)) {
            this._count++;
          }
          return this._map[key] = val;
        }
        get(key) {
          return this._map[key];
        }
        has(key) {
          return key in this._map;
        }
        remove(key) {
          const out = this._map[key];
          if (key in this._map) {
            delete this._map[key];
            this._count--;
          }
          return out;
        }
        clear() {
          if (this._count !== 0) {
            this._map = createMap(true);
            this._count = 0;
          }
        }
        forEach(func) {
          for (const key in this._map) {
            func(this._map[key], key);
          }
        }
        find(predicate) {
          for (const key in this._map) {
            if (predicate(this._map[key], key)) {
              return this._map[key];
            }
          }
          return null;
        }
        get count() {
          return this._count;
        }
        destroy() {
          this._map = null;
        }
      }

      class Pipeline {
        constructor(name, funcs) {
          this.id = Pipeline._pipelineId++;
          this.name = '';
          this.pipes = [];
          this.name = name;
          for (let i = 0, l = funcs.length; i < l; i++) {
            this.pipes.push(funcs[i]);
          }
        }
        insert(func, index) {
          if (index > this.pipes.length) {
            warnID(4921);
            return this;
          }
          this.pipes.splice(index, 0, func);
          return this;
        }
        append(func) {
          this.pipes.push(func);
          return this;
        }
        remove(index) {
          this.pipes.splice(index, 1);
          return this;
        }
        sync(task) {
          const pipes = this.pipes;
          if (pipes.length === 0) {
            return null;
          }
          task.isFinished = false;
          for (let i = 0, l = pipes.length; i < l;) {
            const pipe = pipes[i];
            const result = pipe(task);
            if (result) {
              task.isFinished = true;
              return result;
            }
            i++;
            if (i !== l) {
              task.input = task.output;
              task.output = null;
            }
          }
          task.isFinished = true;
          return task.output;
        }
        async(task) {
          const pipes = this.pipes;
          if (pipes.length === 0) {
            return;
          }
          task.isFinished = false;
          this._flow(0, task);
        }
        _flow(index, task) {
          const pipe = this.pipes[index];
          pipe(task, result => {
            if (result) {
              task.isFinished = true;
              task.dispatch('complete', result);
            } else {
              index++;
              if (index < this.pipes.length) {
                task.input = task.output;
                task.output = null;
                this._flow(index, task);
              } else {
                task.isFinished = true;
                task.dispatch('complete', result, task.output);
              }
            }
          });
        }
      }
      Pipeline._pipelineId = 0;

      const assets = new Cache();
      const files = new Cache();
      const parsed = new Cache();
      const bundles = new Cache();
      const pipeline = new Pipeline('normal load', []);
      const fetchPipeline = new Pipeline('fetch', []);
      const transformPipeline = new Pipeline('transform url', []);
      const references = null;
      const assetsOverrideMap = new Map();
      let RequestType;
      (function (RequestType) {
        RequestType["UUID"] = "uuid";
        RequestType["PATH"] = "path";
        RequestType["DIR"] = "dir";
        RequestType["URL"] = "url";
        RequestType["SCENE"] = "scene";
      })(RequestType || (RequestType = {}));
      const presets = {
        default: {
          priority: 0
        },
        preload: {
          maxConcurrency: 6,
          maxRequestsPerFrame: 2,
          priority: -1
        },
        scene: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 1
        },
        bundle: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 2
        },
        remote: {
          maxRetryCount: 4
        }
      };
      let BuiltinBundleName;
      (function (BuiltinBundleName) {
        BuiltinBundleName["INTERNAL"] = "internal";
        BuiltinBundleName["RESOURCES"] = "resources";
        BuiltinBundleName["MAIN"] = "main";
        BuiltinBundleName["START_SCENE"] = "start-scene";
      })(BuiltinBundleName || (BuiltinBundleName = {}));

      class Task {
        static create(options) {
          let out;
          if (Task._deadPool.length !== 0) {
            out = Task._deadPool.pop();
            out.set(options);
          } else {
            out = new Task(options);
          }
          return out;
        }
        get isFinish() {
          return this.isFinished;
        }
        set isFinish(val) {
          this.isFinished = val;
        }
        constructor(options) {
          this.id = Task._taskId++;
          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = null;
          this.output = null;
          this.input = null;
          this.progress = null;
          this.options = null;
          this.isFinished = true;
          this.set(options);
        }
        set(options = Object.create(null)) {
          this.onComplete = options.onComplete || null;
          this.onProgress = options.onProgress || null;
          this.onError = options.onError || null;
          this.source = this.input = options.input;
          this.output = null;
          this.progress = options.progress;
          this.options = options.options || Object.create(null);
        }
        dispatch(event, param1, param2, param3, param4) {
          switch (event) {
            case 'complete':
              if (this.onComplete) {
                this.onComplete(param1, param2);
              }
              break;
            case 'progress':
              if (this.onProgress) {
                this.onProgress(param1, param2, param3, param4);
              }
              break;
            case 'error':
              if (this.onError) {
                this.onError(param1, param2, param3, param4);
              }
              break;
            default:
              {
                const str = `on${event[0].toUpperCase()}${event.substr(1)}`;
                if (typeof this[str] === 'function') {
                  this[str](param1, param2, param3, param4);
                }
                break;
              }
          }
        }
        recycle() {
          if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
            return;
          }
          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = this.output = this.input = null;
          this.progress = null;
          this.options = null;
          Task._deadPool.push(this);
        }
      }
      Task.MAX_DEAD_NUM = 500;
      Task._taskId = 0;
      Task._deadPool = [];

      const separator = '@';
      const HexChars = '0123456789abcdef'.split('');
      const _t = ['', '', '', ''];
      const UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);
      const Indices = UuidTemplate.map((x, i) => x === '-' ? NaN : i).filter(Number.isFinite);
      function decodeUuid(base64) {
        const strs = base64.split(separator);
        const uuid = strs[0];
        if (uuid.length !== 22) {
          return base64;
        }
        UuidTemplate[0] = base64[0];
        UuidTemplate[1] = base64[1];
        for (let i = 2, j = 2; i < 22; i += 2) {
          const lhs = BASE64_VALUES[base64.charCodeAt(i)];
          const rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
          UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
          UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
          UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
        }
        return base64.replace(uuid, UuidTemplate.join(''));
      }

      const _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
      function getUuidFromURL(url) {
        const matches = _uuidRegex.exec(url);
        if (matches) {
          return matches[1];
        }
        return '';
      }
      function getUrlWithUuid(uuid, options) {
        options = options || Object.create(null);
        options.__isNative__ = options.isNative;
        if (options.nativeExt) {
          options.ext = options.nativeExt;
        }
        const bundle = bundles.find(b => !!b.getAssetInfo(uuid));
        if (bundle) {
          options.bundle = bundle.name;
        }
        return transform(uuid, options);
      }
      function isScene(asset) {
        return !!asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
      }
      function normalize(url) {
        if (url) {
          if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
            url = url.slice(2);
          } else if (url.charCodeAt(0) === 47) {
            url = url.slice(1);
          }
        }
        return url;
      }
      function transform(input, options) {
        const subTask = Task.create({
          input,
          options
        });
        const urls = [];
        try {
          const result = transformPipeline.sync(subTask);
          for (const requestItem of result) {
            const url = requestItem.url;
            requestItem.recycle();
            urls.push(url);
          }
        } catch (e) {
          for (const item of subTask.output) {
            item.recycle();
          }
          error(e.message, e.stack);
        }
        subTask.recycle();
        return urls.length > 1 ? urls : urls[0];
      }

      var helper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getUuidFromURL: getUuidFromURL,
        getUrlWithUuid: getUrlWithUuid,
        isScene: isScene,
        normalize: normalize,
        transform: transform,
        decodeUuid: decodeUuid
      });

      const defaultExec = (cb, decorator, attr) => {
        cb();
      };
      function patch_BloomStage(ctx, apply = defaultExec) {
        const {
          BloomStage,
          Material
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_bloomMaterial');
        apply(() => {
          serializable$6(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'serializable', '_bloomMaterial');
        apply(() => {
          type$6(Material)(BloomStage.prototype, '_bloomMaterial', () => {
            return null;
          });
        }, 'type', '_bloomMaterial');
        apply(() => {
          ccclass$6('BloomStage')(BloomStage);
        }, 'ccclass', null);
      }
      function patch_cc_AmbientInfo(ctx, apply = defaultExec) {
        const {
          AmbientInfo,
          legacyCC,
          CCFloat,
          Vec4,
          Ambient
        } = {
          ...ctx
        };
        const skyLightingColorDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'skyLightingColor');
        const skyIllumDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'skyIllum');
        const groundLightingColorDescriptor = Object.getOwnPropertyDescriptor(AmbientInfo.prototype, 'groundLightingColor');
        apply(() => {
          tooltip$2()(AmbientInfo.prototype, 'skyLightingColor', skyLightingColorDescriptor);
        }, 'tooltip', 'skyLightingColor');
        apply(() => {
          editable$3(AmbientInfo.prototype);
        }, 'editable', 'skyLightingColor');
        apply(() => {
          visible$5()(AmbientInfo.prototype, 'skyLightingColor', skyLightingColorDescriptor);
        }, 'visible', 'skyLightingColor');
        apply(() => {
          range$3()(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'range', 'skyIllum');
        apply(() => {
          tooltip$2()(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'tooltip', 'skyIllum');
        apply(() => {
          type$6(CCFloat)(AmbientInfo.prototype, 'skyIllum', skyIllumDescriptor);
        }, 'type', 'skyIllum');
        apply(() => {
          editable$3(AmbientInfo.prototype);
        }, 'editable', 'skyIllum');
        apply(() => {
          tooltip$2()(AmbientInfo.prototype, 'groundLightingColor', groundLightingColorDescriptor);
        }, 'tooltip', 'groundLightingColor');
        apply(() => {
          editable$3(AmbientInfo.prototype);
        }, 'editable', 'groundLightingColor');
        apply(() => {
          visible$5()(AmbientInfo.prototype, 'groundLightingColor', groundLightingColorDescriptor);
        }, 'visible', 'groundLightingColor');
        apply(() => {
          formerlySerializedAs$3('_skyColor')(AmbientInfo.prototype, '_skyColorHDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'formerlySerializedAs', '_skyColorHDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_skyColorHDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'serializable', '_skyColorHDR');
        apply(() => {
          formerlySerializedAs$3('_skyIllum')(AmbientInfo.prototype, '_skyIllumHDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'formerlySerializedAs', '_skyIllumHDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_skyIllumHDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'serializable', '_skyIllumHDR');
        apply(() => {
          formerlySerializedAs$3('_groundAlbedo')(AmbientInfo.prototype, '_groundAlbedoHDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'formerlySerializedAs', '_groundAlbedoHDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_groundAlbedoHDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'serializable', '_groundAlbedoHDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_skyColorLDR', () => {
            return new Vec4(0.2, 0.5, 0.8, 1.0);
          });
        }, 'serializable', '_skyColorLDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_skyIllumLDR', () => {
            return Ambient.SKY_ILLUM;
          });
        }, 'serializable', '_skyIllumLDR');
        apply(() => {
          serializable$6(AmbientInfo.prototype, '_groundAlbedoLDR', () => {
            return new Vec4(0.2, 0.2, 0.2, 1.0);
          });
        }, 'serializable', '_groundAlbedoLDR');
        apply(() => {
          ccclass$6('cc.AmbientInfo')(AmbientInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Asset(ctx, apply = defaultExec) {
        const {
          Asset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(Asset.prototype, '_nativeAsset');
        apply(() => {
          serializable$6(Asset.prototype, '_native', () => {
            return '';
          });
        }, 'serializable', '_native');
        apply(() => {
          property$2(Asset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'property', '_nativeAsset');
        apply(() => {
          ccclass$6('cc.Asset')(Asset);
        }, 'ccclass', null);
      }
      function patch_cc_BufferAsset(ctx, apply = defaultExec) {
        const {
          BufferAsset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(BufferAsset.prototype, '_nativeAsset');
        apply(() => {
          override(BufferAsset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'override', '_nativeAsset');
        apply(() => {
          ccclass$6('cc.BufferAsset')(BufferAsset);
        }, 'ccclass', null);
      }
      function patch_cc_EffectAsset(ctx, apply = defaultExec) {
        const {
          EffectAsset
        } = {
          ...ctx
        };
        apply(() => {
          editable$3(EffectAsset.prototype);
        }, 'editable', 'techniques');
        apply(() => {
          serializable$6(EffectAsset.prototype, 'techniques', () => {
            return [];
          });
        }, 'serializable', 'techniques');
        apply(() => {
          editable$3(EffectAsset.prototype);
        }, 'editable', 'shaders');
        apply(() => {
          serializable$6(EffectAsset.prototype, 'shaders', () => {
            return [];
          });
        }, 'serializable', 'shaders');
        apply(() => {
          editable$3(EffectAsset.prototype);
        }, 'editable', 'combinations');
        apply(() => {
          serializable$6(EffectAsset.prototype, 'combinations', () => {
            return [];
          });
        }, 'serializable', 'combinations');
        apply(() => {
          editorOnly(EffectAsset.prototype, 'hideInEditor', () => {
            return false;
          });
        }, 'editorOnly', 'hideInEditor');
        apply(() => {
          serializable$6(EffectAsset.prototype, 'hideInEditor', () => {
            return false;
          });
        }, 'serializable', 'hideInEditor');
        apply(() => {
          ccclass$6('cc.EffectAsset')(EffectAsset);
        }, 'ccclass', null);
      }
      function patch_cc_FogInfo(ctx, apply = defaultExec) {
        const {
          FogInfo,
          FogType,
          CCFloat,
          Color
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'enabled');
        const accurateDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'accurate');
        const fogColorDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogColor');
        const typeDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'type');
        const fogDensityDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogDensity');
        const fogStartDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogStart');
        const fogEndDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogEnd');
        const fogAttenDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogAtten');
        const fogTopDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogTop');
        const fogRangeDescriptor = Object.getOwnPropertyDescriptor(FogInfo.prototype, 'fogRange');
        apply(() => {
          displayOrder$3()(FogInfo.prototype, 'enabled', enabledDescriptor);
        }, 'displayOrder', 'enabled');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$3(FogInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          displayOrder$3()(FogInfo.prototype, 'accurate', accurateDescriptor);
        }, 'displayOrder', 'accurate');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'accurate', accurateDescriptor);
        }, 'tooltip', 'accurate');
        apply(() => {
          editable$3(FogInfo.prototype);
        }, 'editable', 'accurate');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogColor', fogColorDescriptor);
        }, 'tooltip', 'fogColor');
        apply(() => {
          editable$3(FogInfo.prototype);
        }, 'editable', 'fogColor');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'type', typeDescriptor);
        }, 'tooltip', 'type');
        apply(() => {
          displayOrder$3()(FogInfo.prototype, 'type', typeDescriptor);
        }, 'displayOrder', 'type');
        apply(() => {
          type$6(FogType)(FogInfo.prototype, 'type', typeDescriptor);
        }, 'type', 'type');
        apply(() => {
          editable$3(FogInfo.prototype);
        }, 'editable', 'type');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'tooltip', 'fogDensity');
        apply(() => {
          slide$3(FogInfo.prototype);
        }, 'slide', 'fogDensity');
        apply(() => {
          range$3()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'range', 'fogDensity');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'type', 'fogDensity');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogDensity', fogDensityDescriptor);
        }, 'visible', 'fogDensity');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'tooltip', 'fogStart');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'rangeStep', 'fogStart');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'type', 'fogStart');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogStart', fogStartDescriptor);
        }, 'visible', 'fogStart');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'tooltip', 'fogEnd');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'rangeStep', 'fogEnd');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'type', 'fogEnd');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogEnd', fogEndDescriptor);
        }, 'visible', 'fogEnd');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'tooltip', 'fogAtten');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'rangeStep', 'fogAtten');
        apply(() => {
          rangeMin()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'rangeMin', 'fogAtten');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'type', 'fogAtten');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogAtten', fogAttenDescriptor);
        }, 'visible', 'fogAtten');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'tooltip', 'fogTop');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'rangeStep', 'fogTop');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'type', 'fogTop');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogTop', fogTopDescriptor);
        }, 'visible', 'fogTop');
        apply(() => {
          tooltip$2()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'tooltip', 'fogRange');
        apply(() => {
          rangeStep()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'rangeStep', 'fogRange');
        apply(() => {
          type$6(CCFloat)(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'type', 'fogRange');
        apply(() => {
          visible$5()(FogInfo.prototype, 'fogRange', fogRangeDescriptor);
        }, 'visible', 'fogRange');
        apply(() => {
          serializable$6(FogInfo.prototype, '_type', () => {
            return FogType.LINEAR;
          });
        }, 'serializable', '_type');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogColor', () => {
            return new Color('#C8C8C8');
          });
        }, 'serializable', '_fogColor');
        apply(() => {
          serializable$6(FogInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogDensity', () => {
            return 0.3;
          });
        }, 'serializable', '_fogDensity');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogStart', () => {
            return 0.5;
          });
        }, 'serializable', '_fogStart');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogEnd', () => {
            return 300;
          });
        }, 'serializable', '_fogEnd');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogAtten', () => {
            return 5;
          });
        }, 'serializable', '_fogAtten');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogTop', () => {
            return 1.5;
          });
        }, 'serializable', '_fogTop');
        apply(() => {
          serializable$6(FogInfo.prototype, '_fogRange', () => {
            return 1.2;
          });
        }, 'serializable', '_fogRange');
        apply(() => {
          serializable$6(FogInfo.prototype, '_accurate', () => {
            return false;
          });
        }, 'serializable', '_accurate');
        apply(() => {
          ccclass$6('cc.FogInfo')(FogInfo);
        }, 'ccclass', null);
      }
      function patch_cc_ImageAsset(ctx, apply = defaultExec) {
        const {
          ImageAsset
        } = {
          ...ctx
        };
        const _nativeAssetDescriptor = Object.getOwnPropertyDescriptor(ImageAsset.prototype, '_nativeAsset');
        apply(() => {
          override(ImageAsset.prototype, '_nativeAsset', _nativeAssetDescriptor);
        }, 'override', '_nativeAsset');
        apply(() => {
          ccclass$6('cc.ImageAsset')(ImageAsset);
        }, 'ccclass', null);
      }
      function patch_cc_LightProbeInfo(ctx, apply = defaultExec) {
        const {
          LightProbeInfo,
          CCFloat,
          CCInteger
        } = {
          ...ctx
        };
        const giScaleDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'giScale');
        const giSamplesDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'giSamples');
        const bouncesDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'bounces');
        const reduceRingingDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'reduceRinging');
        const showWireframeDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'showWireframe');
        const showConvexDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'showConvex');
        const lightProbeSphereVolumeDescriptor = Object.getOwnPropertyDescriptor(LightProbeInfo.prototype, 'lightProbeSphereVolume');
        apply(() => {
          displayName$1()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'displayName', 'giScale');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'tooltip', 'giScale');
        apply(() => {
          type$6(CCFloat)(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'type', 'giScale');
        apply(() => {
          range$3()(LightProbeInfo.prototype, 'giScale', giScaleDescriptor);
        }, 'range', 'giScale');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'giScale');
        apply(() => {
          displayName$1()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'displayName', 'giSamples');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'tooltip', 'giSamples');
        apply(() => {
          type$6(CCInteger)(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'type', 'giSamples');
        apply(() => {
          range$3()(LightProbeInfo.prototype, 'giSamples', giSamplesDescriptor);
        }, 'range', 'giSamples');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'giSamples');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'tooltip', 'bounces');
        apply(() => {
          type$6(CCInteger)(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'type', 'bounces');
        apply(() => {
          range$3()(LightProbeInfo.prototype, 'bounces', bouncesDescriptor);
        }, 'range', 'bounces');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'bounces');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'tooltip', 'reduceRinging');
        apply(() => {
          type$6(CCFloat)(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'type', 'reduceRinging');
        apply(() => {
          slide$3(LightProbeInfo.prototype);
        }, 'slide', 'reduceRinging');
        apply(() => {
          range$3()(LightProbeInfo.prototype, 'reduceRinging', reduceRingingDescriptor);
        }, 'range', 'reduceRinging');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'reduceRinging');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'showWireframe', showWireframeDescriptor);
        }, 'tooltip', 'showWireframe');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'showWireframe');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'showConvex', showConvexDescriptor);
        }, 'tooltip', 'showConvex');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'showConvex');
        apply(() => {
          tooltip$2()(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'tooltip', 'lightProbeSphereVolume');
        apply(() => {
          type$6(CCFloat)(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'type', 'lightProbeSphereVolume');
        apply(() => {
          range$3()(LightProbeInfo.prototype, 'lightProbeSphereVolume', lightProbeSphereVolumeDescriptor);
        }, 'range', 'lightProbeSphereVolume');
        apply(() => {
          editable$3(LightProbeInfo.prototype);
        }, 'editable', 'lightProbeSphereVolume');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_giScale', () => {
            return 1.0;
          });
        }, 'serializable', '_giScale');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_giSamples', () => {
            return 1024;
          });
        }, 'serializable', '_giSamples');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_bounces', () => {
            return 2;
          });
        }, 'serializable', '_bounces');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_reduceRinging', () => {
            return 0.0;
          });
        }, 'serializable', '_reduceRinging');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_showProbe', () => {
            return true;
          });
        }, 'serializable', '_showProbe');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_showWireframe', () => {
            return true;
          });
        }, 'serializable', '_showWireframe');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_showConvex', () => {
            return false;
          });
        }, 'serializable', '_showConvex');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_data', () => {
            return null;
          });
        }, 'serializable', '_data');
        apply(() => {
          serializable$6(LightProbeInfo.prototype, '_lightProbeSphereVolume', () => {
            return 1.0;
          });
        }, 'serializable', '_lightProbeSphereVolume');
        apply(() => {
          ccclass$6('cc.LightProbeInfo')(LightProbeInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Material(ctx, apply = defaultExec) {
        const {
          Material,
          EffectAsset
        } = {
          ...ctx
        };
        apply(() => {
          type$6(EffectAsset)(Material.prototype, '_effectAsset', () => {
            return null;
          });
        }, 'type', '_effectAsset');
        apply(() => {
          serializable$6(Material.prototype, '_techIdx', () => {
            return 0;
          });
        }, 'serializable', '_techIdx');
        apply(() => {
          serializable$6(Material.prototype, '_defines', () => {
            return [];
          });
        }, 'serializable', '_defines');
        apply(() => {
          serializable$6(Material.prototype, '_states', () => {
            return [];
          });
        }, 'serializable', '_states');
        apply(() => {
          serializable$6(Material.prototype, '_props', () => {
            return [];
          });
        }, 'serializable', '_props');
        apply(() => {
          ccclass$6('cc.Material')(Material);
        }, 'ccclass', null);
      }
      function patch_cc_Mesh(ctx, apply = defaultExec) {
        const {
          Mesh
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(Mesh.prototype, '_struct', () => {
            return {
              vertexBundles: [],
              primitives: []
            };
          });
        }, 'serializable', '_struct');
        apply(() => {
          serializable$6(Mesh.prototype, '_hash', () => {
            return 0;
          });
        }, 'serializable', '_hash');
        apply(() => {
          serializable$6(Mesh.prototype, '_allowDataAccess', () => {
            return true;
          });
        }, 'serializable', '_allowDataAccess');
        apply(() => {
          ccclass$6('cc.Mesh')(Mesh);
        }, 'ccclass', null);
      }
      function patch_cc_Node(ctx, apply = defaultExec) {
        const {
          Node,
          Vec3,
          Quat,
          MobilityMode,
          Layers
        } = {
          ...ctx
        };
        const _persistNodeDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, '_persistNode');
        Object.getOwnPropertyDescriptor(Node.prototype, 'name');
        Object.getOwnPropertyDescriptor(Node.prototype, 'children');
        Object.getOwnPropertyDescriptor(Node.prototype, 'active');
        Object.getOwnPropertyDescriptor(Node.prototype, 'activeInHierarchy');
        Object.getOwnPropertyDescriptor(Node.prototype, 'parent');
        const eulerAnglesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'eulerAngles');
        Object.getOwnPropertyDescriptor(Node.prototype, 'angle');
        const mobilityDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'mobility');
        Object.getOwnPropertyDescriptor(Node.prototype, 'layer');
        apply(() => {
          property$2(Node.prototype, '_persistNode', _persistNodeDescriptor);
        }, 'property', '_persistNode');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'name');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'children');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'active');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'activeInHierarchy');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'parent');
        apply(() => {
          serializable$6(Node.prototype, '_parent', () => {
            return null;
          });
        }, 'serializable', '_parent');
        apply(() => {
          serializable$6(Node.prototype, '_children', () => {
            return [];
          });
        }, 'serializable', '_children');
        apply(() => {
          serializable$6(Node.prototype, '_active', () => {
            return true;
          });
        }, 'serializable', '_active');
        apply(() => {
          serializable$6(Node.prototype, '_components', () => {
            return [];
          });
        }, 'serializable', '_components');
        apply(() => {
          serializable$6(Node.prototype, '_prefab', () => {
            return null;
          });
        }, 'serializable', '_prefab');
        apply(() => {
          serializable$6(Node.prototype, '_lpos', () => {
            return new Vec3();
          });
        }, 'serializable', '_lpos');
        apply(() => {
          serializable$6(Node.prototype, '_lrot', () => {
            return new Quat();
          });
        }, 'serializable', '_lrot');
        apply(() => {
          serializable$6(Node.prototype, '_lscale', () => {
            return new Vec3(1, 1, 1);
          });
        }, 'serializable', '_lscale');
        apply(() => {
          serializable$6(Node.prototype, '_mobility', () => {
            return MobilityMode.Static;
          });
        }, 'serializable', '_mobility');
        apply(() => {
          serializable$6(Node.prototype, '_layer', () => {
            return Layers.Enum.DEFAULT;
          });
        }, 'serializable', '_layer');
        apply(() => {
          serializable$6(Node.prototype, '_euler', () => {
            return new Vec3();
          });
        }, 'serializable', '_euler');
        apply(() => {
          type$6(Vec3)(Node.prototype, 'eulerAngles', eulerAnglesDescriptor);
        }, 'type', 'eulerAngles');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'angle');
        apply(() => {
          type$6(MobilityMode)(Node.prototype, 'mobility', mobilityDescriptor);
        }, 'type', 'mobility');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'mobility');
        apply(() => {
          editable$3(Node.prototype);
        }, 'editable', 'layer');
        apply(() => {
          ccclass$6('cc.Node')(Node);
        }, 'ccclass', null);
      }
      function patch_cc_OctreeInfo(ctx, apply = defaultExec) {
        const {
          OctreeInfo,
          CCInteger,
          Vec3,
          DEFAULT_WORLD_MIN_POS,
          DEFAULT_WORLD_MAX_POS,
          DEFAULT_OCTREE_DEPTH
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'enabled');
        const minPosDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'minPos');
        const maxPosDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'maxPos');
        const depthDescriptor = Object.getOwnPropertyDescriptor(OctreeInfo.prototype, 'depth');
        apply(() => {
          tooltip$2()(OctreeInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$3(OctreeInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          displayName$1()(OctreeInfo.prototype, 'minPos', minPosDescriptor);
        }, 'displayName', 'minPos');
        apply(() => {
          tooltip$2()(OctreeInfo.prototype, 'minPos', minPosDescriptor);
        }, 'tooltip', 'minPos');
        apply(() => {
          editable$3(OctreeInfo.prototype);
        }, 'editable', 'minPos');
        apply(() => {
          displayName$1()(OctreeInfo.prototype, 'maxPos', maxPosDescriptor);
        }, 'displayName', 'maxPos');
        apply(() => {
          tooltip$2()(OctreeInfo.prototype, 'maxPos', maxPosDescriptor);
        }, 'tooltip', 'maxPos');
        apply(() => {
          editable$3(OctreeInfo.prototype);
        }, 'editable', 'maxPos');
        apply(() => {
          tooltip$2()(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'tooltip', 'depth');
        apply(() => {
          type$6(CCInteger)(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'type', 'depth');
        apply(() => {
          slide$3(OctreeInfo.prototype);
        }, 'slide', 'depth');
        apply(() => {
          range$3()(OctreeInfo.prototype, 'depth', depthDescriptor);
        }, 'range', 'depth');
        apply(() => {
          editable$3(OctreeInfo.prototype);
        }, 'editable', 'depth');
        apply(() => {
          serializable$6(OctreeInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$6(OctreeInfo.prototype, '_minPos', () => {
            return new Vec3(DEFAULT_WORLD_MIN_POS);
          });
        }, 'serializable', '_minPos');
        apply(() => {
          serializable$6(OctreeInfo.prototype, '_maxPos', () => {
            return new Vec3(DEFAULT_WORLD_MAX_POS);
          });
        }, 'serializable', '_maxPos');
        apply(() => {
          serializable$6(OctreeInfo.prototype, '_depth', () => {
            return DEFAULT_OCTREE_DEPTH;
          });
        }, 'serializable', '_depth');
        apply(() => {
          ccclass$6('cc.OctreeInfo')(OctreeInfo);
        }, 'ccclass', null);
      }
      function patch_cc_PostSettingsInfo(ctx, apply = defaultExec) {
        const {
          PostSettingsInfo,
          ToneMappingType
        } = {
          ...ctx
        };
        const toneMappingTypeDescriptor = Object.getOwnPropertyDescriptor(PostSettingsInfo.prototype, 'toneMappingType');
        apply(() => {
          tooltip$2()(PostSettingsInfo.prototype, 'toneMappingType', toneMappingTypeDescriptor);
        }, 'tooltip', 'toneMappingType');
        apply(() => {
          type$6(ToneMappingType)(PostSettingsInfo.prototype, 'toneMappingType', toneMappingTypeDescriptor);
        }, 'type', 'toneMappingType');
        apply(() => {
          editable$3(PostSettingsInfo.prototype);
        }, 'editable', 'toneMappingType');
        apply(() => {
          serializable$6(PostSettingsInfo.prototype, '_toneMappingType', () => {
            return ToneMappingType.DEFAULT;
          });
        }, 'serializable', '_toneMappingType');
        apply(() => {
          ccclass$6('cc.PostSettingsInfo')(PostSettingsInfo);
        }, 'ccclass', null);
      }
      function patch_cc_RenderPipeline(ctx, apply = defaultExec) {
        const {
          RenderPipeline,
          RenderFlow
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(RenderPipeline.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$3()(RenderPipeline.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          serializable$6(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'serializable', '_flows');
        apply(() => {
          type$6([RenderFlow])(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'type', '_flows');
        apply(() => {
          displayOrder$3()(RenderPipeline.prototype, '_flows', () => {
            return [];
          });
        }, 'displayOrder', '_flows');
        apply(() => {
          ccclass$6('cc.RenderPipeline')(RenderPipeline);
        }, 'ccclass', null);
      }
      function patch_cc_RenderTexture(ctx, apply = defaultExec) {
        const {
          RenderTexture
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('cc.RenderTexture')(RenderTexture);
        }, 'ccclass', null);
      }
      function patch_cc_Scene(ctx, apply = defaultExec) {
        const {
          Scene,
          SceneGlobals
        } = {
          ...ctx
        };
        Object.getOwnPropertyDescriptor(Scene.prototype, 'globals');
        apply(() => {
          editable$3(Scene.prototype);
        }, 'editable', 'globals');
        apply(() => {
          editable$3(Scene.prototype);
        }, 'editable', 'autoReleaseAssets');
        apply(() => {
          serializable$6(Scene.prototype, 'autoReleaseAssets', () => {
            return false;
          });
        }, 'serializable', 'autoReleaseAssets');
        apply(() => {
          serializable$6(Scene.prototype, '_globals', () => {
            return new SceneGlobals();
          });
        }, 'serializable', '_globals');
        apply(() => {
          ccclass$6('cc.Scene')(Scene);
        }, 'ccclass', null);
      }
      function patch_cc_SceneAsset(ctx, apply = defaultExec) {
        const {
          SceneAsset
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(SceneAsset.prototype, 'scene', () => {
            return null;
          });
        }, 'serializable', 'scene');
        apply(() => {
          editable$3(SceneAsset.prototype);
        }, 'editable', 'scene');
        apply(() => {
          ccclass$6('cc.SceneAsset')(SceneAsset);
        }, 'ccclass', null);
      }
      function patch_cc_SceneGlobals(ctx, apply = defaultExec) {
        const {
          SceneGlobals,
          AmbientInfo,
          ShadowsInfo,
          SkyboxInfo,
          FogInfo,
          OctreeInfo,
          SkinInfo,
          LightProbeInfo,
          PostSettingsInfo
        } = {
          ...ctx
        };
        const skyboxDescriptor = Object.getOwnPropertyDescriptor(SceneGlobals.prototype, 'skybox');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'ambient');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'ambient', () => {
            return new AmbientInfo();
          });
        }, 'serializable', 'ambient');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'shadows');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'shadows', () => {
            return new ShadowsInfo();
          });
        }, 'serializable', 'shadows');
        apply(() => {
          serializable$6(SceneGlobals.prototype, '_skybox', () => {
            return new SkyboxInfo();
          });
        }, 'serializable', '_skybox');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'fog', () => {
            return new FogInfo();
          });
        }, 'serializable', 'fog');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'fog');
        apply(() => {
          type$6(SkyboxInfo)(SceneGlobals.prototype, 'skybox', skyboxDescriptor);
        }, 'type', 'skybox');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'skybox');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'octree', () => {
            return new OctreeInfo();
          });
        }, 'serializable', 'octree');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'octree');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'skin', () => {
            return new SkinInfo();
          });
        }, 'serializable', 'skin');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'skin');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'lightProbeInfo', () => {
            return new LightProbeInfo();
          });
        }, 'serializable', 'lightProbeInfo');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'lightProbeInfo');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'postSettings', () => {
            return new PostSettingsInfo();
          });
        }, 'serializable', 'postSettings');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'postSettings');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'bakedWithStationaryMainLight', () => {
            return false;
          });
        }, 'serializable', 'bakedWithStationaryMainLight');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'bakedWithStationaryMainLight');
        apply(() => {
          serializable$6(SceneGlobals.prototype, 'bakedWithHighpLightmap', () => {
            return false;
          });
        }, 'serializable', 'bakedWithHighpLightmap');
        apply(() => {
          editable$3(SceneGlobals.prototype);
        }, 'editable', 'bakedWithHighpLightmap');
        apply(() => {
          ccclass$6('cc.SceneGlobals')(SceneGlobals);
        }, 'ccclass', null);
      }
      function patch_cc_ShadowsInfo(ctx, apply = defaultExec) {
        const {
          ShadowsInfo,
          ShadowType,
          CCFloat,
          CCInteger,
          ShadowSize,
          Vec3,
          Color,
          Vec2
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'enabled');
        const typeDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'type');
        const shadowColorDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'shadowColor');
        const planeDirectionDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'planeDirection');
        const planeHeightDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'planeHeight');
        const planeBiasDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'planeBias');
        const maxReceivedDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'maxReceived');
        const shadowMapSizeDescriptor = Object.getOwnPropertyDescriptor(ShadowsInfo.prototype, 'shadowMapSize');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$3(ShadowsInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          type$6(ShadowType)(ShadowsInfo.prototype, 'type', typeDescriptor);
        }, 'type', 'type');
        apply(() => {
          editable$3(ShadowsInfo.prototype);
        }, 'editable', 'type');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'type', typeDescriptor);
        }, 'tooltip', 'type');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'shadowColor', shadowColorDescriptor);
        }, 'visible', 'shadowColor');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'shadowColor', shadowColorDescriptor);
        }, 'tooltip', 'shadowColor');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'planeDirection', planeDirectionDescriptor);
        }, 'visible', 'planeDirection');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'planeDirection', planeDirectionDescriptor);
        }, 'tooltip', 'planeDirection');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'visible', 'planeHeight');
        apply(() => {
          type$6(CCFloat)(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'type', 'planeHeight');
        apply(() => {
          editable$3(ShadowsInfo.prototype);
        }, 'editable', 'planeHeight');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'planeHeight', planeHeightDescriptor);
        }, 'tooltip', 'planeHeight');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'planeBias', planeBiasDescriptor);
        }, 'visible', 'planeBias');
        apply(() => {
          type$6(CCFloat)(ShadowsInfo.prototype, 'planeBias', planeBiasDescriptor);
        }, 'type', 'planeBias');
        apply(() => {
          editable$3(ShadowsInfo.prototype);
        }, 'editable', 'planeBias');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'planeBias', planeBiasDescriptor);
        }, 'tooltip', 'planeBias');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'visible', 'maxReceived');
        apply(() => {
          type$6(CCInteger)(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'type', 'maxReceived');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'maxReceived', maxReceivedDescriptor);
        }, 'tooltip', 'maxReceived');
        apply(() => {
          visible$5()(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'visible', 'shadowMapSize');
        apply(() => {
          type$6(ShadowSize)(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'type', 'shadowMapSize');
        apply(() => {
          tooltip$2()(ShadowsInfo.prototype, 'shadowMapSize', shadowMapSizeDescriptor);
        }, 'tooltip', 'shadowMapSize');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_type', () => {
            return ShadowType.Planar;
          });
        }, 'serializable', '_type');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_normal', () => {
            return new Vec3(0, 1, 0);
          });
        }, 'serializable', '_normal');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_distance', () => {
            return 0;
          });
        }, 'serializable', '_distance');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_planeBias', () => {
            return 1.0;
          });
        }, 'serializable', '_planeBias');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_shadowColor', () => {
            return new Color(0, 0, 0, 76);
          });
        }, 'serializable', '_shadowColor');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_maxReceived', () => {
            return 4;
          });
        }, 'serializable', '_maxReceived');
        apply(() => {
          serializable$6(ShadowsInfo.prototype, '_size', () => {
            return new Vec2(1024, 1024);
          });
        }, 'serializable', '_size');
        apply(() => {
          ccclass$6('cc.ShadowsInfo')(ShadowsInfo);
        }, 'ccclass', null);
      }
      function patch_cc_SimpleTexture(ctx, apply = defaultExec) {
        const {
          SimpleTexture
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('cc.SimpleTexture')(SimpleTexture);
        }, 'ccclass', null);
      }
      function patch_cc_Skeleton(ctx, apply = defaultExec) {
        const {
          Skeleton,
          CCString,
          Mat4
        } = {
          ...ctx
        };
        apply(() => {
          type$6([CCString])(Skeleton.prototype, '_joints', () => {
            return [];
          });
        }, 'type', '_joints');
        apply(() => {
          type$6([Mat4])(Skeleton.prototype, '_bindposes', () => {
            return [];
          });
        }, 'type', '_bindposes');
        apply(() => {
          serializable$6(Skeleton.prototype, '_hash', () => {
            return 0;
          });
        }, 'serializable', '_hash');
        apply(() => {
          ccclass$6('cc.Skeleton')(Skeleton);
        }, 'ccclass', null);
      }
      function patch_cc_SkinInfo(ctx, apply = defaultExec) {
        const {
          SkinInfo,
          CCFloat
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'enabled');
        const blurRadiusDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'blurRadius');
        const sssIntensityDescriptor = Object.getOwnPropertyDescriptor(SkinInfo.prototype, 'sssIntensity');
        apply(() => {
          tooltip$2()(SkinInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          readOnly(SkinInfo.prototype);
        }, 'readOnly', 'enabled');
        apply(() => {
          editable$3(SkinInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          tooltip$2()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'tooltip', 'blurRadius');
        apply(() => {
          type$6(CCFloat)(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'type', 'blurRadius');
        apply(() => {
          slide$3(SkinInfo.prototype);
        }, 'slide', 'blurRadius');
        apply(() => {
          range$3()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'range', 'blurRadius');
        apply(() => {
          editable$3(SkinInfo.prototype);
        }, 'editable', 'blurRadius');
        apply(() => {
          visible$5()(SkinInfo.prototype, 'blurRadius', blurRadiusDescriptor);
        }, 'visible', 'blurRadius');
        apply(() => {
          tooltip$2()(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'tooltip', 'sssIntensity');
        apply(() => {
          type$6(CCFloat)(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'type', 'sssIntensity');
        apply(() => {
          slide$3(SkinInfo.prototype);
        }, 'slide', 'sssIntensity');
        apply(() => {
          range$3()(SkinInfo.prototype, 'sssIntensity', sssIntensityDescriptor);
        }, 'range', 'sssIntensity');
        apply(() => {
          editable$3(SkinInfo.prototype);
        }, 'editable', 'sssIntensity');
        apply(() => {
          serializable$6(SkinInfo.prototype, '_enabled', () => {
            return true;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$6(SkinInfo.prototype, '_blurRadius', () => {
            return 0.01;
          });
        }, 'serializable', '_blurRadius');
        apply(() => {
          serializable$6(SkinInfo.prototype, '_sssIntensity', () => {
            return 3.0;
          });
        }, 'serializable', '_sssIntensity');
        apply(() => {
          ccclass$6('cc.SkinInfo')(SkinInfo);
        }, 'ccclass', null);
      }
      function patch_cc_SkyboxInfo(ctx, apply = defaultExec) {
        const {
          SkyboxInfo,
          EnvironmentLightingType,
          TextureCube,
          CCFloat,
          Material
        } = {
          ...ctx
        };
        const enabledDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'enabled');
        const envLightingTypeDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'envLightingType');
        const useHDRDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'useHDR');
        const envmapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'envmap');
        const rotationAngleDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'rotationAngle');
        const diffuseMapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'diffuseMap');
        const reflectionMapDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'reflectionMap');
        const skyboxMaterialDescriptor = Object.getOwnPropertyDescriptor(SkyboxInfo.prototype, 'skyboxMaterial');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'enabled', enabledDescriptor);
        }, 'tooltip', 'enabled');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'enabled');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'envLightingType', envLightingTypeDescriptor);
        }, 'tooltip', 'envLightingType');
        apply(() => {
          type$6(EnvironmentLightingType)(SkyboxInfo.prototype, 'envLightingType', envLightingTypeDescriptor);
        }, 'type', 'envLightingType');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'envLightingType');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'useHDR', useHDRDescriptor);
        }, 'tooltip', 'useHDR');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'useHDR');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'envmap', envmapDescriptor);
        }, 'tooltip', 'envmap');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, 'envmap', envmapDescriptor);
        }, 'type', 'envmap');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'envmap');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'tooltip', 'rotationAngle');
        apply(() => {
          slide$3(SkyboxInfo.prototype);
        }, 'slide', 'rotationAngle');
        apply(() => {
          range$3()(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'range', 'rotationAngle');
        apply(() => {
          type$6(CCFloat)(SkyboxInfo.prototype, 'rotationAngle', rotationAngleDescriptor);
        }, 'type', 'rotationAngle');
        apply(() => {
          displayOrder$3()(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'displayOrder', 'diffuseMap');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'type', 'diffuseMap');
        apply(() => {
          readOnly(SkyboxInfo.prototype);
        }, 'readOnly', 'diffuseMap');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'diffuseMap');
        apply(() => {
          visible$5()(SkyboxInfo.prototype, 'diffuseMap', diffuseMapDescriptor);
        }, 'visible', 'diffuseMap');
        apply(() => {
          displayOrder$3()(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'displayOrder', 'reflectionMap');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'type', 'reflectionMap');
        apply(() => {
          readOnly(SkyboxInfo.prototype);
        }, 'readOnly', 'reflectionMap');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'reflectionMap');
        apply(() => {
          visible$5()(SkyboxInfo.prototype, 'reflectionMap', reflectionMapDescriptor);
        }, 'visible', 'reflectionMap');
        apply(() => {
          tooltip$2()(SkyboxInfo.prototype, 'skyboxMaterial', skyboxMaterialDescriptor);
        }, 'tooltip', 'skyboxMaterial');
        apply(() => {
          type$6(Material)(SkyboxInfo.prototype, 'skyboxMaterial', skyboxMaterialDescriptor);
        }, 'type', 'skyboxMaterial');
        apply(() => {
          editable$3(SkyboxInfo.prototype);
        }, 'editable', 'skyboxMaterial');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_envLightingType', () => {
            return EnvironmentLightingType.HEMISPHERE_DIFFUSE;
          });
        }, 'serializable', '_envLightingType');
        apply(() => {
          formerlySerializedAs$3('_envmap')(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'formerlySerializedAs', '_envmapHDR');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'type', '_envmapHDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_envmapHDR', () => {
            return null;
          });
        }, 'serializable', '_envmapHDR');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_envmapLDR', () => {
            return null;
          });
        }, 'type', '_envmapLDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_envmapLDR', () => {
            return null;
          });
        }, 'serializable', '_envmapLDR');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_diffuseMapHDR', () => {
            return null;
          });
        }, 'type', '_diffuseMapHDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_diffuseMapHDR', () => {
            return null;
          });
        }, 'serializable', '_diffuseMapHDR');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_diffuseMapLDR', () => {
            return null;
          });
        }, 'type', '_diffuseMapLDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_diffuseMapLDR', () => {
            return null;
          });
        }, 'serializable', '_diffuseMapLDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_enabled', () => {
            return false;
          });
        }, 'serializable', '_enabled');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_useHDR', () => {
            return true;
          });
        }, 'serializable', '_useHDR');
        apply(() => {
          type$6(Material)(SkyboxInfo.prototype, '_editableMaterial', () => {
            return null;
          });
        }, 'type', '_editableMaterial');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_editableMaterial', () => {
            return null;
          });
        }, 'serializable', '_editableMaterial');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_reflectionHDR', () => {
            return null;
          });
        }, 'type', '_reflectionHDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_reflectionHDR', () => {
            return null;
          });
        }, 'serializable', '_reflectionHDR');
        apply(() => {
          type$6(TextureCube)(SkyboxInfo.prototype, '_reflectionLDR', () => {
            return null;
          });
        }, 'type', '_reflectionLDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_reflectionLDR', () => {
            return null;
          });
        }, 'serializable', '_reflectionLDR');
        apply(() => {
          serializable$6(SkyboxInfo.prototype, '_rotationAngle', () => {
            return 0;
          });
        }, 'serializable', '_rotationAngle');
        apply(() => {
          ccclass$6('cc.SkyboxInfo')(SkyboxInfo);
        }, 'ccclass', null);
      }
      function patch_cc_Texture2D(ctx, apply = defaultExec) {
        const {
          Texture2D,
          ImageAsset
        } = {
          ...ctx
        };
        apply(() => {
          type$6([ImageAsset])(Texture2D.prototype, '_mipmaps', () => {
            return [];
          });
        }, 'type', '_mipmaps');
        apply(() => {
          ccclass$6('cc.Texture2D')(Texture2D);
        }, 'ccclass', null);
      }
      function patch_cc_TextureBase(ctx, apply = defaultExec) {
        const {
          TextureBase,
          PixelFormat,
          Filter,
          WrapMode
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(TextureBase.prototype, '_format', () => {
            return PixelFormat.RGBA8888;
          });
        }, 'serializable', '_format');
        apply(() => {
          serializable$6(TextureBase.prototype, '_minFilter', () => {
            return Filter.LINEAR;
          });
        }, 'serializable', '_minFilter');
        apply(() => {
          serializable$6(TextureBase.prototype, '_magFilter', () => {
            return Filter.LINEAR;
          });
        }, 'serializable', '_magFilter');
        apply(() => {
          serializable$6(TextureBase.prototype, '_mipFilter', () => {
            return Filter.NONE;
          });
        }, 'serializable', '_mipFilter');
        apply(() => {
          serializable$6(TextureBase.prototype, '_wrapS', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapS');
        apply(() => {
          serializable$6(TextureBase.prototype, '_wrapT', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapT');
        apply(() => {
          serializable$6(TextureBase.prototype, '_wrapR', () => {
            return WrapMode.REPEAT;
          });
        }, 'serializable', '_wrapR');
        apply(() => {
          serializable$6(TextureBase.prototype, '_anisotropy', () => {
            return 0;
          });
        }, 'serializable', '_anisotropy');
        apply(() => {
          ccclass$6('cc.TextureBase')(TextureBase);
        }, 'ccclass', null);
      }
      function patch_cc_TextureCube(ctx, apply = defaultExec) {
        const {
          TextureCube,
          MipmapMode
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(TextureCube.prototype, 'isRGBE', () => {
            return false;
          });
        }, 'serializable', 'isRGBE');
        apply(() => {
          serializable$6(TextureCube.prototype, '_mipmapAtlas', () => {
            return null;
          });
        }, 'serializable', '_mipmapAtlas');
        apply(() => {
          serializable$6(TextureCube.prototype, '_mipmapMode', () => {
            return MipmapMode.NONE;
          });
        }, 'serializable', '_mipmapMode');
        apply(() => {
          serializable$6(TextureCube.prototype, '_mipmaps', () => {
            return [];
          });
        }, 'serializable', '_mipmaps');
        apply(() => {
          ccclass$6('cc.TextureCube')(TextureCube);
        }, 'ccclass', null);
      }
      function patch_DeferredPipeline(ctx, apply = defaultExec) {
        const {
          DeferredPipeline,
          RenderTextureConfig
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'displayOrder', 'renderTextures');
        apply(() => {
          serializable$6(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'serializable', 'renderTextures');
        apply(() => {
          type$6([RenderTextureConfig])(DeferredPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'type', 'renderTextures');
        apply(() => {
          ccclass$6('DeferredPipeline')(DeferredPipeline);
        }, 'ccclass', null);
      }
      function patch_ForwardFlow(ctx, apply = defaultExec) {
        const {
          ForwardFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('ForwardFlow')(ForwardFlow);
        }, 'ccclass', null);
      }
      function patch_ForwardPipeline(ctx, apply = defaultExec) {
        const {
          ForwardPipeline,
          RenderTextureConfig
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'displayOrder', 'renderTextures');
        apply(() => {
          serializable$6(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'serializable', 'renderTextures');
        apply(() => {
          type$6([RenderTextureConfig])(ForwardPipeline.prototype, 'renderTextures', () => {
            return [];
          });
        }, 'type', 'renderTextures');
        apply(() => {
          ccclass$6('ForwardPipeline')(ForwardPipeline);
        }, 'ccclass', null);
      }
      function patch_ForwardStage(ctx, apply = defaultExec) {
        const {
          ForwardStage,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$6(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$6([RenderQueueDesc])(ForwardStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$6('ForwardStage')(ForwardStage);
        }, 'ccclass', null);
      }
      function patch_GbufferStage(ctx, apply = defaultExec) {
        const {
          GbufferStage,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$6(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$6([RenderQueueDesc])(GbufferStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$6('GbufferStage')(GbufferStage);
        }, 'ccclass', null);
      }
      function patch_LightingStage(ctx, apply = defaultExec) {
        const {
          LightingStage,
          Material,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_deferredMaterial');
        apply(() => {
          serializable$6(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'serializable', '_deferredMaterial');
        apply(() => {
          type$6(Material)(LightingStage.prototype, '_deferredMaterial', () => {
            return null;
          });
        }, 'type', '_deferredMaterial');
        apply(() => {
          displayOrder$3()(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$6(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$6([RenderQueueDesc])(LightingStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$6('LightingStage')(LightingStage);
        }, 'ccclass', null);
      }
      function patch_MainFlow(ctx, apply = defaultExec) {
        const {
          MainFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('MainFlow')(MainFlow);
        }, 'ccclass', null);
      }
      function patch_PostProcessStage(ctx, apply = defaultExec) {
        const {
          PostProcessStage,
          Material,
          RenderQueueDesc
        } = {
          ...ctx
        };
        apply(() => {
          displayOrder$3()(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'displayOrder', '_postProcessMaterial');
        apply(() => {
          serializable$6(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'serializable', '_postProcessMaterial');
        apply(() => {
          type$6(Material)(PostProcessStage.prototype, '_postProcessMaterial', () => {
            return null;
          });
        }, 'type', '_postProcessMaterial');
        apply(() => {
          displayOrder$3()(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'displayOrder', 'renderQueues');
        apply(() => {
          serializable$6(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'serializable', 'renderQueues');
        apply(() => {
          type$6([RenderQueueDesc])(PostProcessStage.prototype, 'renderQueues', () => {
            return [];
          });
        }, 'type', 'renderQueues');
        apply(() => {
          ccclass$6('PostProcessStage')(PostProcessStage);
        }, 'ccclass', null);
      }
      function patch_ReflectionProbeFlow(ctx, apply = defaultExec) {
        const {
          ReflectionProbeFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('ReflectionProbeFlow')(ReflectionProbeFlow);
        }, 'ccclass', null);
      }
      function patch_ReflectionProbeStage(ctx, apply = defaultExec) {
        const {
          ReflectionProbeStage
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('ReflectionProbeStage')(ReflectionProbeStage);
        }, 'ccclass', null);
      }
      function patch_RenderFlow(ctx, apply = defaultExec) {
        const {
          RenderFlow,
          RenderStage
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(RenderFlow.prototype, '_name', () => {
            return '';
          });
        }, 'serializable', '_name');
        apply(() => {
          displayOrder$3()(RenderFlow.prototype, '_name', () => {
            return '';
          });
        }, 'displayOrder', '_name');
        apply(() => {
          serializable$6(RenderFlow.prototype, '_priority', () => {
            return 0;
          });
        }, 'serializable', '_priority');
        apply(() => {
          displayOrder$3()(RenderFlow.prototype, '_priority', () => {
            return 0;
          });
        }, 'displayOrder', '_priority');
        apply(() => {
          serializable$6(RenderFlow.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$3()(RenderFlow.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          serializable$6(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'serializable', '_stages');
        apply(() => {
          type$6([RenderStage])(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'type', '_stages');
        apply(() => {
          displayOrder$3()(RenderFlow.prototype, '_stages', () => {
            return [];
          });
        }, 'displayOrder', '_stages');
        apply(() => {
          ccclass$6('RenderFlow')(RenderFlow);
        }, 'ccclass', null);
      }
      function patch_RenderQueueDesc(ctx, apply = defaultExec) {
        const {
          RenderQueueDesc,
          RenderQueueSortMode,
          CCString
        } = {
          ...ctx
        };
        apply(() => {
          editable$3(RenderQueueDesc.prototype);
        }, 'editable', 'isTransparent');
        apply(() => {
          serializable$6(RenderQueueDesc.prototype, 'isTransparent', () => {
            return false;
          });
        }, 'serializable', 'isTransparent');
        apply(() => {
          type$6(RenderQueueSortMode)(RenderQueueDesc.prototype, 'sortMode', () => {
            return RenderQueueSortMode.FRONT_TO_BACK;
          });
        }, 'type', 'sortMode');
        apply(() => {
          type$6([CCString])(RenderQueueDesc.prototype, 'stages', () => {
            return [];
          });
        }, 'type', 'stages');
        apply(() => {
          ccclass$6('RenderQueueDesc')(RenderQueueDesc);
        }, 'ccclass', null);
      }
      function patch_RenderStage(ctx, apply = defaultExec) {
        const {
          RenderStage
        } = {
          ...ctx
        };
        apply(() => {
          serializable$6(RenderStage.prototype, '_name', () => {
            return '';
          });
        }, 'serializable', '_name');
        apply(() => {
          displayOrder$3()(RenderStage.prototype, '_name', () => {
            return '';
          });
        }, 'displayOrder', '_name');
        apply(() => {
          serializable$6(RenderStage.prototype, '_priority', () => {
            return 0;
          });
        }, 'serializable', '_priority');
        apply(() => {
          displayOrder$3()(RenderStage.prototype, '_priority', () => {
            return 0;
          });
        }, 'displayOrder', '_priority');
        apply(() => {
          serializable$6(RenderStage.prototype, '_tag', () => {
            return 0;
          });
        }, 'serializable', '_tag');
        apply(() => {
          displayOrder$3()(RenderStage.prototype, '_tag', () => {
            return 0;
          });
        }, 'displayOrder', '_tag');
        apply(() => {
          ccclass$6('RenderStage')(RenderStage);
        }, 'ccclass', null);
      }
      function patch_ShadowFlow(ctx, apply = defaultExec) {
        const {
          ShadowFlow
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('ShadowFlow')(ShadowFlow);
        }, 'ccclass', null);
      }
      function patch_ShadowStage(ctx, apply = defaultExec) {
        const {
          ShadowStage
        } = {
          ...ctx
        };
        apply(() => {
          ccclass$6('ShadowStage')(ShadowStage);
        }, 'ccclass', null);
      }

      applyMixins(jsb.Asset, [CallbacksInvoker, ExtraEventMethods]);
      const assetProto = jsb.Asset.prototype;
      assetProto._ctor = function () {
        this.loaded = true;
        this._ref = 0;
        this.__nativeRefs = {};
        this.__jsb_ref_id = undefined;
        this._iN$t = null;
        this.__editorExtras__ = {
          editorOnly: true
        };
        this._callbackTable = createMap(true);
        this._file = null;
      };
      Object.defineProperty(assetProto, '_nativeAsset', {
        get() {
          return this._file;
        },
        set(obj) {
          this._file = obj;
        }
      });
      Object.defineProperty(assetProto, 'nativeUrl', {
        get() {
          if (!this._nativeUrl) {
            if (!this._native) return '';
            const name = this._native;
            if (name.charCodeAt(0) === 47) {
              return name.slice(1);
            }
            if (name.charCodeAt(0) === 46) {
              this._nativeUrl = getUrlWithUuid(this._uuid, {
                nativeExt: name,
                isNative: true
              });
            } else {
              this._nativeUrl = getUrlWithUuid(this._uuid, {
                __nativeName__: name,
                nativeExt: extname(name),
                isNative: true
              });
            }
          }
          return this._nativeUrl;
        }
      });
      Object.defineProperty(assetProto, 'refCount', {
        configurable: true,
        enumerable: true,
        get() {
          return this._ref;
        }
      });
      assetProto.addRef = function () {
        this._ref++;
        this.addAssetRef();
        return this;
      };
      assetProto.decRef = function (autoRelease = true) {
        this.decAssetRef();
        if (this._ref > 0) {
          this._ref--;
        }
        if (autoRelease) {
          legacyCC.assetManager._releaseManager.tryRelease(this);
        }
        return this;
      };
      assetProto.toString = function () {
        return this.nativeUrl;
      };
      assetProto.createNode = null;
      const Asset = exports('Asset', jsb.Asset);
      legacyCC.Asset = jsb.Asset;
      patch_cc_Asset({
        Asset
      });

      const CUSTOM_PIXEL_FORMAT = 1024;
      let PixelFormat;
      (function (PixelFormat) {
        PixelFormat[PixelFormat["RGB565"] = Format.R5G6B5] = "RGB565";
        PixelFormat[PixelFormat["RGB5A1"] = Format.RGB5A1] = "RGB5A1";
        PixelFormat[PixelFormat["RGBA4444"] = Format.RGBA4] = "RGBA4444";
        PixelFormat[PixelFormat["RGB888"] = Format.RGB8] = "RGB888";
        PixelFormat[PixelFormat["RGB32F"] = Format.RGB32F] = "RGB32F";
        PixelFormat[PixelFormat["RGBA8888"] = Format.RGBA8] = "RGBA8888";
        PixelFormat[PixelFormat["RGBA32F"] = Format.RGBA32F] = "RGBA32F";
        PixelFormat[PixelFormat["A8"] = Format.A8] = "A8";
        PixelFormat[PixelFormat["I8"] = Format.L8] = "I8";
        PixelFormat[PixelFormat["AI8"] = Format.LA8] = "AI8";
        PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT] = "RGB_A_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT + 1] = "RGB_A_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_ETC1"] = Format.ETC_RGB8] = "RGB_ETC1";
        PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT + 2] = "RGBA_ETC1";
        PixelFormat[PixelFormat["RGB_ETC2"] = Format.ETC2_RGB8] = "RGB_ETC2";
        PixelFormat[PixelFormat["RGBA_ETC2"] = Format.ETC2_RGBA8] = "RGBA_ETC2";
        PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
        PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
        PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
        PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
      })(PixelFormat || (PixelFormat = {}));
      let WrapMode;
      (function (WrapMode) {
        WrapMode[WrapMode["REPEAT"] = Address.WRAP] = "REPEAT";
        WrapMode[WrapMode["CLAMP_TO_EDGE"] = Address.CLAMP] = "CLAMP_TO_EDGE";
        WrapMode[WrapMode["MIRRORED_REPEAT"] = Address.MIRROR] = "MIRRORED_REPEAT";
        WrapMode[WrapMode["CLAMP_TO_BORDER"] = Address.BORDER] = "CLAMP_TO_BORDER";
      })(WrapMode || (WrapMode = {}));
      let Filter;
      (function (Filter) {
        Filter[Filter["NONE"] = Filter$1.NONE] = "NONE";
        Filter[Filter["LINEAR"] = Filter$1.LINEAR] = "LINEAR";
        Filter[Filter["NEAREST"] = Filter$1.POINT] = "NEAREST";
      })(Filter || (Filter = {}));

      const ImageAsset$1 = exports('ImageAsset', jsb.ImageAsset);
      const jsbWindow$1 = jsb.window;
      const extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'];
      function isImageBitmap(imageSource) {
        return !!(sys.hasFeature(sys.Feature.IMAGE_BITMAP) && imageSource instanceof ImageBitmap);
      }
      function isNativeImage(imageSource) {
        if (imageSource._compressed === true) {
          return false;
        }
        return imageSource instanceof jsbWindow$1.HTMLImageElement || imageSource instanceof jsbWindow$1.HTMLCanvasElement || isImageBitmap(imageSource);
      }
      const imageAssetProto = ImageAsset$1.prototype;
      imageAssetProto._ctor = function (nativeAsset) {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._width = 0;
        this._height = 0;
        this._nativeData = {
          _data: null,
          width: 0,
          height: 0,
          format: 0,
          _compressed: false,
          mipmapLevelDataSize: []
        };
        if (nativeAsset !== undefined) {
          this.reset(nativeAsset);
        }
      };
      Object.defineProperty(imageAssetProto, '_nativeAsset', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData;
        },
        set(value) {
          if (!(value instanceof jsbWindow$1.HTMLElement) && !isImageBitmap(value)) {
            value.format = value.format || this.format;
          }
          this.reset(value);
        }
      });
      Object.defineProperty(imageAssetProto, 'data', {
        configurable: true,
        enumerable: true,
        get() {
          if (this._nativeData && isNativeImage(this._nativeData)) {
            return this._nativeData;
          }
          return this._nativeData && this._nativeData._data;
        }
      });
      imageAssetProto._setRawAsset = function (filename, inLibrary = true) {
        if (inLibrary !== false) {
          this._native = filename || '';
        } else {
          this._native = `/${filename}`;
        }
      };
      imageAssetProto.reset = function (data) {
        this._nativeData = data;
        if (!(data instanceof jsbWindow$1.HTMLElement)) {
          if (data.format !== undefined) {
            this.format = data.format;
          }
        }
        this._syncDataToNative();
      };
      const superDestroy = jsb.Asset.prototype.destroy;
      imageAssetProto.destroy = function () {
        if (this.data && this.data instanceof jsbWindow$1.HTMLImageElement) {
          this.data.src = '';
          this._setRawAsset('');
          this.data.destroy();
        } else if (isImageBitmap(this.data)) {
          this.data.close && this.data.close();
        }
        return superDestroy.call(this);
      };
      Object.defineProperty(imageAssetProto, 'width', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData.width || this._width;
        }
      });
      Object.defineProperty(imageAssetProto, 'height', {
        configurable: true,
        enumerable: true,
        get() {
          return this._nativeData.height || this._height;
        }
      });
      imageAssetProto._syncDataToNative = function () {
        const data = this._nativeData;
        this._width = data.width;
        this._height = data.height;
        this.setWidth(this._width);
        this.setHeight(this._height);
        this.url = this.nativeUrl;
        if (data instanceof jsbWindow$1.HTMLCanvasElement) {
          this.setData(data._data.data);
        } else if (data instanceof jsbWindow$1.HTMLImageElement) {
          this.setData(data._data);
          if (data._mipmapLevelDataSize) {
            this.setMipmapLevelDataSize(data._mipmapLevelDataSize);
          }
        } else {
          if (!this._nativeData._data) {
            console.error(`[ImageAsset] setData bad argument ${this._nativeData}`);
            return;
          }
          this.setData(this._nativeData._data);
          if (this._nativeData.mipmapLevelDataSize) {
            this.setMipmapLevelDataSize(this._nativeData.mipmapLevelDataSize);
          }
        }
      };
      imageAssetProto._serialize = function () {
      };
      imageAssetProto._deserialize = function (data) {
        let fmtStr = '';
        if (typeof data === 'string') {
          fmtStr = data;
        } else {
          this._width = data.w;
          this._height = data.h;
          fmtStr = data.fmt;
        }
        const device = deviceManager.gfxDevice;
        const extensionIDs = fmtStr.split('_');
        let preferedExtensionIndex = Number.MAX_VALUE;
        let format = this.format;
        let ext = '';
        const SupportTextureFormats = macro.SUPPORT_TEXTURE_FORMATS;
        for (const extensionID of extensionIDs) {
          const extFormat = extensionID.split('@');
          const i = parseInt(extFormat[0], undefined);
          const tmpExt = extnames[i] || extFormat[0];
          const index = SupportTextureFormats.indexOf(tmpExt);
          if (index !== -1 && index < preferedExtensionIndex) {
            const fmt = extFormat[1] ? parseInt(extFormat[1]) : this.format;
            if (tmpExt === '.astc' && (!device || !(device.getFormatFeatures(Format.ASTC_RGBA_4X4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if (tmpExt === '.pvr' && (!device || !(device.getFormatFeatures(Format.PVRTC_RGBA4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !(device.getFormatFeatures(Format.ETC_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !(device.getFormatFeatures(Format.ETC2_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
              continue;
            } else if (tmpExt === '.webp' && !sys.hasFeature(sys.Feature.WEBP)) {
              continue;
            }
            preferedExtensionIndex = index;
            ext = tmpExt;
            format = fmt;
          }
        }
        if (ext) {
          this._setRawAsset(ext);
          this.format = format;
        } else {
          warnID(3121);
        }
      };
      legacyCC.ImageAsset = jsb.ImageAsset;
      patch_cc_ImageAsset({
        ImageAsset: ImageAsset$1
      });

      var _dec$1J, _class$1H, _dec2$1q, _class2$1y, _dec3$15, _class3$F;
      let Script = exports('Script', (_dec$1J = ccclass$6('cc.Script'), _dec$1J(_class$1H = class Script extends Asset {}) || _class$1H));
      legacyCC._Script = Script;
      let JavaScript = exports('JavaScript', (_dec2$1q = ccclass$6('cc.JavaScript'), _dec2$1q(_class2$1y = class JavaScript extends Script {}) || _class2$1y));
      legacyCC._JavaScript = JavaScript;
      let TypeScript = exports('TypeScript', (_dec3$15 = ccclass$6('cc.TypeScript'), _dec3$15(_class3$F = class TypeScript extends Script {}) || _class3$F));
      legacyCC._TypeScript = TypeScript;

      var _dec$1I, _class$1G, _class2$1x, _initializer$1s, _initializer2$1f, _initializer3$$, _initializer4$S, _initializer5$J;
      let EventHandler = exports('EventHandler', (_dec$1I = ccclass$6('cc.ClickEvent'), _dec$1I(_class$1G = (_class2$1x = class EventHandler {
        constructor() {
          this.target = _initializer$1s && _initializer$1s();
          this.component = _initializer2$1f && _initializer2$1f();
          this._componentId = _initializer3$$ && _initializer3$$();
          this.handler = _initializer4$S && _initializer4$S();
          this.customEventData = _initializer5$J && _initializer5$J();
        }
        get _componentName() {
          this._genCompIdIfNeeded();
          return this._compId2Name(this._componentId);
        }
        set _componentName(value) {
          this._componentId = this._compName2Id(value);
        }
        static emitEvents(events, ...args) {
          for (let i = 0, l = events.length; i < l; i++) {
            const event = events[i];
            if (!(event instanceof EventHandler)) {
              continue;
            }
            event.emit(args);
          }
        }
        emit(params) {
          const target = this.target;
          if (!legacyCC.isValid(target)) {
            return;
          }
          this._genCompIdIfNeeded();
          const compType = legacyCC.js.getClassById(this._componentId);
          const comp = target.getComponent(compType);
          if (!legacyCC.isValid(comp)) {
            return;
          }
          const handler = comp[this.handler];
          if (typeof handler !== 'function') {
            return;
          }
          if (this.customEventData != null && this.customEventData !== '') {
            params = params.slice();
            params.push(this.customEventData);
          }
          handler.apply(comp, params);
        }
        _compName2Id(compName) {
          const comp = legacyCC.js.getClassByName(compName);
          return legacyCC.js.getClassId(comp);
        }
        _compId2Name(compId) {
          const comp = legacyCC.js.getClassById(compId);
          return legacyCC.js.getClassName(comp);
        }
        _genCompIdIfNeeded() {
          if (!this._componentId) {
            this._componentName = this.component;
            this.component = '';
          }
        }
      }, (_initializer$1s = applyDecoratedInitializer(_class2$1x.prototype, "target", [serializable$6], function () {
        return null;
      }), _initializer2$1f = applyDecoratedInitializer(_class2$1x.prototype, "component", [serializable$6], function () {
        return '';
      }), _initializer3$$ = applyDecoratedInitializer(_class2$1x.prototype, "_componentId", [serializable$6], function () {
        return '';
      }), _initializer4$S = applyDecoratedInitializer(_class2$1x.prototype, "handler", [serializable$6], function () {
        return '';
      }), _initializer5$J = applyDecoratedInitializer(_class2$1x.prototype, "customEventData", [serializable$6], function () {
        return '';
      })), _class2$1x)) || _class$1G));

      var _dec$1H, _dec2$1p, _class$1F, _class2$1w, _initializer$1r, _initializer2$1e, _initializer3$_, _class3$E;
      const idGenerator = new IDGenerator('Comp');
      const IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
      const NullNode = null;
      let Component = exports('Component', (_dec$1H = ccclass$6('cc.Component'), _dec2$1p = type$6(Script), _dec$1H(_class$1F = (_class2$1w = (_class3$E = class Component extends CCObject {
        constructor(...args) {
          super(...args);
          this.node = _initializer$1r && _initializer$1r();
          this._enabled = _initializer2$1e && _initializer2$1e();
          this.__prefab = _initializer3$_ && _initializer3$_();
          this._sceneGetter = null;
          this._id = idGenerator.getNewId();
        }
        get name() {
          if (this._name) {
            return this._name;
          }
          let className = getClassName(this);
          const trimLeft = className.lastIndexOf('.');
          if (trimLeft >= 0) {
            className = className.slice(trimLeft + 1);
          }
          if (this.node) {
            return `${this.node.name}<${className}>`;
          } else {
            return className;
          }
        }
        set name(value) {
          this._name = value;
        }
        get uuid() {
          return this._id;
        }
        get __scriptAsset() {
          return null;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(value) {
          if (this._enabled !== value) {
            this._enabled = value;
            if (this.node.activeInHierarchy) {
              const compScheduler = legacyCC.director._compScheduler;
              if (value) {
                compScheduler.enableComp(this);
              } else {
                compScheduler.disableComp(this);
              }
            }
          }
        }
        get enabledInHierarchy() {
          return this._enabled && this.node && this.node.activeInHierarchy;
        }
        get _isOnLoadCalled() {
          return this._objFlags & IsOnLoadCalled$1;
        }
        _getRenderScene() {
          if (this._sceneGetter) {
            return this._sceneGetter();
          }
          return this.node.scene.renderScene;
        }
        addComponent(typeOrClassName) {
          return this.node.addComponent(typeOrClassName);
        }
        getComponent(typeOrClassName) {
          return this.node.getComponent(typeOrClassName);
        }
        getComponents(typeOrClassName) {
          return this.node.getComponents(typeOrClassName);
        }
        getComponentInChildren(typeOrClassName) {
          return this.node.getComponentInChildren(typeOrClassName);
        }
        getComponentsInChildren(typeOrClassName) {
          return this.node.getComponentsInChildren(typeOrClassName);
        }
        destroy() {
          if (super.destroy()) {
            if (this._enabled && this.node.activeInHierarchy) {
              legacyCC.director._compScheduler.disableComp(this);
            }
            return true;
          }
          return false;
        }
        _onPreDestroy() {
          this.unscheduleAllCallbacks();
          legacyCC.director._nodeActivator.destroyComp(this);
          this.node._removeComponent(this);
        }
        _instantiate(cloned) {
          if (!cloned) {
            cloned = legacyCC.instantiate._clone(this, this);
          }
          if (cloned) {
            cloned.node = NullNode;
          }
          return cloned;
        }
        schedule(callback, interval = 0, repeat = legacyCC.macro.REPEAT_FOREVER, delay = 0) {
          assertID(Boolean(callback), 1619);
          interval = interval || 0;
          assertID(interval >= 0, 1620);
          repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
          delay = delay || 0;
          const scheduler = legacyCC.director.getScheduler();
          const paused = scheduler.isTargetPaused(this);
          scheduler.schedule(callback, this, interval, repeat, delay, paused);
        }
        scheduleOnce(callback, delay = 0) {
          this.schedule(callback, 0, 0, delay);
        }
        unschedule(callback_fn) {
          if (!callback_fn) {
            return;
          }
          legacyCC.director.getScheduler().unschedule(callback_fn, this);
        }
        unscheduleAllCallbacks() {
          legacyCC.director.getScheduler().unscheduleAllForTarget(this);
        }
        get internalUpdate() {
          return this.update;
        }
        get internalLateUpdate() {
          return this.lateUpdate;
        }
        get internalPreload() {
          return this.__preload;
        }
        get internalOnLoad() {
          return this.onLoad;
        }
        get internalStart() {
          return this.start;
        }
        get internalOnEnable() {
          return this.onEnable;
        }
        get internalOnDisable() {
          return this.onDisable;
        }
        get internalOnDestroy() {
          return this.onDestroy;
        }
      }, _class3$E.EventHandler = EventHandler, _class3$E._executionOrder = 0, _class3$E._requireComponent = null, _class3$E.system = null, _class3$E), (_applyDecoratedDescriptor(_class2$1w.prototype, "__scriptAsset", [_dec2$1p], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "__scriptAsset"), _class2$1w.prototype), _initializer$1r = applyDecoratedInitializer(_class2$1w.prototype, "node", [serializable$6], function () {
        return NullNode;
      }), _initializer2$1e = applyDecoratedInitializer(_class2$1w.prototype, "_enabled", [serializable$6], function () {
        return true;
      }), _initializer3$_ = applyDecoratedInitializer(_class2$1w.prototype, "__prefab", [serializable$6], function () {
        return null;
      })), _class2$1w)) || _class$1F));
      value(Component, '_registerEditorProps', (cls, props) => {
        let reqComp = props.requireComponent;
        if (reqComp) {
          if (Array.isArray(reqComp)) {
            reqComp = reqComp.filter(Boolean);
          }
          cls._requireComponent = reqComp;
        }
        const order = props.executionOrder;
        if (order && typeof order === 'number') {
          cls._executionOrder = order;
        }
      });
      legacyCC.Component = Component;

      var _dec$1G, _class$1E, _class2$1v, _initializer$1q;
      let MissingScript = exports('MissingScript', (_dec$1G = ccclass$6('cc.MissingScript'), _dec$1G(_class$1E = (_class2$1v = class MissingScript extends Component {
        static safeFindClass(id) {
          const cls = getClassById(id);
          if (cls) {
            return cls;
          }
          legacyCC.deserialize.reportMissingClass(id);
          return undefined;
        }
        constructor() {
          super();
          this._$erialized = _initializer$1q && _initializer$1q();
        }
        onLoad() {
          warnID(4600, this.node.name);
        }
      }, (_initializer$1q = applyDecoratedInitializer(_class2$1v.prototype, "_$erialized", [serializable$6, editorOnly], function () {
        return null;
      })), _class2$1v)) || _class$1E));
      legacyCC._MissingScript = MissingScript;
      try {
        const props = MissingScript.__values__;
        if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
          error(`The '_$erialized' prop in MissingScript is missing. Please contact jare.`);
          error(`    Error props: ['${props}']`);
        }
      } catch (e) {
        error(`Error when checking MissingScript 5, ${e}`);
      }

      const VERSION = 1;
      const MAGIC = 0x4E4F4343;
      const CHUNK_ALIGN_AS = 8;
      class CCON {
        constructor(document, chunks) {
          this._document = void 0;
          this._chunks = void 0;
          this._document = document;
          this._chunks = chunks;
        }
        get document() {
          return this._document;
        }
        get chunks() {
          return this._chunks;
        }
      }
      function parseCCONJson(json) {
        const cconPreface = json;
        return {
          chunks: cconPreface.chunks,
          document: cconPreface.document
        };
      }
      function decodeCCONBinary(bytes) {
        if (bytes.length < 16) {
          throw new InvalidCCONError(getError(13102));
        }
        const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        const magic = dataView.getUint32(0, true);
        if (magic !== MAGIC) {
          throw new InvalidCCONError(getError(13100));
        }
        const version = dataView.getUint32(4, true);
        if (version !== VERSION) {
          throw new InvalidCCONError(getError(13101, version));
        }
        const dataByteLength = dataView.getUint32(8, true);
        if (dataByteLength !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }
        let chunksStart = 12;
        const jsonDataLength = dataView.getUint32(chunksStart, true);
        chunksStart += 4;
        const jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
        chunksStart += jsonDataLength;
        const jsonString = decodeJson(jsonData);
        let json;
        try {
          json = JSON.parse(jsonString);
        } catch (err) {
          throw new InvalidCCONError(err);
        }
        const chunks = [];
        while (chunksStart < dataView.byteLength) {
          if (chunksStart % CHUNK_ALIGN_AS !== 0) {
            const padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
            chunksStart += padding;
          }
          const chunkDataLength = dataView.getUint32(chunksStart, true);
          chunksStart += 4;
          chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
          chunksStart += chunkDataLength;
        }
        if (chunksStart !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }
        return new CCON(json, chunks);
      }
      function decodeJson(data) {
        if (typeof TextDecoder !== 'undefined') {
          return new TextDecoder().decode(data);
        } else if ('Buffer' in globalThis) {
          const {
            Buffer
          } = globalThis;
          return Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString();
        } else {
          throw new Error(getError(13104));
        }
      }
      class InvalidCCONError extends Error {}
      legacyCC.internal.parseCCONJson = parseCCONJson;
      legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
      legacyCC.internal.CCON = CCON;

      function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
        if (defaultValue instanceof legacyCC.ValueType) {
          if (!assumeHavePropIfIsValue) {
            sources.push('if(prop){');
          }
          const ctorCode = getClassName(defaultValue);
          sources.push(`s._deserializeFastDefinedObject(o${accessorToSet},prop,${ctorCode});`);
          if (!assumeHavePropIfIsValue) {
            sources.push(`}else o${accessorToSet}=null;`);
          }
        } else {
          sources.push(`
if (prop) {
    s._deserializeAndAssignField(o, prop, ${propNameLiteralToSet});
} else {
    o${accessorToSet}=null;
}
`);
        }
      }
      const compileDeserialize = compileDeserializeJIT ;
      const DELIMITER = CCClass.Attr.DELIMETER;
      const POSTFIX_TYPE = `${DELIMITER}type`;
      const POSTFIX_DEFAULT = `${DELIMITER}default`;
      const POSTFIX_FORMERLY_SERIALIZED_AS = `${DELIMITER}formerlySerializedAs`;
      function compileDeserializeJIT(self, klass) {
        const attrs = CCClass.Attr.getClassAttrs(klass);
        const props = klass.__values__;
        const sources = ['var prop;'];
        const fastMode = canBeDeserializedInFastMode(klass);
        for (let p = 0; p < props.length; p++) {
          const propName = props[p];
          let accessorToSet;
          let propNameLiteralToSet;
          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = `"${propName}"`;
            accessorToSet = `.${propName}`;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = `[${propNameLiteralToSet}]`;
          }
          let accessorToGet = accessorToSet;
          if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
            const propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];
            if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
              accessorToGet = `.${propNameToRead}`;
            } else {
              accessorToGet = `[${CCClass.escapeForJS(propNameToRead)}]`;
            }
          }
          sources.push(`prop=d${accessorToGet};`);
          sources.push(`if(typeof ${'(prop)' }!=="undefined"){`);
          const defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
          const userType = attrs[propName + POSTFIX_TYPE];
          if (fastMode && (defaultValue !== undefined || userType)) {
            const isPrimitiveTypeInFastMode = isPrimitivePropertyByDefaultOrType(defaultValue, userType);
            if (isPrimitiveTypeInFastMode) {
              sources.push(`o${accessorToSet}=prop;`);
            } else {
              compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
            }
          } else {
            sources.push(`${`if(typeof ${'(prop)' }!=="object"){` + 'o'}${accessorToSet}=prop;` + `}else{`);
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
            sources.push('}');
          }
          sources.push('}');
        }
        if (isChildClassOf(klass, legacyCC.Node) || isChildClassOf(klass, legacyCC.Component)) {
          {
            sources.push('d._id&&(o._id=d._id);');
          }
        }
        if (props[props.length - 1] === '_$erialized') {
          sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
          sources.push('s._fillPlainObject(o._$erialized,d);');
        }
        return Function('s', 'o', 'd', 'k', sources.join(''));
      }
      function canBeDeserializedInFastMode(klass) {
        return BUILTIN_CLASSID_RE.test(getClassId(klass));
      }
      function isPrimitivePropertyByDefaultOrType(defaultValue, userType) {
        if (defaultValue === undefined) {
          return userType instanceof CCClass.Attr.PrimitiveType || userType === ENUM_TAG || userType === BITMASK_TAG;
        } else {
          const defaultType = typeof defaultValue;
          return defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
        }
      }
      class DeserializerPool extends Pool$1 {
        constructor() {
          super(deserializer => {
            deserializer.clear();
          }, 1);
        }
      }
      DeserializerPool.prototype.get = function (details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
        const cache = this._get();
        if (cache) {
          cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
          return cache;
        } else {
          return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
        }
      };
      class _Deserializer {
        get ignoreEditorOnly() {
          return this._ignoreEditorOnly;
        }
        constructor(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.deserializedList = void 0;
          this.deserializedData = void 0;
          this._ignoreEditorOnly = void 0;
          this.result = result;
          this.customEnv = customEnv;
          this.deserializedList = [];
          this.deserializedData = null;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        }
        reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.result = result;
          this.customEnv = customEnv;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        }
        clear() {
          this.result = null;
          this.customEnv = null;
          this.deserializedList.length = 0;
          this.deserializedData = null;
          this._classFinder = null;
          this._reportMissingClass = null;
          this._onDereferenced = null;
        }
        deserialize(serializedData) {
          let fromCCON = false;
          let jsonObj;
          if (serializedData instanceof CCON) {
            fromCCON = true;
            jsonObj = serializedData.document;
            if (serializedData.chunks.length > 0) {
              assertIsTrue(serializedData.chunks.length === 1);
              this._mainBinChunk = serializedData.chunks[0];
            }
          } else {
            jsonObj = serializedData;
          }
          this._serializedData = jsonObj;
          this._context = {
            fromCCON
          };
          const serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;
          {
            this.deserializedData = this._deserializeObject(serializedRootObject, 0);
          }
          this._serializedData = undefined;
          this._mainBinChunk = undefined;
          this._context = undefined;
          return this.deserializedData;
        }
        _deserializeObject(serialized, globalIndex, owner, propName) {
          switch (serialized.__type__) {
            case 'TypedArray':
              return this._deserializeTypedArrayView(serialized);
            case 'TypedArrayRef':
              return this._deserializeTypedArrayViewRef(serialized);
            default:
              if (serialized.__type__) {
                return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
              } else if (!Array.isArray(serialized)) {
                return this._deserializePlainObject(serialized);
              } else {
                return this._deserializeArray(serialized);
              }
          }
        }
        _deserializeTypedArrayView(value) {
          return globalThis[value.ctor].from(value.array);
        }
        _deserializeTypedArrayViewRef(value) {
          const {
            offset,
            length,
            ctor: constructorName
          } = value;
          const obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
          return obj;
        }
        _deserializeArray(value) {
          const obj = new Array(value.length);
          let prop;
          for (let i = 0; i < value.length; i++) {
            prop = value[i];
            if (typeof prop === 'object' && prop) {
              const isAssetType = this._deserializeAndAssignField(obj, prop, `${i}`);
              if (isAssetType) {
                obj[i] = null;
              }
            } else {
              obj[i] = prop;
            }
          }
          return obj;
        }
        _deserializePlainObject(value) {
          const obj = {};
          this._fillPlainObject(obj, value);
          return obj;
        }
        _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
          const type = value.__type__;
          const klass = this._classFinder(type, value, owner, propName);
          if (!klass) {
            const notReported = this._classFinder === getClassById;
            if (notReported) {
              this._reportMissingClass(type);
            }
            return null;
          }
          const createObject = constructor => {
            const obj = new constructor();
            if (globalIndex >= 0) {
              this.deserializedList[globalIndex] = obj;
            }
            return obj;
          };
          {
            const obj = createObject(klass);
            this._deserializeInto(value, obj, klass);
            return obj;
          }
        }
        _deserializeInto(value, object, constructor, skipCustomized = false) {
          if (!skipCustomized && object[deserializeTag]) {
            this._runCustomizedDeserialize(value, object, constructor);
            return;
          }
          if (object._deserialize) {
            object._deserialize(value.content, this);
            return;
          }
          if (legacyCC.Class._isCCClass(constructor)) {
            this._deserializeFireClass(object, value, constructor);
          } else {
            this._deserializeFastDefinedObject(object, value, constructor);
          }
        }
        _runCustomizedDeserialize(value, object, constructor) {
          const serializationInput = {
            readProperty: name => {
              const serializedField = value[name];
              if (typeof serializedField !== 'object' || !serializedField) {
                return serializedField;
              } else {
                return this._deserializeObjectField(serializedField);
              }
            },
            readThis: () => {
              this._deserializeInto(value, object, constructor, true);
            },
            readSuper: () => {
              const superConstructor = getSuper(constructor);
              if (superConstructor) {
                this._deserializeInto(value, object, superConstructor);
              }
            }
          };
          object[deserializeTag](serializationInput, this._context);
        }
        _deserializeFireClass(obj, serialized, klass) {
          let deserialize;
          if (klass.hasOwnProperty('__deserialize__')) {
            deserialize = klass.__deserialize__;
          } else {
            deserialize = compileDeserialize(this, klass);
            try {
              if (klass === MissingScript) {
                const props = klass.__values__;
                if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                  error(`The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save.`);
                  error(`    Error props: ['${props}']. Please contact jare.`);
                }
                const rawDeserialize = deserialize;
                deserialize = function (deserializer, object, deserialized, constructor) {
                  rawDeserialize(deserializer, object, deserialized, constructor);
                  if (!object._$erialized) {
                    error(`Unable to stash previously serialized data. ${JSON.stringify(deserialized)}`);
                  }
                };
              }
            } catch (e) {
              error(`Error when checking MissingScript 6, ${e}`);
            }
            value(klass, '__deserialize__', deserialize, true);
          }
          deserialize(this, obj, serialized, klass);
        }
        _deserializeAndAssignField(obj, serializedField, propName) {
          const id = serializedField.__id__;
          if (typeof id === 'number') {
            const field = this.deserializedList[id];
            if (field) {
              obj[propName] = field;
            } else {
              var _this$_onDereferenced;
              const source = this._serializedData[id];
              {
                obj[propName] = this._deserializeObject(source, id, undefined, propName);
              }
              (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
            }
          } else {
            const uuid = serializedField.__uuid__;
            if (uuid) {
              const expectedType = serializedField.__expectedType__;
              this.result.push(obj, propName, uuid, expectedType);
            } else {
              obj[propName] = this._deserializeObject(serializedField, -1);
            }
          }
          return false;
        }
        _deserializeObjectField(serializedField) {
          const id = serializedField.__id__;
          if (typeof id === 'number') {
            const field = this.deserializedList[id];
            if (field) {
              return field;
            } else {
              const source = this._serializedData[id];
              const field = this._deserializeObject(source, id, undefined, undefined);
              return field;
            }
          } else {
            const uuid = serializedField.__uuid__;
            if (uuid) {
              serializedField.__expectedType__;
              throw new Error(`Asset reference field serialization is currently not supported in custom serialization.`);
            } else {
              return this._deserializeObject(serializedField, -1);
            }
          }
        }
        _fillPlainObject(instance, serialized) {
          for (const propName in serialized) {
            if (!serialized.hasOwnProperty(propName)) {
              continue;
            }
            const prop = serialized[propName];
            if (typeof prop !== 'object') {
              if (propName !== '__type__') {
                instance[propName] = prop;
              }
            } else if (prop) {
              const isAssetType = this._deserializeAndAssignField(instance, prop, propName);
              if (isAssetType) {
                instance[propName] = null;
              }
            } else {
              instance[propName] = null;
            }
          }
        }
        _deserializeFastDefinedObject(instance, serialized, klass) {
          if (klass === legacyCC.Vec2) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            return;
          } else if (klass === legacyCC.Vec3) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            instance.z = serialized.z || 0;
            return;
          } else if (klass === legacyCC.Color) {
            instance.r = serialized.r || 0;
            instance.g = serialized.g || 0;
            instance.b = serialized.b || 0;
            const a = serialized.a;
            instance.a = a === undefined ? 255 : a;
            return;
          } else if (klass === legacyCC.Size) {
            instance.width = serialized.width || 0;
            instance.height = serialized.height || 0;
            return;
          }
          const attrs = CCClass.Attr.getClassAttrs(klass);
          const props = klass.__values__;
          if (!props) {
            error(`Unable to deserialize ${getClassName(klass)}. ` + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
          }
          for (let i = 0; i < props.length; i++) {
            const propName = props[i];
            let value = serialized[propName];
            const exists = value !== undefined || serialized.hasOwnProperty(propName);
            if (!exists) {
              value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
            }
            if (typeof value !== 'object') {
              instance[propName] = value;
            } else if (value) {
              this._deserializeAndAssignField(instance, value, propName);
            } else {
              instance[propName] = null;
            }
          }
        }
      }
      _Deserializer.pool = new DeserializerPool();
      function deserializeDynamic(data, details, options) {
        var _options$reportMissin;
        options = options || {};
        const classFinder = options.classFinder || getClassById;
        const createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
        const customEnv = options.customEnv;
        const ignoreEditorOnly = options.ignoreEditorOnly;
        const reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
        details.init();
        const deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
        legacyCC.game._isCloning = true;
        const res = deserializer.deserialize(data);
        legacyCC.game._isCloning = false;
        _Deserializer.pool.put(deserializer);
        if (createAssetRefs) {
          details.assignAssetsBy((uuid, options) => EditorExtends.serialize.asAsset(uuid, options.type));
        }
        return res;
      }

      function reportMissingClass(id) {
        {
          errorID(5302, id);
        }
      }

      const constructorMap = [Vec2, Vec3, Vec4, Quat, Color$1, Size$1, Rect$1, Mat4];
      function vec4LikeSetter(obj, data) {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
        obj.w = data[4];
      }
      const setterMap = [(obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
      }, (obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
      }, vec4LikeSetter, vec4LikeSetter, (obj, data) => {
        obj._val = data[1];
      }, (obj, data) => {
        obj.width = data[1];
        obj.height = data[2];
      }, (obj, data) => {
        obj.x = data[1];
        obj.y = data[2];
        obj.width = data[3];
        obj.height = data[4];
      }, (obj, data) => {
        Mat4.fromArray(obj, data, 1);
      }];
      function deserializeBuiltinValueType(data, owner, key, value) {
        const typeIndex = value[0];
        assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
        const object = new constructorMap[typeIndex]();
        const setter = setterMap[typeIndex];
        setter(object, value);
        owner[key] = object;
      }
      function deserializeBuiltinValueTypeInto(data, owner, key, value) {
        const typeIndex = value[0];
        assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
        {
          const tmp = owner[key];
          const setter = setterMap[typeIndex];
          setter(tmp, value);
          owner[key] = tmp;
        }
      }

      const SUPPORT_MIN_FORMAT_VERSION = 1;
      const EMPTY_PLACEHOLDER = 0;
      const DataTypeID = {
        SimpleType: 0,
        InstanceRef: 1,
        Array_InstanceRef: 2,
        Array_AssetRefByInnerObj: 3,
        Class: 4,
        ValueTypeCreated: 5,
        AssetRefByInnerObj: 6,
        TRS: 7,
        ValueType: 8,
        Array_Class: 9,
        CustomizedClass: 10,
        Dict: 11,
        Array: 12,
        ARRAY_LENGTH: 13
      };
      const CLASS_TYPE = 0;
      const CLASS_KEYS = 1;
      const CLASS_PROP_TYPE_OFFSET = 2;
      const MASK_CLASS = 0;
      const OBJ_DATA_MASK = 0;
      const CUSTOM_OBJ_DATA_CLASS = 0;
      const CUSTOM_OBJ_DATA_CONTENT = 1;
      const DICT_JSON_LAYOUT = 0;
      const ARRAY_ITEM_VALUES = 0;
      const Refs = {
        EACH_RECORD_LENGTH: 3,
        OWNER_OFFSET: 0,
        KEY_OFFSET: 1,
        TARGET_OFFSET: 2
      };
      const File = {
        Version: 0,
        Context: 0,
        SharedUuids: 1,
        SharedStrings: 2,
        SharedClasses: 3,
        SharedMasks: 4,
        Instances: 5,
        InstanceTypes: 6,
        Refs: 7,
        DependObjs: 8,
        DependKeys: 9,
        DependUuidIndices: 10,
        ARRAY_LENGTH: 11
      };
      const PACKED_SECTIONS = File.Instances;
      class Details {
        constructor() {
          this.uuidObjList = null;
          this.uuidPropList = null;
          this.uuidList = null;
          this.uuidTypeList = [];
        }
        init(data) {
          if (data) {
            this.uuidObjList = data[File.DependObjs];
            this.uuidPropList = data[File.DependKeys];
            this.uuidList = data[File.DependUuidIndices];
          } else {
            const used = this.uuidList;
            if (!used) {
              this.uuidList = [];
              this.uuidObjList = [];
              this.uuidPropList = [];
              this.uuidTypeList = [];
            }
          }
        }
        reset() {
          {
            const used = this.uuidList;
            if (used) {
              this.uuidList.length = 0;
              this.uuidObjList.length = 0;
              this.uuidPropList.length = 0;
              this.uuidTypeList.length = 0;
            }
          }
        }
        push(obj, propName, uuid, type) {
          this.uuidObjList.push(obj);
          this.uuidPropList.push(propName);
          this.uuidList.push(uuid);
          this.uuidTypeList.push(type || '');
        }
      } exports('Details', Details);
      Details.pool = new Pool$1(obj => {
        obj.reset();
      }, 5);
      Details.pool.get = function () {
        return this._get() || new Details();
      };
      function dereference(refs, instances, strings) {
        const dataLength = refs.length - 1;
        let i = 0;
        const instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;
        for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
          const owner = refs[i];
          const target = instances[refs[i + Refs.TARGET_OFFSET]];
          const keyIndex = refs[i + Refs.KEY_OFFSET];
          if (keyIndex >= 0) {
            owner[strings[keyIndex]] = target;
          } else {
            owner[~keyIndex] = target;
          }
        }
        for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
          const owner = instances[refs[i]];
          const target = instances[refs[i + Refs.TARGET_OFFSET]];
          const keyIndex = refs[i + Refs.KEY_OFFSET];
          if (keyIndex >= 0) {
            owner[strings[keyIndex]] = target;
          } else {
            owner[~keyIndex] = target;
          }
        }
      }
      function deserializeCCObject(data, objectData) {
        const mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
        const clazz = mask[MASK_CLASS];
        const ctor = clazz[CLASS_TYPE];
        const obj = new ctor();
        const keys = clazz[CLASS_KEYS];
        const classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
        const maskTypeOffset = mask[mask.length - 1];
        let i = MASK_CLASS + 1;
        for (; i < maskTypeOffset; ++i) {
          const key = keys[mask[i]];
          obj[key] = objectData[i];
        }
        for (; i < objectData.length; ++i) {
          const key = keys[mask[i]];
          const type = clazz[mask[i] + classTypeOffset];
          const op = ASSIGNMENTS[type];
          op(data, obj, key, objectData[i]);
        }
        return obj;
      }
      function deserializeCustomCCObject(data, ctor, value) {
        const obj = new ctor();
        if (obj._deserialize) {
          obj._deserialize(value, data[File.Context]);
        } else {
          errorID(5303, getClassName(ctor));
        }
        return obj;
      }
      function assignSimple(data, owner, key, value) {
        owner[key] = value;
      }
      function assignInstanceRef(data, owner, key, value) {
        if (value >= 0) {
          owner[key] = data[File.Instances][value];
        } else {
          data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
        }
      }
      function genArrayParser(parser) {
        return (data, owner, key, value) => {
          for (let i = 0; i < value.length; ++i) {
            parser(data, value, i, value[i]);
          }
          owner[key] = value;
        };
      }
      function parseAssetRefByInnerObj(data, owner, key, value) {
        owner[key] = null;
        data[File.DependObjs][value] = owner;
      }
      function parseClass(data, owner, key, value) {
        owner[key] = deserializeCCObject(data, value);
      }
      function parseCustomClass(data, owner, key, value) {
        const ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
        owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
      }
      function parseTRS(data, owner, key, value) {
        const typedArray = owner[key];
        typedArray.set(value);
      }
      function parseDict(data, owner, key, value) {
        const dict = value[DICT_JSON_LAYOUT];
        owner[key] = dict;
        for (let i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
          const subKey = value[i];
          const subType = value[i + 1];
          const subValue = value[i + 2];
          const op = ASSIGNMENTS[subType];
          op(data, dict, subKey, subValue);
        }
      }
      function parseArray(data, owner, key, value) {
        const array = value[ARRAY_ITEM_VALUES];
        for (let i = 0; i < array.length; ++i) {
          const subValue = array[i];
          const type = value[i + 1];
          if (type !== DataTypeID.SimpleType) {
            const op = ASSIGNMENTS[type];
            op(data, array, i, subValue);
          }
        }
        owner[key] = array;
      }
      const ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
      ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
      ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
      ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
      ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
      ASSIGNMENTS[DataTypeID.Class] = parseClass;
      ASSIGNMENTS[DataTypeID.ValueTypeCreated] = deserializeBuiltinValueTypeInto;
      ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
      ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
      ASSIGNMENTS[DataTypeID.ValueType] = deserializeBuiltinValueType;
      ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
      ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
      ASSIGNMENTS[DataTypeID.Dict] = parseDict;
      ASSIGNMENTS[DataTypeID.Array] = parseArray;
      function parseInstances(data) {
        const instances = data[File.Instances];
        const instanceTypes = data[File.InstanceTypes];
        const instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
        let rootIndex = instances[instances.length - 1];
        let normalObjectCount = instances.length - instanceTypesLen;
        if (typeof rootIndex !== 'number') {
          rootIndex = 0;
        } else {
          if (rootIndex < 0) {
            rootIndex = ~rootIndex;
          }
          --normalObjectCount;
        }
        let insIndex = 0;
        for (; insIndex < normalObjectCount; ++insIndex) {
          instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
        }
        const classes = data[File.SharedClasses];
        for (let typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
          let type = instanceTypes[typeIndex];
          const eachData = instances[insIndex];
          if (type >= 0) {
            const ctor = classes[type];
            instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
          } else {
            type = ~type;
            const op = ASSIGNMENTS[type];
            op(data, instances, insIndex, eachData);
          }
        }
        return rootIndex;
      }
      function getMissingClass(hasCustomFinder, type, reportMissingClass) {
        if (!hasCustomFinder) {
          reportMissingClass(type);
        }
        return Object;
      }
      function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
        let klass = classFinder(type);
        if (!klass) {
          if (silent) {
            container[index] = ((c, i, t) => function proxy() {
              const actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
              c[i] = actualClass;
              return new actualClass();
            })(container, index, type);
            return;
          } else {
            klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
          }
        }
        container[index] = klass;
      }
      function lookupClasses(data, silent, customFinder, reportMissingClass) {
        const classFinder = customFinder || getClassById;
        const classes = data[File.SharedClasses];
        for (let i = 0; i < classes.length; ++i) {
          const klassLayout = classes[i];
          if (typeof klassLayout !== 'string') {
            {
              if (typeof klassLayout[CLASS_TYPE] === 'function') {
                throw new Error('Can not deserialize the same JSON data again.');
              }
            }
            const type = klassLayout[CLASS_TYPE];
            doLookupClass(classFinder, type, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
          } else {
            doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
          }
        }
      }
      function cacheMasks(data) {
        const masks = data[File.SharedMasks];
        if (masks) {
          const classes = data[File.SharedClasses];
          for (let i = 0; i < masks.length; ++i) {
            const mask = masks[i];
            mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
          }
        }
      }
      function parseResult(data) {
        const instances = data[File.Instances];
        const sharedStrings = data[File.SharedStrings];
        const dependSharedUuids = data[File.SharedUuids];
        const dependObjs = data[File.DependObjs];
        const dependKeys = data[File.DependKeys];
        const dependUuids = data[File.DependUuidIndices];
        for (let i = 0; i < dependObjs.length; ++i) {
          const obj = dependObjs[i];
          if (typeof obj === 'number') {
            dependObjs[i] = instances[obj];
          }
          let key = dependKeys[i];
          if (typeof key === 'number') {
            if (key >= 0) {
              key = sharedStrings[key];
            } else {
              key = ~key;
            }
            dependKeys[i] = key;
          }
          const uuid = dependUuids[i];
          if (typeof uuid === 'number') {
            dependUuids[i] = dependSharedUuids[uuid];
          }
        }
      }
      function isCompiledJson(json) {
        if (Array.isArray(json)) {
          const version = json[0];
          return typeof version === 'number' || version instanceof FileInfo;
        } else {
          return false;
        }
      }
      function initializeDeserializationContext(data, details, options) {
        var _options;
        details.init(data);
        (_options = options) !== null && _options !== void 0 ? _options : options = {};
        let version = data[File.Version];
        let preprocessed = false;
        if (typeof version === 'object') {
          preprocessed = version.preprocessed;
          version = version.version;
        }
        if (version < SUPPORT_MIN_FORMAT_VERSION) {
          throw new Error(getError(5304, version));
        }
        const context = options;
        context._version = version;
        context.result = details;
        data[File.Context] = context;
        if (!preprocessed) {
          var _options$reportMissin;
          lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
          cacheMasks(data);
        }
      }
      function deserialize(data, details, options) {
        if (typeof data === 'string') {
          data = JSON.parse(data);
        }
        let isBorrowedDetails = false;
        if (!details) {
          const borrowedDetails = Details.pool.get();
          assertIsTrue(borrowedDetails, `Can not allocate deserialization details`);
          details = borrowedDetails;
          isBorrowedDetails = true;
        }
        let res;
        if (!isCompiledJson(data)) {
          res = deserializeDynamic(data, details, options);
        } else {
          initializeDeserializationContext(data, details, options);
          const runtimeData = data;
          legacyCC.game._isCloning = true;
          const instances = runtimeData[File.Instances];
          const rootIndex = parseInstances(runtimeData);
          legacyCC.game._isCloning = false;
          if (runtimeData[File.Refs]) {
            dereference(runtimeData[File.Refs], instances, runtimeData[File.SharedStrings]);
          }
          parseResult(runtimeData);
          res = instances[rootIndex];
        }
        if (isBorrowedDetails) {
          Details.pool.put(details);
        }
        return res;
      }
      deserialize.Details = Details;
      deserialize.reportMissingClass = reportMissingClass;
      class FileInfo {
        constructor(version) {
          this.preprocessed = true;
          this.version = version;
        }
      }
      function unpackJSONs(data, classFinder, reportMissingClass) {
        if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
          throw new Error(getError(5304, data[File.Version]));
        }
        lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
        cacheMasks(data);
        const version = new FileInfo(data[File.Version]);
        const sharedUuids = data[File.SharedUuids];
        const sharedStrings = data[File.SharedStrings];
        const sharedClasses = data[File.SharedClasses];
        const sharedMasks = data[File.SharedMasks];
        const sections = data[PACKED_SECTIONS];
        for (let i = 0; i < sections.length; ++i) {
          const section = sections[i];
          section.unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
        }
        return sections;
      }
      function packCustomObjData(type, data, hasNativeDep) {
        return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
      }
      function hasNativeDep(data) {
        const instances = data[File.Instances];
        const rootInfo = instances[instances.length - 1];
        if (typeof rootInfo !== 'number') {
          return false;
        } else {
          return rootInfo < 0;
        }
      }
      function getDependUuidList(json) {
        const sharedUuids = json[File.SharedUuids];
        return json[File.DependUuidIndices].map(index => sharedUuids[index]);
      }
      function parseUuidDependencies(serialized) {
        {
          return getDependUuidList(serialized);
        }
      }
      legacyCC.deserialize = deserialize;

      const dependMap = new WeakMap();
      const nativeDependMap = new WeakSet();
      const onLoadedInvokedMap = new WeakSet();

      function deserializeAsset(json, options) {
        let classFinder;
        {
          classFinder = MissingScript.safeFindClass;
        }
        const tdInfo = Details.pool.get();
        let asset;
        try {
          asset = deserialize(json, tdInfo, {
            classFinder,
            customEnv: options
          });
        } catch (e) {
          error(e);
          Details.pool.put(tdInfo);
          throw e;
        }
        asset._uuid = options.__uuid__ || '';
        const uuidList = tdInfo.uuidList;
        const objList = tdInfo.uuidObjList;
        const propList = tdInfo.uuidPropList;
        const typeList = tdInfo.uuidTypeList || [];
        const depends = [];
        for (let i = 0; i < uuidList.length; i++) {
          const dependUuid = uuidList[i];
          depends[i] = {
            uuid: decodeUuid(dependUuid),
            owner: objList[i],
            prop: propList[i],
            type: getClassById(typeList[i])
          };
        }
        dependMap.set(asset, depends);
        if (asset._native) {
          nativeDependMap.add(asset);
        }
        Details.pool.put(tdInfo);
        return asset;
      }

      class DependUtil {
        static get instance() {
          if (!this._instance) {
            this._instance = new DependUtil();
          }
          return this._instance;
        }
        constructor() {
          this._depends = new Cache();
        }
        init() {
          this._depends.clear();
        }
        getNativeDep(uuid) {
          const depend = this._depends.get(uuid);
          if (depend && depend.nativeDep) {
            return {
              ...depend.nativeDep
            };
          }
          return null;
        }
        getDeps(uuid) {
          if (this._depends.has(uuid)) {
            return this._depends.get(uuid).deps;
          }
          return [];
        }
        getDepsRecursively(uuid) {
          const exclude = Object.create(null);
          const depends = [];
          this._descend(uuid, exclude, depends);
          return depends;
        }
        remove(uuid) {
          this._depends.remove(uuid);
        }
        parse(uuid, json) {
          let out = null;
          if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
            if (this._depends.has(uuid)) {
              return this._depends.get(uuid);
            }
            if (Array.isArray(json) && (!hasNativeDep(json))) {
              out = {
                deps: this._parseDepsFromJson(json)
              };
            } else {
              try {
                const asset = deserializeAsset(json, {
                  __uuid__: uuid
                });
                out = this._parseDepsFromAsset(asset);
                if (out.nativeDep) {
                  out.nativeDep.uuid = uuid;
                }
                parsed.add(`${uuid}@import`, asset);
              } catch (e) {
                files.remove(`${uuid}@import`);
                out = {
                  deps: []
                };
              }
            }
          } else {
            if (this._depends.has(uuid)) {
              out = this._depends.get(uuid);
              if (out.parsedFromExistAsset) {
                return out;
              }
            }
            out = this._parseDepsFromAsset(json);
          }
          this._depends.add(uuid, out);
          return out;
        }
        _parseDepsFromAsset(asset) {
          const out = {
            deps: [],
            parsedFromExistAsset: true
          };
          const deps = dependMap.get(asset);
          assertIsNonNullable(deps);
          for (let i = 0, l = deps.length; i < l; i++) {
            out.deps.push(deps[i].uuid);
          }
          if (nativeDependMap.has(asset)) {
            out.nativeDep = asset._nativeDep;
          }
          return out;
        }
        _parseDepsFromJson(json) {
          const depends = parseUuidDependencies(json);
          depends.forEach((uuid, index) => depends[index] = decodeUuid(uuid));
          return depends;
        }
        _descend(uuid, exclude, depends) {
          const deps = this.getDeps(uuid);
          for (let i = 0; i < deps.length; i++) {
            const depend = deps[i];
            if (!exclude[depend]) {
              exclude[depend] = true;
              depends.push(depend);
              this._descend(depend, exclude, depends);
            }
          }
        }
      }
      DependUtil._instance = void 0;
      var dependUtil = DependUtil.instance;

      const textureBaseProto$1 = jsb.TextureBase.prototype;
      textureBaseProto$1._serialize = function (ctxForExporting) {
        return '';
      };
      textureBaseProto$1._deserialize = function (serializedData, handle) {
        const data = serializedData;
        const fields = data.split(',');
        fields.unshift('');
        if (fields.length >= 5) {
          this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
          this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
        }
        if (fields.length >= 7) {
          this.setMipFilter(parseInt(fields[5]));
          this.setAnisotropy(parseInt(fields[6]));
        }
      };
      textureBaseProto$1._getGFXDevice = function () {
        return deviceManager.gfxDevice;
      };
      textureBaseProto$1._getGFXFormat = function () {
        return this._getGFXPixelFormat(this.format);
      };
      textureBaseProto$1._setGFXFormat = function (format) {
        this.format = format === undefined ? PixelFormat.RGBA8888 : format;
      };
      textureBaseProto$1._getGFXPixelFormat = function (format) {
        if (format === PixelFormat.RGBA_ETC1) {
          format = PixelFormat.RGB_ETC1;
        } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
          format = PixelFormat.RGB_PVRTC_4BPPV1;
        } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
          format = PixelFormat.RGB_PVRTC_2BPPV1;
        }
        return format;
      };
      textureBaseProto$1.createNode = null;
      const TextureBase = jsb.TextureBase;
      TextureBase.Filter = Filter;
      TextureBase.PixelFormat = PixelFormat;
      TextureBase.WrapMode = WrapMode;
      textureBaseProto$1._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._gfxSampler = null;
        this._samplerInfo = null;
        this._textureHash = 0;
        this._registerGFXSamplerUpdatedListener();
      };
      const oldGetGFXSampler = textureBaseProto$1.getGFXSampler;
      textureBaseProto$1.getGFXSampler = function () {
        if (!this._gfxSampler) {
          this._gfxSampler = oldGetGFXSampler.call(this);
        }
        return this._gfxSampler;
      };
      const oldGetHash = textureBaseProto$1.getHash;
      textureBaseProto$1.getHash = function () {
        if (this._textureHash === 0) {
          this._textureHash = oldGetHash.call(this);
        }
        return this._textureHash;
      };
      const oldGetSamplerInfo = textureBaseProto$1.getSamplerInfo;
      textureBaseProto$1.getSamplerInfo = function () {
        if (!this._samplerInfo) {
          this._samplerInfo = oldGetSamplerInfo.call(this);
        }
        return this._samplerInfo;
      };
      const oldDestroy$1 = textureBaseProto$1.destroy;
      textureBaseProto$1.destroy = function () {
        var _cclegacy$director$ro;
        if ((_cclegacy$director$ro = legacyCC.director.root) !== null && _cclegacy$director$ro !== void 0 && _cclegacy$director$ro.batcher2D) {
          legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this.getGFXTexture(), this.getGFXSampler());
        }
        return oldDestroy$1.call(this);
      };
      textureBaseProto$1._onGFXSamplerUpdated = function (gfxSampler, samplerInfo) {
        this._gfxSampler = gfxSampler;
        this._samplerInfo = samplerInfo;
      };
      legacyCC.TextureBase = jsb.TextureBase;
      patch_cc_TextureBase({
        TextureBase,
        Filter,
        WrapMode,
        PixelFormat
      });

      const SimpleTexture = jsb.SimpleTexture;
      const jsbWindow = jsb.window;
      SimpleTexture.Filter = Filter;
      SimpleTexture.PixelFormat = PixelFormat;
      SimpleTexture.WrapMode = WrapMode;
      const simpleTextureProto = jsb.SimpleTexture.prototype;
      const oldUpdateDataFunc = simpleTextureProto.uploadData;
      simpleTextureProto.uploadData = function (source, level = 0, arrayIndex = 0) {
        let data;
        if (source instanceof jsbWindow.HTMLCanvasElement) {
          data = source.data;
        } else if (source instanceof jsbWindow.HTMLImageElement) {
          data = source._data;
        } else if (ArrayBuffer.isView(source)) {
          data = source.buffer;
        }
        oldUpdateDataFunc.call(this, data, level, arrayIndex);
      };
      simpleTextureProto._ctor = function () {
        jsb.TextureBase.prototype._ctor.apply(this, arguments);
        this._gfxTexture = null;
        this._registerListeners();
      };
      const oldGetGFXTexture = simpleTextureProto.getGFXTexture;
      simpleTextureProto.getGFXTexture = function () {
        if (!this._gfxTexture) {
          this._gfxTexture = oldGetGFXTexture.call(this);
        }
        return this._gfxTexture;
      };
      simpleTextureProto._onGFXTextureUpdated = function (gfxTexture) {
        this._gfxTexture = gfxTexture;
      };
      simpleTextureProto._onAfterAssignImage = function (image) {
        if (macro.CLEANUP_IMAGE_CACHE) {
          const deps = dependUtil.getDeps(this._uuid);
          const index = deps.indexOf(image._uuid);
          if (index !== -1) {
            fastRemoveAt$2(deps, index);
            image.decRef();
          }
        }
      };
      patch_cc_SimpleTexture({
        SimpleTexture
      });
      legacyCC.SimpleTexture = jsb.SimpleTexture;

      const texture2DProto = jsb.Texture2D.prototype;
      texture2DProto.createNode = null;
      const Texture2D$1 = exports('Texture2D', jsb.Texture2D);
      Texture2D$1.Filter = Filter;
      Texture2D$1.PixelFormat = PixelFormat;
      Texture2D$1.WrapMode = WrapMode;
      texture2DProto._ctor = function () {
        SimpleTexture.prototype._ctor.apply(this, arguments);
        this._mipmaps = [];
      };
      texture2DProto._serialize = function (ctxForExporting) {
        return null;
      };
      texture2DProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        TextureBase.prototype._deserialize.call(this, data.base, undefined);
        this._mipmaps = new Array(data.mipmaps.length);
        for (let i = 0; i < data.mipmaps.length; ++i) {
          this._mipmaps[i] = new ImageAsset$1();
          if (!data.mipmaps[i]) {
            continue;
          }
          const mipmapUUID = data.mipmaps[i];
          handle.result.push(this._mipmaps, `${i}`, mipmapUUID, getClassId(ImageAsset$1));
        }
      };
      const oldOnLoaded$2 = texture2DProto.onLoaded;
      texture2DProto.onLoaded = function () {
        this.syncMipmapsForJS(this._mipmaps);
        oldOnLoaded$2.call(this);
      };
      Object.defineProperty(texture2DProto, 'image', {
        configurable: true,
        enumerable: true,
        get() {
          return this._mipmaps.length === 0 ? null : this._mipmaps[0];
        },
        set(value) {
          this.mipmaps = value ? [value] : [];
        }
      });
      Object.defineProperty(texture2DProto, 'mipmaps', {
        configurable: true,
        enumerable: true,
        get() {
          return this._mipmaps;
        },
        set(arr) {
          for (let i = 0, len = arr.length; i < len; ++i) {
            arr[i]._syncDataToNative();
          }
          this._mipmaps = arr;
          this.setMipmaps(arr);
        }
      });
      legacyCC.Texture2D = jsb.Texture2D;
      patch_cc_Texture2D({
        Texture2D: Texture2D$1,
        ImageAsset: ImageAsset$1
      });

      const space$1 = 2;
      class Atlas {
        constructor(width, height) {
          this._texture = void 0;
          this._width = void 0;
          this._height = void 0;
          this._x = void 0;
          this._y = void 0;
          this._nexty = void 0;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = void 0;
          this._count = void 0;
          const texture = new DynamicAtlasTexture();
          texture.initWithSize(width, height);
          this._texture = texture;
          this._width = width;
          this._height = height;
          this._x = space$1;
          this._y = space$1;
          this._nexty = space$1;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = [];
          this._count = 0;
        }
        insertSpriteFrame(spriteFrame) {
          const rect = spriteFrame.rect;
          const texture = spriteFrame.texture;
          const info = this._innerTextureInfos[texture.getId()];
          let sx = rect.x;
          let sy = rect.y;
          if (info) {
            sx += info.x;
            sy += info.y;
          } else {
            const width = texture.width;
            const height = texture.height;
            if (this._x + width + space$1 > this._width) {
              this._x = space$1;
              this._y = this._nexty;
            }
            if (this._y + height + space$1 > this._nexty) {
              this._nexty = this._y + height + space$1;
            }
            if (this._nexty > this._height) {
              return null;
            }
            if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
              if (width <= 8 || height <= 8) {
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);
                this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);
                this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
              }
              this._texture.drawTextureAt(texture.image, this._x - 1, this._y);
              this._texture.drawTextureAt(texture.image, this._x + 1, this._y);
              this._texture.drawTextureAt(texture.image, this._x, this._y - 1);
              this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
            }
            this._texture.drawTextureAt(texture.image, this._x, this._y);
            this._innerTextureInfos[texture.getId()] = {
              x: this._x,
              y: this._y,
              texture
            };
            this._count++;
            sx += this._x;
            sy += this._y;
            this._x += width + space$1;
          }
          const frame = {
            x: sx,
            y: sy,
            texture: this._texture
          };
          this._innerSpriteFrames.push(spriteFrame);
          return frame;
        }
        deleteInnerTexture(texture) {
          if (texture && this._innerTextureInfos[texture.getId()]) {
            delete this._innerTextureInfos[texture.getId()];
            this._count--;
          }
        }
        isEmpty() {
          return this._count <= 0;
        }
        reset() {
          this._x = space$1;
          this._y = space$1;
          this._nexty = space$1;
          const frames = this._innerSpriteFrames;
          for (let i = 0, l = frames.length; i < l; i++) {
            const frame = frames[i];
            if (!frame.isValid) {
              continue;
            }
            frame._resetDynamicAtlasFrame();
          }
          this._innerSpriteFrames.length = 0;
          this._innerTextureInfos = {};
        }
        destroy() {
          this.reset();
          this._texture.destroy();
        }
      }
      class DynamicAtlasTexture extends Texture2D$1 {
        initWithSize(width, height, format = PixelFormat.RGBA8888) {
          this.reset({
            width,
            height,
            format
          });
        }
        drawTextureAt(image, x, y) {
          const gfxTexture = this.getGFXTexture();
          if (!image || !gfxTexture) {
            return;
          }
          const gfxDevice = this._getGFXDevice();
          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }
          const region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        }
      }

      const SceneAsset = exports('SceneAsset', jsb.SceneAsset);
      legacyCC.SceneAsset = SceneAsset;
      const sceneAssetProto = SceneAsset.prototype;
      Object.defineProperty(sceneAssetProto, 'scene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._scene) {
            this._scene = this.getScene();
          }
          return this._scene;
        },
        set(v) {
          this._scene = v;
          this.setScene(v);
        }
      });
      sceneAssetProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._scene = null;
      };
      patch_cc_SceneAsset({
        SceneAsset
      });

      deprecateModuleExportedName({
        SystemEventType: {
          newName: 'Input.EventType',
          since: '3.3.0',
          removed: false
        }
      });

      deprecateModuleExportedName({
        SystemEvent: {
          newName: 'Input',
          since: '3.4.0',
          removed: false
        },
        systemEvent: {
          newName: 'input',
          since: '3.4.0',
          removed: false
        }
      });

      class Event {
        constructor(type, bubbles) {
          this.type = void 0;
          this.bubbles = void 0;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = 0;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
          this.type = type;
          this.bubbles = !!bubbles;
        }
        unuse() {
          this.type = Event.NO_TYPE;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = Event.NONE;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
        }
        reuse(type, bubbles) {
          this.type = type;
          this.bubbles = bubbles || false;
        }
        isStopped() {
          return this.propagationStopped || this.propagationImmediateStopped;
        }
        getCurrentTarget() {
          return this.currentTarget;
        }
        getType() {
          return this.type;
        }
      } exports('Event', Event);
      Event.NO_TYPE = 'no_type';
      Event.TOUCH = 'touch';
      Event.MOUSE = 'mouse';
      Event.KEYBOARD = 'keyboard';
      Event.ACCELERATION = 'acceleration';
      Event.NONE = 0;
      Event.CAPTURING_PHASE = 1;
      Event.AT_TARGET = 2;
      Event.BUBBLING_PHASE = 3;
      legacyCC.Event = Event;

      let SystemEventType; exports('SystemEventType', SystemEventType);
      (function (SystemEventType) {
        SystemEventType["TOUCH_START"] = "touch-start";
        SystemEventType["TOUCH_MOVE"] = "touch-move";
        SystemEventType["TOUCH_END"] = "touch-end";
        SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
        SystemEventType["MOUSE_DOWN"] = "mouse-down";
        SystemEventType["MOUSE_MOVE"] = "mouse-move";
        SystemEventType["MOUSE_UP"] = "mouse-up";
        SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
        SystemEventType["MOUSE_ENTER"] = "mouse-enter";
        SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
        SystemEventType["KEY_DOWN"] = "keydown";
        SystemEventType["KEY_UP"] = "keyup";
        SystemEventType["DEVICEMOTION"] = "devicemotion";
        SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
        SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        SystemEventType["SIZE_CHANGED"] = "size-changed";
        SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
        SystemEventType["COLOR_CHANGED"] = "color-changed";
        SystemEventType["CHILD_ADDED"] = "child-added";
        SystemEventType["CHILD_REMOVED"] = "child-removed";
        SystemEventType["PARENT_CHANGED"] = "parent-changed";
        SystemEventType["NODE_DESTROYED"] = "node-destroyed";
        SystemEventType["LAYER_CHANGED"] = "layer-changed";
        SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
      })(SystemEventType || (exports('SystemEventType', SystemEventType = {})));
      let InputEventType;
      (function (InputEventType) {
        InputEventType["TOUCH_START"] = "touch-start";
        InputEventType["TOUCH_MOVE"] = "touch-move";
        InputEventType["TOUCH_END"] = "touch-end";
        InputEventType["TOUCH_CANCEL"] = "touch-cancel";
        InputEventType["MOUSE_DOWN"] = "mouse-down";
        InputEventType["MOUSE_MOVE"] = "mouse-move";
        InputEventType["MOUSE_UP"] = "mouse-up";
        InputEventType["MOUSE_WHEEL"] = "mouse-wheel";
        InputEventType["KEY_DOWN"] = "keydown";
        InputEventType["KEY_PRESSING"] = "key-pressing";
        InputEventType["KEY_UP"] = "keyup";
        InputEventType["DEVICEMOTION"] = "devicemotion";
        InputEventType["GAMEPAD_INPUT"] = "gamepad-input";
        InputEventType["GAMEPAD_CHANGE"] = "gamepad-change";
        InputEventType["HANDLE_INPUT"] = "handle-input";
        InputEventType["HANDLE_POSE_INPUT"] = "handle-pose-input";
        InputEventType["HMD_POSE_INPUT"] = "hmd-pose-input";
        InputEventType["HANDHELD_POSE_INPUT"] = "handheld-pose-input";
      })(InputEventType || (InputEventType = {}));
      legacyCC.SystemEventType = SystemEventType;

      class EventAcceleration extends Event {
        constructor(acc, bubbles) {
          super(SystemEventType.DEVICEMOTION, bubbles);
          this.acc = void 0;
          this.acc = acc;
        }
      } exports('EventAcceleration', EventAcceleration);
      Event.EventAcceleration = EventAcceleration;

      class EventKeyboard extends Event {
        get isPressed() {
          return this._isPressed;
        }
        constructor(keyCode, eventType, bubbles) {
          if (typeof eventType === 'boolean') {
            const isPressed = eventType;
            eventType = isPressed ? SystemEventType.KEY_DOWN : SystemEventType.KEY_UP;
          }
          super(eventType, bubbles);
          this.windowId = void 0;
          this.keyCode = void 0;
          this.rawEvent = void 0;
          this._isPressed = void 0;
          this._isPressed = eventType !== SystemEventType.KEY_UP;
          if (typeof keyCode === 'number') {
            this.keyCode = keyCode;
          } else {
            this.keyCode = keyCode.keyCode;
            this.rawEvent = keyCode;
          }
          this.windowId = 0;
        }
      } exports('EventKeyboard', EventKeyboard);
      Event.EventKeyboard = EventKeyboard;

      class EventMouse extends Event {
        get eventType() {
          return this._eventType;
        }
        constructor(eventType, bubbles, prevLoc, windowId) {
          super(eventType, bubbles);
          this.movementX = 0;
          this.movementY = 0;
          this.windowId = 0;
          this.preventSwallow = false;
          this._eventType = void 0;
          this._button = EventMouse.BUTTON_MISSING;
          this._x = 0;
          this._y = 0;
          this._prevX = 0;
          this._prevY = 0;
          this._scrollX = 0;
          this._scrollY = 0;
          this._eventType = eventType;
          if (prevLoc) {
            this._prevX = prevLoc.x;
            this._prevY = prevLoc.y;
          }
          this.windowId = windowId !== null && windowId !== void 0 ? windowId : this.windowId;
        }
        setScrollData(scrollX, scrollY) {
          this._scrollX = scrollX;
          this._scrollY = scrollY;
        }
        getScrollX() {
          return this._scrollX;
        }
        getScrollY() {
          return this._scrollY;
        }
        setLocation(x, y) {
          this._x = x;
          this._y = y;
        }
        getLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, this._y);
          return out;
        }
        getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
          return out;
        }
        getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x, this._y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._prevX, this._prevY);
          return out;
        }
        getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._prevX, this._prevY);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
          return out;
        }
        getDeltaX() {
          return this._x - this._prevX;
        }
        getDeltaY() {
          return this._y - this._prevY;
        }
        getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
          return out;
        }
        getUIDeltaX() {
          return (this._x - this._prevX) / legacyCC.view.getScaleX();
        }
        getUIDeltaY() {
          return (this._y - this._prevY) / legacyCC.view.getScaleY();
        }
        setButton(button) {
          this._button = button;
        }
        getButton() {
          return this._button;
        }
        getLocationX() {
          return this._x;
        }
        getLocationY() {
          return this._y;
        }
        getUILocationX() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._x - viewport.x) / legacyCC.view.getScaleX();
        }
        getUILocationY() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._y - viewport.y) / legacyCC.view.getScaleY();
        }
      } exports('EventMouse', EventMouse);
      EventMouse.BUTTON_MISSING = -1;
      EventMouse.BUTTON_LEFT = 0;
      EventMouse.BUTTON_RIGHT = 2;
      EventMouse.BUTTON_MIDDLE = 1;
      EventMouse.BUTTON_4 = 3;
      EventMouse.BUTTON_5 = 4;
      EventMouse.BUTTON_6 = 5;
      EventMouse.BUTTON_7 = 6;
      EventMouse.BUTTON_8 = 7;
      Event.EventMouse = EventMouse;

      const _vec2$1 = new Vec2();
      class EventTouch extends Event {
        constructor(changedTouches, bubbles, eventType, touches = []) {
          super(eventType, bubbles);
          this.touch = null;
          this.simulate = false;
          this.windowId = 0;
          this.preventSwallow = false;
          this._eventCode = void 0;
          this._touches = void 0;
          this._allTouches = void 0;
          this._eventCode = eventType;
          this._touches = changedTouches || [];
          this._allTouches = touches;
        }
        getEventCode() {
          return this._eventCode;
        }
        getTouches() {
          return this._touches;
        }
        getAllTouches() {
          return this._allTouches;
        }
        setLocation(x, y) {
          if (this.touch) {
            this.touch.setTouchInfo(this.touch.getID(), x, y);
          }
        }
        getLocation(out) {
          return this.touch ? this.touch.getLocation(out) : new Vec2();
        }
        getUILocation(out) {
          return this.touch ? this.touch.getUILocation(out) : new Vec2();
        }
        getLocationInView(out) {
          return this.touch ? this.touch.getLocationInView(out) : new Vec2();
        }
        getPreviousLocation(out) {
          return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
        }
        getStartLocation(out) {
          return this.touch ? this.touch.getStartLocation(out) : new Vec2();
        }
        getUIStartLocation(out) {
          return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
        }
        getID() {
          return this.touch ? this.touch.getID() : null;
        }
        getDelta(out) {
          return this.touch ? this.touch.getDelta(out) : new Vec2();
        }
        getUIDelta(out) {
          return this.touch ? this.touch.getUIDelta(out) : new Vec2();
        }
        getDeltaX() {
          return this.touch ? this.touch.getDelta(_vec2$1).x : 0;
        }
        getDeltaY() {
          return this.touch ? this.touch.getDelta(_vec2$1).y : 0;
        }
        getLocationX() {
          return this.touch ? this.touch.getLocationX() : 0;
        }
        getLocationY() {
          return this.touch ? this.touch.getLocationY() : 0;
        }
      } exports('EventTouch', EventTouch);
      EventTouch.MAX_TOUCHES = 5;
      Event.EventTouch = EventTouch;

      class EventGamepad extends Event {
        constructor(type, gamepad) {
          super(type, false);
          this.gamepad = void 0;
          this.gamepad = gamepad;
        }
      } exports('EventGamepad', EventGamepad);

      class EventHandle extends Event {
        constructor(eventType, handleInputDevice) {
          super(eventType, false);
          this.handleInputDevice = void 0;
          this.handleInputDevice = handleInputDevice;
        }
      } exports('EventHandle', EventHandle);

      class EventHMD extends Event {
        constructor(eventType, hmdInputDevice) {
          super(eventType, false);
          this.hmdInputDevice = void 0;
          this.hmdInputDevice = hmdInputDevice;
        }
      } exports('EventHMD', EventHMD);

      class EventHandheld extends Event {
        constructor(eventType, handheldInputDevice) {
          super(eventType, false);
          this.handheldInputDevice = void 0;
          this.handheldInputDevice = handheldInputDevice;
        }
      } exports('EventHandheld', EventHandheld);

      class Acceleration {
        constructor(x = 0, y = 0, z = 0, timestamp = 0) {
          this.x = void 0;
          this.y = void 0;
          this.z = void 0;
          this.timestamp = void 0;
          this.x = x;
          this.y = y;
          this.z = z;
          this.timestamp = timestamp;
        }
      } exports('Acceleration', Acceleration);

      let KeyCode; exports('KeyCode', KeyCode);
      (function (KeyCode) {
        KeyCode[KeyCode["NONE"] = 0] = "NONE";
        KeyCode[KeyCode["MOBILE_BACK"] = 6] = "MOBILE_BACK";
        KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
        KeyCode[KeyCode["TAB"] = 9] = "TAB";
        KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
        KeyCode[KeyCode["SHIFT_LEFT"] = 16] = "SHIFT_LEFT";
        KeyCode[KeyCode["CTRL_LEFT"] = 17] = "CTRL_LEFT";
        KeyCode[KeyCode["ALT_LEFT"] = 18] = "ALT_LEFT";
        KeyCode[KeyCode["PAUSE"] = 19] = "PAUSE";
        KeyCode[KeyCode["CAPS_LOCK"] = 20] = "CAPS_LOCK";
        KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
        KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
        KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
        KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
        KeyCode[KeyCode["END"] = 35] = "END";
        KeyCode[KeyCode["HOME"] = 36] = "HOME";
        KeyCode[KeyCode["ARROW_LEFT"] = 37] = "ARROW_LEFT";
        KeyCode[KeyCode["ARROW_UP"] = 38] = "ARROW_UP";
        KeyCode[KeyCode["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
        KeyCode[KeyCode["ARROW_DOWN"] = 40] = "ARROW_DOWN";
        KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
        KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
        KeyCode[KeyCode["DIGIT_0"] = 48] = "DIGIT_0";
        KeyCode[KeyCode["DIGIT_1"] = 49] = "DIGIT_1";
        KeyCode[KeyCode["DIGIT_2"] = 50] = "DIGIT_2";
        KeyCode[KeyCode["DIGIT_3"] = 51] = "DIGIT_3";
        KeyCode[KeyCode["DIGIT_4"] = 52] = "DIGIT_4";
        KeyCode[KeyCode["DIGIT_5"] = 53] = "DIGIT_5";
        KeyCode[KeyCode["DIGIT_6"] = 54] = "DIGIT_6";
        KeyCode[KeyCode["DIGIT_7"] = 55] = "DIGIT_7";
        KeyCode[KeyCode["DIGIT_8"] = 56] = "DIGIT_8";
        KeyCode[KeyCode["DIGIT_9"] = 57] = "DIGIT_9";
        KeyCode[KeyCode["KEY_A"] = 65] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 66] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 67] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 68] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 69] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 70] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 71] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 72] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 73] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 74] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 75] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 76] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 77] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 78] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 79] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 80] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 81] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 82] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 83] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 84] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 85] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 86] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 87] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 88] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 89] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 90] = "KEY_Z";
        KeyCode[KeyCode["NUM_0"] = 96] = "NUM_0";
        KeyCode[KeyCode["NUM_1"] = 97] = "NUM_1";
        KeyCode[KeyCode["NUM_2"] = 98] = "NUM_2";
        KeyCode[KeyCode["NUM_3"] = 99] = "NUM_3";
        KeyCode[KeyCode["NUM_4"] = 100] = "NUM_4";
        KeyCode[KeyCode["NUM_5"] = 101] = "NUM_5";
        KeyCode[KeyCode["NUM_6"] = 102] = "NUM_6";
        KeyCode[KeyCode["NUM_7"] = 103] = "NUM_7";
        KeyCode[KeyCode["NUM_8"] = 104] = "NUM_8";
        KeyCode[KeyCode["NUM_9"] = 105] = "NUM_9";
        KeyCode[KeyCode["NUM_MULTIPLY"] = 106] = "NUM_MULTIPLY";
        KeyCode[KeyCode["NUM_PLUS"] = 107] = "NUM_PLUS";
        KeyCode[KeyCode["NUM_SUBTRACT"] = 109] = "NUM_SUBTRACT";
        KeyCode[KeyCode["NUM_DECIMAL"] = 110] = "NUM_DECIMAL";
        KeyCode[KeyCode["NUM_DIVIDE"] = 111] = "NUM_DIVIDE";
        KeyCode[KeyCode["F1"] = 112] = "F1";
        KeyCode[KeyCode["F2"] = 113] = "F2";
        KeyCode[KeyCode["F3"] = 114] = "F3";
        KeyCode[KeyCode["F4"] = 115] = "F4";
        KeyCode[KeyCode["F5"] = 116] = "F5";
        KeyCode[KeyCode["F6"] = 117] = "F6";
        KeyCode[KeyCode["F7"] = 118] = "F7";
        KeyCode[KeyCode["F8"] = 119] = "F8";
        KeyCode[KeyCode["F9"] = 120] = "F9";
        KeyCode[KeyCode["F10"] = 121] = "F10";
        KeyCode[KeyCode["F11"] = 122] = "F11";
        KeyCode[KeyCode["F12"] = 123] = "F12";
        KeyCode[KeyCode["NUM_LOCK"] = 144] = "NUM_LOCK";
        KeyCode[KeyCode["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
        KeyCode[KeyCode["SEMICOLON"] = 186] = "SEMICOLON";
        KeyCode[KeyCode["EQUAL"] = 187] = "EQUAL";
        KeyCode[KeyCode["COMMA"] = 188] = "COMMA";
        KeyCode[KeyCode["DASH"] = 189] = "DASH";
        KeyCode[KeyCode["PERIOD"] = 190] = "PERIOD";
        KeyCode[KeyCode["SLASH"] = 191] = "SLASH";
        KeyCode[KeyCode["BACK_QUOTE"] = 192] = "BACK_QUOTE";
        KeyCode[KeyCode["BRACKET_LEFT"] = 219] = "BRACKET_LEFT";
        KeyCode[KeyCode["BACKSLASH"] = 220] = "BACKSLASH";
        KeyCode[KeyCode["BRACKET_RIGHT"] = 221] = "BRACKET_RIGHT";
        KeyCode[KeyCode["QUOTE"] = 222] = "QUOTE";
        KeyCode[KeyCode["SHIFT_RIGHT"] = 2000] = "SHIFT_RIGHT";
        KeyCode[KeyCode["CTRL_RIGHT"] = 2001] = "CTRL_RIGHT";
        KeyCode[KeyCode["ALT_RIGHT"] = 2002] = "ALT_RIGHT";
        KeyCode[KeyCode["NUM_ENTER"] = 2003] = "NUM_ENTER";
      })(KeyCode || (exports('KeyCode', KeyCode = {})));

      const _vec2 = new Vec2();
      class Touch {
        get lastModified() {
          return this._lastModified;
        }
        constructor(x, y, id = 0) {
          this._point = new Vec2();
          this._prevPoint = new Vec2();
          this._lastModified = 0;
          this._id = 0;
          this._startPoint = new Vec2();
          this._startPointCaptured = false;
          this.setTouchInfo(id, x, y);
        }
        getLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, this._point.y);
          return out;
        }
        getLocationX() {
          return this._point.x;
        }
        getLocationY() {
          return this._point.y;
        }
        getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, this._point.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getUILocationX() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
        }
        getUILocationY() {
          const viewport = legacyCC.view.getViewportRect();
          return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
        }
        getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, this._prevPoint.y);
          return out;
        }
        getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, this._prevPoint.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, this._startPoint.y);
          return out;
        }
        getUIStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, this._startPoint.y);
          legacyCC.view._convertToUISpace(out);
          return out;
        }
        getDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point);
          out.subtract(this._prevPoint);
          return out;
        }
        getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }
          _vec2.set(this._point);
          _vec2.subtract(this._prevPoint);
          out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
          Vec2.divide(out, _vec2, out);
          return out;
        }
        getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
          return out;
        }
        getPreviousLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
          return out;
        }
        getStartLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
          return out;
        }
        getID() {
          return this._id;
        }
        setTouchInfo(id = 0, x = 0, y = 0) {
          this._prevPoint = this._point;
          this._point = new Vec2(x || 0, y || 0);
          this._id = id;
          if (!this._startPointCaptured) {
            this._startPoint = new Vec2(this._point);
            this._startPointCaptured = true;
          }
        }
        setPoint(x, y) {
          if (typeof x === 'object') {
            this._point.x = x.x;
            this._point.y = x.y;
          } else {
            this._point.x = x || 0;
            this._point.y = y || 0;
          }
          this._lastModified = legacyCC.game.frameStartTime;
        }
        setPrevPoint(x, y) {
          if (typeof x === 'object') {
            this._prevPoint = new Vec2(x.x, x.y);
          } else {
            this._prevPoint = new Vec2(x || 0, y || 0);
          }
          this._lastModified = legacyCC.game.frameStartTime;
        }
        clone() {
          const touchID = this.getID();
          this.getStartLocation(_vec2);
          const clonedTouch = new Touch(_vec2.x, _vec2.y, touchID);
          this.getLocation(_vec2);
          clonedTouch.setPoint(_vec2.x, _vec2.y);
          this.getPreviousLocation(_vec2);
          clonedTouch.setPrevPoint(_vec2);
          return clonedTouch;
        }
      } exports('Touch', Touch);
      legacyCC.Touch = Touch;

      class AccelerometerInputSource {
        constructor() {
          this._intervalInSeconds = 0.2;
          this._intervalId = void 0;
          this._isEnabled = false;
          this._eventTarget = new EventTarget();
          this._didAccelerateFunc = void 0;
          this._didAccelerateFunc = this._didAccelerate.bind(this);
        }
        _didAccelerate() {
          const deviceMotionValue = jsb.device.getDeviceMotionValue();
          let x = deviceMotionValue[3] * 0.1;
          let y = deviceMotionValue[4] * 0.1;
          const z = deviceMotionValue[5] * 0.1;
          const orientation = screenAdapter.orientation;
          const tmpX = x;
          if (orientation === Orientation.LANDSCAPE_RIGHT) {
            x = -y;
            y = tmpX;
          } else if (orientation === Orientation.LANDSCAPE_LEFT) {
            x = y;
            y = -tmpX;
          } else if (orientation === Orientation.PORTRAIT_UPSIDE_DOWN) {
            x = -x;
            y = -y;
          }
          if (systemInfo.os === OS.ANDROID || systemInfo.os === OS.OHOS || systemInfo.os === OS.OPENHARMONY) {
            x = -x;
            y = -y;
          }
          const timestamp = performance.now();
          const acceleration = new Acceleration(x, y, z, timestamp);
          const eventAcceleration = new EventAcceleration(acceleration);
          this._eventTarget.emit(InputEventType.DEVICEMOTION, eventAcceleration);
        }
        start() {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = setInterval(this._didAccelerateFunc, this._intervalInSeconds * 1000);
          jsb.device.setAccelerometerInterval(this._intervalInSeconds);
          jsb.device.setAccelerometerEnabled(true);
          this._isEnabled = true;
        }
        stop() {
          if (this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = undefined;
          }
          jsb.device.setAccelerometerEnabled(false);
          this._isEnabled = false;
        }
        setInterval(intervalInMileseconds) {
          this._intervalInSeconds = intervalInMileseconds / 1000;
          jsb.device.setAccelerometerInterval(this._intervalInSeconds);
          if (this._isEnabled) {
            jsb.device.setAccelerometerEnabled(false);
            jsb.device.setAccelerometerEnabled(true);
          }
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      class InputSource {}
      class InputSourceAxis1D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceAxis2D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceAxis3D extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class InputSourceQuat extends InputSource {
        getValue() {
          throw new Error('Method not implemented.');
        }
      }
      class CompositeInputSourceAxis1D extends InputSourceAxis1D {
        constructor(options) {
          super();
          this.positive = void 0;
          this.negative = void 0;
          this.positive = options.positive;
          this.negative = options.negative;
        }
        getValue() {
          const positiveValue = this.positive.getValue();
          const negativeValue = this.negative.getValue();
          if (Math.abs(positiveValue) > Math.abs(negativeValue)) {
            return positiveValue;
          }
          return -negativeValue;
        }
      }
      class CompositeInputSourceAxis2D extends InputSourceAxis2D {
        constructor(options) {
          super();
          this.up = void 0;
          this.down = void 0;
          this.left = void 0;
          this.right = void 0;
          this.xAxis = void 0;
          this.yAxis = void 0;
          this.up = options.up;
          this.down = options.down;
          this.left = options.left;
          this.right = options.right;
          this.xAxis = new CompositeInputSourceAxis1D({
            positive: this.right,
            negative: this.left
          });
          this.yAxis = new CompositeInputSourceAxis1D({
            positive: this.up,
            negative: this.down
          });
        }
        getValue() {
          return new Vec2(this.xAxis.getValue(), this.yAxis.getValue());
        }
      }
      class InputSourceButton extends InputSourceAxis1D {
        getValue() {
          return super.getValue();
        }
      }
      class InputSourceDpad extends CompositeInputSourceAxis2D {}
      class InputSourceStick extends CompositeInputSourceAxis2D {}
      class InputSourceOrientation extends InputSourceQuat {
        getValue() {
          return super.getValue();
        }
      }
      class InputSourcePosition extends InputSourceAxis3D {
        getValue() {
          return super.getValue();
        }
      }
      class InputSourceTouch extends InputSourceAxis1D {
        getValue() {
          return super.getValue();
        }
      }

      var Button$2;
      (function (Button) {
        Button[Button["BUTTON_SOUTH"] = 0] = "BUTTON_SOUTH";
        Button[Button["BUTTON_EAST"] = 1] = "BUTTON_EAST";
        Button[Button["BUTTON_WEST"] = 2] = "BUTTON_WEST";
        Button[Button["BUTTON_NORTH"] = 3] = "BUTTON_NORTH";
        Button[Button["NS_MINUS"] = 4] = "NS_MINUS";
        Button[Button["NS_PLUS"] = 5] = "NS_PLUS";
        Button[Button["BUTTON_L1"] = 6] = "BUTTON_L1";
        Button[Button["BUTTON_L2"] = 7] = "BUTTON_L2";
        Button[Button["BUTTON_L3"] = 8] = "BUTTON_L3";
        Button[Button["BUTTON_R1"] = 9] = "BUTTON_R1";
        Button[Button["BUTTON_R2"] = 10] = "BUTTON_R2";
        Button[Button["BUTTON_R3"] = 11] = "BUTTON_R3";
        Button[Button["DPAD_UP"] = 12] = "DPAD_UP";
        Button[Button["DPAD_DOWN"] = 13] = "DPAD_DOWN";
        Button[Button["DPAD_LEFT"] = 14] = "DPAD_LEFT";
        Button[Button["DPAD_RIGHT"] = 15] = "DPAD_RIGHT";
        Button[Button["LEFT_STICK_UP"] = 16] = "LEFT_STICK_UP";
        Button[Button["LEFT_STICK_DOWN"] = 17] = "LEFT_STICK_DOWN";
        Button[Button["LEFT_STICK_LEFT"] = 18] = "LEFT_STICK_LEFT";
        Button[Button["LEFT_STICK_RIGHT"] = 19] = "LEFT_STICK_RIGHT";
        Button[Button["RIGHT_STICK_UP"] = 20] = "RIGHT_STICK_UP";
        Button[Button["RIGHT_STICK_DOWN"] = 21] = "RIGHT_STICK_DOWN";
        Button[Button["RIGHT_STICK_LEFT"] = 22] = "RIGHT_STICK_LEFT";
        Button[Button["RIGHT_STICK_RIGHT"] = 23] = "RIGHT_STICK_RIGHT";
        Button[Button["ROKID_MENU"] = 24] = "ROKID_MENU";
        Button[Button["ROKID_START"] = 25] = "ROKID_START";
      })(Button$2 || (Button$2 = {}));
      const _nativeButtonMap$1 = {
        1: Button$2.BUTTON_EAST,
        2: Button$2.BUTTON_SOUTH,
        3: Button$2.BUTTON_NORTH,
        4: Button$2.BUTTON_WEST,
        5: Button$2.BUTTON_L1,
        6: Button$2.BUTTON_R1,
        7: Button$2.NS_MINUS,
        8: Button$2.NS_PLUS,
        9: Button$2.BUTTON_L3,
        10: Button$2.BUTTON_R3,
        11: Button$2.ROKID_MENU,
        12: Button$2.ROKID_START
      };
      class GamepadInputDevice {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonL1() {
          return this._buttonL1;
        }
        get buttonL2() {
          return this._buttonL2;
        }
        get buttonL3() {
          return this._buttonL3;
        }
        get buttonR1() {
          return this._buttonR1;
        }
        get buttonR2() {
          return this._buttonR2;
        }
        get buttonR3() {
          return this._buttonR3;
        }
        get buttonShare() {
          return this._buttonShare;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get dpad() {
          return this._dpad;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        get deviceId() {
          return this._deviceId;
        }
        get connected() {
          return this._connected;
        }
        constructor(deviceId) {
          this._buttonNorth = void 0;
          this._buttonEast = void 0;
          this._buttonWest = void 0;
          this._buttonSouth = void 0;
          this._buttonL1 = void 0;
          this._buttonL2 = void 0;
          this._buttonL3 = void 0;
          this._buttonR1 = void 0;
          this._buttonR2 = void 0;
          this._buttonR3 = void 0;
          this._buttonShare = void 0;
          this._buttonOptions = void 0;
          this._dpad = void 0;
          this._leftStick = void 0;
          this._rightStick = void 0;
          this._buttonStart = void 0;
          this._gripLeft = void 0;
          this._gripRight = void 0;
          this._handLeftPosition = void 0;
          this._handLeftOrientation = void 0;
          this._handRightPosition = void 0;
          this._handRightOrientation = void 0;
          this._aimLeftPosition = void 0;
          this._aimLeftOrientation = void 0;
          this._aimRightPosition = void 0;
          this._aimRightOrientation = void 0;
          this._deviceId = -1;
          this._connected = false;
          this._nativeButtonState = {
            [Button$2.BUTTON_SOUTH]: 0,
            [Button$2.BUTTON_EAST]: 0,
            [Button$2.BUTTON_WEST]: 0,
            [Button$2.BUTTON_NORTH]: 0,
            [Button$2.NS_MINUS]: 0,
            [Button$2.NS_PLUS]: 0,
            [Button$2.BUTTON_L1]: 0,
            [Button$2.BUTTON_L2]: 0,
            [Button$2.BUTTON_L3]: 0,
            [Button$2.BUTTON_R1]: 0,
            [Button$2.BUTTON_R2]: 0,
            [Button$2.BUTTON_R3]: 0,
            [Button$2.DPAD_UP]: 0,
            [Button$2.DPAD_DOWN]: 0,
            [Button$2.DPAD_LEFT]: 0,
            [Button$2.DPAD_RIGHT]: 0,
            [Button$2.LEFT_STICK_UP]: 0,
            [Button$2.LEFT_STICK_DOWN]: 0,
            [Button$2.LEFT_STICK_LEFT]: 0,
            [Button$2.LEFT_STICK_RIGHT]: 0,
            [Button$2.RIGHT_STICK_UP]: 0,
            [Button$2.RIGHT_STICK_DOWN]: 0,
            [Button$2.RIGHT_STICK_LEFT]: 0,
            [Button$2.RIGHT_STICK_RIGHT]: 0,
            [Button$2.ROKID_MENU]: 0,
            [Button$2.ROKID_START]: 0
          };
          this._deviceId = deviceId;
          this._initInputSource();
        }
        static _init() {
          if (!systemInfo.hasFeature(Feature$1.EVENT_GAMEPAD)) {
            return;
          }
          GamepadInputDevice._registerEvent();
        }
        static _on(eventType, cb, target) {
          GamepadInputDevice._eventTarget.on(eventType, cb, target);
        }
        static _removeInputDevice(id) {
          const removeIndex = GamepadInputDevice.all.findIndex(device => device.deviceId === id);
          if (removeIndex === -1) {
            return;
          }
          fastRemoveAt$2(GamepadInputDevice.all, removeIndex);
        }
        static _getInputDevice(id) {
          return GamepadInputDevice.all.find(device => device.deviceId === id);
        }
        static _createInputDevice(id, connected) {
          const device = new GamepadInputDevice(id);
          device._connected = connected;
          GamepadInputDevice.all.push(device);
          return device;
        }
        static _getOrCreateInputDevice(id, connected) {
          let device = GamepadInputDevice._getInputDevice(id);
          if (!device) {
            device = GamepadInputDevice._createInputDevice(id, connected);
          }
          device._connected = connected;
          return device;
        }
        static _registerEvent() {
          jsb.onControllerInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              const device = GamepadInputDevice._getOrCreateInputDevice(info.id, true);
              device._updateNativeButtonState(info);
              GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_INPUT, new EventGamepad(InputEventType.GAMEPAD_INPUT, device));
            }
          };
          jsb.onControllerChange = controllerIds => {
            for (let i = 0; i < controllerIds.length; ++i) {
              const id = controllerIds[i];
              let device = GamepadInputDevice._getInputDevice(id);
              if (!device) {
                device = GamepadInputDevice._createInputDevice(id, true);
                GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_CHANGE, new EventGamepad(InputEventType.GAMEPAD_CHANGE, device));
              }
            }
            const allDevices = GamepadInputDevice.all;
            for (let i = 0; i < allDevices.length; ++i) {
              const device = allDevices[i];
              if (!controllerIds.includes(device.deviceId)) {
                GamepadInputDevice._removeInputDevice(device.deviceId);
                device._connected = false;
                GamepadInputDevice._eventTarget.emit(InputEventType.GAMEPAD_CHANGE, new EventGamepad(InputEventType.GAMEPAD_CHANGE, device));
              }
            }
          };
        }
        _axisToButtons(axisValue) {
          const value = Math.abs(axisValue);
          if (axisValue > 0) {
            return {
              negative: 0,
              positive: value
            };
          } else if (axisValue < 0) {
            return {
              negative: value,
              positive: 0
            };
          } else {
            return {
              negative: 0,
              positive: 0
            };
          }
        }
        _updateNativeButtonState(info) {
          const {
            buttonInfoList,
            axisInfoList
          } = info;
          for (let i = 0; i < buttonInfoList.length; ++i) {
            const buttonInfo = buttonInfoList[i];
            const button = _nativeButtonMap$1[buttonInfo.code];
            this._nativeButtonState[button] = buttonInfo.isPressed ? 1 : 0;
          }
          for (let i = 0; i < axisInfoList.length; ++i) {
            const axisInfo = axisInfoList[i];
            const {
              code,
              value
            } = axisInfo;
            let negativeButton;
            let positiveButton;
            let axisValue;
            switch (code) {
              case 1:
                negativeButton = Button$2.DPAD_LEFT;
                positiveButton = Button$2.DPAD_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 2:
                negativeButton = Button$2.DPAD_DOWN;
                positiveButton = Button$2.DPAD_UP;
                axisValue = this._axisToButtons(value);
                break;
              case 3:
                negativeButton = Button$2.LEFT_STICK_LEFT;
                positiveButton = Button$2.LEFT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 4:
                negativeButton = Button$2.LEFT_STICK_DOWN;
                positiveButton = Button$2.LEFT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              case 5:
                negativeButton = Button$2.RIGHT_STICK_LEFT;
                positiveButton = Button$2.RIGHT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case 6:
                negativeButton = Button$2.RIGHT_STICK_DOWN;
                positiveButton = Button$2.RIGHT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              default:
                if (code === 7) {
                  this._nativeButtonState[Button$2.BUTTON_L2] = value;
                } else if (code === 8) {
                  this._nativeButtonState[Button$2.BUTTON_R2] = value;
                }
                break;
            }
            if (negativeButton && positiveButton && axisValue) {
              this._nativeButtonState[negativeButton] = axisValue.negative;
              this._nativeButtonState[positiveButton] = axisValue.positive;
            }
          }
        }
        _initInputSource() {
          this._buttonNorth = new InputSourceButton();
          this._buttonNorth.getValue = () => this._nativeButtonState[Button$2.BUTTON_NORTH];
          this._buttonEast = new InputSourceButton();
          this._buttonEast.getValue = () => this._nativeButtonState[Button$2.BUTTON_EAST];
          this._buttonWest = new InputSourceButton();
          this._buttonWest.getValue = () => this._nativeButtonState[Button$2.BUTTON_WEST];
          this._buttonSouth = new InputSourceButton();
          this._buttonSouth.getValue = () => this._nativeButtonState[Button$2.BUTTON_SOUTH];
          this._buttonL1 = new InputSourceButton();
          this._buttonL1.getValue = () => this._nativeButtonState[Button$2.BUTTON_L1];
          this._buttonL2 = new InputSourceButton();
          this._buttonL2.getValue = () => this._nativeButtonState[Button$2.BUTTON_L2];
          this._buttonL3 = new InputSourceButton();
          this._buttonL3.getValue = () => this._nativeButtonState[Button$2.BUTTON_L3];
          this._buttonR1 = new InputSourceButton();
          this._buttonR1.getValue = () => this._nativeButtonState[Button$2.BUTTON_R1];
          this._buttonR2 = new InputSourceButton();
          this._buttonR2.getValue = () => this._nativeButtonState[Button$2.BUTTON_R2];
          this._buttonR3 = new InputSourceButton();
          this._buttonR3.getValue = () => this._nativeButtonState[Button$2.BUTTON_R3];
          this._buttonShare = new InputSourceButton();
          this._buttonShare.getValue = () => this._nativeButtonState[Button$2.NS_MINUS];
          this._buttonOptions = new InputSourceButton();
          this._buttonOptions.getValue = () => this._nativeButtonState[Button$2.NS_PLUS] || this._nativeButtonState[Button$2.ROKID_MENU];
          const dpadUp = new InputSourceButton();
          dpadUp.getValue = () => this._nativeButtonState[Button$2.DPAD_UP];
          const dpadDown = new InputSourceButton();
          dpadDown.getValue = () => this._nativeButtonState[Button$2.DPAD_DOWN];
          const dpadLeft = new InputSourceButton();
          dpadLeft.getValue = () => this._nativeButtonState[Button$2.DPAD_LEFT];
          const dpadRight = new InputSourceButton();
          dpadRight.getValue = () => this._nativeButtonState[Button$2.DPAD_RIGHT];
          this._dpad = new InputSourceDpad({
            up: dpadUp,
            down: dpadDown,
            left: dpadLeft,
            right: dpadRight
          });
          const leftStickUp = new InputSourceButton();
          leftStickUp.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_UP];
          const leftStickDown = new InputSourceButton();
          leftStickDown.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_DOWN];
          const leftStickLeft = new InputSourceButton();
          leftStickLeft.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_LEFT];
          const leftStickRight = new InputSourceButton();
          leftStickRight.getValue = () => this._nativeButtonState[Button$2.LEFT_STICK_RIGHT];
          this._leftStick = new InputSourceStick({
            up: leftStickUp,
            down: leftStickDown,
            left: leftStickLeft,
            right: leftStickRight
          });
          const rightStickUp = new InputSourceButton();
          rightStickUp.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_UP];
          const rightStickDown = new InputSourceButton();
          rightStickDown.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_DOWN];
          const rightStickLeft = new InputSourceButton();
          rightStickLeft.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_LEFT];
          const rightStickRight = new InputSourceButton();
          rightStickRight.getValue = () => this._nativeButtonState[Button$2.RIGHT_STICK_RIGHT];
          this._rightStick = new InputSourceStick({
            up: rightStickUp,
            down: rightStickDown,
            left: rightStickLeft,
            right: rightStickRight
          });
          this._buttonStart = new InputSourceButton();
          this._buttonStart.getValue = () => this._nativeButtonState[Button$2.ROKID_START];
          this._gripLeft = new InputSourceButton();
          this._gripLeft.getValue = () => 0;
          this._gripRight = new InputSourceButton();
          this._gripRight.getValue = () => 0;
          this._handLeftPosition = new InputSourcePosition();
          this._handLeftPosition.getValue = () => Vec3.ZERO;
          this._handLeftOrientation = new InputSourceOrientation();
          this._handLeftOrientation.getValue = () => Quat.IDENTITY;
          this._handRightPosition = new InputSourcePosition();
          this._handRightPosition.getValue = () => Vec3.ZERO;
          this._handRightOrientation = new InputSourceOrientation();
          this._handRightOrientation.getValue = () => Quat.IDENTITY;
          this._aimLeftPosition = new InputSourcePosition();
          this._aimLeftPosition.getValue = () => Vec3.ZERO;
          this._aimLeftOrientation = new InputSourceOrientation();
          this._aimLeftOrientation.getValue = () => Quat.IDENTITY;
          this._aimRightPosition = new InputSourcePosition();
          this._aimRightPosition.getValue = () => Vec3.ZERO;
          this._aimRightOrientation = new InputSourceOrientation();
          this._aimRightOrientation.getValue = () => Quat.IDENTITY;
        }
      }
      GamepadInputDevice.all = [];
      GamepadInputDevice.xr = null;
      GamepadInputDevice._eventTarget = new EventTarget();

      var Button$1;
      (function (Button) {
        Button[Button["BUTTON_EAST"] = 0] = "BUTTON_EAST";
        Button[Button["BUTTON_SOUTH"] = 1] = "BUTTON_SOUTH";
        Button[Button["BUTTON_WEST"] = 2] = "BUTTON_WEST";
        Button[Button["BUTTON_NORTH"] = 3] = "BUTTON_NORTH";
        Button[Button["BUTTON_TRIGGER_LEFT"] = 4] = "BUTTON_TRIGGER_LEFT";
        Button[Button["BUTTON_TRIGGER_RIGHT"] = 5] = "BUTTON_TRIGGER_RIGHT";
        Button[Button["TRIGGER_LEFT"] = 6] = "TRIGGER_LEFT";
        Button[Button["TRIGGER_RIGHT"] = 7] = "TRIGGER_RIGHT";
        Button[Button["GRIP_LEFT"] = 8] = "GRIP_LEFT";
        Button[Button["GRIP_RIGHT"] = 9] = "GRIP_RIGHT";
        Button[Button["BUTTON_LEFT_STICK"] = 10] = "BUTTON_LEFT_STICK";
        Button[Button["LEFT_STICK_UP"] = 11] = "LEFT_STICK_UP";
        Button[Button["LEFT_STICK_DOWN"] = 12] = "LEFT_STICK_DOWN";
        Button[Button["LEFT_STICK_LEFT"] = 13] = "LEFT_STICK_LEFT";
        Button[Button["LEFT_STICK_RIGHT"] = 14] = "LEFT_STICK_RIGHT";
        Button[Button["BUTTON_RIGHT_STICK"] = 15] = "BUTTON_RIGHT_STICK";
        Button[Button["RIGHT_STICK_UP"] = 16] = "RIGHT_STICK_UP";
        Button[Button["RIGHT_STICK_DOWN"] = 17] = "RIGHT_STICK_DOWN";
        Button[Button["RIGHT_STICK_LEFT"] = 18] = "RIGHT_STICK_LEFT";
        Button[Button["RIGHT_STICK_RIGHT"] = 19] = "RIGHT_STICK_RIGHT";
        Button[Button["ROKID_MENU"] = 20] = "ROKID_MENU";
        Button[Button["ROKID_START"] = 21] = "ROKID_START";
      })(Button$1 || (Button$1 = {}));
      var Pose$2;
      (function (Pose) {
        Pose[Pose["HAND_LEFT"] = 0] = "HAND_LEFT";
        Pose[Pose["HAND_RIGHT"] = 1] = "HAND_RIGHT";
        Pose[Pose["AIM_LEFT"] = 2] = "AIM_LEFT";
        Pose[Pose["AIM_RIGHT"] = 3] = "AIM_RIGHT";
      })(Pose$2 || (Pose$2 = {}));
      var StickKeyCode;
      (function (StickKeyCode) {
        StickKeyCode[StickKeyCode["UNDEFINE"] = 0] = "UNDEFINE";
        StickKeyCode[StickKeyCode["A"] = 1] = "A";
        StickKeyCode[StickKeyCode["B"] = 2] = "B";
        StickKeyCode[StickKeyCode["X"] = 3] = "X";
        StickKeyCode[StickKeyCode["Y"] = 4] = "Y";
        StickKeyCode[StickKeyCode["L1"] = 5] = "L1";
        StickKeyCode[StickKeyCode["R1"] = 6] = "R1";
        StickKeyCode[StickKeyCode["MINUS"] = 7] = "MINUS";
        StickKeyCode[StickKeyCode["PLUS"] = 8] = "PLUS";
        StickKeyCode[StickKeyCode["L3"] = 9] = "L3";
        StickKeyCode[StickKeyCode["R3"] = 10] = "R3";
        StickKeyCode[StickKeyCode["MENU"] = 11] = "MENU";
        StickKeyCode[StickKeyCode["START"] = 12] = "START";
        StickKeyCode[StickKeyCode["TRIGGER_LEFT"] = 13] = "TRIGGER_LEFT";
        StickKeyCode[StickKeyCode["TRIGGER_RIGHT"] = 14] = "TRIGGER_RIGHT";
      })(StickKeyCode || (StickKeyCode = {}));
      var StickAxisCode;
      (function (StickAxisCode) {
        StickAxisCode[StickAxisCode["UNDEFINE"] = 0] = "UNDEFINE";
        StickAxisCode[StickAxisCode["X"] = 1] = "X";
        StickAxisCode[StickAxisCode["Y"] = 2] = "Y";
        StickAxisCode[StickAxisCode["LEFT_STICK_X"] = 3] = "LEFT_STICK_X";
        StickAxisCode[StickAxisCode["LEFT_STICK_Y"] = 4] = "LEFT_STICK_Y";
        StickAxisCode[StickAxisCode["RIGHT_STICK_X"] = 5] = "RIGHT_STICK_X";
        StickAxisCode[StickAxisCode["RIGHT_STICK_Y"] = 6] = "RIGHT_STICK_Y";
        StickAxisCode[StickAxisCode["L2"] = 7] = "L2";
        StickAxisCode[StickAxisCode["R2"] = 8] = "R2";
        StickAxisCode[StickAxisCode["LEFT_GRIP"] = 9] = "LEFT_GRIP";
        StickAxisCode[StickAxisCode["RIGHT_GRIP"] = 10] = "RIGHT_GRIP";
      })(StickAxisCode || (StickAxisCode = {}));
      var StickTouchCode;
      (function (StickTouchCode) {
        StickTouchCode[StickTouchCode["UNDEFINE"] = 0] = "UNDEFINE";
        StickTouchCode[StickTouchCode["A"] = 1] = "A";
        StickTouchCode[StickTouchCode["B"] = 2] = "B";
        StickTouchCode[StickTouchCode["X"] = 3] = "X";
        StickTouchCode[StickTouchCode["Y"] = 4] = "Y";
        StickTouchCode[StickTouchCode["LEFT_TRIGGER"] = 5] = "LEFT_TRIGGER";
        StickTouchCode[StickTouchCode["RIGHT_TRIGGER"] = 6] = "RIGHT_TRIGGER";
        StickTouchCode[StickTouchCode["LEFT_THUMBSTICK"] = 7] = "LEFT_THUMBSTICK";
        StickTouchCode[StickTouchCode["RIGHT_THUMBSTICK"] = 8] = "RIGHT_THUMBSTICK";
      })(StickTouchCode || (StickTouchCode = {}));
      const _nativeButtonMap = {
        1: Button$1.BUTTON_EAST,
        2: Button$1.BUTTON_SOUTH,
        3: Button$1.BUTTON_NORTH,
        4: Button$1.BUTTON_WEST,
        9: Button$1.BUTTON_LEFT_STICK,
        10: Button$1.BUTTON_RIGHT_STICK,
        11: Button$1.ROKID_MENU,
        12: Button$1.ROKID_START,
        13: Button$1.BUTTON_TRIGGER_LEFT,
        14: Button$1.BUTTON_TRIGGER_RIGHT
      };
      class HandleInputDevice {
        get buttonNorth() {
          return this._buttonNorth;
        }
        get buttonEast() {
          return this._buttonEast;
        }
        get buttonWest() {
          return this._buttonWest;
        }
        get buttonSouth() {
          return this._buttonSouth;
        }
        get buttonTriggerLeft() {
          return this._buttonTriggerLeft;
        }
        get buttonTriggerRight() {
          return this._buttonTriggerRight;
        }
        get triggerLeft() {
          return this._triggerLeft;
        }
        get triggerRight() {
          return this._triggerRight;
        }
        get gripLeft() {
          return this._gripLeft;
        }
        get gripRight() {
          return this._gripRight;
        }
        get leftStick() {
          return this._leftStick;
        }
        get rightStick() {
          return this._rightStick;
        }
        get buttonLeftStick() {
          return this._buttonLeftStick;
        }
        get buttonRightStick() {
          return this._buttonRightStick;
        }
        get buttonOptions() {
          return this._buttonOptions;
        }
        get buttonStart() {
          return this._buttonStart;
        }
        get handLeftPosition() {
          return this._handLeftPosition;
        }
        get handLeftOrientation() {
          return this._handLeftOrientation;
        }
        get handRightPosition() {
          return this._handRightPosition;
        }
        get handRightOrientation() {
          return this._handRightOrientation;
        }
        get aimLeftPosition() {
          return this._aimLeftPosition;
        }
        get aimLeftOrientation() {
          return this._aimLeftOrientation;
        }
        get aimRightPosition() {
          return this._aimRightPosition;
        }
        get aimRightOrientation() {
          return this._aimRightOrientation;
        }
        get touchButtonA() {
          return this._touchButtonA;
        }
        get touchButtonB() {
          return this._touchButtonB;
        }
        get touchButtonX() {
          return this._touchButtonX;
        }
        get touchButtonY() {
          return this._touchButtonY;
        }
        get touchButtonTriggerLeft() {
          return this._touchButtonTriggerLeft;
        }
        get touchButtonTriggerRight() {
          return this._touchButtonTriggerRight;
        }
        get touchButtonThumbStickLeft() {
          return this._touchButtonThumbStickLeft;
        }
        get touchButtonThumbStickRight() {
          return this._touchButtonThumbStickRight;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._buttonNorth = void 0;
          this._buttonEast = void 0;
          this._buttonWest = void 0;
          this._buttonSouth = void 0;
          this._buttonTriggerLeft = void 0;
          this._buttonTriggerRight = void 0;
          this._triggerLeft = void 0;
          this._triggerRight = void 0;
          this._gripLeft = void 0;
          this._gripRight = void 0;
          this._leftStick = void 0;
          this._rightStick = void 0;
          this._buttonLeftStick = void 0;
          this._buttonRightStick = void 0;
          this._buttonOptions = void 0;
          this._buttonStart = void 0;
          this._handLeftPosition = void 0;
          this._handLeftOrientation = void 0;
          this._handRightPosition = void 0;
          this._handRightOrientation = void 0;
          this._aimLeftPosition = void 0;
          this._aimLeftOrientation = void 0;
          this._aimRightPosition = void 0;
          this._aimRightOrientation = void 0;
          this._touchButtonA = void 0;
          this._touchButtonB = void 0;
          this._touchButtonX = void 0;
          this._touchButtonY = void 0;
          this._touchButtonTriggerLeft = void 0;
          this._touchButtonTriggerRight = void 0;
          this._touchButtonThumbStickLeft = void 0;
          this._touchButtonThumbStickRight = void 0;
          this._nativeButtonState = {
            [Button$1.BUTTON_SOUTH]: 0,
            [Button$1.BUTTON_EAST]: 0,
            [Button$1.BUTTON_WEST]: 0,
            [Button$1.BUTTON_NORTH]: 0,
            [Button$1.BUTTON_TRIGGER_LEFT]: 0,
            [Button$1.BUTTON_TRIGGER_RIGHT]: 0,
            [Button$1.TRIGGER_LEFT]: 0,
            [Button$1.TRIGGER_RIGHT]: 0,
            [Button$1.GRIP_LEFT]: 0,
            [Button$1.GRIP_RIGHT]: 0,
            [Button$1.LEFT_STICK_UP]: 0,
            [Button$1.LEFT_STICK_DOWN]: 0,
            [Button$1.LEFT_STICK_LEFT]: 0,
            [Button$1.LEFT_STICK_RIGHT]: 0,
            [Button$1.RIGHT_STICK_UP]: 0,
            [Button$1.RIGHT_STICK_DOWN]: 0,
            [Button$1.RIGHT_STICK_LEFT]: 0,
            [Button$1.RIGHT_STICK_RIGHT]: 0,
            [Button$1.BUTTON_LEFT_STICK]: 0,
            [Button$1.BUTTON_RIGHT_STICK]: 0,
            [Button$1.ROKID_MENU]: 0,
            [Button$1.ROKID_START]: 0
          };
          this._nativeTouchState = {
            [StickTouchCode.UNDEFINE]: 0,
            [StickTouchCode.A]: 0,
            [StickTouchCode.B]: 0,
            [StickTouchCode.X]: 0,
            [StickTouchCode.Y]: 0,
            [StickTouchCode.LEFT_TRIGGER]: 0,
            [StickTouchCode.RIGHT_TRIGGER]: 0,
            [StickTouchCode.LEFT_THUMBSTICK]: 0,
            [StickTouchCode.RIGHT_THUMBSTICK]: 0
          };
          this._nativePoseState = {
            [Pose$2.HAND_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.HAND_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.AIM_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$2.AIM_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHandleInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativeButtonState(info);
              this._eventTarget.emit(InputEventType.HANDLE_INPUT, new EventHandle(InputEventType.HANDLE_INPUT, this));
            }
          };
          jsb.onHandlePoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HANDLE_POSE_INPUT, new EventHandle(InputEventType.HANDLE_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _axisToButtons(axisValue) {
          const value = Math.abs(axisValue);
          if (axisValue > 0) {
            return {
              negative: 0,
              positive: value
            };
          } else if (axisValue < 0) {
            return {
              negative: value,
              positive: 0
            };
          } else {
            return {
              negative: 0,
              positive: 0
            };
          }
        }
        _updateNativeButtonState(info) {
          const {
            buttonInfoList,
            axisInfoList,
            touchInfoList
          } = info;
          for (let i = 0; i < buttonInfoList.length; ++i) {
            const buttonInfo = buttonInfoList[i];
            const button = _nativeButtonMap[buttonInfo.code];
            this._nativeButtonState[button] = buttonInfo.isPressed ? 1 : 0;
          }
          for (let i = 0; i < axisInfoList.length; ++i) {
            const axisInfo = axisInfoList[i];
            const {
              code,
              value
            } = axisInfo;
            let negativeButton;
            let positiveButton;
            let axisValue;
            switch (code) {
              case StickAxisCode.LEFT_STICK_X:
                negativeButton = Button$1.LEFT_STICK_LEFT;
                positiveButton = Button$1.LEFT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case StickAxisCode.LEFT_STICK_Y:
                negativeButton = Button$1.LEFT_STICK_DOWN;
                positiveButton = Button$1.LEFT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              case StickAxisCode.RIGHT_STICK_X:
                negativeButton = Button$1.RIGHT_STICK_LEFT;
                positiveButton = Button$1.RIGHT_STICK_RIGHT;
                axisValue = this._axisToButtons(value);
                break;
              case StickAxisCode.RIGHT_STICK_Y:
                negativeButton = Button$1.RIGHT_STICK_DOWN;
                positiveButton = Button$1.RIGHT_STICK_UP;
                axisValue = this._axisToButtons(value);
                break;
              case StickAxisCode.L2:
                this._nativeButtonState[Button$1.TRIGGER_LEFT] = value;
                break;
              case StickAxisCode.R2:
                this._nativeButtonState[Button$1.TRIGGER_RIGHT] = value;
                break;
              case StickAxisCode.LEFT_GRIP:
                this._nativeButtonState[Button$1.GRIP_LEFT] = value;
                break;
              case StickAxisCode.RIGHT_GRIP:
                this._nativeButtonState[Button$1.GRIP_RIGHT] = value;
                break;
            }
            if (negativeButton && positiveButton && axisValue) {
              this._nativeButtonState[negativeButton] = axisValue.negative;
              this._nativeButtonState[positiveButton] = axisValue.positive;
            }
          }
          if (touchInfoList) {
            for (let i = 0; i < touchInfoList.length; ++i) {
              const touchInfo = touchInfoList[i];
              const {
                code,
                value
              } = touchInfo;
              switch (code) {
                case StickTouchCode.A:
                case StickTouchCode.B:
                case StickTouchCode.X:
                case StickTouchCode.Y:
                case StickTouchCode.LEFT_TRIGGER:
                case StickTouchCode.RIGHT_TRIGGER:
                case StickTouchCode.LEFT_THUMBSTICK:
                case StickTouchCode.RIGHT_THUMBSTICK:
                  this._nativeTouchState[code] = value;
                  break;
              }
            }
          }
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 1:
              this._nativePoseState[Pose$2.HAND_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 2:
              this._nativePoseState[Pose$2.AIM_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 4:
              this._nativePoseState[Pose$2.HAND_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 5:
              this._nativePoseState[Pose$2.AIM_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._buttonNorth = new InputSourceButton();
          this._buttonNorth.getValue = () => this._nativeButtonState[Button$1.BUTTON_NORTH];
          this._buttonEast = new InputSourceButton();
          this._buttonEast.getValue = () => this._nativeButtonState[Button$1.BUTTON_EAST];
          this._buttonWest = new InputSourceButton();
          this._buttonWest.getValue = () => this._nativeButtonState[Button$1.BUTTON_WEST];
          this._buttonSouth = new InputSourceButton();
          this._buttonSouth.getValue = () => this._nativeButtonState[Button$1.BUTTON_SOUTH];
          this._buttonTriggerLeft = new InputSourceButton();
          this._buttonTriggerLeft.getValue = () => this._nativeButtonState[Button$1.BUTTON_TRIGGER_LEFT];
          this._buttonTriggerRight = new InputSourceButton();
          this._buttonTriggerRight.getValue = () => this._nativeButtonState[Button$1.BUTTON_TRIGGER_RIGHT];
          this._triggerLeft = new InputSourceButton();
          this._triggerLeft.getValue = () => this._nativeButtonState[Button$1.TRIGGER_LEFT];
          this._triggerRight = new InputSourceButton();
          this._triggerRight.getValue = () => this._nativeButtonState[Button$1.TRIGGER_RIGHT];
          this._gripLeft = new InputSourceButton();
          this._gripLeft.getValue = () => this._nativeButtonState[Button$1.GRIP_LEFT];
          this._gripRight = new InputSourceButton();
          this._gripRight.getValue = () => this._nativeButtonState[Button$1.GRIP_RIGHT];
          this._buttonLeftStick = new InputSourceButton();
          this._buttonLeftStick.getValue = () => this._nativeButtonState[Button$1.BUTTON_LEFT_STICK];
          const leftStickUp = new InputSourceButton();
          leftStickUp.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_UP];
          const leftStickDown = new InputSourceButton();
          leftStickDown.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_DOWN];
          const leftStickLeft = new InputSourceButton();
          leftStickLeft.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_LEFT];
          const leftStickRight = new InputSourceButton();
          leftStickRight.getValue = () => this._nativeButtonState[Button$1.LEFT_STICK_RIGHT];
          this._leftStick = new InputSourceStick({
            up: leftStickUp,
            down: leftStickDown,
            left: leftStickLeft,
            right: leftStickRight
          });
          this._buttonRightStick = new InputSourceButton();
          this._buttonRightStick.getValue = () => this._nativeButtonState[Button$1.BUTTON_RIGHT_STICK];
          const rightStickUp = new InputSourceButton();
          rightStickUp.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_UP];
          const rightStickDown = new InputSourceButton();
          rightStickDown.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_DOWN];
          const rightStickLeft = new InputSourceButton();
          rightStickLeft.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_LEFT];
          const rightStickRight = new InputSourceButton();
          rightStickRight.getValue = () => this._nativeButtonState[Button$1.RIGHT_STICK_RIGHT];
          this._rightStick = new InputSourceStick({
            up: rightStickUp,
            down: rightStickDown,
            left: rightStickLeft,
            right: rightStickRight
          });
          this._buttonOptions = new InputSourceButton();
          this._buttonOptions.getValue = () => this._nativeButtonState[Button$1.ROKID_MENU];
          this._buttonStart = new InputSourceButton();
          this._buttonStart.getValue = () => this._nativeButtonState[Button$1.ROKID_START];
          this._handLeftPosition = new InputSourcePosition();
          this._handLeftPosition.getValue = () => this._nativePoseState[Pose$2.HAND_LEFT].position;
          this._handLeftOrientation = new InputSourceOrientation();
          this._handLeftOrientation.getValue = () => this._nativePoseState[Pose$2.HAND_LEFT].orientation;
          this._handRightPosition = new InputSourcePosition();
          this._handRightPosition.getValue = () => this._nativePoseState[Pose$2.HAND_RIGHT].position;
          this._handRightOrientation = new InputSourceOrientation();
          this._handRightOrientation.getValue = () => this._nativePoseState[Pose$2.HAND_RIGHT].orientation;
          this._aimLeftPosition = new InputSourcePosition();
          this._aimLeftPosition.getValue = () => this._nativePoseState[Pose$2.AIM_LEFT].position;
          this._aimLeftOrientation = new InputSourceOrientation();
          this._aimLeftOrientation.getValue = () => this._nativePoseState[Pose$2.AIM_LEFT].orientation;
          this._aimRightPosition = new InputSourcePosition();
          this._aimRightPosition.getValue = () => this._nativePoseState[Pose$2.AIM_RIGHT].position;
          this._aimRightOrientation = new InputSourceOrientation();
          this._aimRightOrientation.getValue = () => this._nativePoseState[Pose$2.AIM_RIGHT].orientation;
          this._touchButtonA = new InputSourceTouch();
          this._touchButtonA.getValue = () => this._nativeTouchState[StickTouchCode.A];
          this._touchButtonB = new InputSourceTouch();
          this._touchButtonB.getValue = () => this._nativeTouchState[StickTouchCode.B];
          this._touchButtonX = new InputSourceTouch();
          this._touchButtonX.getValue = () => this._nativeTouchState[StickTouchCode.X];
          this._touchButtonY = new InputSourceTouch();
          this._touchButtonY.getValue = () => this._nativeTouchState[StickTouchCode.Y];
          this._touchButtonTriggerLeft = new InputSourceTouch();
          this._touchButtonTriggerLeft.getValue = () => this._nativeTouchState[StickTouchCode.LEFT_TRIGGER];
          this._touchButtonTriggerRight = new InputSourceTouch();
          this._touchButtonTriggerRight.getValue = () => this._nativeTouchState[StickTouchCode.RIGHT_TRIGGER];
          this._touchButtonThumbStickLeft = new InputSourceTouch();
          this._touchButtonThumbStickLeft.getValue = () => this._nativeTouchState[StickTouchCode.LEFT_THUMBSTICK];
          this._touchButtonThumbStickRight = new InputSourceTouch();
          this._touchButtonThumbStickRight.getValue = () => this._nativeTouchState[StickTouchCode.RIGHT_THUMBSTICK];
        }
      }

      var Pose$1;
      (function (Pose) {
        Pose[Pose["VIEW_LEFT"] = 0] = "VIEW_LEFT";
        Pose[Pose["VIEW_RIGHT"] = 1] = "VIEW_RIGHT";
        Pose[Pose["HEAD_MIDDLE"] = 2] = "HEAD_MIDDLE";
      })(Pose$1 || (Pose$1 = {}));
      class HMDInputDevice {
        get viewLeftPosition() {
          return this._viewLeftPosition;
        }
        get viewLeftOrientation() {
          return this._viewLeftOrientation;
        }
        get viewRightPosition() {
          return this._viewRightPosition;
        }
        get viewRightOrientation() {
          return this._viewRightOrientation;
        }
        get headMiddlePosition() {
          return this._headMiddlePosition;
        }
        get headMiddleOrientation() {
          return this._headMiddleOrientation;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._viewLeftPosition = void 0;
          this._viewLeftOrientation = void 0;
          this._viewRightPosition = void 0;
          this._viewRightOrientation = void 0;
          this._headMiddlePosition = void 0;
          this._headMiddleOrientation = void 0;
          this._nativePoseState = {
            [Pose$1.VIEW_LEFT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$1.VIEW_RIGHT]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            },
            [Pose$1.HEAD_MIDDLE]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHMDPoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HMD_POSE_INPUT, new EventHMD(InputEventType.HMD_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 0:
              this._nativePoseState[Pose$1.VIEW_LEFT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 3:
              this._nativePoseState[Pose$1.VIEW_RIGHT] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
            case 6:
              this._nativePoseState[Pose$1.HEAD_MIDDLE] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._viewLeftPosition = new InputSourcePosition();
          this._viewLeftPosition.getValue = () => this._nativePoseState[Pose$1.VIEW_LEFT].position;
          this._viewLeftOrientation = new InputSourceOrientation();
          this._viewLeftOrientation.getValue = () => this._nativePoseState[Pose$1.VIEW_LEFT].orientation;
          this._viewRightPosition = new InputSourcePosition();
          this._viewRightPosition.getValue = () => this._nativePoseState[Pose$1.VIEW_RIGHT].position;
          this._viewRightOrientation = new InputSourceOrientation();
          this._viewRightOrientation.getValue = () => this._nativePoseState[Pose$1.VIEW_RIGHT].orientation;
          this._headMiddlePosition = new InputSourcePosition();
          this._headMiddlePosition.getValue = () => this._nativePoseState[Pose$1.HEAD_MIDDLE].position;
          this._headMiddleOrientation = new InputSourceOrientation();
          this._headMiddleOrientation.getValue = () => this._nativePoseState[Pose$1.HEAD_MIDDLE].orientation;
        }
      }

      var Pose;
      (function (Pose) {
        Pose[Pose["AR_MOBILE"] = 0] = "AR_MOBILE";
      })(Pose || (Pose = {}));
      class HandheldInputDevice {
        get handheldPosition() {
          return this._handheldPosition;
        }
        get handheldOrientation() {
          return this._handheldOrientation;
        }
        constructor() {
          this._eventTarget = new EventTarget();
          this._handheldPosition = void 0;
          this._handheldOrientation = void 0;
          this._nativePoseState = {
            [Pose.AR_MOBILE]: {
              position: Vec3.ZERO,
              orientation: Quat.IDENTITY
            }
          };
          this._initInputSource();
          this._registerEvent();
        }
        _registerEvent() {
          jsb.onHandheldPoseInput = infoList => {
            for (let i = 0; i < infoList.length; ++i) {
              const info = infoList[i];
              this._updateNativePoseState(info);
            }
            this._eventTarget.emit(InputEventType.HANDHELD_POSE_INPUT, new EventHandheld(InputEventType.HANDHELD_POSE_INPUT, this));
          };
        }
        _on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
        _updateNativePoseState(info) {
          switch (info.code) {
            case 7:
              this._nativePoseState[Pose.AR_MOBILE] = {
                position: new Vec3(info.x, info.y, info.z),
                orientation: new Quat(info.quaternionX, info.quaternionY, info.quaternionZ, info.quaternionW)
              };
              break;
          }
        }
        _initInputSource() {
          this._handheldPosition = new InputSourcePosition();
          this._handheldPosition.getValue = () => this._nativePoseState[Pose.AR_MOBILE].position;
          this._handheldOrientation = new InputSourceOrientation();
          this._handheldOrientation.getValue = () => this._nativePoseState[Pose.AR_MOBILE].orientation;
        }
      }

      const code2KeyCode = {
        Backspace: KeyCode.BACKSPACE,
        Tab: KeyCode.TAB,
        Enter: KeyCode.ENTER,
        ShiftLeft: KeyCode.SHIFT_LEFT,
        ControlLeft: KeyCode.CTRL_LEFT,
        AltLeft: KeyCode.ALT_LEFT,
        ShiftRight: KeyCode.SHIFT_RIGHT,
        ControlRight: KeyCode.CTRL_RIGHT,
        AltRight: KeyCode.ALT_RIGHT,
        Pause: KeyCode.PAUSE,
        CapsLock: KeyCode.CAPS_LOCK,
        Escape: KeyCode.ESCAPE,
        Space: KeyCode.SPACE,
        PageUp: KeyCode.PAGE_UP,
        PageDown: KeyCode.PAGE_DOWN,
        End: KeyCode.END,
        Home: KeyCode.HOME,
        ArrowLeft: KeyCode.ARROW_LEFT,
        ArrowUp: KeyCode.ARROW_UP,
        ArrowRight: KeyCode.ARROW_RIGHT,
        ArrowDown: KeyCode.ARROW_DOWN,
        Insert: KeyCode.INSERT,
        Delete: KeyCode.DELETE,
        Digit0: KeyCode.DIGIT_0,
        Digit1: KeyCode.DIGIT_1,
        Digit2: KeyCode.DIGIT_2,
        Digit3: KeyCode.DIGIT_3,
        Digit4: KeyCode.DIGIT_4,
        Digit5: KeyCode.DIGIT_5,
        Digit6: KeyCode.DIGIT_6,
        Digit7: KeyCode.DIGIT_7,
        Digit8: KeyCode.DIGIT_8,
        Digit9: KeyCode.DIGIT_9,
        KeyA: KeyCode.KEY_A,
        KeyB: KeyCode.KEY_B,
        KeyC: KeyCode.KEY_C,
        KeyD: KeyCode.KEY_D,
        KeyE: KeyCode.KEY_E,
        KeyF: KeyCode.KEY_F,
        KeyG: KeyCode.KEY_G,
        KeyH: KeyCode.KEY_H,
        KeyI: KeyCode.KEY_I,
        KeyJ: KeyCode.KEY_J,
        KeyK: KeyCode.KEY_K,
        KeyL: KeyCode.KEY_L,
        KeyM: KeyCode.KEY_M,
        KeyN: KeyCode.KEY_N,
        KeyO: KeyCode.KEY_O,
        KeyP: KeyCode.KEY_P,
        KeyQ: KeyCode.KEY_Q,
        KeyR: KeyCode.KEY_R,
        KeyS: KeyCode.KEY_S,
        KeyT: KeyCode.KEY_T,
        KeyU: KeyCode.KEY_U,
        KeyV: KeyCode.KEY_V,
        KeyW: KeyCode.KEY_W,
        KeyX: KeyCode.KEY_X,
        KeyY: KeyCode.KEY_Y,
        KeyZ: KeyCode.KEY_Z,
        Numpad0: KeyCode.NUM_0,
        Numpad1: KeyCode.NUM_1,
        Numpad2: KeyCode.NUM_2,
        Numpad3: KeyCode.NUM_3,
        Numpad4: KeyCode.NUM_4,
        Numpad5: KeyCode.NUM_5,
        Numpad6: KeyCode.NUM_6,
        Numpad7: KeyCode.NUM_7,
        Numpad8: KeyCode.NUM_8,
        Numpad9: KeyCode.NUM_9,
        NumpadMultiply: KeyCode.NUM_MULTIPLY,
        NumpadAdd: KeyCode.NUM_PLUS,
        NumpadSubtract: KeyCode.NUM_SUBTRACT,
        NumpadDecimal: KeyCode.NUM_DECIMAL,
        NumpadDivide: KeyCode.NUM_DIVIDE,
        NumpadEnter: KeyCode.NUM_ENTER,
        F1: KeyCode.F1,
        F2: KeyCode.F2,
        F3: KeyCode.F3,
        F4: KeyCode.F4,
        F5: KeyCode.F5,
        F6: KeyCode.F6,
        F7: KeyCode.F7,
        F8: KeyCode.F8,
        F9: KeyCode.F9,
        F10: KeyCode.F10,
        F11: KeyCode.F11,
        F12: KeyCode.F12,
        NumLock: KeyCode.NUM_LOCK,
        ScrollLock: KeyCode.SCROLL_LOCK,
        Semicolon: KeyCode.SEMICOLON,
        Equal: KeyCode.EQUAL,
        Comma: KeyCode.COMMA,
        Minus: KeyCode.DASH,
        Period: KeyCode.PERIOD,
        Slash: KeyCode.SLASH,
        Backquote: KeyCode.BACK_QUOTE,
        BracketLeft: KeyCode.BRACKET_LEFT,
        Backslash: KeyCode.BACKSLASH,
        BracketRight: KeyCode.BRACKET_RIGHT,
        Quote: KeyCode.QUOTE
      };

      const nativeKeyCode2KeyCode = {
        12: KeyCode.NUM_LOCK,
        10048: KeyCode.NUM_0,
        10049: KeyCode.NUM_1,
        10050: KeyCode.NUM_2,
        10051: KeyCode.NUM_3,
        10052: KeyCode.NUM_4,
        10053: KeyCode.NUM_5,
        10054: KeyCode.NUM_6,
        10055: KeyCode.NUM_7,
        10056: KeyCode.NUM_8,
        10057: KeyCode.NUM_9,
        20013: KeyCode.NUM_ENTER,
        20016: KeyCode.SHIFT_RIGHT,
        20017: KeyCode.CTRL_RIGHT,
        20018: KeyCode.ALT_RIGHT
      };
      function getKeyCode(event) {
        if (event.code) {
          if (event.code in code2KeyCode) {
            return code2KeyCode[event.code];
          } else {
            console.error(`Can not find keyCode for code: ${event.code}`);
          }
        }
        return nativeKeyCode2KeyCode[event.keyCode] || event.keyCode;
      }
      class KeyboardInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._keyStateMap = {};
          this._handleKeyboardDown = void 0;
          this._handleKeyboardUp = void 0;
          this._handleKeyboardDown = event => {
            const keyCode = getKeyCode(event);
            if (!this._keyStateMap[keyCode]) {
              const eventKeyDown = this._getInputEvent(event, InputEventType.KEY_DOWN);
              this._eventTarget.emit(InputEventType.KEY_DOWN, eventKeyDown);
            } else {
              const eventKeyPressing = this._getInputEvent(event, InputEventType.KEY_PRESSING);
              this._eventTarget.emit(InputEventType.KEY_PRESSING, eventKeyPressing);
            }
            this._keyStateMap[keyCode] = true;
          };
          this._handleKeyboardUp = event => {
            const keyCode = getKeyCode(event);
            const eventKeyUp = this._getInputEvent(event, InputEventType.KEY_UP);
            this._keyStateMap[keyCode] = false;
            this._eventTarget.emit(InputEventType.KEY_UP, eventKeyUp);
          };
          this._registerEvent();
        }
        dispatchKeyboardDownEvent(nativeKeyboardEvent) {
          this._handleKeyboardDown(nativeKeyboardEvent);
        }
        dispatchKeyboardUpEvent(nativeKeyboardEvent) {
          this._handleKeyboardUp(nativeKeyboardEvent);
        }
        _registerEvent() {
          jsb.onKeyDown = this._handleKeyboardDown;
          jsb.onKeyUp = this._handleKeyboardUp;
        }
        _getInputEvent(event, eventType) {
          const keyCode = getKeyCode(event);
          const eventKeyboard = new EventKeyboard(keyCode, eventType);
          eventKeyboard.windowId = event.windowId;
          return eventKeyboard;
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      class MouseInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._preMousePos = new Vec2();
          this._isPressed = false;
          this._windowManager = void 0;
          this._pointLocked = false;
          this._handleMouseDown = void 0;
          this._handleMouseMove = void 0;
          this._handleMouseUp = void 0;
          this._boundedHandleMouseWheel = void 0;
          this._handleMouseDown = this._createCallback(InputEventType.MOUSE_DOWN);
          this._handleMouseMove = this._createCallback(InputEventType.MOUSE_MOVE);
          this._handleMouseUp = this._createCallback(InputEventType.MOUSE_UP);
          this._boundedHandleMouseWheel = this._handleMouseWheel.bind(this);
          this._registerEvent();
          this._windowManager = jsb.ISystemWindowManager.getInstance();
        }
        dispatchMouseDownEvent(nativeMouseEvent) {
          this._handleMouseDown(nativeMouseEvent);
        }
        dispatchMouseMoveEvent(nativeMouseEvent) {
          this._handleMouseMove(nativeMouseEvent);
        }
        dispatchMouseUpEvent(nativeMouseEvent) {
          this._handleMouseUp(nativeMouseEvent);
        }
        dispatchScrollEvent(nativeMouseEvent) {
          this._boundedHandleMouseWheel(nativeMouseEvent);
        }
        _getLocation(event) {
          const window = this._windowManager.getWindow(event.windowId);
          const windowSize = window.getViewSize();
          const dpr = screenAdapter.devicePixelRatio;
          const x = event.x * dpr;
          const y = windowSize.height - event.y * dpr;
          return new Vec2(x, y);
        }
        _registerEvent() {
          jsb.onMouseDown = this._handleMouseDown;
          jsb.onMouseMove = this._handleMouseMove;
          jsb.onMouseUp = this._handleMouseUp;
          jsb.onMouseWheel = this._boundedHandleMouseWheel;
          jsb.onPointerlockChange = value => {
            this._pointLocked = value;
          };
        }
        _createCallback(eventType) {
          return mouseEvent => {
            const location = this._getLocation(mouseEvent);
            let button = mouseEvent.button;
            switch (eventType) {
              case InputEventType.MOUSE_DOWN:
                this._isPressed = true;
                break;
              case InputEventType.MOUSE_UP:
                this._isPressed = false;
                break;
              case InputEventType.MOUSE_MOVE:
                if (!this._isPressed) {
                  button = EventMouse.BUTTON_MISSING;
                }
                break;
            }
            const eventMouse = new EventMouse(eventType, false, this._preMousePos, mouseEvent.windowId);
            eventMouse.setLocation(location.x, location.y);
            eventMouse.setButton(button);
            const dpr = screenAdapter.devicePixelRatio;
            eventMouse.movementX = typeof mouseEvent.xDelta === 'undefined' ? 0 : mouseEvent.xDelta * dpr;
            eventMouse.movementY = typeof mouseEvent.yDelta === 'undefined' ? 0 : mouseEvent.yDelta * dpr;
            this._preMousePos.set(location.x, location.y);
            this._eventTarget.emit(eventType, eventMouse);
          };
        }
        _handleMouseWheel(mouseEvent) {
          const eventType = InputEventType.MOUSE_WHEEL;
          const location = this._getLocation(mouseEvent);
          const button = mouseEvent.button;
          const eventMouse = new EventMouse(eventType, false, this._preMousePos, mouseEvent.windowId);
          eventMouse.setLocation(location.x, location.y);
          eventMouse.setButton(button);
          eventMouse.movementX = location.x - this._preMousePos.x;
          eventMouse.movementY = this._preMousePos.y - location.y;
          const matchStandardFactor = 120;
          eventMouse.setScrollData(mouseEvent.wheelDeltaX * matchStandardFactor, mouseEvent.wheelDeltaY * matchStandardFactor);
          this._preMousePos.set(location.x, location.y);
          this._eventTarget.emit(eventType, eventMouse);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      const tempVec2 = new Vec2();
      class TouchManager {
        constructor() {
          this._touchMap = void 0;
          this._maxTouches = 8;
          this._touchMap = new Map();
        }
        _createTouch(touchID, x, y) {
          if (this._touchMap.has(touchID)) {
            log('Cannot create the same touch object.');
            return undefined;
          }
          const checkResult = this._checkTouchMapSizeMoreThanMax(touchID);
          if (checkResult) {
            log('The touches is more than MAX_TOUCHES.');
            return undefined;
          }
          const touch = new Touch(x, y, touchID);
          this._touchMap.set(touchID, touch);
          this._updateTouch(touch, x, y);
          return touch;
        }
        releaseTouch(touchID) {
          if (!this._touchMap.has(touchID)) {
            return;
          }
          this._touchMap.delete(touchID);
        }
        getTouch(touchID) {
          return this._touchMap.get(touchID);
        }
        getOrCreateTouch(touchID, x, y) {
          let touch = this.getTouch(touchID);
          if (!touch) {
            touch = this._createTouch(touchID, x, y);
          } else {
            this._updateTouch(touch, x, y);
          }
          return touch;
        }
        getAllTouches() {
          const touches = [];
          this._touchMap.forEach(touch => {
            if (touch) {
              touches.push(touch);
            }
          });
          return touches;
        }
        getTouchCount() {
          return touchManager._touchMap.size;
        }
        _updateTouch(touch, x, y) {
          touch.getLocation(tempVec2);
          touch.setPrevPoint(tempVec2);
          touch.setPoint(x, y);
        }
        _checkTouchMapSizeMoreThanMax(touchID) {
          if (this._touchMap.has(touchID)) {
            return false;
          }
          const maxSize = macro.ENABLE_MULTI_TOUCH ? this._maxTouches : 1;
          if (this._touchMap.size < maxSize) {
            return false;
          }
          const now = performance.now();
          this._touchMap.forEach(touch => {
            if (now - touch.lastModified > macro.TOUCH_TIMEOUT) {
              log(`The touches is more than MAX_TOUCHES, release touch id ${touch.getID()}.`);
              this.releaseTouch(touch.getID());
            }
          });
          return maxSize >= this._touchMap.size;
        }
      }
      const touchManager = new TouchManager();

      class TouchInputSource {
        constructor() {
          this._eventTarget = new EventTarget();
          this._windowManager = void 0;
          this._registerEvent();
          this._windowManager = jsb.ISystemWindowManager.getInstance();
        }
        _registerEvent() {
          jsb.onTouchStart = this._createCallback(InputEventType.TOUCH_START);
          jsb.onTouchMove = this._createCallback(InputEventType.TOUCH_MOVE);
          jsb.onTouchEnd = this._createCallback(InputEventType.TOUCH_END);
          jsb.onTouchCancel = this._createCallback(InputEventType.TOUCH_CANCEL);
        }
        _createCallback(eventType) {
          return (changedTouches, windowId) => {
            const handleTouches = [];
            const length = changedTouches.length;
            const windowSize = this._windowManager.getWindow(windowId).getViewSize();
            for (let i = 0; i < length; ++i) {
              const changedTouch = changedTouches[i];
              const touchID = changedTouch.identifier;
              if (touchID === null) {
                continue;
              }
              const location = this._getLocation(changedTouch, windowSize);
              const touch = touchManager.getOrCreateTouch(touchID, location.x, location.y);
              if (!touch) {
                continue;
              }
              if (eventType === InputEventType.TOUCH_END || eventType === InputEventType.TOUCH_CANCEL) {
                touchManager.releaseTouch(touchID);
              }
              handleTouches.push(touch);
            }
            if (handleTouches.length > 0) {
              const eventTouch = new EventTouch(handleTouches, false, eventType, macro.ENABLE_MULTI_TOUCH ? touchManager.getAllTouches() : handleTouches);
              eventTouch.windowId = windowId;
              this._eventTarget.emit(eventType, eventTouch);
            }
          };
        }
        _getLocation(touch, windowSize) {
          const dpr = screenAdapter.devicePixelRatio;
          const x = touch.clientX * dpr;
          const y = windowSize.height - touch.clientY * dpr;
          return new Vec2(x, y);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        }
      }

      let EventDispatcherPriority;
      (function (EventDispatcherPriority) {
        EventDispatcherPriority[EventDispatcherPriority["GLOBAL"] = 0] = "GLOBAL";
        EventDispatcherPriority[EventDispatcherPriority["UI"] = 1] = "UI";
      })(EventDispatcherPriority || (EventDispatcherPriority = {}));
      class InputEventDispatcher {
        constructor(inputEventTarget) {
          this.priority = EventDispatcherPriority.GLOBAL;
          this._inputEventTarget = void 0;
          this._inputEventTarget = inputEventTarget;
        }
        dispatchEvent(event) {
          this._inputEventTarget.emit(event.type, event);
          return true;
        }
      }
      const pointerEventTypeMap = {
        [InputEventType.MOUSE_DOWN]: InputEventType.TOUCH_START,
        [InputEventType.MOUSE_MOVE]: InputEventType.TOUCH_MOVE,
        [InputEventType.MOUSE_UP]: InputEventType.TOUCH_END
      };
      class Input {
        constructor() {
          this._dispatchImmediately = !NATIVE;
          this._eventTarget = new EventTarget();
          this._touchInput = new TouchInputSource();
          this._mouseInput = new MouseInputSource();
          this._keyboardInput = new KeyboardInputSource();
          this._accelerometerInput = new AccelerometerInputSource();
          this._handleInput = new HandleInputDevice();
          this._hmdInput = new HMDInputDevice();
          this._handheldInput = new HandheldInputDevice();
          this._eventTouchList = [];
          this._eventMouseList = [];
          this._eventKeyboardList = [];
          this._eventAccelerationList = [];
          this._eventGamepadList = [];
          this._eventHandleList = [];
          this._eventHMDList = [];
          this._eventHandheldList = [];
          this._needSimulateTouchMoveEvent = false;
          this._inputEventDispatcher = void 0;
          this._eventDispatcherList = [];
          this._registerEvent();
          this._inputEventDispatcher = new InputEventDispatcher(this._eventTarget);
          this._registerEventDispatcher(this._inputEventDispatcher);
          GamepadInputDevice._init();
        }
        _dispatchMouseDownEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis, _this$_mouseInput;
          (_this$_mouseInput$dis = (_this$_mouseInput = this._mouseInput).dispatchMouseDownEvent) === null || _this$_mouseInput$dis === void 0 ? void 0 : _this$_mouseInput$dis.call(_this$_mouseInput, nativeMouseEvent);
        }
        _dispatchMouseMoveEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis2, _this$_mouseInput2;
          (_this$_mouseInput$dis2 = (_this$_mouseInput2 = this._mouseInput).dispatchMouseMoveEvent) === null || _this$_mouseInput$dis2 === void 0 ? void 0 : _this$_mouseInput$dis2.call(_this$_mouseInput2, nativeMouseEvent);
        }
        _dispatchMouseUpEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis3, _this$_mouseInput3;
          (_this$_mouseInput$dis3 = (_this$_mouseInput3 = this._mouseInput).dispatchMouseUpEvent) === null || _this$_mouseInput$dis3 === void 0 ? void 0 : _this$_mouseInput$dis3.call(_this$_mouseInput3, nativeMouseEvent);
        }
        _dispatchMouseScrollEvent(nativeMouseEvent) {
          var _this$_mouseInput$dis4, _this$_mouseInput4;
          (_this$_mouseInput$dis4 = (_this$_mouseInput4 = this._mouseInput).dispatchScrollEvent) === null || _this$_mouseInput$dis4 === void 0 ? void 0 : _this$_mouseInput$dis4.call(_this$_mouseInput4, nativeMouseEvent);
        }
        _dispatchKeyboardDownEvent(nativeKeyboardEvent) {
          var _this$_keyboardInput$, _this$_keyboardInput;
          (_this$_keyboardInput$ = (_this$_keyboardInput = this._keyboardInput).dispatchKeyboardDownEvent) === null || _this$_keyboardInput$ === void 0 ? void 0 : _this$_keyboardInput$.call(_this$_keyboardInput, nativeKeyboardEvent);
        }
        _dispatchKeyboardUpEvent(nativeKeyboardEvent) {
          var _this$_keyboardInput$2, _this$_keyboardInput2;
          (_this$_keyboardInput$2 = (_this$_keyboardInput2 = this._keyboardInput).dispatchKeyboardUpEvent) === null || _this$_keyboardInput$2 === void 0 ? void 0 : _this$_keyboardInput$2.call(_this$_keyboardInput2, nativeKeyboardEvent);
        }
        on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
          return callback;
        }
        once(eventType, callback, target) {
          this._eventTarget.once(eventType, callback, target);
          return callback;
        }
        off(eventType, callback, target) {
          this._eventTarget.off(eventType, callback, target);
        }
        getTouch(touchID) {
          return touchManager.getTouch(touchID);
        }
        getAllTouches() {
          return touchManager.getAllTouches();
        }
        getTouchCount() {
          return touchManager.getTouchCount();
        }
        setAccelerometerEnabled(isEnable) {
          if (isEnable) {
            this._accelerometerInput.start();
          } else {
            this._accelerometerInput.stop();
          }
        }
        setAccelerometerInterval(intervalInMileSeconds) {
          this._accelerometerInput.setInterval(intervalInMileSeconds);
        }
        _simulateEventTouch(eventMouse) {
          const eventType = pointerEventTypeMap[eventMouse.type];
          const touchID = 0;
          const touch = touchManager.getOrCreateTouch(touchID, eventMouse.getLocationX(), eventMouse.getLocationY());
          if (!touch) {
            return;
          }
          const changedTouches = [touch];
          const eventTouch = new EventTouch(changedTouches, false, eventType, eventType === InputEventType.TOUCH_END ? [] : changedTouches);
          eventTouch.windowId = eventMouse.windowId;
          if (eventType === InputEventType.TOUCH_END) {
            touchManager.releaseTouch(touchID);
          }
          this._dispatchOrPushEventTouch(eventTouch, this._eventTouchList);
        }
        _registerEventDispatcher(eventDispatcher) {
          this._eventDispatcherList.push(eventDispatcher);
          this._eventDispatcherList.sort((a, b) => b.priority - a.priority);
        }
        _emitEvent(event) {
          const length = this._eventDispatcherList.length;
          for (let i = 0; i < length; ++i) {
            const dispatcher = this._eventDispatcherList[i];
            try {
              if (!dispatcher.dispatchEvent(event)) {
                break;
              }
            } catch (e) {
              this._clearEvents();
              throw e;
            }
          }
        }
        _registerEvent() {
          if (sys.hasFeature(sys.Feature.INPUT_TOUCH)) {
            const eventTouchList = this._eventTouchList;
            this._touchInput.on(InputEventType.TOUCH_START, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_MOVE, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_END, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
            this._touchInput.on(InputEventType.TOUCH_CANCEL, event => {
              this._dispatchOrPushEventTouch(event, eventTouchList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_MOUSE)) {
            const eventMouseList = this._eventMouseList;
            this._mouseInput.on(InputEventType.MOUSE_DOWN, event => {
              this._needSimulateTouchMoveEvent = true;
              this._simulateEventTouch(event);
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_MOVE, event => {
              if (this._needSimulateTouchMoveEvent) {
                this._simulateEventTouch(event);
              }
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_UP, event => {
              this._needSimulateTouchMoveEvent = false;
              this._simulateEventTouch(event);
              this._dispatchOrPushEvent(event, eventMouseList);
            });
            this._mouseInput.on(InputEventType.MOUSE_WHEEL, event => {
              this._dispatchOrPushEvent(event, eventMouseList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_KEYBOARD)) {
            const eventKeyboardList = this._eventKeyboardList;
            this._keyboardInput.on(InputEventType.KEY_DOWN, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
            this._keyboardInput.on(InputEventType.KEY_PRESSING, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
            this._keyboardInput.on(InputEventType.KEY_UP, event => {
              this._dispatchOrPushEvent(event, eventKeyboardList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_ACCELEROMETER)) {
            const eventAccelerationList = this._eventAccelerationList;
            this._accelerometerInput.on(InputEventType.DEVICEMOTION, event => {
              this._dispatchOrPushEvent(event, eventAccelerationList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_GAMEPAD)) {
            const eventGamepadList = this._eventGamepadList;
            GamepadInputDevice._on(InputEventType.GAMEPAD_CHANGE, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
            GamepadInputDevice._on(InputEventType.GAMEPAD_INPUT, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
            GamepadInputDevice._on(InputEventType.HANDLE_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventGamepadList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HANDLE)) {
            const eventHandleList = this._eventHandleList;
            this._handleInput._on(InputEventType.HANDLE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandleList);
            });
            this._handleInput._on(InputEventType.HANDLE_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandleList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HMD)) {
            const eventHMDList = this._eventHMDList;
            this._hmdInput._on(InputEventType.HMD_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHMDList);
            });
          }
          if (sys.hasFeature(sys.Feature.EVENT_HANDHELD)) {
            const eventHandheldList = this._eventHandheldList;
            this._handheldInput._on(InputEventType.HANDHELD_POSE_INPUT, event => {
              this._dispatchOrPushEvent(event, eventHandheldList);
            });
          }
        }
        _clearEvents() {
          this._eventMouseList.length = 0;
          this._eventTouchList.length = 0;
          this._eventKeyboardList.length = 0;
          this._eventAccelerationList.length = 0;
          this._eventGamepadList.length = 0;
          this._eventHandleList.length = 0;
          this._eventHMDList.length = 0;
        }
        _dispatchOrPushEvent(event, eventList) {
          if (this._dispatchImmediately) {
            this._emitEvent(event);
          } else {
            eventList.push(event);
          }
        }
        _dispatchOrPushEventTouch(eventTouch, touchEventList) {
          if (this._dispatchImmediately) {
            const touches = eventTouch.getTouches();
            const touchesLength = touches.length;
            for (let i = 0; i < touchesLength; ++i) {
              eventTouch.touch = touches[i];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;
              this._emitEvent(eventTouch);
            }
          } else {
            touchEventList.push(eventTouch);
          }
        }
        _frameDispatchEvents() {
          const eventHMDList = this._eventHMDList;
          for (let i = 0, length = eventHMDList.length; i < length; ++i) {
            const eventHMD = eventHMDList[i];
            this._emitEvent(eventHMD);
          }
          const eventHandheldList = this._eventHandheldList;
          for (let i = 0, length = eventHandheldList.length; i < length; ++i) {
            const eventHandheld = eventHandheldList[i];
            this._emitEvent(eventHandheld);
          }
          const eventMouseList = this._eventMouseList;
          for (let i = 0, length = eventMouseList.length; i < length; ++i) {
            const eventMouse = eventMouseList[i];
            this._emitEvent(eventMouse);
          }
          const eventTouchList = this._eventTouchList;
          for (let i = 0, length = eventTouchList.length; i < length; ++i) {
            const eventTouch = eventTouchList[i];
            const touches = eventTouch.getTouches();
            const touchesLength = touches.length;
            for (let j = 0; j < touchesLength; ++j) {
              eventTouch.touch = touches[j];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;
              this._emitEvent(eventTouch);
            }
          }
          const eventKeyboardList = this._eventKeyboardList;
          for (let i = 0, length = eventKeyboardList.length; i < length; ++i) {
            const eventKeyboard = eventKeyboardList[i];
            this._emitEvent(eventKeyboard);
          }
          const eventAccelerationList = this._eventAccelerationList;
          for (let i = 0, length = eventAccelerationList.length; i < length; ++i) {
            const eventAcceleration = eventAccelerationList[i];
            this._emitEvent(eventAcceleration);
          }
          const eventGamepadList = this._eventGamepadList;
          for (let i = 0, length = eventGamepadList.length; i < length; ++i) {
            const eventGamepad = eventGamepadList[i];
            this._emitEvent(eventGamepad);
          }
          const eventHandleList = this._eventHandleList;
          for (let i = 0, length = eventHandleList.length; i < length; ++i) {
            const eventHandle = eventHandleList[i];
            this._emitEvent(eventHandle);
          }
          this._clearEvents();
        }
      } exports('Input', Input);
      Input.EventType = InputEventType;
      const input = exports('input', new Input());

      class SystemEvent extends EventTarget {
        constructor() {
          super();
          input.on(InputEventType.MOUSE_DOWN, e => {
            this.emit(SystemEventType.MOUSE_DOWN, e);
          });
          input.on(InputEventType.MOUSE_MOVE, e => {
            this.emit(SystemEventType.MOUSE_MOVE, e);
          });
          input.on(InputEventType.MOUSE_UP, e => {
            this.emit(SystemEventType.MOUSE_UP, e);
          });
          input.on(InputEventType.MOUSE_WHEEL, e => {
            this.emit(SystemEventType.MOUSE_WHEEL, e);
          });
          input.on(InputEventType.TOUCH_START, e => {
            this.emit(SystemEventType.TOUCH_START, e.touch, e);
          });
          input.on(InputEventType.TOUCH_MOVE, e => {
            this.emit(SystemEventType.TOUCH_MOVE, e.touch, e);
          });
          input.on(InputEventType.TOUCH_END, e => {
            this.emit(SystemEventType.TOUCH_END, e.touch, e);
          });
          input.on(InputEventType.TOUCH_CANCEL, e => {
            this.emit(SystemEventType.TOUCH_CANCEL, e.touch, e);
          });
          input.on(InputEventType.KEY_DOWN, e => {
            this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_PRESSING, e => {
            this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_UP, e => {
            this.emit(SystemEventType.KEY_UP, e);
          });
          input.on(InputEventType.DEVICEMOTION, e => {
            this.emit(SystemEventType.DEVICEMOTION, e);
          });
        }
        setAccelerometerEnabled(isEnabled) {
          input.setAccelerometerEnabled(isEnabled);
        }
        setAccelerometerInterval(interval) {
          input.setAccelerometerInterval(interval);
        }
        on(type, callback, target, once) {
          super.on(type, callback, target, once);
          return callback;
        }
        off(type, callback, target) {
          super.off(type, callback, target);
        }
      } exports('SystemEvent', SystemEvent);
      SystemEvent.EventType = SystemEventType;
      legacyCC.SystemEvent = SystemEvent;
      const systemEvent = exports('systemEvent', new SystemEvent());
      legacyCC.systemEvent = systemEvent;

      replaceProperty(SystemEventType, 'Node.EventType', [{
        name: 'POSITION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'ROTATION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'SCALE_PART',
        newName: 'TRANSFORM_CHANGED'
      }]);
      replaceProperty(Event, 'Event', [{
        name: 'ACCELERATION',
        newName: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(Event, 'Event', [{
        name: 'TOUCH',
        suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
      }, {
        name: 'MOUSE',
        suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
      }, {
        name: 'KEYBOARD',
        suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
      }]);
      replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(item => ({
        name: item,
        newName: `MOUSE_${item}`,
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      })));
      replaceProperty(EventMouse, 'EventMouse', [{
        name: 'SCROLL',
        newName: 'MOUSE_WHEEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
        name: 'eventType',
        suggest: 'please use EventMouse.prototype.type instead'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'BEGAN',
        newName: 'TOUCH_START',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'MOVED',
        newName: 'TOUCH_MOVE',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'ENDED',
        newName: 'TOUCH_END',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'CANCELLED',
        newName: 'TOUCH_CANCEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getEventCode',
        suggest: 'please use EventTouch.prototype.type instead'
      }]);
      replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getUILocationInView',
        newName: 'getLocationInView',
        target: EventTouch,
        targetName: 'EventTouch'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(item => ({
        name: item
      })));
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'shift',
        suggest: 'please use KeyCode.SHIFT_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'ctrl',
        suggest: 'please use KeyCode.CTRL_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'alt',
        suggest: 'please use KeyCode.ALT_LEFT instead'
      }]);
      markAsWarning(macro, 'macro', [{
        name: 'KEY',
        suggest: 'please use KeyCode instead'
      }]);

      const layerList = {
        NONE: 0,
        IGNORE_RAYCAST: 1 << 20,
        GIZMOS: 1 << 21,
        EDITOR: 1 << 22,
        UI_3D: 1 << 23,
        SCENE_GIZMO: 1 << 24,
        UI_2D: 1 << 25,
        PROFILER: 1 << 28,
        DEFAULT: 1 << 30,
        ALL: 0xffffffff
      };
      class Layers {
        static init() {
          const userLayers = settings.querySettings(Settings.Category.ENGINE, 'customLayers');
          if (!userLayers) return;
          for (let i = 0; i < userLayers.length; i++) {
            const layer = userLayers[i];
            Layers.addLayer(layer.name, layer.bit);
          }
        }
        static makeMaskInclude(includes) {
          let mask = 0;
          for (const inc of includes) {
            mask |= inc;
          }
          return mask;
        }
        static makeMaskExclude(excludes) {
          return ~Layers.makeMaskInclude(excludes);
        }
        static addLayer(name, bitNum) {
          if (bitNum === undefined) {
            console.warn('bitNum can\'t be undefined');
            return;
          }
          if (bitNum > 19 || bitNum < 0) {
            console.warn('maximum layers reached.');
            return;
          }
          const val = 1 << bitNum;
          assertIsTrue(!Layers.Enum[name], getError(2104, name));
          Layers.Enum[name] = val;
          value(Layers.Enum, String(val), name);
          Layers.BitMask[name] = val;
          value(Layers.BitMask, String(val), name);
          BitMask.update(Layers.BitMask);
          Enum.update(Layers.Enum);
        }
        static deleteLayer(bitNum) {
          if (bitNum > 19 || bitNum < 0) {
            console.warn('do not change buildin layers.');
            return;
          }
          const val = 1 << bitNum;
          delete Layers.Enum[Layers.Enum[val]];
          delete Layers.Enum[val];
          delete Layers.BitMask[Layers.BitMask[val]];
          delete Layers.BitMask[val];
          BitMask.update(Layers.BitMask);
          Enum.update(Layers.Enum);
        }
        static nameToLayer(name) {
          if (name === undefined) {
            console.warn('name can\'t be undefined');
            return -1;
          }
          return log2(Layers.Enum[name]);
        }
        static layerToName(bitNum) {
          if (bitNum > 31 || bitNum < 0) {
            console.warn('Unable to access unknown layer.');
            return '';
          }
          return Layers.Enum[1 << bitNum];
        }
      } exports('Layers', Layers);
      Layers.Enum = Enum(layerList);
      Layers.BitMask = BitMask({
        ...layerList
      });
      legacyCC.Layers = Layers;

      var _class$1D, _class2$1u, _class3$D, _class4$8, _class5$9, _class6$2, _class7$4, _class8$4, _class10$2, _class11$2, _class12, _class13$2, _class14$2, _class15;
      const PIPELINE_FLOW_MAIN = 'MainFlow';
      const PIPELINE_FLOW_FORWARD = 'ForwardFlow';
      const PIPELINE_FLOW_SHADOW = 'ShadowFlow';
      const PIPELINE_FLOW_SMAA = 'SMAAFlow';
      const PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
      let RenderPassStage;
      (function (RenderPassStage) {
        RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
        RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
      })(RenderPassStage || (RenderPassStage = {}));
      legacyCC.RenderPassStage = RenderPassStage;
      let RenderPriority;
      (function (RenderPriority) {
        RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
        RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
        RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
      })(RenderPriority || (RenderPriority = {}));
      const globalDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      const localDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      let PipelineGlobalBindings;
      (function (PipelineGlobalBindings) {
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_CSM"] = 3] = "UBO_CSM";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 4] = "SAMPLER_SHADOWMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 5] = "SAMPLER_ENVIRONMENT";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_SHADOW_MAP"] = 6] = "SAMPLER_SPOT_SHADOW_MAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_DIFFUSEMAP"] = 7] = "SAMPLER_DIFFUSEMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 8] = "COUNT";
      })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));
      const GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      const GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
      let ModelLocalBindings;
      (function (ModelLocalBindings) {
        ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
        ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
        ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
        ModelLocalBindings[ModelLocalBindings["UBO_UI_LOCAL"] = 5] = "UBO_UI_LOCAL";
        ModelLocalBindings[ModelLocalBindings["UBO_SH"] = 6] = "UBO_SH";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 7] = "SAMPLER_JOINTS";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 8] = "SAMPLER_MORPH_POSITION";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 9] = "SAMPLER_MORPH_NORMAL";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 10] = "SAMPLER_MORPH_TANGENT";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 11] = "SAMPLER_LIGHTMAP";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 12] = "SAMPLER_SPRITE";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 13] = "SAMPLER_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 14] = "STORAGE_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_CUBE"] = 15] = "SAMPLER_REFLECTION_PROBE_CUBE";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_PLANAR"] = 16] = "SAMPLER_REFLECTION_PROBE_PLANAR";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_DATA_MAP"] = 17] = "SAMPLER_REFLECTION_PROBE_DATA_MAP";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION_PROBE_BLEND_CUBE"] = 18] = "SAMPLER_REFLECTION_PROBE_BLEND_CUBE";
        ModelLocalBindings[ModelLocalBindings["COUNT"] = 19] = "COUNT";
      })(ModelLocalBindings || (ModelLocalBindings = {}));
      const LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
      const LOCAL_SAMPLER_COUNT = ModelLocalBindings.STORAGE_REFLECTION - LOCAL_UBO_COUNT;
      const LOCAL_STORAGE_IMAGE_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT - LOCAL_SAMPLER_COUNT;
      let SetIndex;
      (function (SetIndex) {
        SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
        SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
        SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
        SetIndex[SetIndex["COUNT"] = 3] = "COUNT";
      })(SetIndex || (SetIndex = {}));
      const bindingMappingInfo = new BindingMappingInfo([GLOBAL_UBO_COUNT, 0, LOCAL_UBO_COUNT, 0], [GLOBAL_SAMPLER_COUNT, 0, LOCAL_SAMPLER_COUNT, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, LOCAL_STORAGE_IMAGE_COUNT, 0], [0, 0, 0, 0], [0, 2, 1, 3]);
      class UBOGlobal {}
      _class$1D = UBOGlobal;
      UBOGlobal.TIME_OFFSET = 0;
      UBOGlobal.SCREEN_SIZE_OFFSET = _class$1D.TIME_OFFSET + 4;
      UBOGlobal.NATIVE_SIZE_OFFSET = _class$1D.SCREEN_SIZE_OFFSET + 4;
      UBOGlobal.PROBE_INFO_OFFSET = _class$1D.NATIVE_SIZE_OFFSET + 4;
      UBOGlobal.DEBUG_VIEW_MODE_OFFSET = _class$1D.PROBE_INFO_OFFSET + 4;
      UBOGlobal.COUNT = _class$1D.DEBUG_VIEW_MODE_OFFSET + 4;
      UBOGlobal.SIZE = _class$1D.COUNT * 4;
      UBOGlobal.NAME = 'CCGlobal';
      UBOGlobal.BINDING = PipelineGlobalBindings.UBO_GLOBAL;
      UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class$1D.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOGlobal.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class$1D.BINDING, _class$1D.NAME, [new Uniform('cc_time', Type$1.FLOAT4, 1), new Uniform('cc_screenSize', Type$1.FLOAT4, 1), new Uniform('cc_nativeSize', Type$1.FLOAT4, 1), new Uniform('cc_probeInfo', Type$1.FLOAT4, 1), new Uniform('cc_debug_view_mode', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
      class UBOCamera {}
      _class2$1u = UBOCamera;
      UBOCamera.MAT_VIEW_OFFSET = 0;
      UBOCamera.MAT_VIEW_INV_OFFSET = _class2$1u.MAT_VIEW_OFFSET + 16;
      UBOCamera.MAT_PROJ_OFFSET = _class2$1u.MAT_VIEW_INV_OFFSET + 16;
      UBOCamera.MAT_PROJ_INV_OFFSET = _class2$1u.MAT_PROJ_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_OFFSET = _class2$1u.MAT_PROJ_INV_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = _class2$1u.MAT_VIEW_PROJ_OFFSET + 16;
      UBOCamera.CAMERA_POS_OFFSET = _class2$1u.MAT_VIEW_PROJ_INV_OFFSET + 16;
      UBOCamera.SURFACE_TRANSFORM_OFFSET = _class2$1u.CAMERA_POS_OFFSET + 4;
      UBOCamera.SCREEN_SCALE_OFFSET = _class2$1u.SURFACE_TRANSFORM_OFFSET + 4;
      UBOCamera.EXPOSURE_OFFSET = _class2$1u.SCREEN_SCALE_OFFSET + 4;
      UBOCamera.MAIN_LIT_DIR_OFFSET = _class2$1u.EXPOSURE_OFFSET + 4;
      UBOCamera.MAIN_LIT_COLOR_OFFSET = _class2$1u.MAIN_LIT_DIR_OFFSET + 4;
      UBOCamera.AMBIENT_SKY_OFFSET = _class2$1u.MAIN_LIT_COLOR_OFFSET + 4;
      UBOCamera.AMBIENT_GROUND_OFFSET = _class2$1u.AMBIENT_SKY_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_COLOR_OFFSET = _class2$1u.AMBIENT_GROUND_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_BASE_OFFSET = _class2$1u.GLOBAL_FOG_COLOR_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_ADD_OFFSET = _class2$1u.GLOBAL_FOG_BASE_OFFSET + 4;
      UBOCamera.NEAR_FAR_OFFSET = _class2$1u.GLOBAL_FOG_ADD_OFFSET + 4;
      UBOCamera.VIEW_PORT_OFFSET = _class2$1u.NEAR_FAR_OFFSET + 4;
      UBOCamera.COUNT = _class2$1u.VIEW_PORT_OFFSET + 4;
      UBOCamera.SIZE = _class2$1u.COUNT * 4;
      UBOCamera.NAME = 'CCCamera';
      UBOCamera.BINDING = PipelineGlobalBindings.UBO_CAMERA;
      UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(_class2$1u.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOCamera.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class2$1u.BINDING, _class2$1u.NAME, [new Uniform('cc_matView', Type$1.MAT4, 1), new Uniform('cc_matViewInv', Type$1.MAT4, 1), new Uniform('cc_matProj', Type$1.MAT4, 1), new Uniform('cc_matProjInv', Type$1.MAT4, 1), new Uniform('cc_matViewProj', Type$1.MAT4, 1), new Uniform('cc_matViewProjInv', Type$1.MAT4, 1), new Uniform('cc_cameraPos', Type$1.FLOAT4, 1), new Uniform('cc_surfaceTransform', Type$1.FLOAT4, 1), new Uniform('cc_screenScale', Type$1.FLOAT4, 1), new Uniform('cc_exposure', Type$1.FLOAT4, 1), new Uniform('cc_mainLitDir', Type$1.FLOAT4, 1), new Uniform('cc_mainLitColor', Type$1.FLOAT4, 1), new Uniform('cc_ambientSky', Type$1.FLOAT4, 1), new Uniform('cc_ambientGround', Type$1.FLOAT4, 1), new Uniform('cc_fogColor', Type$1.FLOAT4, 1), new Uniform('cc_fogBase', Type$1.FLOAT4, 1), new Uniform('cc_fogAdd', Type$1.FLOAT4, 1), new Uniform('cc_nearFar', Type$1.FLOAT4, 1), new Uniform('cc_viewPort', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
      class UBOShadow {}
      _class3$D = UBOShadow;
      UBOShadow.MAT_LIGHT_VIEW_OFFSET = 0;
      UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = _class3$D.MAT_LIGHT_VIEW_OFFSET + 16;
      UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET = _class3$D.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
      UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET = _class3$D.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_PROJ_INFO_OFFSET = _class3$D.SHADOW_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = _class3$D.SHADOW_PROJ_INFO_OFFSET + 4;
      UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = _class3$D.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
      UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = _class3$D.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
      UBOShadow.SHADOW_COLOR_OFFSET = _class3$D.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
      UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = _class3$D.SHADOW_COLOR_OFFSET + 4;
      UBOShadow.COUNT = _class3$D.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 4;
      UBOShadow.SIZE = _class3$D.COUNT * 4;
      UBOShadow.NAME = 'CCShadow';
      UBOShadow.BINDING = PipelineGlobalBindings.UBO_SHADOW;
      UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(_class3$D.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOShadow.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class3$D.BINDING, _class3$D.NAME, [new Uniform('cc_matLightView', Type$1.MAT4, 1), new Uniform('cc_matLightViewProj', Type$1.MAT4, 1), new Uniform('cc_shadowInvProjDepthInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowProjDepthInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowProjInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowNFLSInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', Type$1.FLOAT4, 1), new Uniform('cc_shadowColor', Type$1.FLOAT4, 1), new Uniform('cc_planarNDInfo', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
      class UBOCSM {}
      _class4$8 = UBOCSM;
      UBOCSM.CSM_LEVEL_COUNT = 4;
      UBOCSM.CSM_VIEW_DIR_0_OFFSET = 0;
      UBOCSM.CSM_VIEW_DIR_1_OFFSET = _class4$8.CSM_VIEW_DIR_0_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.CSM_VIEW_DIR_2_OFFSET = _class4$8.CSM_VIEW_DIR_1_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.CSM_ATLAS_OFFSET = _class4$8.CSM_VIEW_DIR_2_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.MAT_CSM_VIEW_PROJ_OFFSET = _class4$8.CSM_ATLAS_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.CSM_PROJ_DEPTH_INFO_OFFSET = _class4$8.MAT_CSM_VIEW_PROJ_OFFSET + 16 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.CSM_PROJ_INFO_OFFSET = _class4$8.CSM_PROJ_DEPTH_INFO_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.CSM_SPLITS_INFO_OFFSET = _class4$8.CSM_PROJ_INFO_OFFSET + 4 * _class4$8.CSM_LEVEL_COUNT;
      UBOCSM.COUNT = _class4$8.CSM_SPLITS_INFO_OFFSET + 4;
      UBOCSM.SIZE = _class4$8.COUNT * 4;
      UBOCSM.NAME = 'CCCSM';
      UBOCSM.BINDING = PipelineGlobalBindings.UBO_CSM;
      UBOCSM.DESCRIPTOR = new DescriptorSetLayoutBinding(_class4$8.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOCSM.LAYOUT = new UniformBlock(SetIndex.GLOBAL, _class4$8.BINDING, _class4$8.NAME, [new Uniform('cc_csmViewDir0', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir1', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir2', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmAtlas', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_matCSMViewProj', Type$1.MAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmProjDepthInfo', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmProjInfo', Type$1.FLOAT4, _class4$8.CSM_LEVEL_COUNT), new Uniform('cc_csmSplitsInfo', Type$1.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOCSM.NAME] = UBOCSM.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOCSM.BINDING] = UBOCSM.DESCRIPTOR;
      const UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
      const UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      const UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, Type$1.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
      const UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
      const UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
      const UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, Type$1.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
      const UNIFORM_DIFFUSEMAP_NAME = 'cc_diffuseMap';
      const UNIFORM_DIFFUSEMAP_BINDING = PipelineGlobalBindings.SAMPLER_DIFFUSEMAP;
      const UNIFORM_DIFFUSEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_DIFFUSEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_DIFFUSEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_DIFFUSEMAP_BINDING, UNIFORM_DIFFUSEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_DIFFUSEMAP_NAME] = UNIFORM_DIFFUSEMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_DIFFUSEMAP_BINDING] = UNIFORM_DIFFUSEMAP_DESCRIPTOR;
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME = 'cc_spotShadowMap';
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_SHADOW_MAP;
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR;
      class UBOLocal {}
      _class5$9 = UBOLocal;
      UBOLocal.MAT_WORLD_OFFSET = 0;
      UBOLocal.MAT_WORLD_IT_OFFSET = _class5$9.MAT_WORLD_OFFSET + 16;
      UBOLocal.LIGHTINGMAP_UVPARAM = _class5$9.MAT_WORLD_IT_OFFSET + 16;
      UBOLocal.LOCAL_SHADOW_BIAS = _class5$9.LIGHTINGMAP_UVPARAM + 4;
      UBOLocal.REFLECTION_PROBE_DATA1 = _class5$9.LOCAL_SHADOW_BIAS + 4;
      UBOLocal.REFLECTION_PROBE_DATA2 = _class5$9.REFLECTION_PROBE_DATA1 + 4;
      UBOLocal.REFLECTION_PROBE_BLEND_DATA1 = _class5$9.REFLECTION_PROBE_DATA2 + 4;
      UBOLocal.REFLECTION_PROBE_BLEND_DATA2 = _class5$9.REFLECTION_PROBE_BLEND_DATA1 + 4;
      UBOLocal.COUNT = _class5$9.REFLECTION_PROBE_BLEND_DATA2 + 4;
      UBOLocal.SIZE = _class5$9.COUNT * 4;
      UBOLocal.NAME = 'CCLocal';
      UBOLocal.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class5$9.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.FRAGMENT | ShaderStageFlagBit.COMPUTE);
      UBOLocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class5$9.BINDING, _class5$9.NAME, [new Uniform('cc_matWorld', Type$1.MAT4, 1), new Uniform('cc_matWorldIT', Type$1.MAT4, 1), new Uniform('cc_lightingMapUVParam', Type$1.FLOAT4, 1), new Uniform('cc_localShadowBias', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeData1', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeData2', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeBlendData1', Type$1.FLOAT4, 1), new Uniform('cc_reflectionProbeBlendData2', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
      class UBOWorldBound {}
      _class6$2 = UBOWorldBound;
      UBOWorldBound.WORLD_BOUND_CENTER = 0;
      UBOWorldBound.WORLD_BOUND_HALF_EXTENTS = _class6$2.WORLD_BOUND_CENTER + 4;
      UBOWorldBound.COUNT = _class6$2.WORLD_BOUND_HALF_EXTENTS + 4;
      UBOWorldBound.SIZE = _class6$2.COUNT * 4;
      UBOWorldBound.NAME = 'CCWorldBound';
      UBOWorldBound.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOWorldBound.DESCRIPTOR = new DescriptorSetLayoutBinding(_class6$2.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOWorldBound.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class6$2.BINDING, _class6$2.NAME, [new Uniform('cc_worldBoundCenter', Type$1.FLOAT4, 1), new Uniform('cc_worldBoundHalfExtents', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOWorldBound.NAME] = UBOWorldBound.LAYOUT;
      localDescriptorSetLayout.bindings[UBOWorldBound.BINDING] = UBOWorldBound.DESCRIPTOR;
      const INST_MAT_WORLD = 'a_matWorld0';
      const INST_SH = 'a_sh_linear_const_r';
      class UBOLocalBatched {}
      _class7$4 = UBOLocalBatched;
      UBOLocalBatched.BATCHING_COUNT = 10;
      UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
      UBOLocalBatched.COUNT = 16 * _class7$4.BATCHING_COUNT;
      UBOLocalBatched.SIZE = _class7$4.COUNT * 4;
      UBOLocalBatched.NAME = 'CCLocalBatched';
      UBOLocalBatched.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(_class7$4.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOLocalBatched.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class7$4.BINDING, _class7$4.NAME, [new Uniform('cc_matWorlds', Type$1.MAT4, _class7$4.BATCHING_COUNT)], 1);
      localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
      class UBOForwardLight {}
      _class8$4 = UBOForwardLight;
      UBOForwardLight.LIGHTS_PER_PASS = 1;
      UBOForwardLight.LIGHT_POS_OFFSET = 0;
      UBOForwardLight.LIGHT_COLOR_OFFSET = _class8$4.LIGHT_POS_OFFSET + _class8$4.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = _class8$4.LIGHT_COLOR_OFFSET + _class8$4.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_DIR_OFFSET = _class8$4.LIGHT_SIZE_RANGE_ANGLE_OFFSET + _class8$4.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_BOUNDING_SIZE_VS_OFFSET = _class8$4.LIGHT_DIR_OFFSET + _class8$4.LIGHTS_PER_PASS * 4;
      UBOForwardLight.COUNT = _class8$4.LIGHT_BOUNDING_SIZE_VS_OFFSET + _class8$4.LIGHTS_PER_PASS * 4;
      UBOForwardLight.SIZE = _class8$4.COUNT * 4;
      UBOForwardLight.NAME = 'CCForwardLight';
      UBOForwardLight.BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
      UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(_class8$4.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOForwardLight.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class8$4.BINDING, _class8$4.NAME, [new Uniform('cc_lightPos', Type$1.FLOAT4, _class8$4.LIGHTS_PER_PASS), new Uniform('cc_lightColor', Type$1.FLOAT4, _class8$4.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', Type$1.FLOAT4, _class8$4.LIGHTS_PER_PASS), new Uniform('cc_lightDir', Type$1.FLOAT4, _class8$4.LIGHTS_PER_PASS), new Uniform('cc_lightBoundingSizeVS', Type$1.FLOAT4, _class8$4.LIGHTS_PER_PASS)], 1);
      localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
      localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
      class UBODeferredLight {}
      UBODeferredLight.LIGHTS_PER_PASS = 10;
      const JOINT_UNIFORM_CAPACITY = 30;
      class UBOSkinningTexture {}
      _class10$2 = UBOSkinningTexture;
      UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
      UBOSkinningTexture.COUNT = _class10$2.JOINTS_TEXTURE_INFO_OFFSET + 4;
      UBOSkinningTexture.SIZE = _class10$2.COUNT * 4;
      UBOSkinningTexture.NAME = 'CCSkinningTexture';
      UBOSkinningTexture.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(_class10$2.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningTexture.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class10$2.BINDING, _class10$2.NAME, [new Uniform('cc_jointTextureInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
      class UBOSkinningAnimation {}
      _class11$2 = UBOSkinningAnimation;
      UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
      UBOSkinningAnimation.COUNT = _class11$2.JOINTS_ANIM_INFO_OFFSET + 4;
      UBOSkinningAnimation.SIZE = _class11$2.COUNT * 4;
      UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
      UBOSkinningAnimation.BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
      UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(_class11$2.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningAnimation.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class11$2.BINDING, _class11$2.NAME, [new Uniform('cc_jointAnimInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
      const INST_JOINT_ANIM_INFO = 'a_jointAnimInfo';
      class UBOSkinning {
        static get JOINT_UNIFORM_CAPACITY() {
          return UBOSkinning._jointUniformCapacity;
        }
        static get COUNT() {
          return UBOSkinning._count;
        }
        static get SIZE() {
          return UBOSkinning._size;
        }
        static initLayout(capacity) {
          UBOSkinning._jointUniformCapacity = capacity;
          UBOSkinning._count = capacity * 12;
          UBOSkinning._size = UBOSkinning._count * 4;
          UBOSkinning.LAYOUT.members[0].count = capacity * 3;
        }
      }
      _class12 = UBOSkinning;
      UBOSkinning._jointUniformCapacity = 0;
      UBOSkinning._count = 0;
      UBOSkinning._size = 0;
      UBOSkinning.NAME = 'CCSkinning';
      UBOSkinning.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(_class12.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinning.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class12.BINDING, _class12.NAME, [new Uniform('cc_joints', Type$1.FLOAT4, 1)], 1);
      function localDescriptorSetLayout_ResizeMaxJoints(maxCount) {
        UBOSkinning.initLayout(maxCount);
        localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
        localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
      }
      class UBOMorph {}
      _class13$2 = UBOMorph;
      UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
      UBOMorph.OFFSET_OF_WEIGHTS = 0;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * _class13$2.MAX_MORPH_TARGET_COUNT;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = _class13$2.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
      UBOMorph.OFFSET_OF_VERTICES_COUNT = _class13$2.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
      UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(_class13$2.MAX_MORPH_TARGET_COUNT / 4) + 4;
      UBOMorph.SIZE = _class13$2.COUNT_BASE_4_BYTES * 4;
      UBOMorph.NAME = 'CCMorph';
      UBOMorph.BINDING = ModelLocalBindings.UBO_MORPH;
      UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(_class13$2.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOMorph.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class13$2.BINDING, _class13$2.NAME, [new Uniform('cc_displacementWeights', Type$1.FLOAT4, _class13$2.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
      localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
      class UBOUILocal {}
      _class14$2 = UBOUILocal;
      UBOUILocal.NAME = 'CCUILocal';
      UBOUILocal.BINDING = ModelLocalBindings.UBO_UI_LOCAL;
      UBOUILocal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class14$2.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOUILocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class14$2.BINDING, _class14$2.NAME, [new Uniform('cc_local_data', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOUILocal.NAME] = UBOUILocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOUILocal.BINDING] = UBOUILocal.DESCRIPTOR;
      class UBOSH {}
      _class15 = UBOSH;
      UBOSH.SH_LINEAR_CONST_R_OFFSET = 0;
      UBOSH.SH_LINEAR_CONST_G_OFFSET = _class15.SH_LINEAR_CONST_R_OFFSET + 4;
      UBOSH.SH_LINEAR_CONST_B_OFFSET = _class15.SH_LINEAR_CONST_G_OFFSET + 4;
      UBOSH.SH_QUADRATIC_R_OFFSET = _class15.SH_LINEAR_CONST_B_OFFSET + 4;
      UBOSH.SH_QUADRATIC_G_OFFSET = _class15.SH_QUADRATIC_R_OFFSET + 4;
      UBOSH.SH_QUADRATIC_B_OFFSET = _class15.SH_QUADRATIC_G_OFFSET + 4;
      UBOSH.SH_QUADRATIC_A_OFFSET = _class15.SH_QUADRATIC_B_OFFSET + 4;
      UBOSH.COUNT = _class15.SH_QUADRATIC_A_OFFSET + 4;
      UBOSH.SIZE = _class15.COUNT * 4;
      UBOSH.NAME = 'CCSH';
      UBOSH.BINDING = ModelLocalBindings.UBO_SH;
      UBOSH.DESCRIPTOR = new DescriptorSetLayoutBinding(_class15.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOSH.LAYOUT = new UniformBlock(SetIndex.LOCAL, _class15.BINDING, _class15.NAME, [new Uniform('cc_sh_linear_const_r', Type$1.FLOAT4, 1), new Uniform('cc_sh_linear_const_g', Type$1.FLOAT4, 1), new Uniform('cc_sh_linear_const_b', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_r', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_g', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_b', Type$1.FLOAT4, 1), new Uniform('cc_sh_quadratic_a', Type$1.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSH.NAME] = UBOSH.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSH.BINDING] = UBOSH.DESCRIPTOR;
      const UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
      const UNIFORM_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
      const UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
      const UNIFORM_REALTIME_JOINT_TEXTURE_NAME = 'cc_realtimeJoint';
      const UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
      const UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, UNIFORM_REALTIME_JOINT_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REALTIME_JOINT_TEXTURE_NAME] = UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REALTIME_JOINT_TEXTURE_BINDING] = UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR;
      const UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
      const UNIFORM_POSITION_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_POSITION;
      const UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
      const UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_NORMAL;
      const UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
      const UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_TANGENT;
      const UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      const UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
      const UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
      const UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
      const UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
      const UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
      const UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
      const UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
      const UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
      const UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
      const UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
      const UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, DescriptorType.STORAGE_IMAGE, 1, ShaderStageFlagBit.COMPUTE);
      const UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, Type$1.IMAGE2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME = 'cc_reflectionProbeCubemap';
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_CUBE;
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME] = UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING] = UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_TEXTURE_NAME = 'cc_reflectionProbePlanarMap';
      const UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_PLANAR;
      const UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, UNIFORM_REFLECTION_PROBE_TEXTURE_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_TEXTURE_NAME] = UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING] = UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME = 'cc_reflectionProbeDataMap';
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_DATA_MAP;
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME, Type$1.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME] = UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING] = UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR;
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME = 'cc_reflectionProbeBlendCubemap';
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING = ModelLocalBindings.SAMPLER_REFLECTION_PROBE_BLEND_CUBE;
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      const UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME, Type$1.SAMPLER_CUBE, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME] = UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING] = UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_DESCRIPTOR;
      const CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
      const CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
      const MODEL_ALWAYS_MASK = Layers.Enum.ALL;
      function supportsR16HalfFloatTexture(device) {
        return (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);
      }
      function supportsR32FloatTexture(device) {
        return (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function supportsRGBA16HalfFloatTexture(device) {
        return (device.getFormatFeatures(Format.RGBA16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function supportsRGBA32FloatTexture(device) {
        return (device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) && !(device.gfxAPI === API.WEBGL);
      }
      function isEnableEffect() {
        return !!(legacyCC.rendering && legacyCC.rendering.enableEffectImport);
      }

      var define$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PIPELINE_FLOW_MAIN: PIPELINE_FLOW_MAIN,
        PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
        PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
        PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
        PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
        get RenderPassStage () { return RenderPassStage; },
        get RenderPriority () { return RenderPriority; },
        globalDescriptorSetLayout: globalDescriptorSetLayout,
        localDescriptorSetLayout: localDescriptorSetLayout,
        get PipelineGlobalBindings () { return PipelineGlobalBindings; },
        get ModelLocalBindings () { return ModelLocalBindings; },
        get SetIndex () { return SetIndex; },
        bindingMappingInfo: bindingMappingInfo,
        UBOGlobal: UBOGlobal,
        UBOCamera: UBOCamera,
        UBOShadow: UBOShadow,
        UBOCSM: UBOCSM,
        UNIFORM_SHADOWMAP_BINDING: UNIFORM_SHADOWMAP_BINDING,
        UNIFORM_ENVIRONMENT_BINDING: UNIFORM_ENVIRONMENT_BINDING,
        UNIFORM_DIFFUSEMAP_BINDING: UNIFORM_DIFFUSEMAP_BINDING,
        UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING: UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING,
        UBOLocal: UBOLocal,
        UBOWorldBound: UBOWorldBound,
        INST_MAT_WORLD: INST_MAT_WORLD,
        INST_SH: INST_SH,
        UBOLocalBatched: UBOLocalBatched,
        UBOForwardLight: UBOForwardLight,
        UBODeferredLight: UBODeferredLight,
        JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
        UBOSkinningTexture: UBOSkinningTexture,
        UBOSkinningAnimation: UBOSkinningAnimation,
        INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
        UBOSkinning: UBOSkinning,
        localDescriptorSetLayout_ResizeMaxJoints: localDescriptorSetLayout_ResizeMaxJoints,
        UBOMorph: UBOMorph,
        UBOUILocal: UBOUILocal,
        UBOSH: UBOSH,
        UNIFORM_JOINT_TEXTURE_BINDING: UNIFORM_JOINT_TEXTURE_BINDING,
        UNIFORM_REALTIME_JOINT_TEXTURE_BINDING: UNIFORM_REALTIME_JOINT_TEXTURE_BINDING,
        UNIFORM_POSITION_MORPH_TEXTURE_BINDING: UNIFORM_POSITION_MORPH_TEXTURE_BINDING,
        UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,
        UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: UNIFORM_TANGENT_MORPH_TEXTURE_BINDING,
        UNIFORM_LIGHTMAP_TEXTURE_BINDING: UNIFORM_LIGHTMAP_TEXTURE_BINDING,
        UNIFORM_SPRITE_TEXTURE_BINDING: UNIFORM_SPRITE_TEXTURE_BINDING,
        UNIFORM_REFLECTION_TEXTURE_BINDING: UNIFORM_REFLECTION_TEXTURE_BINDING,
        UNIFORM_REFLECTION_STORAGE_BINDING: UNIFORM_REFLECTION_STORAGE_BINDING,
        UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING,
        UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING: UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING,
        UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING: UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING,
        UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING,
        CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
        CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
        MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK,
        supportsR16HalfFloatTexture: supportsR16HalfFloatTexture,
        supportsR32FloatTexture: supportsR32FloatTexture,
        supportsRGBA16HalfFloatTexture: supportsRGBA16HalfFloatTexture,
        supportsRGBA32FloatTexture: supportsRGBA32FloatTexture,
        isEnableEffect: isEnableEffect
      });
      exports('pipeline', define$1);

      const renderTextureProto = jsb.RenderTexture.prototype;
      const textureBaseProto = jsb.TextureBase.prototype;
      renderTextureProto.createNode = null;
      const RenderTexture = exports('RenderTexture', jsb.RenderTexture);
      RenderTexture.Filter = Filter;
      RenderTexture.PixelFormat = PixelFormat;
      RenderTexture.WrapMode = WrapMode;
      renderTextureProto._serialize = function (ctxForExporting) {
        return {};
      };
      renderTextureProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        this._width = data.w;
        this._height = data.h;
        this._name = data.n;
        textureBaseProto._deserialize.call(this, data.base, handle);
      };
      const oldReadPixels = renderTextureProto.readPixels;
      renderTextureProto.readPixels = function readPixels(x, y, width, height, buffer) {
        x = x || 0;
        y = y || 0;
        width = width || this.width;
        height = height || this.height;
        let tmpBuffer = oldReadPixels.call(this, x, y, width, height);
        if (tmpBuffer.length == 0) {
          return null;
        }
        buffer = tmpBuffer;
        return buffer;
      };
      legacyCC.RenderTexture = jsb.RenderTexture;
      patch_cc_RenderTexture({
        RenderTexture
      });

      const getPhaseID = exports('getPhaseID', (() => {
        const phases = new Map();
        let phaseNum = 0;
        return phaseName => {
          if (typeof phaseName === 'number') {
            return phaseName;
          }
          if (!phases.has(phaseName)) {
            phases.set(phaseName, 1 << phaseNum);
            phaseNum++;
          }
          return phases.get(phaseName);
        };
      })());

      let PipelineEventType; exports('PipelineEventType', PipelineEventType);
      (function (PipelineEventType) {
        PipelineEventType["RENDER_FRAME_BEGIN"] = "render-frame-begin";
        PipelineEventType["RENDER_FRAME_END"] = "render-frame-end";
        PipelineEventType["RENDER_CAMERA_BEGIN"] = "render-camera-begin";
        PipelineEventType["RENDER_CAMERA_END"] = "render-camera-end";
        PipelineEventType["ATTACHMENT_SCALE_CAHNGED"] = "attachment-scale-changed";
      })(PipelineEventType || (exports('PipelineEventType', PipelineEventType = {})));

      var _dec$1F, _dec2$1o, _class$1C, _initializer$1p, _initializer2$1d, _initializer3$Z, _dec3$14, _dec4$R, _class3$C, _class4$7, _initializer4$R, _initializer5$I;
      const RenderPipeline = exports('RenderPipeline', nr.RenderPipeline);
      const RenderFlow = exports('RenderFlow', nr.RenderFlow);
      const RenderStage = exports('RenderStage', nr.RenderStage);
      const InstancedBuffer = exports('InstancedBuffer', nr.InstancedBuffer);
      const PipelineStateManager = exports('PipelineStateManager', nr.PipelineStateManager);
      const ForwardPipeline = exports('ForwardPipeline', nr.ForwardPipeline);
      const ForwardFlow = exports('ForwardFlow', nr.ForwardFlow);
      const ShadowFlow = exports('ShadowFlow', nr.ShadowFlow);
      const ForwardStage = exports('ForwardStage', nr.ForwardStage);
      const ShadowStage = exports('ShadowStage', nr.ShadowStage);
      const DeferredPipeline = exports('DeferredPipeline', nr.DeferredPipeline);
      const MainFlow = exports('MainFlow', nr.MainFlow);
      const LightingStage = exports('LightingStage', nr.LightingStage);
      const PostProcessStage = exports('PostProcessStage', nr.PostProcessStage);
      const GbufferStage = exports('GbufferStage', nr.GbufferStage);
      const BloomStage = exports('BloomStage', nr.BloomStage);
      const ReflectionProbeFlow = exports('ReflectionProbeFlow', nr.ReflectionProbeFlow);
      const ReflectionProbeStage = exports('ReflectionProbeStage', nr.ReflectionProbeStage);
      let getOrCreatePipelineState = nr.PipelineStateManager.getOrCreatePipelineState;
      nr.PipelineStateManager.getOrCreatePipelineState = function (device, pass, shader, renderPass, ia) {
        return getOrCreatePipelineState(pass, shader, renderPass, ia);
      };
      const forwardPipelineProto = ForwardPipeline.prototype;
      forwardPipelineProto._ctor = function () {
        this._tag = 0;
        this._flows = [];
      };
      forwardPipelineProto.init = function () {
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        const info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const oldForwardOnLoaded = forwardPipelineProto.onLoaded;
      forwardPipelineProto.onLoaded = function () {
        if (oldForwardOnLoaded) oldForwardOnLoaded.call(this);
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        const info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const forwardFlowProto = ForwardFlow.prototype;
      forwardFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      forwardFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const shadowFlowProto = ShadowFlow.prototype;
      shadowFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      shadowFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const reflectionProbeFlowProto = ReflectionProbeFlow.prototype;
      reflectionProbeFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      reflectionProbeFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const forwardStageProto = ForwardStage.prototype;
      forwardStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      forwardStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const shadowStageProto = ShadowStage.prototype;
      shadowStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
      };
      const reflectionProbeStage = ReflectionProbeStage.prototype;
      reflectionProbeStage._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      reflectionProbeStage.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      let RenderQueueSortMode; exports('RenderQueueSortMode', RenderQueueSortMode);
      (function (RenderQueueSortMode) {
        RenderQueueSortMode[RenderQueueSortMode["FRONT_TO_BACK"] = 0] = "FRONT_TO_BACK";
        RenderQueueSortMode[RenderQueueSortMode["BACK_TO_FRONT"] = 1] = "BACK_TO_FRONT";
      })(RenderQueueSortMode || (exports('RenderQueueSortMode', RenderQueueSortMode = {})));
      ccenum(RenderQueueSortMode);
      shadowStageProto.init = function (pipeline) {
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: []
        };
        this.initialize(info);
      };
      let RenderQueueDesc = exports('RenderQueueDesc', (_dec$1F = type$6(RenderQueueSortMode), _dec2$1o = type$6([CCString]), (_class$1C = class RenderQueueDesc {
        constructor() {
          this.isTransparent = _initializer$1p && _initializer$1p();
          this.sortMode = _initializer2$1d && _initializer2$1d();
          this.stages = _initializer3$Z && _initializer3$Z();
          this.stages = [];
        }
        init() {
          return new nr.RenderQueueDesc(this.isTransparent, this.sortMode, this.stages);
        }
      }, (_initializer$1p = applyDecoratedInitializer(_class$1C.prototype, "isTransparent", [serializable$6], function () {
        return false;
      }), _initializer2$1d = applyDecoratedInitializer(_class$1C.prototype, "sortMode", [_dec$1F], function () {
        return RenderQueueSortMode.FRONT_TO_BACK;
      }), _initializer3$Z = applyDecoratedInitializer(_class$1C.prototype, "stages", [_dec2$1o], function () {
        return [];
      })), _class$1C)));
      const deferredPipelineProto = DeferredPipeline.prototype;
      deferredPipelineProto._ctor = function () {
        this._tag = 0;
        this._flows = [];
        this.renderTextures = [];
        this.materials = [];
      };
      const oldDeferredOnLoaded = deferredPipelineProto.onLoaded;
      deferredPipelineProto.onLoaded = function () {
        if (oldDeferredOnLoaded) oldDeferredOnLoaded.call(this);
        for (let i = 0; i < this._flows.length; i++) {
          this._flows[i].init(this);
        }
        let info = {
          tag: this._tag,
          flows: this._flows
        };
        this.initialize(info);
      };
      const mainFlowProto = MainFlow.prototype;
      mainFlowProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this._stages = [];
      };
      mainFlowProto.init = function (pipeline) {
        for (let i = 0; i < this._stages.length; i++) {
          this._stages[i].init(pipeline);
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          stages: this._stages
        };
        this.initialize(info);
      };
      const gbufferStageProto = GbufferStage.prototype;
      gbufferStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
      };
      gbufferStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const lightingStageProto = LightingStage.prototype;
      lightingStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._deferredMaterial = null;
      };
      lightingStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const bloomStageProto = BloomStage.prototype;
      bloomStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._bloomMaterial = null;
      };
      bloomStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.bloomMaterial = this._bloomMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      const postProcessStageProto = PostProcessStage.prototype;
      postProcessStageProto._ctor = function () {
        this._name = 0;
        this._priority = 0;
        this._tag = 0;
        this.renderQueues = [];
        this._postProcessMaterial = null;
      };
      postProcessStageProto.init = function (pipeline) {
        const queues = [];
        for (let i = 0; i < this.renderQueues.length; i++) {
          queues.push(this.renderQueues[i].init());
        }
        pipeline.pipelineSceneData.postProcessMaterial = this._postProcessMaterial;
        const info = {
          name: this._name,
          priority: this._priority,
          tag: this._tag,
          renderQueues: queues
        };
        this.initialize(info);
      };
      legacyCC.RenderFlow = RenderFlow;
      legacyCC.RenderStage = RenderStage;
      legacyCC.RenderPipeline = RenderPipeline;
      let RenderTextureConfig = (_dec3$14 = ccclass$6('RenderTextureConfig'), _dec4$R = type$6(RenderTexture), _dec3$14(_class3$C = (_class4$7 = class RenderTextureConfig {
        constructor() {
          this.name = _initializer4$R && _initializer4$R();
          this.texture = _initializer5$I && _initializer5$I();
        }
      }, (_initializer4$R = applyDecoratedInitializer(_class4$7.prototype, "name", [serializable$6], function () {
        return '';
      }), _initializer5$I = applyDecoratedInitializer(_class4$7.prototype, "texture", [_dec4$R], function () {
        return null;
      })), _class4$7)) || _class3$C);
      function proxyArrayAttributeImpl(proto, attr) {
        const proxyTarget = `_${attr}_target`;
        let arrayProxy = (self, targetArrayAttr) => {
          return new Proxy(self[targetArrayAttr], {
            get(targetArray, prop, receiver) {
              return Reflect.get(targetArray, prop, receiver);
            },
            set(targetArray, prop, receiver) {
              const ret = Reflect.set(targetArray, prop, receiver);
              self[targetArrayAttr] = targetArray;
              return ret;
            }
          });
        };
        Object.defineProperty(proto, attr, {
          configurable: true,
          enumerable: true,
          get: function () {
            this[proxyTarget] || (this[proxyTarget] = []);
            return arrayProxy(this, proxyTarget);
          },
          set: function (v) {
            this[proxyTarget] = v;
          }
        });
      }
      let proxyArrayAttribute = proxyArrayAttributeImpl;
      {
        proxyArrayAttribute(RenderFlow.prototype, '_stages');
        proxyArrayAttribute(RenderPipeline.prototype, '_flows');
      }
      const Material$1 = jsb.Material;
      patch_RenderQueueDesc({
        RenderQueueDesc,
        RenderQueueSortMode,
        CCString
      });
      patch_RenderStage({
        RenderStage
      });
      patch_ReflectionProbeStage({
        ReflectionProbeStage
      });
      patch_GbufferStage({
        GbufferStage,
        RenderQueueDesc
      });
      patch_LightingStage({
        LightingStage,
        RenderQueueDesc,
        Material: Material$1
      });
      patch_BloomStage({
        BloomStage,
        Material: Material$1
      });
      patch_PostProcessStage({
        PostProcessStage,
        Material: Material$1,
        RenderQueueDesc
      });
      patch_ForwardStage({
        ForwardStage,
        RenderQueueDesc
      });
      patch_ShadowStage({
        ShadowStage
      });
      patch_RenderFlow({
        RenderFlow,
        RenderStage
      });
      patch_MainFlow({
        MainFlow
      });
      patch_ForwardFlow({
        ForwardFlow
      });
      patch_ShadowFlow({
        ShadowFlow
      });
      patch_ReflectionProbeFlow({
        ReflectionProbeFlow
      });
      patch_cc_RenderPipeline({
        RenderPipeline,
        RenderFlow
      });
      patch_ForwardPipeline({
        ForwardPipeline,
        RenderTextureConfig
      });
      patch_DeferredPipeline({
        DeferredPipeline,
        RenderTextureConfig
      });

      const Root = exports('Root', jsb.Root);
      var LightType$2;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType$2 || (LightType$2 = {}));
      const rootProto = Root.prototype;
      rootProto._createBatcher2D = function () {
        if (!this._batcher && legacyCC.internal.Batcher2D) {
          this._batcher = new legacyCC.internal.Batcher2D(this);
          if (!this._batcher.initialize()) {
            this._batcher = null;
            this.destroy();
            return;
          }
          this._batcher._nativeObj = this.getBatcher2D();
        }
      };
      Object.defineProperty(rootProto, 'batcher2D', {
        configurable: true,
        enumerable: true,
        get() {
          return this._batcher;
        }
      });
      Object.defineProperty(rootProto, 'dataPoolManager', {
        configurable: true,
        enumerable: true,
        get() {
          return this._dataPoolMgr;
        }
      });
      Object.defineProperty(rootProto, 'pipelineEvent', {
        configurable: true,
        enumerable: true,
        get() {
          return this._pipelineEvent;
        }
      });
      class DummyPipelineEvent {
        on(type, callback, target, once) {}
        once(type, callback, target) {}
        off(type, callback, target) {}
        emit(type, arg0, arg1, arg2, arg3, arg4) {}
        targetOff(typeOrTarget) {}
        removeAll(typeOrTarget) {}
        hasEventListener(type, callback, target) {
          return false;
        }
      }
      rootProto._ctor = function (device) {
        this._device = device;
        this._dataPoolMgr = legacyCC.internal.DataPoolManager && new legacyCC.internal.DataPoolManager(device);
        this._modelPools = new Map();
        this._lightPools = new Map();
        this._batcher = null;
        this._pipelineEvent = new DummyPipelineEvent();
        this._registerListeners();
      };
      rootProto.initialize = function (info) {
        var _this$_dataPoolMgr;
        this._initialize(deviceManager.swapchain);
        const customJointTextureLayouts = settings.querySettings(Settings.Category.ANIMATION, 'customJointTextureLayouts') || [];
        (_this$_dataPoolMgr = this._dataPoolMgr) === null || _this$_dataPoolMgr === void 0 ? void 0 : _this$_dataPoolMgr.jointTexturePool.registerCustomTextureLayouts(customJointTextureLayouts);
      };
      rootProto.createModel = function (ModelCtor) {
        let p = this._modelPools.get(ModelCtor);
        if (!p) {
          this._modelPools.set(ModelCtor, new Pool(() => new ModelCtor(), 10, obj => obj.destroy()));
          p = this._modelPools.get(ModelCtor);
        }
        const model = p.alloc();
        model.initialize();
        return model;
      };
      rootProto.destroyModel = function (m) {
        const p = this._modelPools.get(m.constructor);
        if (p) {
          p.free(m);
          if (m.scene) {
            m.scene.removeModel(m);
          }
        } else {
          warnID(1300, m.constructor.name);
        }
        m.destroy();
      };
      rootProto.createLight = function (LightCtor) {
        let l = this._lightPools.get(LightCtor);
        if (!l) {
          this._lightPools.set(LightCtor, new Pool(() => new LightCtor(), 4, obj => obj.destroy()));
          l = this._lightPools.get(LightCtor);
        }
        const light = l.alloc();
        light.initialize();
        return light;
      };
      rootProto.destroyLight = function (l) {
        if (l.scene) {
          switch (l.type) {
            case LightType$2.DIRECTIONAL:
              l.scene.removeDirectionalLight(l);
              break;
            case LightType$2.SPHERE:
              l.scene.removeSphereLight(l);
              break;
            case LightType$2.SPOT:
              l.scene.removeSpotLight(l);
              break;
            case LightType$2.POINT:
              l.scene.removePointLight(l);
              break;
            case LightType$2.RANGED_DIRECTIONAL:
              l.scene.removeRangedDirLight(l);
              break;
          }
        }
        l.destroy();
      };
      rootProto.recycleLight = function (l) {
        const p = this._lightPools.get(l.constructor);
        if (p) {
          p.free(l);
          if (l.scene) {
            switch (l.type) {
              case LightType$2.DIRECTIONAL:
                l.scene.removeDirectionalLight(l);
                break;
              case LightType$2.SPHERE:
                l.scene.removeSphereLight(l);
                break;
              case LightType$2.SPOT:
                l.scene.removeSpotLight(l);
                break;
              case LightType$2.POINT:
                l.scene.removePointLight(l);
                break;
              case LightType$2.RANGED_DIRECTIONAL:
                l.scene.removeRangedDirLight(l);
                break;
            }
          }
        }
      };
      rootProto._onDirectorBeforeCommit = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_COMMIT);
      };
      rootProto._onDirectorBeforeRender = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_RENDER);
      };
      rootProto._onDirectorAfterRender = function () {
        legacyCC.director.emit(legacyCC.Director.EVENT_AFTER_RENDER);
      };
      rootProto._onDirectorPipelineChanged = function () {
        const scene = legacyCC.director.getScene();
        if (scene) {
          scene._activate();
        }
      };
      const oldOnGlobalPipelineStateChanged = rootProto.onGlobalPipelineStateChanged;
      rootProto.onGlobalPipelineStateChanged = function () {
        oldOnGlobalPipelineStateChanged.call(this);
        const builder = legacyCC.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
        if (builder) {
          if (typeof builder.onGlobalPipelineStateChanged === 'function') {
            builder.onGlobalPipelineStateChanged();
          }
        }
      };
      const oldFrameMove = rootProto.frameMove;
      rootProto.frameMove = function (deltaTime) {
        oldFrameMove.call(this, deltaTime, legacyCC.director.getTotalFrames());
      };
      const oldSetPipeline = rootProto.setRenderPipeline;
      rootProto.setRenderPipeline = function (pipeline) {
        let ppl;
        if (macro.CUSTOM_PIPELINE_NAME !== '' && legacyCC.rendering && this.usesCustomPipeline) {
          legacyCC.rendering.createCustomPipeline();
          ppl = oldSetPipeline.call(this, null);
          log('Using custom pipeline');
        } else {
          if (!pipeline) {
            pipeline = new ForwardPipeline();
            pipeline.init();
          }
          ppl = oldSetPipeline.call(this, pipeline);
        }
        this._createBatcher2D();
        return ppl;
      };
      rootProto.addBatch = function (batch) {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };
      rootProto.removeBatch = function (batch) {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };
      rootProto.removeBatches = function () {
        console.error('The Draw Batch class is implemented differently in the native platform and does not support this interface.');
      };

      let NodeEventType; exports('NodeEventType', NodeEventType);
      (function (NodeEventType) {
        NodeEventType["TOUCH_START"] = "touch-start";
        NodeEventType["TOUCH_MOVE"] = "touch-move";
        NodeEventType["TOUCH_END"] = "touch-end";
        NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
        NodeEventType["MOUSE_DOWN"] = "mouse-down";
        NodeEventType["MOUSE_MOVE"] = "mouse-move";
        NodeEventType["MOUSE_UP"] = "mouse-up";
        NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
        NodeEventType["MOUSE_ENTER"] = "mouse-enter";
        NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
        NodeEventType["KEY_DOWN"] = "keydown";
        NodeEventType["KEY_UP"] = "keyup";
        NodeEventType["DEVICEMOTION"] = "devicemotion";
        NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
        NodeEventType["MOBILITY_CHANGED"] = "mobility-changed";
        NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        NodeEventType["SIZE_CHANGED"] = "size-changed";
        NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
        NodeEventType["COLOR_CHANGED"] = "color-changed";
        NodeEventType["CHILD_ADDED"] = "child-added";
        NodeEventType["CHILD_REMOVED"] = "child-removed";
        NodeEventType["PARENT_CHANGED"] = "parent-changed";
        NodeEventType["NODE_DESTROYED"] = "node-destroyed";
        NodeEventType["LAYER_CHANGED"] = "layer-changed";
        NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
        NodeEventType["CHILDREN_ORDER_CHANGED"] = "sibling-order-changed";
        NodeEventType["ACTIVE_IN_HIERARCHY_CHANGED"] = "active-in-hierarchy-changed";
        NodeEventType["COMPONENT_ADDED"] = "component-added";
        NodeEventType["COMPONENT_REMOVED"] = "component-removed";
        NodeEventType["LIGHT_PROBE_CHANGED"] = "light-probe-changed";
        NodeEventType["LIGHT_PROBE_BAKING_CHANGED"] = "light-probe-baking-changed";
      })(NodeEventType || (exports('NodeEventType', NodeEventType = {})));

      class NodeUIProperties {
        get uiTransformComp() {
          if (!this._uiTransformComp) {
            this._uiTransformComp = this._node.getComponent('cc.UITransform');
          }
          return this._uiTransformComp;
        }
        set uiTransformComp(value) {
          this._uiTransformComp = value;
        }
        get uiComp() {
          return this._uiComp;
        }
        set uiComp(comp) {
          if (this._uiComp && comp) {
            warnID(12002);
            return;
          }
          this._uiComp = comp;
        }
        setOpacity(v) {
          this._opacity = v;
        }
        get opacity() {
          return this._opacity;
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(val) {
          this._localOpacity = val;
          this.colorDirty = true;
        }
        constructor(node) {
          this._uiComp = null;
          this._opacity = 1;
          this._localOpacity = 1;
          this.colorDirty = true;
          this._uiTransformComp = null;
          this._node = void 0;
          this._node = node;
        }
        applyOpacity(effectOpacity) {
          this._opacity = this._localOpacity * effectOpacity;
        }
        static markOpacityTree(node, isDirty = true) {}
      }

      let NodeSpace; exports('NodeSpace', NodeSpace);
      (function (NodeSpace) {
        NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
        NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
      })(NodeSpace || (exports('NodeSpace', NodeSpace = {})));
      let TransformBit; exports('TransformBit', TransformBit);
      (function (TransformBit) {
        TransformBit[TransformBit["NONE"] = 0] = "NONE";
        TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
        TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
        TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
        TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
        TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
        TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
      })(TransformBit || (exports('TransformBit', TransformBit = {})));
      legacyCC.internal.TransformBit = TransformBit;
      const MobilityMode = exports('MobilityMode', Enum({
        Static: 0,
        Stationary: 1,
        Movable: 2
      }));

      const _tempFloatArray = new Float32Array(jsb.createExternalArrayBuffer(20 * 4));
      const fillMat4WithTempFloatArray = function fillMat4WithTempFloatArray(out) {
        Mat4.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2], _tempFloatArray[3], _tempFloatArray[4], _tempFloatArray[5], _tempFloatArray[6], _tempFloatArray[7], _tempFloatArray[8], _tempFloatArray[9], _tempFloatArray[10], _tempFloatArray[11], _tempFloatArray[12], _tempFloatArray[13], _tempFloatArray[14], _tempFloatArray[15]);
      };

      CCObject.Flags.Destroying;
      !!legacyCC.GAME_VIEW;

      const reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
      const Node$1 = jsb.Node; exports({ Node: Node$1, BaseNode: Node$1 });
      legacyCC.Node = Node$1;
      const NodeCls = Node$1;
      NodeCls.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag;
      NodeCls.EventType = NodeEventType;
      NodeCls.NodeSpace = NodeSpace;
      NodeCls.TransformDirtyBit = TransformBit;
      NodeCls.TransformBit = TransformBit;
      const TRANSFORMBIT_TRS = TransformBit.TRS;
      const nodeProto = jsb.Node.prototype;
      const TRANSFORM_ON = 1 << 0;
      const Destroying = CCObject.Flags.Destroying;
      Node$1._setTempFloatArray(_tempFloatArray.buffer);
      function getConstructor(typeOrClassName) {
        if (!typeOrClassName) {
          return null;
        }
        if (typeof typeOrClassName === 'string') {
          return getClassByName(typeOrClassName);
        }
        return typeOrClassName;
      }
      nodeProto.attr = function (attrs) {
        mixin(this, attrs);
      };
      nodeProto.getComponent = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        if (constructor) {
          return NodeCls._findComponent(this, constructor);
        }
        return null;
      };
      nodeProto.getComponents = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        const components = [];
        if (constructor) {
          NodeCls._findComponents(this, constructor, components);
        }
        return components;
      };
      nodeProto.getComponentInChildren = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        if (constructor) {
          return NodeCls._findChildComponent(this._children, constructor);
        }
        return null;
      };
      nodeProto.getComponentsInChildren = function (typeOrClassName) {
        const constructor = getConstructor(typeOrClassName);
        const components = [];
        if (constructor) {
          NodeCls._findComponents(this, constructor, components);
          NodeCls._findChildComponents(this.children, constructor, components);
        }
        return components;
      };
      nodeProto.addComponent = function (typeOrClassName) {
        let constructor;
        if (typeof typeOrClassName === 'string') {
          constructor = getClassByName(typeOrClassName);
          if (!constructor) {
            if (legacyCC._RF.peek()) {
              errorID(3808, typeOrClassName);
            }
            throw TypeError(getError(3807, typeOrClassName));
          }
        } else {
          if (!typeOrClassName) {
            throw TypeError(getError(3804));
          }
          constructor = typeOrClassName;
        }
        if (typeof constructor !== 'function') {
          throw TypeError(getError(3809));
        }
        if (!isChildClassOf(constructor, Component)) {
          throw TypeError(getError(3810));
        }
        const reqComps = constructor._requireComponent;
        if (reqComps) {
          const tryAdd = c => {
            if (!this.getComponent(c)) {
              this.addComponent(c);
            }
          };
          if (Array.isArray(reqComps)) {
            reqComps.forEach(c => tryAdd(c));
          } else {
            tryAdd(reqComps);
          }
        }
        const component = new constructor();
        component.node = this;
        this._components.push(component);
        this.emit(NodeEventType.COMPONENT_ADDED, component);
        if (this._activeInHierarchy) {
          legacyCC.director._nodeActivator.activateComp(component);
        }
        return component;
      };
      nodeProto.removeComponent = function (component) {
        if (!component) {
          errorID(3813);
          return;
        }
        let componentInstance = null;
        if (component instanceof Component) {
          componentInstance = component;
        } else {
          componentInstance = this.getComponent(component);
        }
        if (componentInstance) {
          componentInstance.destroy();
        }
      };
      const REGISTERED_EVENT_MASK_TRANSFORM_CHANGED = 1 << 0;
      const REGISTERED_EVENT_MASK_PARENT_CHANGED = 1 << 1;
      const REGISTERED_EVENT_MASK_MOBILITY_CHANGED = 1 << 2;
      const REGISTERED_EVENT_MASK_LAYER_CHANGED = 1 << 3;
      const REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED = 1 << 4;
      const REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED = 1 << 5;
      nodeProto.on = function (type, callback, target, useCapture = false) {
        switch (type) {
          case NodeEventType.TRANSFORM_CHANGED:
            this._eventMask |= TRANSFORM_ON;
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_TRANSFORM_CHANGED)) {
              this._registerOnTransformChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_TRANSFORM_CHANGED;
            }
            break;
          case NodeEventType.PARENT_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_PARENT_CHANGED)) {
              this._registerOnParentChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_PARENT_CHANGED;
            }
            break;
          case NodeEventType.MOBILITY_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_MOBILITY_CHANGED)) {
              this._registerOnMobilityChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_MOBILITY_CHANGED;
            }
            break;
          case NodeEventType.LAYER_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_LAYER_CHANGED)) {
              this._registerOnLayerChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_LAYER_CHANGED;
            }
            break;
          case NodeEventType.CHILDREN_ORDER_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED)) {
              this._registerOnSiblingOrderChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_SIBLING_ORDER_CHANGED;
            }
            break;
          case NodeEventType.LIGHT_PROBE_BAKING_CHANGED:
            if (!(this._registeredNodeEventTypeMask & REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED)) {
              this._registerOnLightProbeBakingChanged();
              this._registeredNodeEventTypeMask |= REGISTERED_EVENT_MASK_LIGHT_PROBE_BAKING_CHANGED;
            }
            break;
        }
        this._eventProcessor.on(type, callback, target, useCapture);
      };
      nodeProto.off = function (type, callback, target, useCapture = false) {
        this._eventProcessor.off(type, callback, target, useCapture);
        const hasListeners = this._eventProcessor.hasEventListener(type);
        if (!hasListeners) {
          switch (type) {
            case NodeEventType.TRANSFORM_CHANGED:
              this._eventMask &= ~TRANSFORM_ON;
              break;
          }
        }
      };
      nodeProto.once = function (type, callback, target, useCapture) {
        this._eventProcessor.once(type, callback, target, useCapture);
      };
      nodeProto.emit = function (type, arg0, arg1, arg2, arg3, arg4) {
        this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
      };
      nodeProto.dispatchEvent = function (event) {
        this._eventProcessor.dispatchEvent(event);
      };
      nodeProto.hasEventListener = function (type, callback, target) {
        return this._eventProcessor.hasEventListener(type, callback, target);
      };
      nodeProto.targetOff = function (target) {
        this._eventProcessor.targetOff(target);
        if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(NodeEventType.TRANSFORM_CHANGED)) {
          this._eventMask &= ~TRANSFORM_ON;
        }
      };
      nodeProto.pauseSystemEvents = function pauseSystemEvents(recursive) {
        this._eventProcessor.setEnabled(false, recursive);
      };
      nodeProto.resumeSystemEvents = function resumeSystemEvents(recursive) {
        this._eventProcessor.setEnabled(true, recursive);
      };
      nodeProto.getWritableComponents = function () {
        return this._components;
      };
      nodeProto._setActiveInHierarchy = function (v) {
        return this._activeInHierarchy = v;
      };
      nodeProto._removeComponent = function (component) {
        if (!component) {
          errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          const i = this._components.indexOf(component);
          if (i !== -1) {
            this._components.splice(i, 1);
            this.emit(NodeEventType.COMPONENT_REMOVED, component);
          } else if (component.node !== this) {
            errorID(3815);
          }
        }
      };
      nodeProto._registerIfAttached = undefined ;
      nodeProto._onTransformChanged = function (transformType) {
        this.emit(NodeEventType.TRANSFORM_CHANGED, transformType);
      };
      nodeProto._onParentChanged = function (oldParent) {
        this.emit(NodeEventType.PARENT_CHANGED, oldParent);
      };
      nodeProto._onReAttach = function () {
        this._eventProcessor.reattach();
      };
      nodeProto._onEditorAttached = function (attached) {
      };
      nodeProto._onRemovePersistRootNode = function () {
        legacyCC.game.removePersistRootNode(this);
      };
      nodeProto._onDestroyComponents = function () {
        this._eventProcessor.destroy();
        const comps = this._components;
        for (let i = 0; i < comps.length; ++i) {
          comps[i]._destroyImmediate();
        }
      };
      nodeProto._onMobilityChanged = function () {
        this.emit(NodeEventType.MOBILITY_CHANGED);
      };
      nodeProto._onLayerChanged = function (layer) {
        this.emit(NodeEventType.LAYER_CHANGED, layer);
      };
      nodeProto._onChildRemoved = function (child) {
        const removeAt = this._children.indexOf(child);
        if (removeAt < 0) {
          errorID(1633);
          return;
        }
        this._children.splice(removeAt, 1);
        this.emit(NodeEventType.CHILD_REMOVED, child);
      };
      nodeProto._onChildAdded = function (child) {
        this._children.push(child);
        this.emit(NodeEventType.CHILD_ADDED, child);
      };
      const oldPreDestroy = nodeProto._onPreDestroy;
      nodeProto._onPreDestroy = function _onPreDestroy() {
        const ret = oldPreDestroy.call(this);
        this.emit(NodeEventType.NODE_DESTROYED, this);
        this._eventProcessor.destroy();
        const children = this._children;
        for (let i = 0; i < children.length; ++i) {
          children[i]._destroyImmediate();
        }
        const comps = this._components;
        for (let i = 0; i < comps.length; ++i) {
          comps[i]._destroyImmediate();
        }
        return ret;
      };
      nodeProto.destroyAllChildren = function destroyAllChildren() {
        const children = this._children;
        for (let i = 0, len = children.length; i < len; ++i) {
          children[i].destroy();
        }
      };
      nodeProto._onSiblingOrderChanged = function () {
        this.emit(NodeEventType.CHILDREN_ORDER_CHANGED);
      };
      nodeProto._onActivateNode = function (shouldActiveNow) {
        legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
      };
      nodeProto._onPostActivated = function (active) {
        if (active) {
          this._eventProcessor.setEnabled(true);
          this.invalidateChildren(TransformBit.TRS);
          if (this._uiProps && this._uiProps.uiComp) {
            this._uiProps.uiComp.setNodeDirty();
            this._uiProps.uiComp.setTextureDirty();
            this._uiProps.uiComp.markForUpdateRenderData();
          }
        } else {
          this._eventProcessor.setEnabled(false);
        }
      };
      nodeProto._onLightProbeBakingChanged = function () {
        this.emit(NodeEventType.LIGHT_PROBE_BAKING_CHANGED);
      };
      NodeCls._findComponent = function (node, constructor) {
        const cls = constructor;
        const comps = node._components;
        if (cls._sealed) {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp.constructor === constructor) {
              return comp;
            }
          }
        } else {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp instanceof constructor) {
              return comp;
            }
          }
        }
        return null;
      };
      NodeCls._findComponents = function (node, constructor, components) {
        const cls = constructor;
        const comps = node._components;
        if (cls._sealed) {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp.constructor === constructor) {
              components.push(comp);
            }
          }
        } else {
          for (let i = 0; i < comps.length; ++i) {
            const comp = comps[i];
            if (comp instanceof constructor) {
              components.push(comp);
            }
          }
        }
      };
      NodeCls._findChildComponent = function (children, constructor) {
        for (let i = 0; i < children.length; ++i) {
          const node = children[i];
          let comp = NodeCls._findComponent(node, constructor);
          if (comp) {
            return comp;
          }
          const childChildren = node.children;
          if (childChildren.length > 0) {
            comp = NodeCls._findChildComponent(childChildren, constructor);
            if (comp) {
              return comp;
            }
          }
        }
        return null;
      };
      NodeCls._findChildComponents = function (children, constructor, components) {
        for (let i = 0; i < children.length; ++i) {
          const node = children[i];
          NodeCls._findComponents(node, constructor, components);
          const childChildren = node.children;
          if (childChildren.length > 0) {
            NodeCls._findChildComponents(childChildren, constructor, components);
          }
        }
      };
      NodeCls.isNode = function (obj) {
        return obj instanceof jsb.Node && (obj.constructor === jsb.Node || !(obj instanceof legacyCC.Scene));
      };
      let _tempQuat = new Quat();
      nodeProto.setRTS = function setRTS(rot, pos, scale) {
        if (rot) {
          let val = _tempQuat;
          if (rot instanceof Quat) {
            val = rot;
          } else {
            Quat.fromEuler(val, rot.x, rot.y, rot.z);
          }
          _tempFloatArray[0] = 4;
          _tempFloatArray[1] = val.x;
          _tempFloatArray[2] = val.y;
          _tempFloatArray[3] = val.z;
          _tempFloatArray[4] = val.w;
          this._lrot.set(val.x, val.y, val.z, val.w);
        } else {
          _tempFloatArray[0] = 0;
        }
        if (pos) {
          _tempFloatArray[5] = 3;
          _tempFloatArray[6] = pos.x;
          _tempFloatArray[7] = pos.y;
          _tempFloatArray[8] = pos.z;
          this._lpos.set(pos.x, pos.y, pos.z);
        } else {
          _tempFloatArray[5] = 0;
        }
        if (scale) {
          _tempFloatArray[9] = 3;
          _tempFloatArray[10] = scale.x;
          _tempFloatArray[11] = scale.y;
          _tempFloatArray[12] = scale.z;
          this._lscale.set(scale.x, scale.y, scale.z);
        } else {
          _tempFloatArray[9] = 0;
        }
        this._setRTS();
      };
      nodeProto.getPosition = function getPosition(out) {
        if (out) {
          return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
        }
        return Vec3.copy(new Vec3(), this._lpos);
      };
      nodeProto.setPosition = function setPosition(val, y, z) {
        if (y === undefined && z === undefined) {
          _tempFloatArray[0] = 3;
          const pos = val;
          this._lpos.x = _tempFloatArray[1] = pos.x;
          this._lpos.y = _tempFloatArray[2] = pos.y;
          this._lpos.z = _tempFloatArray[3] = pos.z;
        } else if (z === undefined) {
          _tempFloatArray[0] = 2;
          this._lpos.x = _tempFloatArray[1] = val;
          this._lpos.y = _tempFloatArray[2] = y;
        } else {
          _tempFloatArray[0] = 3;
          this._lpos.x = _tempFloatArray[1] = val;
          this._lpos.y = _tempFloatArray[2] = y;
          this._lpos.z = _tempFloatArray[3] = z;
        }
        this._setPosition();
      };
      nodeProto.getRotation = function getRotation(out) {
        const lrot = this._lrot;
        if (out) {
          return Quat.set(out, lrot.x, lrot.y, lrot.z, lrot.w);
        }
        return Quat.copy(new Quat(), lrot);
      };
      nodeProto.setRotation = function setRotation(val, y, z, w) {
        if (y === undefined || z === undefined || w === undefined) {
          const rot = val;
          this._lrot.x = _tempFloatArray[0] = rot.x;
          this._lrot.y = _tempFloatArray[1] = rot.y;
          this._lrot.z = _tempFloatArray[2] = rot.z;
          this._lrot.w = _tempFloatArray[3] = rot.w;
        } else {
          this._lrot.x = _tempFloatArray[0] = val;
          this._lrot.y = _tempFloatArray[1] = y;
          this._lrot.z = _tempFloatArray[2] = z;
          this._lrot.w = _tempFloatArray[3] = w;
        }
        this._setRotation();
      };
      nodeProto.setRotationFromEuler = function setRotationFromEuler(val, y, zOpt) {
        const z = zOpt === undefined ? this._euler.z : zOpt;
        if (y === undefined) {
          const euler = val;
          this._euler.x = _tempFloatArray[0] = euler.x;
          this._euler.y = _tempFloatArray[1] = euler.y;
          this._euler.z = _tempFloatArray[2] = euler.z;
        } else {
          this._euler.x = _tempFloatArray[0] = val;
          this._euler.y = _tempFloatArray[1] = y;
          this._euler.z = _tempFloatArray[2] = z;
        }
        this._setRotationFromEuler();
      };
      nodeProto.getScale = function getScale(out) {
        if (out) {
          return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
        }
        return Vec3.copy(new Vec3(), this._lscale);
      };
      nodeProto.setScale = function setScale(val, y, z) {
        if (y === undefined && z === undefined) {
          _tempFloatArray[0] = 3;
          const scale = val;
          this._lscale.x = _tempFloatArray[1] = scale.x;
          this._lscale.y = _tempFloatArray[2] = scale.y;
          this._lscale.z = _tempFloatArray[3] = scale.z;
        } else if (z === undefined) {
          _tempFloatArray[0] = 2;
          this._lscale.x = _tempFloatArray[1] = val;
          this._lscale.y = _tempFloatArray[2] = y;
        } else {
          _tempFloatArray[0] = 3;
          this._lscale.x = _tempFloatArray[1] = val;
          this._lscale.y = _tempFloatArray[2] = y;
          this._lscale.z = _tempFloatArray[3] = z;
        }
        this._setScale();
      };
      nodeProto.getWorldPosition = function getWorldPosition(out) {
        this._getWorldPosition();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getWorldRotation = function getWorldRotation(out) {
        this._getWorldRotation();
        out = out || new Quat();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2], _tempFloatArray[3]);
      };
      nodeProto.getWorldScale = function getWorldScale(out) {
        this._getWorldScale();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getWorldMatrix = function getWorldMatrix(out) {
        this._getWorldMatrix();
        out = out || new Mat4();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.getEulerAngles = function getEulerAngles(out) {
        this._getEulerAngles();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getForward = function getForward(out) {
        this._getForward();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getUp = function getUp(out) {
        this._getUp();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.getRight = function getRight(out) {
        this._getRight();
        out = out || new Vec3();
        return out.set(_tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
      };
      nodeProto.inverseTransformPoint = function inverseTransformPoint(out, p) {
        _tempFloatArray[0] = p.x;
        _tempFloatArray[1] = p.y;
        _tempFloatArray[2] = p.z;
        this._inverseTransformPoint();
        out.x = _tempFloatArray[0];
        out.y = _tempFloatArray[1];
        out.z = _tempFloatArray[2];
        return out;
      };
      nodeProto.getWorldRT = function getWorldRT(out) {
        out = out || new Mat4();
        this._getWorldRT();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.getWorldRS = function getWorldRS(out) {
        out = out || new Mat4();
        this._getWorldRS();
        fillMat4WithTempFloatArray(out);
        return out;
      };
      nodeProto.isTransformDirty = function () {
        return this._transformFlags !== TransformBit.NONE;
      };
      Object.defineProperty(nodeProto, 'name', {
        configurable: true,
        enumerable: true,
        get() {
          return this._name;
        },
        set(v) {
          this._name = v;
        }
      });
      Object.defineProperty(nodeProto, 'position', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lpos;
        },
        set(v) {
          this.setPosition(v);
        }
      });
      Object.defineProperty(nodeProto, 'rotation', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lrot;
        },
        set(v) {
          this.setRotation(v);
        }
      });
      Object.defineProperty(nodeProto, 'scale', {
        configurable: true,
        enumerable: true,
        get() {
          return this._lscale;
        },
        set(v) {
          this.setScale(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldPosition', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldPosition();
        },
        set(v) {
          this.setWorldPosition(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldRotation', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldRotation();
        },
        set(v) {
          this.setWorldRotation(v);
        }
      });
      Object.defineProperty(nodeProto, 'worldScale', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldScale();
        },
        set(v) {
          this.setWorldScale(v);
        }
      });
      Object.defineProperty(nodeProto, '_pos', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldPosition();
        }
      });
      Object.defineProperty(nodeProto, '_rot', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldRotation();
        }
      });
      Object.defineProperty(nodeProto, '_scale', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldScale();
        }
      });
      Object.defineProperty(nodeProto, 'eulerAngles', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getEulerAngles();
        },
        set(v) {
          this.setRotationFromEuler(v.x, v.y, v.z);
        }
      });
      Object.defineProperty(nodeProto, 'worldMatrix', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldMatrix();
        }
      });
      Object.defineProperty(nodeProto, '_mat', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getWorldMatrix();
        }
      });
      Object.defineProperty(nodeProto, 'activeInHierarchy', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[0] != 0;
        },
        set(v) {
          this._sharedUint8Arr[0] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, '_activeInHierarchy', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[0] != 0;
        },
        set(v) {
          this._sharedUint8Arr[0] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'layer', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[1];
        },
        set(v) {
          this._sharedUint32Arr[1] = v;
          if (this._uiProps && this._uiProps.uiComp) {
            this._uiProps.uiComp.setNodeDirty();
            this._uiProps.uiComp.markForUpdateRenderData();
          }
          this.emit(NodeEventType.LAYER_CHANGED, v);
        }
      });
      Object.defineProperty(nodeProto, '_layer', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[1];
        },
        set(v) {
          this._sharedUint32Arr[1] = v;
        }
      });
      Object.defineProperty(nodeProto, '_eventMask', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[0];
        },
        set(v) {
          this._sharedUint32Arr[0] = v;
        }
      });
      Object.defineProperty(nodeProto, '_siblingIndex', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedInt32Arr[0];
        },
        set(v) {
          this._sharedInt32Arr[0] = v;
        }
      });
      Object.defineProperty(nodeProto, 'prefab', {
        configurable: true,
        enumerable: true,
        get() {
          return this._prefab;
        }
      });
      Object.defineProperty(nodeProto, 'siblingIndex', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedInt32Arr[0];
        },
        set(v) {
          this._sharedInt32Arr[0] = v;
        }
      });
      nodeProto.getSiblingIndex = function getSiblingIndex() {
        return this._sharedInt32Arr[0];
      };
      Object.defineProperty(nodeProto, '_transformFlags', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint32Arr[2];
        },
        set(v) {
          this._sharedUint32Arr[2] = v;
        }
      });
      Object.defineProperty(nodeProto, '_active', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[1] != 0;
        },
        set(v) {
          this._sharedUint8Arr[1] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'active', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[1] != 0;
        },
        set(v) {
          this.setActive(!!v);
        }
      });
      Object.defineProperty(nodeProto, '_static', {
        configurable: true,
        enumerable: true,
        get() {
          return this._sharedUint8Arr[2] != 0;
        },
        set(v) {
          this._sharedUint8Arr[2] = v ? 1 : 0;
        }
      });
      Object.defineProperty(nodeProto, 'forward', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getForward();
        },
        set(dir) {
          this.setForward(dir);
        }
      });
      Object.defineProperty(nodeProto, 'up', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getUp();
        }
      });
      Object.defineProperty(nodeProto, 'right', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getRight();
        }
      });
      Object.defineProperty(nodeProto, 'eventProcessor', {
        configurable: true,
        enumerable: true,
        get() {
          return this._eventProcessor;
        }
      });
      Object.defineProperty(nodeProto, 'components', {
        configurable: true,
        enumerable: true,
        get() {
          return this._components;
        }
      });
      Object.defineProperty(nodeProto, '_parent', {
        configurable: true,
        enumerable: true,
        get() {
          this._parentRef = this._parentInternal;
          return this._parentRef;
        },
        set(v) {
          this._parentRef = this._parentInternal = v;
        }
      });
      Object.defineProperty(nodeProto, 'parent', {
        configurable: true,
        enumerable: true,
        get() {
          this._parentRef = this.getParent();
          return this._parentRef;
        },
        set(v) {
          this._parentRef = v;
          this.setParent(v);
        }
      });
      Object.defineProperty(nodeProto, 'children', {
        configurable: true,
        enumerable: true,
        get() {
          return this._children;
        },
        set(v) {
          this._children = v;
        }
      });
      Object.defineProperty(nodeProto, 'scene', {
        configurable: true,
        enumerable: true,
        get() {
          return this._scene;
        }
      });
      nodeProto.rotate = function (rot, ns) {
        _tempFloatArray[1] = rot.x;
        _tempFloatArray[2] = rot.y;
        _tempFloatArray[3] = rot.z;
        _tempFloatArray[4] = rot.w;
        if (ns) {
          _tempFloatArray[5] = ns;
          _tempFloatArray[0] = 5;
        } else {
          _tempFloatArray[0] = 4;
        }
        this._rotateForJS();
        const lrot = this._lrot;
        lrot.x = _tempFloatArray[0];
        lrot.y = _tempFloatArray[1];
        lrot.z = _tempFloatArray[2];
        lrot.w = _tempFloatArray[3];
      };
      nodeProto.addChild = function (child) {
        child.setParent(this);
      };
      nodeProto.insertChild = function (child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      };
      nodeProto[serializeTag] = function (serializationOutput, context) {
        {
          serializationOutput.writeThis();
        }
        const isMountedChild = () => {
          var _this$editorExtrasTag;
          return !!((_this$editorExtrasTag = this[editorExtrasTag]) !== null && _this$editorExtrasTag !== void 0 && _this$editorExtrasTag.mountedRoot);
        };
        const isSyncPrefab = () => {
          var _this$_prefab, _this$_prefab$root, _this$_prefab$root$_p, _this$_prefab2;
          return ((_this$_prefab = this._prefab) === null || _this$_prefab === void 0 ? void 0 : (_this$_prefab$root = _this$_prefab.root) === null || _this$_prefab$root === void 0 ? void 0 : (_this$_prefab$root$_p = _this$_prefab$root._prefab) === null || _this$_prefab$root$_p === void 0 ? void 0 : _this$_prefab$root$_p.instance) && ((this === null || this === void 0 ? void 0 : (_this$_prefab2 = this._prefab) === null || _this$_prefab2 === void 0 ? void 0 : _this$_prefab2.instance) || !isMountedChild());
        };
        const canDiscardByPrefabRoot = () => !(context.customArguments[reserveContentsForAllSyncablePrefabTag] || !isSyncPrefab() || context.root === this);
        if (canDiscardByPrefabRoot()) {
          var _this$_prefab3;
          const isRoot = ((_this$_prefab3 = this._prefab) === null || _this$_prefab3 === void 0 ? void 0 : _this$_prefab3.root) === this;
          if (isRoot) {
            let isNestedPrefab = false;
            let parent = this.getParent();
            while (parent) {
              var _parent$_prefab;
              const nestedRoots = (_parent$_prefab = parent._prefab) === null || _parent$_prefab === void 0 ? void 0 : _parent$_prefab.nestedPrefabInstanceRoots;
              if (nestedRoots && nestedRoots.length > 0) {
                isNestedPrefab = !nestedRoots.some(root => root === this);
                break;
              }
              parent = parent.getParent();
            }
            if (!isNestedPrefab) {
              serializationOutput.writeProperty('_objFlags', this._objFlags);
              serializationOutput.writeProperty('_parent', this._parent);
              serializationOutput.writeProperty('_prefab', this._prefab);
              if (context.customArguments.keepNodeUuid) {
                serializationOutput.writeProperty('_id', this._id);
              }
            }
            serializationOutput.writeProperty(editorExtrasTag, this[editorExtrasTag]);
          }
        } else {
          serializationOutput.writeThis();
        }
      };
      nodeProto._onActiveNode = function (shouldActiveNow) {
        legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
      };
      nodeProto._onBatchCreated = function (dontSyncChildPrefab) {
        this.hasChangedFlags = TRANSFORMBIT_TRS;
        const children = this._children;
        const len = children.length;
        let child;
        for (let i = 0; i < len; ++i) {
          child = children[i];
          child._siblingIndex = i;
          child._onBatchCreated(dontSyncChildPrefab);
        }
        syncNodeValues(this);
      };
      nodeProto._onSceneUpdated = function (scene) {
        this._scene = scene;
      };
      nodeProto._onLocalPositionUpdated = function (x, y, z) {
        const lpos = this._lpos;
        lpos.x = x;
        lpos.y = y;
        lpos.z = z;
      };
      nodeProto._onLocalRotationUpdated = function (x, y, z, w) {
        const lrot = this._lrot;
        lrot.x = x;
        lrot.y = y;
        lrot.z = z;
        lrot.w = w;
      };
      nodeProto._onLocalScaleUpdated = function (x, y, z) {
        const lscale = this._lscale;
        lscale.x = x;
        lscale.y = y;
        lscale.z = z;
      };
      nodeProto._onLocalPositionRotationScaleUpdated = function (px, py, pz, rx, ry, rz, rw, sx, sy, sz) {
        const lpos = this._lpos;
        lpos.x = px;
        lpos.y = py;
        lpos.z = pz;
        const lrot = this._lrot;
        lrot.x = rx;
        lrot.y = ry;
        lrot.z = rz;
        lrot.w = rw;
        const lscale = this._lscale;
        lscale.x = sx;
        lscale.y = sy;
        lscale.z = sz;
      };
      nodeProto._instantiate = function (cloned, isSyncedNode) {
        if (!cloned) {
          cloned = legacyCC.instantiate._clone(this, this);
        }
        cloned._prefab;
        cloned._parent = null;
        cloned._onBatchCreated(isSyncedNode);
        return cloned;
      };
      nodeProto._onSiblingIndexChanged = function (index) {
        const siblings = this._parent._children;
        index = index !== -1 ? index : siblings.length - 1;
        const oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          if (index < siblings.length) {
            siblings.splice(index, 0, this);
          } else {
            siblings.push(this);
          }
        }
      };
      nodeProto._ctor = function (name) {
        this.__nativeRefs = {};
        this._parentRef = null;
        this.__jsb_ref_id = undefined;
        this._iN$t = null;
        this.__editorExtras__ = {
          editorOnly: true
        };
        this._components = [];
        this._eventProcessor = new legacyCC.NodeEventProcessor(this);
        this._uiProps = new NodeUIProperties(this);
        const sharedArrayBuffer = this._initAndReturnSharedBuffer();
        this._sharedUint32Arr = new Uint32Array(sharedArrayBuffer, 0, 3);
        this._sharedInt32Arr = new Int32Array(sharedArrayBuffer, 12, 1);
        this._sharedUint8Arr = new Uint8Array(sharedArrayBuffer, 16, 3);
        this._sharedUint32Arr[1] = Layers.Enum.DEFAULT;
        this._scene = null;
        this._prefab = null;
        this._originalSceneId = '';
        this._children = [];
        this._lpos = new Vec3();
        this._lrot = new Quat();
        this._lscale = new Vec3(1, 1, 1);
        this._euler = new Vec3();
        this._registeredNodeEventTypeMask = 0;
      };
      patch_cc_Node({
        Node: Node$1,
        Vec3,
        Quat,
        MobilityMode,
        Layers
      });

      CCClass.Attr.setClassAttr(EventHandler, 'target', 'type', 'Object');
      CCClass.Attr.setClassAttr(EventHandler, 'target', 'ctor', Node$1);

      const _cachedArray = new Array(16);
      let _currentHovered = null;
      const pos = new Vec2();
      const _touchEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_MOVE, NodeEventType.TOUCH_END, NodeEventType.TOUCH_CANCEL];
      const _mouseEvents = [NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_WHEEL];
      let DispatcherEventType;
      (function (DispatcherEventType) {
        DispatcherEventType[DispatcherEventType["ADD_POINTER_EVENT_PROCESSOR"] = 0] = "ADD_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["REMOVE_POINTER_EVENT_PROCESSOR"] = 1] = "REMOVE_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["MARK_LIST_DIRTY"] = 2] = "MARK_LIST_DIRTY";
      })(DispatcherEventType || (DispatcherEventType = {}));
      class NodeEventProcessor {
        get isEnabled() {
          return this._isEnabled;
        }
        get node() {
          return this._node;
        }
        constructor(node) {
          this.claimedTouchIdList = [];
          this.maskList = null;
          this.cachedCameraPriority = 0;
          this.previousMouseIn = false;
          this.bubblingTarget = null;
          this.capturingTarget = null;
          this.shouldHandleEventMouse = false;
          this.shouldHandleEventTouch = false;
          this._dispatchingTouch = null;
          this._isEnabled = false;
          this._node = void 0;
          this._node = node;
        }
        setEnabled(value, recursive = false) {
          if (this._isEnabled === value) {
            return;
          }
          this._isEnabled = value;
          const node = this.node;
          const children = node.children;
          if (value) {
            this._attachMask();
          }
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.MARK_LIST_DIRTY);
          if (recursive && children.length > 0) {
            for (let i = 0; i < children.length; ++i) {
              const child = children[i];
              child.eventProcessor.setEnabled(value, true);
            }
          }
        }
        reattach() {
          let currentMaskList;
          this.node.walk(node => {
            if (!currentMaskList) {
              currentMaskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
            }
            node.eventProcessor.maskList = currentMaskList;
          });
        }
        destroy() {
          if (_currentHovered === this._node) {
            _currentHovered = null;
          }
          if (this.capturingTarget) this.capturingTarget.clear();
          if (this.bubblingTarget) this.bubblingTarget.clear();
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
          if (this._dispatchingTouch) {
            const cancelEvent = new EventTouch([this._dispatchingTouch], true, InputEventType.TOUCH_CANCEL);
            cancelEvent.touch = this._dispatchingTouch;
            this.dispatchEvent(cancelEvent);
            this._dispatchingTouch = null;
          }
        }
        on(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            var _this$capturingTarget;
            invoker = (_this$capturingTarget = this.capturingTarget) !== null && _this$capturingTarget !== void 0 ? _this$capturingTarget : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget;
            invoker = (_this$bubblingTarget = this.bubblingTarget) !== null && _this$bubblingTarget !== void 0 ? _this$bubblingTarget : this.bubblingTarget = this._newCallbacksInvoker();
          }
          invoker.on(type, callback, target);
          return callback;
        }
        once(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            var _this$capturingTarget2;
            invoker = (_this$capturingTarget2 = this.capturingTarget) !== null && _this$capturingTarget2 !== void 0 ? _this$capturingTarget2 : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget2;
            invoker = (_this$bubblingTarget2 = this.bubblingTarget) !== null && _this$bubblingTarget2 !== void 0 ? _this$bubblingTarget2 : this.bubblingTarget = this._newCallbacksInvoker();
          }
          invoker.on(type, callback, target, true);
          return callback;
        }
        off(type, callback, target, useCapture) {
          var _invoker;
          useCapture = !!useCapture;
          let invoker;
          if (useCapture) {
            invoker = this.capturingTarget;
          } else {
            invoker = this.bubblingTarget;
          }
          (_invoker = invoker) === null || _invoker === void 0 ? void 0 : _invoker.off(type, callback, target);
        }
        targetOff(target) {
          var _this$capturingTarget3, _this$bubblingTarget3;
          (_this$capturingTarget3 = this.capturingTarget) === null || _this$capturingTarget3 === void 0 ? void 0 : _this$capturingTarget3.removeAll(target);
          (_this$bubblingTarget3 = this.bubblingTarget) === null || _this$bubblingTarget3 === void 0 ? void 0 : _this$bubblingTarget3.removeAll(target);
          if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
            this.shouldHandleEventTouch = false;
          }
          if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
            this.shouldHandleEventMouse = false;
          }
          if (!this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
          }
        }
        emit(type, arg0, arg1, arg2, arg3, arg4) {
          var _this$bubblingTarget4;
          (_this$bubblingTarget4 = this.bubblingTarget) === null || _this$bubblingTarget4 === void 0 ? void 0 : _this$bubblingTarget4.emit(type, arg0, arg1, arg2, arg3, arg4);
        }
        dispatchEvent(event) {
          const owner = this.node;
          let target;
          let i = 0;
          event.target = owner;
          _cachedArray.length = 0;
          this.getCapturingTargets(event.type, _cachedArray);
          event.eventPhase = 1;
          for (i = _cachedArray.length - 1; i >= 0; --i) {
            target = _cachedArray[i];
            if (target.eventProcessor.capturingTarget) {
              event.currentTarget = target;
              target.eventProcessor.capturingTarget.emit(event.type, event, _cachedArray);
              if (event.propagationStopped) {
                _cachedArray.length = 0;
                return;
              }
            }
          }
          _cachedArray.length = 0;
          event.eventPhase = 2;
          event.currentTarget = owner;
          if (this.capturingTarget) {
            this.capturingTarget.emit(event.type, event);
          }
          if (!event.propagationImmediateStopped && this.bubblingTarget) {
            this.bubblingTarget.emit(event.type, event);
          }
          if (!event.propagationStopped && event.bubbles) {
            this.getBubblingTargets(event.type, _cachedArray);
            event.eventPhase = 3;
            for (i = 0; i < _cachedArray.length; ++i) {
              target = _cachedArray[i];
              if (target.eventProcessor.bubblingTarget) {
                event.currentTarget = target;
                target.eventProcessor.bubblingTarget.emit(event.type, event);
                if (event.propagationStopped) {
                  _cachedArray.length = 0;
                  return;
                }
              }
            }
          }
          _cachedArray.length = 0;
        }
        hasEventListener(type, callback, target) {
          let has = false;
          if (this.bubblingTarget) {
            has = this.bubblingTarget.hasEventListener(type, callback, target);
          }
          if (!has && this.capturingTarget) {
            has = this.capturingTarget.hasEventListener(type, callback, target);
          }
          return has;
        }
        getCapturingTargets(type, targets) {
          let parent = this._node.parent;
          while (parent) {
            var _parent$eventProcesso;
            if ((_parent$eventProcesso = parent.eventProcessor.capturingTarget) !== null && _parent$eventProcesso !== void 0 && _parent$eventProcesso.hasEventListener(type)) {
              targets.push(parent);
            }
            parent = parent.parent;
          }
        }
        getBubblingTargets(type, targets) {
          let parent = this._node.parent;
          while (parent) {
            var _parent$eventProcesso2;
            if ((_parent$eventProcesso2 = parent.eventProcessor.bubblingTarget) !== null && _parent$eventProcesso2 !== void 0 && _parent$eventProcesso2.hasEventListener(type)) {
              targets.push(parent);
            }
            parent = parent.parent;
          }
        }
        onUpdatingSiblingIndex() {
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.MARK_LIST_DIRTY);
        }
        _searchComponentsInParent(ctor) {
          const node = this.node;
          if (ctor) {
            let index = 0;
            let list = [];
            for (let curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
              const comp = curr.getComponent(ctor);
              if (comp) {
                const next = {
                  index,
                  comp
                };
                if (list) {
                  list.push(next);
                } else {
                  list = [next];
                }
              }
            }
            return list.length > 0 ? list : null;
          }
          return null;
        }
        _attachMask() {
          this.maskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
        }
        _isTouchEvent(type) {
          const index = _touchEvents.indexOf(type);
          return index !== -1;
        }
        _isMouseEvent(type) {
          const index = _mouseEvents.indexOf(type);
          return index !== -1;
        }
        _hasTouchListeners() {
          for (let i = 0; i < _touchEvents.length; ++i) {
            const eventType = _touchEvents[i];
            if (this.hasEventListener(eventType)) {
              return true;
            }
          }
          return false;
        }
        _hasMouseListeners() {
          for (let i = 0; i < _mouseEvents.length; ++i) {
            const eventType = _mouseEvents[i];
            if (this.hasEventListener(eventType)) {
              return true;
            }
          }
          return false;
        }
        _hasPointerListeners() {
          const has = this._hasTouchListeners();
          if (has) {
            return true;
          }
          return this._hasMouseListeners();
        }
        _tryEmittingAddEvent(typeToAdd) {
          const isTouchEvent = this._isTouchEvent(typeToAdd);
          const isMouseEvent = this._isMouseEvent(typeToAdd);
          if (isTouchEvent) {
            this.shouldHandleEventTouch = true;
          } else if (isMouseEvent) {
            this.shouldHandleEventMouse = true;
          }
          if ((isTouchEvent || isMouseEvent) && !this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this);
          }
        }
        _newCallbacksInvoker() {
          const callbacksInvoker = new CallbacksInvoker();
          callbacksInvoker._registerOffCallback(() => {
            if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
              this.shouldHandleEventTouch = false;
            }
            if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
              this.shouldHandleEventMouse = false;
            }
            if (!this._hasPointerListeners()) {
              NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
            }
          });
          return callbacksInvoker;
        }
        _handleEventMouse(eventMouse) {
          switch (eventMouse.type) {
            case InputEventType.MOUSE_DOWN:
              return this._handleMouseDown(eventMouse);
            case InputEventType.MOUSE_MOVE:
              return this._handleMouseMove(eventMouse);
            case InputEventType.MOUSE_UP:
              return this._handleMouseUp(eventMouse);
            case InputEventType.MOUSE_WHEEL:
              return this._handleMouseWheel(eventMouse);
            default:
              return false;
          }
        }
        _handleMouseDown(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_DOWN;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleMouseMove(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          const hit = node._uiProps.uiTransformComp.hitTest(pos, event.windowId);
          if (hit) {
            if (!this.previousMouseIn) {
              if (_currentHovered && _currentHovered !== node) {
                event.type = NodeEventType.MOUSE_LEAVE;
                _currentHovered.dispatchEvent(event);
                _currentHovered.eventProcessor.previousMouseIn = false;
              }
              _currentHovered = node;
              event.type = NodeEventType.MOUSE_ENTER;
              node.dispatchEvent(event);
              this.previousMouseIn = true;
            }
            event.type = NodeEventType.MOUSE_MOVE;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          } else if (this.previousMouseIn) {
            event.type = NodeEventType.MOUSE_LEAVE;
            node.dispatchEvent(event);
            this.previousMouseIn = false;
            _currentHovered = null;
          }
          return false;
        }
        _handleMouseUp(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_UP;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleMouseWheel(event) {
          const node = this._node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.MOUSE_WHEEL;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }
          return false;
        }
        _handleEventTouch(eventTouch) {
          switch (eventTouch.type) {
            case InputEventType.TOUCH_START:
              return this._handleTouchStart(eventTouch);
            case InputEventType.TOUCH_MOVE:
              return this._handleTouchMove(eventTouch);
            case InputEventType.TOUCH_END:
              return this._handleTouchEnd(eventTouch);
            case InputEventType.TOUCH_CANCEL:
              return this._handleTouchCancel(eventTouch);
            default:
              return false;
          }
        }
        _handleTouchStart(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.TOUCH_START;
            event.bubbles = true;
            this._dispatchingTouch = event.touch;
            node.dispatchEvent(event);
            return true;
          }
          return false;
        }
        _handleTouchMove(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }
          event.type = NodeEventType.TOUCH_MOVE;
          event.bubbles = true;
          this._dispatchingTouch = event.touch;
          node.dispatchEvent(event);
          return true;
        }
        _handleTouchEnd(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }
          event.getLocation(pos);
          if (node._uiProps.uiTransformComp.hitTest(pos, event.windowId)) {
            event.type = NodeEventType.TOUCH_END;
          } else {
            event.type = NodeEventType.TOUCH_CANCEL;
          }
          event.bubbles = true;
          node.dispatchEvent(event);
          this._dispatchingTouch = null;
        }
        _handleTouchCancel(event) {
          const node = this.node;
          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }
          event.type = NodeEventType.TOUCH_CANCEL;
          event.bubbles = true;
          node.dispatchEvent(event);
          this._dispatchingTouch = null;
        }
      }
      NodeEventProcessor._maskComp = null;
      NodeEventProcessor.callbacksInvoker = new CallbacksInvoker();
      legacyCC.NodeEventProcessor = NodeEventProcessor;

      const textureCubeProto = jsb.TextureCube.prototype;
      var FaceIndex;
      (function (FaceIndex) {
        FaceIndex[FaceIndex["right"] = 0] = "right";
        FaceIndex[FaceIndex["left"] = 1] = "left";
        FaceIndex[FaceIndex["top"] = 2] = "top";
        FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
        FaceIndex[FaceIndex["front"] = 4] = "front";
        FaceIndex[FaceIndex["back"] = 5] = "back";
      })(FaceIndex || (FaceIndex = {}));
      var MipmapMode;
      (function (MipmapMode) {
        MipmapMode[MipmapMode["NONE"] = 0] = "NONE";
        MipmapMode[MipmapMode["AUTO"] = 1] = "AUTO";
        MipmapMode[MipmapMode["BAKED_CONVOLUTION_MAP"] = 2] = "BAKED_CONVOLUTION_MAP";
      })(MipmapMode || (MipmapMode = {}));
      textureCubeProto.createNode = null;
      const TextureCube = exports('TextureCube', jsb.TextureCube);
      TextureCube.Filter = Filter;
      TextureCube.PixelFormat = PixelFormat;
      TextureCube.WrapMode = WrapMode;
      textureCubeProto._ctor = function () {
        jsb.SimpleTexture.prototype._ctor.apply(this, arguments);
        this._mipmaps = null;
        this._mipmapAtlas = null;
      };
      Object.defineProperty(textureCubeProto, 'mipmaps', {
        get() {
          return this._mipmaps;
        },
        set(value) {
          this._mipmaps = value;
          this.setMipmaps(value);
        }
      });
      Object.defineProperty(textureCubeProto, 'image', {
        get() {
          return this._mipmaps.length === 0 ? null : this._mipmaps[0];
        },
        set(value) {
          this.mipmaps = value ? [value] : [];
        }
      });
      const oldOnLoaded$1 = textureCubeProto.onLoaded;
      textureCubeProto.onLoaded = function () {
        if (this._mipmapMode === MipmapMode.BAKED_CONVOLUTION_MAP) {
          this.setMipmapAtlasForJS(this._mipmapAtlas);
        } else {
          this.setMipmapsForJS(this._mipmaps);
        }
        oldOnLoaded$1.apply(this);
      };
      textureCubeProto._serialize = function (ctxForExporting) {
        return null;
      };
      textureCubeProto._deserialize = function (serializedData, handle) {
        const data = serializedData;
        jsb.TextureBase.prototype._deserialize.call(this, data.base, handle);
        this.isRGBE = data.rgbe;
        if (data.mipmapMode != undefined) {
          this._mipmapMode = data.mipmapMode;
        }
        if (this._mipmapMode === MipmapMode.BAKED_CONVOLUTION_MAP) {
          const mipmapAtlas = data.mipmapAtlas;
          const mipmapLayout = data.mipmapLayout;
          this._mipmapAtlas = {
            atlas: {},
            layout: mipmapLayout
          };
          this._mipmapAtlas.atlas = {
            front: new jsb.ImageAsset(),
            back: new jsb.ImageAsset(),
            left: new jsb.ImageAsset(),
            right: new jsb.ImageAsset(),
            top: new jsb.ImageAsset(),
            bottom: new jsb.ImageAsset()
          };
          if (mipmapAtlas) {
            const imageAssetClassId = getClassId(jsb.ImageAsset);
            handle.result.push(this._mipmapAtlas.atlas, `front`, mipmapAtlas.front, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `back`, mipmapAtlas.back, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `left`, mipmapAtlas.left, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `right`, mipmapAtlas.right, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `top`, mipmapAtlas.top, imageAssetClassId);
            handle.result.push(this._mipmapAtlas.atlas, `bottom`, mipmapAtlas.bottom, imageAssetClassId);
          }
        } else {
          this._mipmaps = new Array(data.mipmaps.length);
          for (let i = 0; i < data.mipmaps.length; ++i) {
            this._mipmaps[i] = {
              front: new jsb.ImageAsset(),
              back: new jsb.ImageAsset(),
              left: new jsb.ImageAsset(),
              right: new jsb.ImageAsset(),
              top: new jsb.ImageAsset(),
              bottom: new jsb.ImageAsset()
            };
            const mipmap = data.mipmaps[i];
            const imageAssetClassId = getClassId(jsb.ImageAsset);
            handle.result.push(this._mipmaps[i], `front`, mipmap.front, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `back`, mipmap.back, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `left`, mipmap.left, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `right`, mipmap.right, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `top`, mipmap.top, imageAssetClassId);
            handle.result.push(this._mipmaps[i], `bottom`, mipmap.bottom, imageAssetClassId);
          }
        }
      };
      legacyCC.TextureCube = jsb.TextureCube;
      patch_cc_TextureCube({
        TextureCube,
        MipmapMode
      });

      let ModelType;
      (function (ModelType) {
        ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
        ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
        ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
        ModelType[ModelType["BATCH_2D"] = 3] = "BATCH_2D";
        ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
        ModelType[ModelType["LINE"] = 5] = "LINE";
      })(ModelType || (ModelType = {}));
      const Model = jsb.Model;
      const modelProto = Model.prototype;
      modelProto._ctor = function () {
        this._device = deviceManager.gfxDevice;
      };
      const oldCreateBoundingShape = modelProto.createBoundingShape;
      modelProto.createBoundingShape = function (minPos, maxPos) {
        if (!minPos || !maxPos) {
          return;
        }
        oldCreateBoundingShape.call(this, minPos, maxPos);
      };

      const SubModel = jsb.SubModel;

      let CameraFOVAxis;
      (function (CameraFOVAxis) {
        CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
        CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
      })(CameraFOVAxis || (CameraFOVAxis = {}));
      let CameraProjection;
      (function (CameraProjection) {
        CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
        CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
      })(CameraProjection || (CameraProjection = {}));
      let CameraAperture;
      (function (CameraAperture) {
        CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
        CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
        CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
        CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
        CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
        CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
        CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
        CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
        CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
        CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
        CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
        CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
        CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
        CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
        CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
        CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
        CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
        CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
        CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
        CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
        CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
        CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
        CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
      })(CameraAperture || (CameraAperture = {}));
      let CameraISO;
      (function (CameraISO) {
        CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
        CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
        CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
        CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
      })(CameraISO || (CameraISO = {}));
      let CameraShutter;
      (function (CameraShutter) {
        CameraShutter[CameraShutter["D1"] = 0] = "D1";
        CameraShutter[CameraShutter["D2"] = 1] = "D2";
        CameraShutter[CameraShutter["D4"] = 2] = "D4";
        CameraShutter[CameraShutter["D8"] = 3] = "D8";
        CameraShutter[CameraShutter["D15"] = 4] = "D15";
        CameraShutter[CameraShutter["D30"] = 5] = "D30";
        CameraShutter[CameraShutter["D60"] = 6] = "D60";
        CameraShutter[CameraShutter["D125"] = 7] = "D125";
        CameraShutter[CameraShutter["D250"] = 8] = "D250";
        CameraShutter[CameraShutter["D500"] = 9] = "D500";
        CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
        CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
        CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
      })(CameraShutter || (CameraShutter = {}));
      let CameraType;
      (function (CameraType) {
        CameraType[CameraType["DEFAULT"] = -1] = "DEFAULT";
        CameraType[CameraType["LEFT_EYE"] = 0] = "LEFT_EYE";
        CameraType[CameraType["RIGHT_EYE"] = 1] = "RIGHT_EYE";
        CameraType[CameraType["MAIN"] = 2] = "MAIN";
      })(CameraType || (CameraType = {}));
      let TrackingType;
      (function (TrackingType) {
        TrackingType[TrackingType["NO_TRACKING"] = 0] = "NO_TRACKING";
        TrackingType[TrackingType["POSITION_AND_ROTATION"] = 1] = "POSITION_AND_ROTATION";
        TrackingType[TrackingType["POSITION"] = 2] = "POSITION";
        TrackingType[TrackingType["ROTATION"] = 3] = "ROTATION";
      })(TrackingType || (TrackingType = {}));
      let CameraUsage;
      (function (CameraUsage) {
        CameraUsage[CameraUsage["EDITOR"] = 0] = "EDITOR";
        CameraUsage[CameraUsage["GAME_VIEW"] = 1] = "GAME_VIEW";
        CameraUsage[CameraUsage["SCENE_VIEW"] = 2] = "SCENE_VIEW";
        CameraUsage[CameraUsage["PREVIEW"] = 3] = "PREVIEW";
        CameraUsage[CameraUsage["GAME"] = 100] = "GAME";
      })(CameraUsage || (CameraUsage = {}));
      const SKYBOX_FLAG = ClearFlagBit.STENCIL << 1;
      const Camera$1 = jsb.Camera;
      const cameraProto = jsb.Camera.prototype;
      Object.defineProperty(Camera$1, "standardExposureValue", {
        configurable: true,
        enumerable: true,
        get() {
          return Camera$1.getStandardExposureValue();
        }
      });
      Object.defineProperty(Camera$1, "standardLightMeterScale", {
        configurable: true,
        enumerable: true,
        get() {
          return Camera$1.getStandardLightMeterScale();
        }
      });
      Object.defineProperty(cameraProto, 'matView', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatView();
          fillMat4WithTempFloatArray(this._matView);
          return this._matView;
        }
      });
      Object.defineProperty(cameraProto, 'matProj', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatProj();
          fillMat4WithTempFloatArray(this._matProj);
          return this._matProj;
        }
      });
      Object.defineProperty(cameraProto, 'matProjInv', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatProjInv();
          fillMat4WithTempFloatArray(this._matProjInv);
          return this._matProjInv;
        }
      });
      Object.defineProperty(cameraProto, 'matViewProj', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatViewProj();
          fillMat4WithTempFloatArray(this._matViewProj);
          return this._matViewProj;
        }
      });
      Object.defineProperty(cameraProto, 'matViewProjInv', {
        configurable: true,
        enumerable: true,
        get() {
          this.getMatViewProjInv();
          fillMat4WithTempFloatArray(this._matViewProjInv);
          return this._matViewProjInv;
        }
      });
      const oldInitialize = cameraProto.initialize;
      cameraProto.initialize = function initialize() {
        oldInitialize.apply(this, arguments);
        this._matView = new Mat4();
        this._matProj = new Mat4();
        this._matProjInv = new Mat4();
        this._matViewProj = new Mat4();
        this._matViewProjInv = new Mat4();
      };
      const oldScreenPointToRay = cameraProto.screenPointToRay;
      const oldScreenToWorld = cameraProto.screenToWorld;
      const oldWorldToScreen = cameraProto.worldToScreen;
      const oldWorldMatrixToScreen = cameraProto.worldMatrixToScreen;
      cameraProto.screenPointToRay = function screenPointToRay(out, x, y) {
        _tempFloatArray[0] = x;
        _tempFloatArray[1] = y;
        oldScreenPointToRay.call(this);
        out.o.x = _tempFloatArray[0];
        out.o.y = _tempFloatArray[1];
        out.o.z = _tempFloatArray[2];
        out.d.x = _tempFloatArray[3];
        out.d.y = _tempFloatArray[4];
        out.d.z = _tempFloatArray[5];
        return out;
      };
      cameraProto.screenToWorld = function screenToWorld(out, screenPos) {
        _tempFloatArray[0] = screenPos.x;
        _tempFloatArray[1] = screenPos.y;
        _tempFloatArray[2] = screenPos.z;
        oldScreenToWorld.call(this);
        Vec3.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
        return out;
      };
      cameraProto.worldToScreen = function worldToScreen(out, worldPos) {
        _tempFloatArray[0] = worldPos.x;
        _tempFloatArray[1] = worldPos.y;
        _tempFloatArray[2] = worldPos.z;
        oldWorldToScreen.call(this);
        Vec3.set(out, _tempFloatArray[0], _tempFloatArray[1], _tempFloatArray[2]);
        return out;
      };
      cameraProto.worldMatrixToScreen = function worldMatrixToScreen(out, worldMatrix, width, height) {
        _tempFloatArray[0] = worldMatrix.m00;
        _tempFloatArray[1] = worldMatrix.m01;
        _tempFloatArray[2] = worldMatrix.m02;
        _tempFloatArray[3] = worldMatrix.m03;
        _tempFloatArray[4] = worldMatrix.m04;
        _tempFloatArray[5] = worldMatrix.m05;
        _tempFloatArray[6] = worldMatrix.m06;
        _tempFloatArray[7] = worldMatrix.m07;
        _tempFloatArray[8] = worldMatrix.m08;
        _tempFloatArray[9] = worldMatrix.m09;
        _tempFloatArray[10] = worldMatrix.m10;
        _tempFloatArray[11] = worldMatrix.m11;
        _tempFloatArray[12] = worldMatrix.m12;
        _tempFloatArray[13] = worldMatrix.m13;
        _tempFloatArray[14] = worldMatrix.m14;
        _tempFloatArray[15] = worldMatrix.m15;
        _tempFloatArray[16] = width;
        _tempFloatArray[17] = height;
        oldWorldMatrixToScreen.call(this);
        fillMat4WithTempFloatArray(out);
        return out;
      };

      let ProbeClearFlag;
      (function (ProbeClearFlag) {
        ProbeClearFlag[ProbeClearFlag["SKYBOX"] = SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL] = "SKYBOX";
        ProbeClearFlag[ProbeClearFlag["SOLID_COLOR"] = ClearFlagBit.ALL] = "SOLID_COLOR";
      })(ProbeClearFlag || (ProbeClearFlag = {}));
      let ProbeType;
      (function (ProbeType) {
        ProbeType[ProbeType["CUBE"] = 0] = "CUBE";
        ProbeType[ProbeType["PLANAR"] = 1] = "PLANAR";
      })(ProbeType || (ProbeType = {}));
      const ReflectionProbe$1 = jsb.ReflectionProbe;
      const reflectionProbeProto = jsb.ReflectionProbe.prototype;
      reflectionProbeProto._ctor = function (id) {
        this._probeId = id;
      };

      const LODData = jsb.LODData;
      const LODGroup$1 = jsb.LODGroup;
      const Ambient = jsb.Ambient;
      legacyCC.Ambient = Ambient;
      Ambient.SUN_ILLUM = 65000.0;
      Ambient.SKY_ILLUM = 20000.0;
      function ColorTemperatureToRGB(rgb, kelvin) {
        if (kelvin < 1000.0) {
          kelvin = 1000.0;
        } else if (kelvin > 15000.0) {
          kelvin = 15000.0;
        }
        const kSqr = kelvin * kelvin;
        const u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
        const v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
        const d = 2.0 * u - 8.0 * v + 4.0;
        const x = 3.0 * u / d;
        const y = 2.0 * v / d;
        const z = 1.0 - x - y;
        const X = 1.0 / y * x;
        const Z = 1.0 / y * z;
        rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
        rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
        rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
      }
      let LightType$1;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType$1 || (LightType$1 = {}));
      const nt2lm = size => 4 * Math.PI * Math.PI * size * size;
      const Light$1 = jsb.Light;
      legacyCC.Light = jsb.Light;
      const DirectionalLight$1 = jsb.DirectionalLight;
      legacyCC.DirectionalLight = jsb.DirectionalLight;
      const SpotLight$1 = jsb.SpotLight;
      legacyCC.SpotLight = jsb.SpotLight;
      const SphereLight$1 = jsb.SphereLight;
      legacyCC.SphereLight = jsb.SphereLight;
      const PointLight$1 = jsb.PointLight;
      legacyCC.PointLight = jsb.PointLight;
      const RangedDirectionalLight$1 = jsb.RangedDirectionalLight;
      legacyCC.RangedDirectionalLight = jsb.RangedDirectionalLight;
      const FogType$1 = Enum({
        LINEAR: 0,
        EXP: 1,
        EXP_SQUARED: 2,
        LAYERED: 3
      });
      const FOG_TYPE_NONE = FogType$1.LAYERED + 1;
      const FogInfo$1 = jsb.FogInfo;
      const Fog = jsb.Fog;
      legacyCC.Fog = Fog;
      const ShadowSize$1 = Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      });
      const ShadowType$2 = Enum({
        Planar: 0,
        ShadowMap: 1
      });
      const PCFType = Enum({
        HARD: 0,
        SOFT: 1,
        SOFT_2X: 2,
        SOFT_4X: 3
      });
      const CSMLevel$1 = Enum({
        LEVEL_1: 1,
        LEVEL_2: 2,
        LEVEL_3: 3,
        LEVEL_4: 4
      });
      const CSMOptimizationMode = Enum({
        NONE: 1,
        RemoveDuplicates: 2,
        DisableRotationFix: 3
      });
      const EnvironmentLightingType = Enum({
        HEMISPHERE_DIFFUSE: 0,
        AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: 1,
        DIFFUSEMAP_WITH_REFLECTION: 2
      });
      const ToneMappingType = Enum({
        DEFAULT: 0,
        LINEAR: 1
      });
      const ShadowsInfo$1 = jsb.ShadowsInfo;
      const Shadows$1 = jsb.Shadows;
      legacyCC.Shadows = Shadows$1;
      Object.defineProperty(Shadows$1, "MAX_FAR", {
        configurable: true,
        enumerable: true,
        get() {
          return 2000.0;
        }
      });
      const COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
      Object.defineProperty(Shadows$1, 'COEFFICIENT_OF_EXPANSION', {
        configurable: true,
        enumerable: true,
        get() {
          return COEFFICIENT_OF_EXPANSION;
        }
      });
      const Skybox = jsb.Skybox;
      legacyCC.Skybox = Skybox;
      const PostSettings = jsb.PostSettings;
      legacyCC.PostSettings = PostSettings;

      var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ModelType () { return ModelType; },
        Model: Model,
        SubModel: SubModel,
        get CameraFOVAxis () { return CameraFOVAxis; },
        get CameraProjection () { return CameraProjection; },
        get CameraAperture () { return CameraAperture; },
        get CameraISO () { return CameraISO; },
        get CameraShutter () { return CameraShutter; },
        get CameraType () { return CameraType; },
        get TrackingType () { return TrackingType; },
        get CameraUsage () { return CameraUsage; },
        SKYBOX_FLAG: SKYBOX_FLAG,
        Camera: Camera$1,
        get ProbeClearFlag () { return ProbeClearFlag; },
        get ProbeType () { return ProbeType; },
        ReflectionProbe: ReflectionProbe$1,
        LODData: LODData,
        LODGroup: LODGroup$1,
        Ambient: Ambient,
        ColorTemperatureToRGB: ColorTemperatureToRGB,
        get LightType () { return LightType$1; },
        nt2lm: nt2lm,
        Light: Light$1,
        DirectionalLight: DirectionalLight$1,
        SpotLight: SpotLight$1,
        SphereLight: SphereLight$1,
        PointLight: PointLight$1,
        RangedDirectionalLight: RangedDirectionalLight$1,
        FogType: FogType$1,
        FOG_TYPE_NONE: FOG_TYPE_NONE,
        FogInfo: FogInfo$1,
        Fog: Fog,
        ShadowSize: ShadowSize$1,
        ShadowType: ShadowType$2,
        PCFType: PCFType,
        CSMLevel: CSMLevel$1,
        CSMOptimizationMode: CSMOptimizationMode,
        EnvironmentLightingType: EnvironmentLightingType,
        ToneMappingType: ToneMappingType,
        ShadowsInfo: ShadowsInfo$1,
        Shadows: Shadows$1,
        Skybox: Skybox,
        PostSettings: PostSettings
      });

      const EffectAsset = exports('EffectAsset', jsb.EffectAsset);
      legacyCC.EffectAsset = EffectAsset;
      const effectAssetProto = EffectAsset.prototype;
      effectAssetProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this.hideInEditor = false;
      };
      patch_cc_EffectAsset({
        EffectAsset
      });

      const matProto = jsb.Material.prototype;
      function wrapSetProperty(cb, target, name, val, passIdx) {
        if (passIdx != undefined) {
          cb.call(target, name, val, passIdx);
        } else {
          cb.call(target, name, val);
        }
      }
      var MathType;
      (function (MathType) {
        MathType[MathType["VEC2"] = 0] = "VEC2";
        MathType[MathType["VEC3"] = 1] = "VEC3";
        MathType[MathType["VEC4"] = 2] = "VEC4";
        MathType[MathType["QUATERNION"] = 3] = "QUATERNION";
        MathType[MathType["MAT3"] = 4] = "MAT3";
        MathType[MathType["MAT4"] = 5] = "MAT4";
        MathType[MathType["SIZE"] = 6] = "SIZE";
        MathType[MathType["RECT"] = 7] = "RECT";
        MathType[MathType["COLOR"] = 8] = "COLOR";
      })(MathType || (MathType = {}));
      matProto.setProperty = function (name, val, passIdx) {
        if (Array.isArray(val)) {
          const first = val[0];
          if (typeof first === 'number') {
            if (Number.isInteger(first)) {
              wrapSetProperty(this.setPropertyInt32Array, this, name, val, passIdx);
            } else {
              wrapSetProperty(this.setPropertyFloat32Array, this, name, val, passIdx);
            }
          } else if (first instanceof Vec2) {
            wrapSetProperty(this.setPropertyVec2Array, this, name, val, passIdx);
          } else if (first instanceof Vec3) {
            wrapSetProperty(this.setPropertyVec3Array, this, name, val, passIdx);
          } else if (first instanceof Vec4) {
            wrapSetProperty(this.setPropertyVec4Array, this, name, val, passIdx);
          } else if (first instanceof Color$1) {
            wrapSetProperty(this.setPropertyColorArray, this, name, val, passIdx);
          } else if (first instanceof Mat3) {
            wrapSetProperty(this.setPropertyMat3Array, this, name, val, passIdx);
          } else if (first instanceof Mat4) {
            wrapSetProperty(this.setPropertyMat4Array, this, name, val, passIdx);
          } else if (first instanceof Quat) {
            wrapSetProperty(this.setPropertyQuatArray, this, name, val, passIdx);
          } else if (first instanceof TextureBase) {
            wrapSetProperty(this.setPropertyTextureBaseArray, this, name, val, passIdx);
          } else if (first instanceof Texture) {
            wrapSetProperty(this.setPropertyGFXTextureArray, this, name, val, passIdx);
          } else {
            legacyCC.error(`Material.setProperty Unknown type: ${val}`);
          }
        } else if (typeof val === 'number') {
          if (Number.isInteger(val)) {
            wrapSetProperty(this.setPropertyInt32, this, name, val, passIdx);
          } else {
            wrapSetProperty(this.setPropertyFloat32, this, name, val, passIdx);
          }
        } else if (val instanceof Vec2) {
          wrapSetProperty(this.setPropertyVec2, this, name, val, passIdx);
        } else if (val instanceof Vec3) {
          wrapSetProperty(this.setPropertyVec3, this, name, val, passIdx);
        } else if (val instanceof Vec4) {
          wrapSetProperty(this.setPropertyVec4, this, name, val, passIdx);
        } else if (val instanceof Color$1) {
          wrapSetProperty(this.setPropertyColor, this, name, val, passIdx);
        } else if (val instanceof Mat3) {
          wrapSetProperty(this.setPropertyMat3, this, name, val, passIdx);
        } else if (val instanceof Mat4) {
          wrapSetProperty(this.setPropertyMat4, this, name, val, passIdx);
        } else if (val instanceof Quat) {
          wrapSetProperty(this.setPropertyQuat, this, name, val, passIdx);
        } else if (val instanceof TextureBase) {
          wrapSetProperty(this.setPropertyTextureBase, this, name, val, passIdx);
        } else if (val instanceof Texture) {
          wrapSetProperty(this.setPropertyGFXTexture, this, name, val, passIdx);
        } else if (val === null) {
          if (passIdx) {
            this.setPropertyNull(name, passIdx);
          } else {
            this.setPropertyNull(name);
          }
        } else {
          legacyCC.error(`Material.setProperty Unknown type: ${val}`);
        }
      };
      matProto.getProperty = function (name, passIdx) {
        let val;
        if (passIdx !== undefined) {
          val = this._getProperty(name, passIdx);
        } else {
          val = this._getProperty(name);
        }
        if (Array.isArray(val)) {
          const first = val[0];
          const arr = [];
          if (first instanceof jsb.Vec2 || first.type === MathType.VEC2) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec2(e.x, e.y));
            }
          } else if (first.type === MathType.VEC3) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec3(e.x, e.y, e.z));
            }
          } else if (first.type === MathType.VEC4) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Vec4(e.x, e.y, e.z, e.w));
            }
          } else if (first instanceof jsb.Color) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Color$1(e.r, e.g, e.b, e.a));
            }
          } else if (first.type === MathType.MAT3) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Mat3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]));
            }
          } else if (first.type === MathType.MAT4) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Mat4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]));
            }
          } else if (first.type === MathType.QUATERNION) {
            for (let i = 0, len = val.length; i < len; ++i) {
              const e = val[i];
              arr.push(new Quat(e.x, e.y, e.z, e.w));
            }
          }
          return arr || val;
        } else if (val === null || val === undefined) {
          return null;
        }
        let ret;
        const e = val;
        if (val instanceof jsb.Vec2 || val.type === MathType.VEC2) {
          ret = new Vec3(e.x, e.y);
        } else if (val.type === MathType.VEC3) {
          ret = new Vec3(e.x, e.y, e.z);
        } else if (val.type === MathType.VEC4) {
          ret = new Vec4(e.x, e.y, e.z, e.w);
        } else if (val instanceof jsb.Color) {
          ret = new Color$1(e.r, e.g, e.b, e.a);
        } else if (val.type === MathType.MAT3) {
          ret = new Mat3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        } else if (val.type === MathType.MAT4) {
          ret = new Mat4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        } else if (val.type === MathType.QUATERNION) {
          ret = new Quat(e.x, e.y, e.z, e.w);
        }
        return ret || val;
      };
      const Material = exports('Material', jsb.Material);
      legacyCC.Material = Material;
      const materialProto = Material.prototype;
      materialProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._props = [];
        this._passes = [];
        this._registerPassesUpdatedListener();
        this._isCtorCalled = true;
      };
      const oldOnLoaded = materialProto.onLoaded;
      materialProto.onLoaded = function () {
        this._propsInternal = this._props;
        oldOnLoaded.call(this);
      };
      materialProto._onPassesUpdated = function () {
        this._passes = this.getPasses();
      };
      Object.defineProperty(materialProto, 'passes', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._isCtorCalled) {
            this._ctor();
            this._passes = this.getPasses();
          }
          return this._passes;
        }
      });
      patch_cc_Material({
        Material,
        EffectAsset
      });

      const DEFAULT_WORLD_MIN_POS = exports('DEFAULT_WORLD_MIN_POS', new Vec3(-1024.0, -1024.0, -1024.0));
      const DEFAULT_WORLD_MAX_POS = exports('DEFAULT_WORLD_MAX_POS', new Vec3(1024.0, 1024.0, 1024.0));
      const DEFAULT_OCTREE_DEPTH = exports('DEFAULT_OCTREE_DEPTH', 8);
      const FogType = exports('FogType', Enum({
        LINEAR: 0,
        EXP: 1,
        EXP_SQUARED: 2,
        LAYERED: 3
      }));
      const ShadowSize = exports('ShadowSize', Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      }));
      const ShadowType$1 = exports('ShadowType', Enum({
        Planar: 0,
        ShadowMap: 1
      }));
      const AmbientInfo = exports('AmbientInfo', jsb.AmbientInfo);
      legacyCC.AmbientInfo = AmbientInfo;
      const SkyboxInfo = exports('SkyboxInfo', jsb.SkyboxInfo);
      legacyCC.SkyboxInfo = SkyboxInfo;
      const FogInfo = exports('FogInfo', jsb.FogInfo);
      legacyCC.FogInfo = FogInfo;
      FogInfo.FogType = FogType;
      const ShadowsInfo = exports('ShadowsInfo', jsb.ShadowsInfo);
      legacyCC.ShadowsInfo = ShadowsInfo;
      const OctreeInfo = exports('OctreeInfo', jsb.OctreeInfo);
      legacyCC.OctreeInfo = OctreeInfo;
      const LightProbeInfo = exports('LightProbeInfo', jsb.LightProbeInfo);
      const SceneGlobals = exports('SceneGlobals', jsb.SceneGlobals);
      legacyCC.SceneGlobals = SceneGlobals;
      const SkinInfo = exports('SkinInfo', jsb.SkinInfo);
      legacyCC.SkinInfo = SkinInfo;
      const PostSettingsInfo = exports('PostSettingsInfo', jsb.PostSettingsInfo);
      legacyCC.PostSettingsInfo = PostSettingsInfo;
      (function () {
        const sceneGlobalsProto = SceneGlobals.prototype;
        sceneGlobalsProto._ctor = function () {
          this._ambientRef = this.getAmbientInfo();
          this._shadowsRef = this.getShadowsInfo();
          this._skyboxRef = this.getSkyboxInfo();
          this._fogRef = this.getFogInfo();
          this._octreeRef = this.getOctreeInfo();
          this._lightProbeRef = this.getLightProbeInfo();
          this._skinRef = this.getSkinInfo();
          this._postSettingsRef = this.getPostSettingsInfo();
        };
        Object.defineProperty(sceneGlobalsProto, 'ambient', {
          enumerable: true,
          configurable: true,
          get() {
            return this._ambientRef;
          },
          set(v) {
            this._ambientRef = v;
            this.setAmbientInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'shadows', {
          enumerable: true,
          configurable: true,
          get() {
            return this._shadowsRef;
          },
          set(v) {
            this._shadowsRef = v;
            this.setShadowsInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, '_skybox', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skyboxRef;
          },
          set(v) {
            this._skyboxRef = v;
            this.setSkyboxInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'skybox', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skyboxRef;
          },
          set(v) {
            this._skyboxRef = v;
            this.setSkyboxInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'fog', {
          enumerable: true,
          configurable: true,
          get() {
            return this._fogRef;
          },
          set(v) {
            this._fogRef = v;
            this.setFogInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'octree', {
          enumerable: true,
          configurable: true,
          get() {
            return this._octreeRef;
          },
          set(v) {
            this._octreeRef = v;
            this.setOctreeInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'lightProbeInfo', {
          enumerable: true,
          configurable: true,
          get() {
            return this._lightProbeRef;
          },
          set(v) {
            this._lightProbeRef = v;
            this.setLightProbeInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'skin', {
          enumerable: true,
          configurable: true,
          get() {
            return this._skinRef;
          },
          set(v) {
            this._skinRef = v;
            this.setSkinInfo(v);
          }
        });
        Object.defineProperty(sceneGlobalsProto, 'postSettings', {
          enumerable: true,
          configurable: true,
          get() {
            return this._postSettingsRef;
          },
          set(v) {
            this._postSettingsRef = v;
            this.setPostSettingsInfo(v);
          }
        });
      })();
      patch_cc_SceneGlobals({
        SceneGlobals,
        AmbientInfo,
        SkyboxInfo,
        FogInfo,
        ShadowsInfo,
        LightProbeInfo,
        OctreeInfo,
        SkinInfo,
        PostSettingsInfo
      });
      patch_cc_OctreeInfo({
        OctreeInfo,
        CCInteger,
        Vec3,
        DEFAULT_WORLD_MAX_POS,
        DEFAULT_WORLD_MIN_POS,
        DEFAULT_OCTREE_DEPTH
      });
      patch_cc_ShadowsInfo({
        ShadowsInfo,
        ShadowType: ShadowType$1,
        CCFloat,
        CCInteger,
        ShadowSize,
        Vec3,
        Color: Color$1,
        Vec2
      });
      patch_cc_FogInfo({
        FogInfo,
        FogType,
        CCFloat,
        Color: Color$1
      });
      patch_cc_SkyboxInfo({
        SkyboxInfo,
        EnvironmentLightingType,
        TextureCube,
        CCFloat,
        Material
      });
      patch_cc_AmbientInfo({
        AmbientInfo,
        Vec4,
        Ambient,
        CCFloat,
        legacyCC
      });
      patch_cc_LightProbeInfo({
        LightProbeInfo,
        CCFloat,
        CCInteger
      });
      patch_cc_SkinInfo({
        SkinInfo,
        CCFloat
      });
      patch_cc_PostSettingsInfo({
        PostSettingsInfo,
        ToneMappingType
      });

      var _dec$1E, _class$1B;
      replaceProperty(Node$1.prototype, 'Node', [{
        name: 'childrenCount',
        newName: 'children.length',
        customGetter() {
          return this.children.length;
        }
      }]);
      replaceProperty(Node$1.prototype, 'Node', [{
        name: 'width',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.width;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.width = value;
        }
      }, {
        name: 'height',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.height;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.height = value;
        }
      }, {
        name: 'anchorX',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.anchorX;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.anchorX = value;
        }
      }, {
        name: 'anchorY',
        targetName: 'node.getComponent(UITransform)',
        customGetter() {
          return this._uiProps.uiTransformComp.anchorY;
        },
        customSetter(value) {
          this._uiProps.uiTransformComp.anchorY = value;
        }
      }, {
        name: 'getAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction(out) {
          if (!out) {
            out = new Vec2();
          }
          out.set(this._uiProps.uiTransformComp.anchorPoint);
          return out;
        }
      }, {
        name: 'setAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction(point, y) {
          this._uiProps.uiTransformComp.setAnchorPoint(point, y);
        }
      }, {
        name: 'getContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction(out) {
          if (!out) {
            out = new Size$1();
          }
          out.set(this._uiProps.uiTransformComp.contentSize);
          return out;
        }
      }, {
        name: 'setContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction(size, height) {
          if (typeof size === 'number') {
            this._uiProps.uiTransformComp.setContentSize(size, height);
          } else {
            this._uiProps.uiTransformComp.setContentSize(size);
          }
        }
      }]);
      removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      replaceProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'distance',
        newName: 'planeHeight'
      }, {
        name: 'normal',
        newName: 'planeDirection'
      }, {
        name: 'size',
        newName: 'shadowMapSize'
      }]);
      removeProperty(Node$1.prototype, 'Node.prototype', [{
        name: 'addLayer'
      }, {
        name: 'removeLayer'
      }]);
      replaceProperty(NodeUIProperties.prototype, 'NodeUIProperties', [{
        name: 'opacityDirty',
        newName: 'colorDirty'
      }]);
      removeProperty(Layers, 'Layers', [{
        name: 'All'
      }, {
        name: 'RaycastMask'
      }, {
        name: 'check'
      }]);
      replaceProperty(Layers, 'Layers', [{
        name: 'Default',
        newName: 'DEFAULT',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Always',
        newName: 'ALWAYS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'IgnoreRaycast',
        newName: 'IGNORE_RAYCAST',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Gizmos',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Editor',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI',
        newName: 'UI_3D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI2D',
        newName: 'UI_2D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'SceneGizmo',
        newName: 'SCENE_GIZMO',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'makeInclusiveMask',
        newName: 'makeMaskInclude',
        target: Layers,
        targetName: 'Layers'
      }, {
        name: 'makeExclusiveMask',
        newName: 'makeMaskExclude',
        target: Layers,
        targetName: 'Layers'
      }]);
      removeProperty(Layers.Enum, 'Layers.Enum', [{
        name: 'ALWAYS'
      }]);
      removeProperty(Layers.BitMask, 'Layers.BitMask', [{
        name: 'ALWAYS'
      }]);
      const HideInHierarchy = CCObject.Flags.HideInHierarchy;
      const DontSave = CCObject.Flags.DontSave;
      let PrivateNode = exports('PrivateNode', (_dec$1E = ccclass$6('cc.PrivateNode'), _dec$1E(_class$1B = class PrivateNode extends Node$1 {
        constructor(name) {
          super(name);
          warnID(12003, this.name);
          this.hideFlags |= DontSave | HideInHierarchy;
        }
      }) || _class$1B));
      replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(name => ({
        name,
        target: Node$1.EventType,
        targetName: 'Node.EventType'
      })));
      replaceProperty(Node$1.EventType, 'Node.EventType', [{
        name: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_DOWN',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_UP',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      legacyCC.PrivateNode = PrivateNode;

      deprecateModuleExportedName({
        BaseNode: {
          newName: 'Node',
          since: '3.7.0',
          removed: false
        }
      });

      var _dec$1D, _dec2$1n, _class$1A, _class2$1t, _initializer$1o, _dec3$13, _dec4$Q, _dec5$J, _dec6$w, _dec7$q, _dec8$k, _class4$6, _class5$8, _initializer2$1c, _initializer3$Y, _initializer4$Q, _initializer5$H, _initializer6$y, _dec9$h, _class7$3, _class8$3, _initializer7$t, _dec10$c, _dec11$8, _dec12$8, _class10$1, _class11$1, _initializer8$r, _initializer9$o, _initializer10$l, _dec13$7, _dec14$6, _dec15$5, _class13$1, _class14$1, _initializer11$j, _initializer12$g, _dec16$4, _dec17$4, _dec18$4, _class16, _class17, _initializer13$f, _initializer14$c, _dec19$4, _dec20$4, _dec21$4, _dec22$4, _dec23$4, _dec24$4, _class19, _class20, _initializer15$9, _initializer16$9, _initializer17$8, _initializer18$8, _initializer19$7, _initializer20$5, _dec25$4, _dec26$4, _dec27$4, _dec28$4, _class22, _class23, _initializer21$5, _initializer22$4, _initializer23$3, _initializer24$3, _initializer25$2, _initializer26$2;
      let TargetInfo = (_dec$1D = ccclass$6('cc.TargetInfo'), _dec2$1n = type$6([CCString]), _dec$1D(_class$1A = (_class2$1t = class TargetInfo {
        constructor() {
          this.localID = _initializer$1o && _initializer$1o();
        }
      }, (_initializer$1o = applyDecoratedInitializer(_class2$1t.prototype, "localID", [serializable$6, _dec2$1n], function () {
        return [];
      })), _class2$1t)) || _class$1A);
      let TargetOverrideInfo = (_dec3$13 = ccclass$6('cc.TargetOverrideInfo'), _dec4$Q = type$6(CCObject), _dec5$J = type$6(TargetInfo), _dec6$w = type$6([CCString]), _dec7$q = type$6(Node$1), _dec8$k = type$6(TargetInfo), _dec3$13(_class4$6 = (_class5$8 = class TargetOverrideInfo {
        constructor() {
          this.source = _initializer2$1c && _initializer2$1c();
          this.sourceInfo = _initializer3$Y && _initializer3$Y();
          this.propertyPath = _initializer4$Q && _initializer4$Q();
          this.target = _initializer5$H && _initializer5$H();
          this.targetInfo = _initializer6$y && _initializer6$y();
        }
      }, (_initializer2$1c = applyDecoratedInitializer(_class5$8.prototype, "source", [serializable$6, _dec4$Q], function () {
        return null;
      }), _initializer3$Y = applyDecoratedInitializer(_class5$8.prototype, "sourceInfo", [serializable$6, _dec5$J], function () {
        return null;
      }), _initializer4$Q = applyDecoratedInitializer(_class5$8.prototype, "propertyPath", [serializable$6, _dec6$w], function () {
        return [];
      }), _initializer5$H = applyDecoratedInitializer(_class5$8.prototype, "target", [serializable$6, _dec7$q], function () {
        return null;
      }), _initializer6$y = applyDecoratedInitializer(_class5$8.prototype, "targetInfo", [serializable$6, _dec8$k], function () {
        return null;
      })), _class5$8)) || _class4$6);
      let CompPrefabInfo = (_dec9$h = ccclass$6('cc.CompPrefabInfo'), _dec9$h(_class7$3 = (_class8$3 = class CompPrefabInfo {
        constructor() {
          this.fileId = _initializer7$t && _initializer7$t();
        }
      }, (_initializer7$t = applyDecoratedInitializer(_class8$3.prototype, "fileId", [serializable$6], function () {
        return '';
      })), _class8$3)) || _class7$3);
      let PropertyOverrideInfo = (_dec10$c = ccclass$6('CCPropertyOverrideInfo'), _dec11$8 = type$6(TargetInfo), _dec12$8 = type$6([CCString]), _dec10$c(_class10$1 = (_class11$1 = class PropertyOverrideInfo {
        constructor() {
          this.targetInfo = _initializer8$r && _initializer8$r();
          this.propertyPath = _initializer9$o && _initializer9$o();
          this.value = _initializer10$l && _initializer10$l();
        }
        isTarget(localID, propPath) {
        }
      }, (_initializer8$r = applyDecoratedInitializer(_class11$1.prototype, "targetInfo", [serializable$6, _dec11$8], function () {
        return null;
      }), _initializer9$o = applyDecoratedInitializer(_class11$1.prototype, "propertyPath", [serializable$6, _dec12$8], function () {
        return [];
      }), _initializer10$l = applyDecoratedInitializer(_class11$1.prototype, "value", [serializable$6], null)), _class11$1)) || _class10$1);
      let MountedChildrenInfo = (_dec13$7 = ccclass$6('cc.MountedChildrenInfo'), _dec14$6 = type$6(TargetInfo), _dec15$5 = type$6([Node$1]), _dec13$7(_class13$1 = (_class14$1 = class MountedChildrenInfo {
        constructor() {
          this.targetInfo = _initializer11$j && _initializer11$j();
          this.nodes = _initializer12$g && _initializer12$g();
        }
        isTarget(localID) {
        }
      }, (_initializer11$j = applyDecoratedInitializer(_class14$1.prototype, "targetInfo", [serializable$6, _dec14$6], function () {
        return null;
      }), _initializer12$g = applyDecoratedInitializer(_class14$1.prototype, "nodes", [serializable$6, _dec15$5], function () {
        return [];
      })), _class14$1)) || _class13$1);
      let MountedComponentsInfo = (_dec16$4 = ccclass$6('cc.MountedComponentsInfo'), _dec17$4 = type$6(TargetInfo), _dec18$4 = type$6([Component]), _dec16$4(_class16 = (_class17 = class MountedComponentsInfo {
        constructor() {
          this.targetInfo = _initializer13$f && _initializer13$f();
          this.components = _initializer14$c && _initializer14$c();
        }
        isTarget(localID) {
        }
      }, (_initializer13$f = applyDecoratedInitializer(_class17.prototype, "targetInfo", [serializable$6, _dec17$4], function () {
        return null;
      }), _initializer14$c = applyDecoratedInitializer(_class17.prototype, "components", [serializable$6, _dec18$4], function () {
        return [];
      })), _class17)) || _class16);
      let PrefabInstance = (_dec19$4 = ccclass$6('cc.PrefabInstance'), _dec20$4 = type$6(Node$1), _dec21$4 = type$6([MountedChildrenInfo]), _dec22$4 = type$6([MountedComponentsInfo]), _dec23$4 = type$6([PropertyOverrideInfo]), _dec24$4 = type$6([TargetInfo]), _dec19$4(_class19 = (_class20 = class PrefabInstance {
        constructor() {
          this.fileId = _initializer15$9 && _initializer15$9();
          this.prefabRootNode = _initializer16$9 && _initializer16$9();
          this.mountedChildren = _initializer17$8 && _initializer17$8();
          this.mountedComponents = _initializer18$8 && _initializer18$8();
          this.propertyOverrides = _initializer19$7 && _initializer19$7();
          this.removedComponents = _initializer20$5 && _initializer20$5();
          this.targetMap = {};
          this.expanded = false;
        }
        findPropertyOverride(localID, propPath) {
        }
        removePropertyOverride(localID, propPath) {
        }
      }, (_initializer15$9 = applyDecoratedInitializer(_class20.prototype, "fileId", [serializable$6], function () {
        return '';
      }), _initializer16$9 = applyDecoratedInitializer(_class20.prototype, "prefabRootNode", [serializable$6, _dec20$4], null), _initializer17$8 = applyDecoratedInitializer(_class20.prototype, "mountedChildren", [serializable$6, _dec21$4], function () {
        return [];
      }), _initializer18$8 = applyDecoratedInitializer(_class20.prototype, "mountedComponents", [serializable$6, _dec22$4], function () {
        return [];
      }), _initializer19$7 = applyDecoratedInitializer(_class20.prototype, "propertyOverrides", [serializable$6, _dec23$4], function () {
        return [];
      }), _initializer20$5 = applyDecoratedInitializer(_class20.prototype, "removedComponents", [serializable$6, _dec24$4], function () {
        return [];
      })), _class20)) || _class19);
      let PrefabInfo = (_dec25$4 = ccclass$6('cc.PrefabInfo'), _dec26$4 = type$6(Node$1), _dec27$4 = type$6(PrefabInstance), _dec28$4 = type$6([TargetOverrideInfo]), _dec25$4(_class22 = (_class23 = class PrefabInfo {
        constructor() {
          this.root = _initializer21$5 && _initializer21$5();
          this.asset = _initializer22$4 && _initializer22$4();
          this.fileId = _initializer23$3 && _initializer23$3();
          this.instance = _initializer24$3 && _initializer24$3();
          this.targetOverrides = _initializer25$2 && _initializer25$2();
          this.nestedPrefabInstanceRoots = _initializer26$2 && _initializer26$2();
        }
      }, (_initializer21$5 = applyDecoratedInitializer(_class23.prototype, "root", [serializable$6, _dec26$4], null), _initializer22$4 = applyDecoratedInitializer(_class23.prototype, "asset", [serializable$6], null), _initializer23$3 = applyDecoratedInitializer(_class23.prototype, "fileId", [serializable$6], function () {
        return '';
      }), _initializer24$3 = applyDecoratedInitializer(_class23.prototype, "instance", [serializable$6, _dec27$4], null), _initializer25$2 = applyDecoratedInitializer(_class23.prototype, "targetOverrides", [serializable$6, _dec28$4], null), _initializer26$2 = applyDecoratedInitializer(_class23.prototype, "nestedPrefabInstanceRoots", [serializable$6], null)), _class23)) || _class22);
      legacyCC._PrefabInfo = PrefabInfo;

      function createNodeWithPrefab(node) {
        const prefabInfo = node === null || node === void 0 ? void 0 : node.prefab;
        if (!prefabInfo) {
          return;
        }
        const prefabInstance = prefabInfo.instance;
        if (!prefabInstance) {
          return;
        }
        if (!prefabInfo.asset) {
          {
            errorID(3701, node.name);
          }
          prefabInfo.instance = undefined;
          return;
        }
        const _objFlags = node._objFlags;
        const _parent = node.getParent();
        const _id = node.uuid;
        node[editorExtrasTag];
        legacyCC.game._isCloning = true;
        {
          prefabInfo.asset._doInstantiate(node);
        }
        legacyCC.game._isCloning = false;
        node._objFlags = _objFlags;
        node.modifyParent(_parent);
        node.id = _id;
        if (node.prefab) {
          node.prefab.instance = prefabInfo.instance;
        }
      }
      function generateTargetMap(node, targetMap, isRoot) {
        var _node$prefab;
        if (!targetMap) {
          return;
        }
        if (!node) {
          return;
        }
        let curTargetMap = targetMap;
        const prefabInstance = (_node$prefab = node.prefab) === null || _node$prefab === void 0 ? void 0 : _node$prefab.instance;
        if (!isRoot && prefabInstance) {
          targetMap[prefabInstance.fileId] = {};
          curTargetMap = targetMap[prefabInstance.fileId];
        }
        const prefabInfo = node.prefab;
        if (prefabInfo) {
          curTargetMap[prefabInfo.fileId] = node;
        }
        const components = node.components;
        for (let i = 0; i < components.length; i++) {
          const comp = components[i];
          if (comp.__prefab) {
            curTargetMap[comp.__prefab.fileId] = comp;
          }
        }
        for (let i = 0; i < node.children.length; i++) {
          const childNode = node.children[i];
          generateTargetMap(childNode, curTargetMap, false);
        }
      }
      function getTarget(localID, targetMap) {
        if (!localID) {
          return null;
        }
        let target = null;
        let targetIter = targetMap;
        for (let i = 0; i < localID.length; i++) {
          if (!targetIter) {
            return null;
          }
          targetIter = targetIter[localID[i]];
        }
        target = targetIter;
        return target;
      }
      function applyMountedChildren(node, mountedChildren, targetMap) {
        if (!mountedChildren) {
          return;
        }
        for (let i = 0; i < mountedChildren.length; i++) {
          const childInfo = mountedChildren[i];
          if (childInfo && childInfo.targetInfo) {
            const target = getTarget(childInfo.targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            let curTargetMap = targetMap;
            const localID = childInfo.targetInfo.localID;
            if (localID.length > 0) {
              for (let i = 0; i < localID.length - 1; i++) {
                curTargetMap = curTargetMap[localID[i]];
              }
            }
            if (childInfo.nodes) {
              for (let i = 0; i < childInfo.nodes.length; i++) {
                const childNode = childInfo.nodes[i];
                if (!childNode || target.children.includes(childNode)) {
                  continue;
                }
                target.children.push(childNode);
                childNode.modifyParent(target);
                generateTargetMap(childNode, curTargetMap, false);
                childNode.siblingIndex = target.children.length - 1;
                expandPrefabInstanceNode(childNode, true);
              }
            }
          }
        }
      }
      function applyMountedComponents(node, mountedComponents, targetMap) {
        if (!mountedComponents) {
          return;
        }
        for (let i = 0; i < mountedComponents.length; i++) {
          const componentsInfo = mountedComponents[i];
          if (componentsInfo && componentsInfo.targetInfo) {
            const target = getTarget(componentsInfo.targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            if (componentsInfo.components) {
              for (let i = 0; i < componentsInfo.components.length; i++) {
                const comp = componentsInfo.components[i];
                if (!comp) {
                  continue;
                }
                comp.node = target;
                target.getWritableComponents().push(comp);
              }
            }
          }
        }
      }
      function applyRemovedComponents(node, removedComponents, targetMap) {
        if (!removedComponents) {
          return;
        }
        for (let i = 0; i < removedComponents.length; i++) {
          const targetInfo = removedComponents[i];
          if (targetInfo) {
            const target = getTarget(targetInfo.localID, targetMap);
            if (!target || !target.node) {
              continue;
            }
            const index = target.node.components.indexOf(target);
            if (index >= 0) {
              target.node.getWritableComponents().splice(index, 1);
            }
          }
        }
      }
      function applyPropertyOverrides(node, propertyOverrides, targetMap) {
        if (propertyOverrides.length <= 0) {
          return;
        }
        let target = null;
        for (let i = 0; i < propertyOverrides.length; i++) {
          const propOverride = propertyOverrides[i];
          if (propOverride && propOverride.targetInfo) {
            const targetInfo = propOverride.targetInfo;
            target = getTarget(targetInfo.localID, targetMap);
            if (!target) {
              continue;
            }
            let targetPropOwner = target;
            const propertyPath = propOverride.propertyPath.slice();
            if (propertyPath.length > 0) {
              const targetPropName = propertyPath.pop();
              if (!targetPropName) {
                continue;
              }
              for (let i = 0; i < propertyPath.length; i++) {
                const propName = propertyPath[i];
                targetPropOwner = targetPropOwner[propName];
                if (!targetPropOwner) {
                  break;
                }
              }
              if (!targetPropOwner) {
                continue;
              }
              if (Array.isArray(targetPropOwner)) {
                if (targetPropName === 'length') {
                  targetPropOwner[targetPropName] = propOverride.value;
                } else {
                  const index = Number.parseInt(targetPropName);
                  if (Number.isInteger(index) && index < targetPropOwner.length) {
                    targetPropOwner[targetPropName] = propOverride.value;
                  }
                }
              } else if (targetPropOwner[targetPropName] instanceof ValueType) {
                targetPropOwner[targetPropName].set(propOverride.value);
              } else {
                targetPropOwner[targetPropName] = propOverride.value;
              }
            }
          }
        }
      }
      function applyTargetOverrides(node) {
        var _node$prefab2;
        const targetOverrides = (_node$prefab2 = node.prefab) === null || _node$prefab2 === void 0 ? void 0 : _node$prefab2.targetOverrides;
        if (targetOverrides) {
          for (let i = 0; i < targetOverrides.length; i++) {
            var _targetAsNode$prefab;
            const targetOverride = targetOverrides[i];
            let source = targetOverride.source;
            const sourceInfo = targetOverride.sourceInfo;
            if (sourceInfo) {
              var _src$prefab;
              const src = targetOverride.source;
              const sourceInstance = src === null || src === void 0 ? void 0 : (_src$prefab = src.prefab) === null || _src$prefab === void 0 ? void 0 : _src$prefab.instance;
              if (sourceInstance && sourceInstance.targetMap) {
                source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
              }
            }
            if (!source) {
              continue;
            }
            let target = null;
            const targetInfo = targetOverride.targetInfo;
            if (!targetInfo) {
              continue;
            }
            const targetAsNode = targetOverride.target;
            const targetInstance = targetAsNode === null || targetAsNode === void 0 ? void 0 : (_targetAsNode$prefab = targetAsNode.prefab) === null || _targetAsNode$prefab === void 0 ? void 0 : _targetAsNode$prefab.instance;
            if (!targetInstance || !targetInstance.targetMap) {
              continue;
            }
            target = getTarget(targetInfo.localID, targetInstance.targetMap);
            if (!target) {
              continue;
            }
            const propertyPath = targetOverride.propertyPath.slice();
            let targetPropOwner = source;
            if (propertyPath.length > 0) {
              const targetPropName = propertyPath.pop();
              if (!targetPropName) {
                return;
              }
              for (let i = 0; i < propertyPath.length; i++) {
                const propName = propertyPath[i];
                targetPropOwner = targetPropOwner[propName];
                if (!targetPropOwner) {
                  break;
                }
              }
              if (!targetPropOwner) {
                continue;
              }
              targetPropOwner[targetPropName] = target;
            }
          }
        }
      }
      function expandPrefabInstanceNode(node, recursively = false) {
        var _node$prefab3;
        const prefabInstance = node === null || node === void 0 ? void 0 : (_node$prefab3 = node.prefab) === null || _node$prefab3 === void 0 ? void 0 : _node$prefab3.instance;
        if (prefabInstance && !prefabInstance.expanded) {
          createNodeWithPrefab(node);
          if (recursively) {
            if (node && node.children) {
              node.children.forEach(child => {
                expandPrefabInstanceNode(child, true);
              });
            }
          }
          const targetMap = {};
          prefabInstance.targetMap = targetMap;
          generateTargetMap(node, targetMap, true);
          applyMountedChildren(node, prefabInstance.mountedChildren, targetMap);
          applyRemovedComponents(node, prefabInstance.removedComponents, targetMap);
          applyMountedComponents(node, prefabInstance.mountedComponents, targetMap);
          applyPropertyOverrides(node, prefabInstance.propertyOverrides, targetMap);
          prefabInstance.expanded = true;
        } else if (recursively) {
          if (node && node.children) {
            node.children.forEach(child => {
              expandPrefabInstanceNode(child, true);
            });
          }
        }
      }
      function expandNestedPrefabInstanceNode(node) {
        const prefabInfo = node.prefab;
        if (prefabInfo && prefabInfo.nestedPrefabInstanceRoots) {
          prefabInfo.nestedPrefabInstanceRoots.forEach(instanceNode => {
            expandPrefabInstanceNode(instanceNode);
          });
        }
      }
      function applyNodeAndComponentId(prefabInstanceNode, rootId) {
        const {
          components,
          children
        } = prefabInstanceNode;
        for (let i = 0; i < components.length; i++) {
          var _comp$__prefab$fileId, _comp$__prefab;
          const comp = components[i];
          const fileID = (_comp$__prefab$fileId = (_comp$__prefab = comp.__prefab) === null || _comp$__prefab === void 0 ? void 0 : _comp$__prefab.fileId) !== null && _comp$__prefab$fileId !== void 0 ? _comp$__prefab$fileId : '';
          comp._id = `${rootId}${fileID}`;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const prefabInfo = child.prefab;
          const fileId = prefabInfo !== null && prefabInfo !== void 0 && prefabInfo.instance ? prefabInfo.instance.fileId : prefabInfo === null || prefabInfo === void 0 ? void 0 : prefabInfo.fileId;
          if (!fileId) continue;
          child.id = `${rootId}${fileId}`;
          if (!(prefabInfo !== null && prefabInfo !== void 0 && prefabInfo.instance)) {
            applyNodeAndComponentId(child, rootId);
          }
        }
      }

      var utils$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createNodeWithPrefab: createNodeWithPrefab,
        generateTargetMap: generateTargetMap,
        getTarget: getTarget,
        applyMountedChildren: applyMountedChildren,
        applyMountedComponents: applyMountedComponents,
        applyRemovedComponents: applyRemovedComponents,
        applyPropertyOverrides: applyPropertyOverrides,
        applyTargetOverrides: applyTargetOverrides,
        expandPrefabInstanceNode: expandPrefabInstanceNode,
        expandNestedPrefabInstanceNode: expandNestedPrefabInstanceNode,
        applyNodeAndComponentId: applyNodeAndComponentId,
        TargetInfo: TargetInfo,
        TargetOverrideInfo: TargetOverrideInfo,
        CompPrefabInfo: CompPrefabInfo,
        PropertyOverrideInfo: PropertyOverrideInfo,
        MountedChildrenInfo: MountedChildrenInfo,
        MountedComponentsInfo: MountedComponentsInfo,
        PrefabInstance: PrefabInstance,
        PrefabInfo: PrefabInfo
      });

      const Scene = exports('Scene', jsb.Scene);
      legacyCC.Scene = Scene;
      const sceneProto = Scene.prototype;
      Object.defineProperty(sceneProto, '_globals', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getSceneGlobals();
        },
        set(v) {
          this._globalRef = v;
          this.setSceneGlobals(v);
        }
      });
      Object.defineProperty(sceneProto, 'globals', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getSceneGlobals();
        }
      });
      Object.defineProperty(sceneProto, '_renderScene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._renderSceneInternal) {
            this._renderSceneInternal = this.getRenderScene();
          }
          return this._renderSceneInternal;
        }
      });
      Object.defineProperty(sceneProto, 'renderScene', {
        enumerable: true,
        configurable: true,
        get() {
          if (!this._renderSceneInternal) {
            this._renderSceneInternal = this.getRenderScene();
          }
          return this._renderSceneInternal;
        }
      });
      sceneProto._ctor = function () {
        Node$1.prototype._ctor.apply(this, arguments);
        this._inited = false;
        this._renderSceneInternal = null;
        this._globalRef = null;
        this._prefabSyncedInLiveReload = false;
      };
      sceneProto._onBatchCreated = function (dontSyncChildPrefab) {
        if (this._parent) {
          this._siblingIndex = this._parent.children.indexOf(this);
        }
        const children = this._children;
        const len = children.length;
        let child;
        for (let i = 0; i < len; ++i) {
          child = children[i];
          child._siblingIndex = i;
          child._onBatchCreated(dontSyncChildPrefab);
        }
      };
      const oldLoad = sceneProto._load;
      sceneProto._load = function () {
        this._scene = this;
        if (!this._inited) {
          expandNestedPrefabInstanceNode(this);
          applyTargetOverrides(this);
          this._onBatchCreated(EDITOR );
          this._inited = true;
        }
        updateChildrenForDeserialize(this);
        oldLoad.call(this);
      };
      sceneProto._activate = function (active) {
        active = active !== false;
        legacyCC.director._nodeActivator.activateNode(this, active);
        {
          this._globals.activate(this);
          if (this._renderScene) {
            this._renderScene.activate();
          }
        }
      };
      sceneProto._instantiate = function () {};
      patch_cc_Scene({
        Scene,
        SceneGlobals
      });

      function find(path, referenceNode) {
        if (!referenceNode) {
          const scene = legacyCC.director.getScene();
          if (!scene) {
            return null;
          }
          referenceNode = scene;
        }
        return referenceNode.getChildByPath(path);
      }
      legacyCC.find = find;

      const fastRemoveAt = fastRemoveAt$2;
      const IsStartCalled = CCObject.Flags.IsStartCalled;
      const IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
      CCObject.Flags.IsEditorOnEnableCalled;
      function sortedIndex(array, comp) {
        const order = comp.constructor._executionOrder;
        const id = comp._id;
        let l = 0;
        for (let h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
          const test = array[m];
          const testOrder = test.constructor._executionOrder;
          if (testOrder > order) {
            h = m - 1;
          } else if (testOrder < order) {
            l = m + 1;
          } else {
            const testId = test._id;
            if (testId > id) {
              h = m - 1;
            } else if (testId < id) {
              l = m + 1;
            } else {
              return m;
            }
          }
        }
        return ~l;
      }
      function stableRemoveInactive(iterator, flagToClear) {
        const array = iterator.array;
        let next = iterator.i + 1;
        while (next < array.length) {
          const comp = array[next];
          if (comp.node._activeInHierarchy) {
            ++next;
          } else {
            iterator.removeAt(next);
            if (flagToClear) {
              comp._objFlags &= ~flagToClear;
            }
          }
        }
      }
      class LifeCycleInvoker {
        get zero() {
          return this._zero;
        }
        get neg() {
          return this._neg;
        }
        get pos() {
          return this._pos;
        }
        constructor(invokeFunc) {
          this._zero = void 0;
          this._neg = void 0;
          this._pos = void 0;
          this._invoke = void 0;
          const Iterator = MutableForwardIterator;
          this._zero = new Iterator([]);
          this._neg = new Iterator([]);
          this._pos = new Iterator([]);
          this._invoke = invokeFunc;
        }
      }
      LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
      function compareOrder(a, b) {
        return a.constructor._executionOrder - b.constructor._executionOrder;
      }
      class OneOffInvoker extends LifeCycleInvoker {
        add(comp) {
          const order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
        }
        remove(comp) {
          const order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
        }
        cancelInactive(flagToClear) {
          stableRemoveInactive(this._zero, flagToClear);
          stableRemoveInactive(this._neg, flagToClear);
          stableRemoveInactive(this._pos, flagToClear);
        }
        invoke() {
          const compsNeg = this._neg;
          if (compsNeg.array.length > 0) {
            compsNeg.array.sort(compareOrder);
            this._invoke(compsNeg);
            compsNeg.array.length = 0;
          }
          this._invoke(this._zero);
          this._zero.array.length = 0;
          const compsPos = this._pos;
          if (compsPos.array.length > 0) {
            compsPos.array.sort(compareOrder);
            this._invoke(compsPos);
            compsPos.array.length = 0;
          }
        }
      }
      class ReusableInvoker extends LifeCycleInvoker {
        add(comp) {
          const order = comp.constructor._executionOrder;
          if (order === 0) {
            this._zero.array.push(comp);
          } else {
            const array = order < 0 ? this._neg.array : this._pos.array;
            const i = sortedIndex(array, comp);
            if (i < 0) {
              array.splice(~i, 0, comp);
            }
          }
        }
        remove(comp) {
          const order = comp.constructor._executionOrder;
          if (order === 0) {
            this._zero.fastRemove(comp);
          } else {
            const iterator = order < 0 ? this._neg : this._pos;
            const i = sortedIndex(iterator.array, comp);
            if (i >= 0) {
              iterator.removeAt(i);
            }
          }
        }
        invoke(dt) {
          if (this._neg.array.length > 0) {
            this._invoke(this._neg, dt);
          }
          this._invoke(this._zero, dt);
          if (this._pos.array.length > 0) {
            this._invoke(this._pos, dt);
          }
        }
      }
      function createInvokeImplJit(code, useDt, ensureFlag) {
        const body = `${'var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];'}${code}}`;
        const fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
        const singleInvoke = Function('c', 'dt', code);
        return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
      }
      function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
        return (iterator, dt) => {
          try {
            fastPath(iterator, dt);
          } catch (e) {
            legacyCC._throw(e);
            const array = iterator.array;
            if (ensureFlag) {
              array[iterator.i]._objFlags |= ensureFlag;
            }
            ++iterator.i;
            for (; iterator.i < array.length; ++iterator.i) {
              try {
                singleInvoke(array[iterator.i], dt);
              } catch (e) {
                legacyCC._throw(e);
                if (ensureFlag) {
                  array[iterator.i]._objFlags |= ensureFlag;
                }
              }
            }
          }
        };
      }
      const invokeStart = createInvokeImplJit(`c.start();c._objFlags|=${IsStartCalled}`, false, IsStartCalled) ;
      const invokeUpdate = createInvokeImplJit('c.update(dt)', true) ;
      const invokeLateUpdate = createInvokeImplJit('c.lateUpdate(dt)', true) ;
      const invokeOnEnable = iterator => {
        const compScheduler = legacyCC.director._compScheduler;
        const array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          const comp = array[iterator.i];
          if (comp._enabled) {
            comp.onEnable();
            const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (!deactivatedDuringOnEnable) {
              compScheduler._onEnabled(comp);
            }
          }
        }
      };
      class ComponentScheduler {
        constructor() {
          this.startInvoker = void 0;
          this.updateInvoker = void 0;
          this.lateUpdateInvoker = void 0;
          this._deferredComps = [];
          this._updating = void 0;
          this.unscheduleAll();
        }
        unscheduleAll() {
          this.startInvoker = new OneOffInvoker(invokeStart);
          this.updateInvoker = new ReusableInvoker(invokeUpdate);
          this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
          this._updating = false;
        }
        _onEnabled(comp) {
          legacyCC.director.getScheduler().resumeTarget(comp);
          comp._objFlags |= IsOnEnableCalled$1;
          if (this._updating) {
            this._deferredComps.push(comp);
          } else {
            this._scheduleImmediate(comp);
          }
        }
        _onDisabled(comp) {
          legacyCC.director.getScheduler().pauseTarget(comp);
          comp._objFlags &= ~IsOnEnableCalled$1;
          const index = this._deferredComps.indexOf(comp);
          if (index >= 0) {
            fastRemoveAt(this._deferredComps, index);
            return;
          }
          if (comp.internalStart && !(comp._objFlags & IsStartCalled)) {
            this.startInvoker.remove(comp);
          }
          if (comp.internalUpdate) {
            this.updateInvoker.remove(comp);
          }
          if (comp.internalLateUpdate) {
            this.lateUpdateInvoker.remove(comp);
          }
        }
        enableComp(comp, invoker) {
          if (!(comp._objFlags & IsOnEnableCalled$1)) {
            if (comp.internalOnEnable) {
              if (invoker) {
                invoker.add(comp);
                return;
              } else {
                comp.internalOnEnable();
                const deactivatedDuringOnEnable = !comp.node.activeInHierarchy;
                if (deactivatedDuringOnEnable) {
                  return;
                }
              }
            }
            this._onEnabled(comp);
          }
        }
        disableComp(comp) {
          if (comp._objFlags & IsOnEnableCalled$1) {
            if (comp.internalOnDisable) {
              comp.internalOnDisable();
            }
            this._onDisabled(comp);
          }
        }
        startPhase() {
          this._updating = true;
          this.startInvoker.invoke();
          this._startForNewComps();
        }
        updatePhase(dt) {
          this.updateInvoker.invoke(dt);
        }
        lateUpdatePhase(dt) {
          this.lateUpdateInvoker.invoke(dt);
          this._updating = false;
          this._startForNewComps();
        }
        _startForNewComps() {
          if (this._deferredComps.length > 0) {
            this._deferredSchedule();
            this.startInvoker.invoke();
          }
        }
        _scheduleImmediate(comp) {
          if (typeof comp.internalStart === 'function' && !(comp._objFlags & IsStartCalled)) {
            this.startInvoker.add(comp);
          }
          if (typeof comp.internalUpdate === 'function') {
            this.updateInvoker.add(comp);
          }
          if (typeof comp.internalLateUpdate === 'function') {
            this.lateUpdateInvoker.add(comp);
          }
        }
        _deferredSchedule() {
          const comps = this._deferredComps;
          for (let i = 0, len = comps.length; i < len; i++) {
            this._scheduleImmediate(comps[i]);
          }
          comps.length = 0;
        }
      }

      const MAX_POOL_SIZE = 4;
      const IsPreloadStarted = CCObject.Flags.IsPreloadStarted;
      const IsOnLoadStarted = CCObject.Flags.IsOnLoadStarted;
      const IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
      const IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
      const Deactivating = CCObject.Flags.Deactivating;
      class UnsortedInvoker extends LifeCycleInvoker {
        add(comp) {
          this._zero.array.push(comp);
        }
        remove(comp) {
          this._zero.fastRemove(comp);
        }
        cancelInactive(flagToClear) {
          LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
        }
        invoke() {
          this._invoke(this._zero);
          this._zero.array.length = 0;
        }
      }
      const invokePreload = createInvokeImplJit('c.__preload();') ;
      const invokeOnLoad = createInvokeImplJit(`c.onLoad();c._objFlags|=${IsOnLoadCalled}`, false, IsOnLoadCalled) ;
      const activateTasksPool = new Pool$1(MAX_POOL_SIZE);
      activateTasksPool.get = function getActivateTask() {
        const task = this._get() || {
          preload: new UnsortedInvoker(invokePreload),
          onLoad: new OneOffInvoker(invokeOnLoad),
          onEnable: new OneOffInvoker(invokeOnEnable)
        };
        task.preload.zero.i = -1;
        let invoker = task.onLoad;
        invoker.zero.i = -1;
        invoker.neg.i = -1;
        invoker.pos.i = -1;
        invoker = task.onEnable;
        invoker.zero.i = -1;
        invoker.neg.i = -1;
        invoker.pos.i = -1;
        return task;
      };
      function _componentCorrupted(node, comp, index) {
        errorID(3817, node.name, index);
        console.log('Corrupted component value:', comp);
        if (comp) {
          node._removeComponent(comp);
        } else {
          removeAt(node.getWritableComponents(), index);
        }
      }
      class NodeActivator {
        constructor() {
          this._activatingStack = void 0;
          this.reset();
        }
        reset() {
          this._activatingStack = [];
        }
        activateNode(node, active) {
          if (active) {
            const task = activateTasksPool.get();
            if (task) {
              this._activatingStack.push(task);
              this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
              task.preload.invoke();
              task.onLoad.invoke();
              task.onEnable.invoke();
              this._activatingStack.pop();
              activateTasksPool.put(task);
            }
          } else {
            this._deactivateNodeRecursively(node);
            const stack = this._activatingStack;
            for (const lastTask of stack) {
              lastTask.preload.cancelInactive(IsPreloadStarted);
              lastTask.onLoad.cancelInactive(IsOnLoadStarted);
              lastTask.onEnable.cancelInactive(IsOnEnableCalled);
            }
          }
          node.emit(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, node);
        }
        activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (!isValid(comp, true)) {
            return;
          }
          if (!(comp._objFlags & IsPreloadStarted)) {
            comp._objFlags |= IsPreloadStarted;
            if (comp.internalPreload) {
              if (preloadInvoker) {
                preloadInvoker.add(comp);
              } else {
                comp.internalPreload();
              }
            }
          }
          if (!(comp._objFlags & IsOnLoadStarted)) {
            comp._objFlags |= IsOnLoadStarted;
            if (comp.internalOnLoad) {
              if (onLoadInvoker) {
                onLoadInvoker.add(comp);
              } else {
                comp.internalOnLoad();
                comp._objFlags |= IsOnLoadCalled;
              }
            } else {
              comp._objFlags |= IsOnLoadCalled;
            }
          }
          if (comp._enabled) {
            {
              assertIsTrue(comp.node, getError(3823, comp.uuid, comp.name));
            }
            const deactivatedOnLoading = !comp.node.activeInHierarchy;
            if (deactivatedOnLoading) {
              return;
            }
            legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
          }
        }
        destroyComp(comp) {
          legacyCC.director._compScheduler.disableComp(comp);
          if (comp.internalOnDestroy && comp._objFlags & IsOnLoadCalled) {
            comp.internalOnDestroy();
          }
        }
        _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (node._objFlags & Deactivating) {
            errorID(3816, node.name);
            return;
          }
          node._setActiveInHierarchy(true);
          let originCount = node.components.length;
          for (let i = 0; i < originCount; ++i) {
            const component = node.components[i];
            if (component instanceof legacyCC.Component) {
              this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
            } else {
              _componentCorrupted(node, component, i);
              --i;
              --originCount;
            }
          }
          for (let i = 0, len = node.children.length; i < len; ++i) {
            const child = node.children[i];
            if (child.active) {
              this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
            }
          }
          node._onPostActivated(true);
        }
        _deactivateNodeRecursively(node) {
          node._objFlags |= Deactivating;
          node._setActiveInHierarchy(false);
          const originCount = node.components.length;
          for (let c = 0; c < originCount; ++c) {
            const component = node.components[c];
            if (component._enabled) {
              legacyCC.director._compScheduler.disableComp(component);
              if (node.activeInHierarchy) {
                node._objFlags &= ~Deactivating;
                return;
              }
            }
          }
          for (let i = 0, len = node.children.length; i < len; ++i) {
            const child = node.children[i];
            if (child.activeInHierarchy) {
              this._deactivateNodeRecursively(child);
              if (node.activeInHierarchy) {
                node._objFlags &= ~Deactivating;
                return;
              }
            }
          }
          node._onPostActivated(false);
          node._objFlags &= ~Deactivating;
        }
      } exports('NodeActivator', NodeActivator);

      const Destroyed$1 = CCObject.Flags.Destroyed;
      const PersistentMask$1 = CCObject.Flags.PersistentMask;
      const DEFAULT = `${CCClass.Attr.DELIMETER}default`;
      const IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
      const VAR = 'var ';
      const LOCAL_OBJ = 'o';
      const LOCAL_TEMP_OBJ = 't';
      const LOCAL_ARRAY = 'a';
      const LINE_INDEX_OF_NEW_OBJ = 0;
      const DEFAULT_MODULE_CACHE = {
        'cc.ClickEvent': false,
        'cc.PrefabInfo': false
      };
      const escapeForJS = CCClass.escapeForJS;
      class Declaration {
        constructor(varName, expression) {
          this.varName = void 0;
          this.expression = void 0;
          this.varName = varName;
          this.expression = expression;
        }
        toString() {
          return `${VAR + this.varName}=${this.expression};`;
        }
      }
      function mergeDeclaration(statement, expression) {
        if (expression instanceof Declaration) {
          return new Declaration(expression.varName, statement + expression.expression);
        } else {
          return statement + expression;
        }
      }
      function writeAssignment(codeArray, statement, expression) {
        if (Array.isArray(expression)) {
          expression[0] = mergeDeclaration(statement, expression[0]);
          codeArray.push(expression);
        } else {
          codeArray.push(`${mergeDeclaration(statement, expression)};`);
        }
      }
      class Assignments {
        constructor(targetExpression) {
          this._exps = void 0;
          this._targetExp = void 0;
          this._exps = [];
          this._targetExp = targetExpression;
        }
        append(key, expression) {
          this._exps.push([key, expression]);
        }
        writeCode(codeArray) {
          let targetVar;
          if (this._exps.length > 1) {
            codeArray.push(`${LOCAL_TEMP_OBJ}=${this._targetExp};`);
            targetVar = LOCAL_TEMP_OBJ;
          } else if (this._exps.length === 1) {
            targetVar = this._targetExp;
          } else {
            return;
          }
          for (let i = 0; i < this._exps.length; i++) {
            const pair = this._exps[i];
            writeAssignment(codeArray, `${targetVar + getPropAccessor(pair[0])}=`, pair[1]);
          }
        }
      }
      Assignments.pool = void 0;
      Assignments.pool = new Pool$1(obj => {
        obj._exps.length = 0;
        obj._targetExp = null;
      }, 1);
      Assignments.pool.get = function (targetExpression) {
        const cache = this._get() || new Assignments();
        cache._targetExp = targetExpression;
        return cache;
      };
      function getPropAccessor(key) {
        return IDENTIFIER_RE.test(key) ? `.${key}` : `[${escapeForJS(key)}]`;
      }
      class Parser$1 {
        constructor(obj, parent) {
          this.parent = void 0;
          this.objsToClear_iN$t = void 0;
          this.codeArray = void 0;
          this.objs = void 0;
          this.funcs = void 0;
          this.funcModuleCache = void 0;
          this.globalVariables = void 0;
          this.globalVariableId = void 0;
          this.localVariableId = void 0;
          this.result = void 0;
          this.parent = parent;
          this.objsToClear_iN$t = [];
          this.codeArray = [];
          this.objs = [];
          this.funcs = [];
          this.funcModuleCache = createMap();
          mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
          this.globalVariables = [];
          this.globalVariableId = 0;
          this.localVariableId = 0;
          this.codeArray.push(`${VAR + LOCAL_OBJ},${LOCAL_TEMP_OBJ};`, 'if(R){', `${LOCAL_OBJ}=R;`, '}else{', `${LOCAL_OBJ}=R=new ${this.getFuncModule(obj.constructor, true)}();`, '}');
          obj._iN$t = {
            globalVar: 'R'
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(this.codeArray, obj);
          let globalVariablesDeclaration;
          if (this.globalVariables.length > 0) {
            globalVariablesDeclaration = `${VAR + this.globalVariables.join(',')};`;
          }
          const code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
          this.result = Function('O', 'F', code)(this.objs, this.funcs);
          for (let i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
            this.objsToClear_iN$t[i]._iN$t = null;
          }
          this.objsToClear_iN$t.length = 0;
        }
        getFuncModule(func, usedInNew) {
          const clsName = getClassName(func);
          if (clsName) {
            const cache = this.funcModuleCache[clsName];
            if (cache) {
              return cache;
            } else if (cache === undefined) {
              let clsNameIsModule = clsName.indexOf('.') !== -1;
              if (clsNameIsModule) {
                try {
                  clsNameIsModule = func === Function(`return ${clsName}`)();
                  if (clsNameIsModule) {
                    this.funcModuleCache[clsName] = clsName;
                    return clsName;
                  }
                } catch (e) {}
              }
            }
          }
          let index = this.funcs.indexOf(func);
          if (index < 0) {
            index = this.funcs.length;
            this.funcs.push(func);
          }
          let res = `F[${index}]`;
          if (usedInNew) {
            res = `(${res})`;
          }
          this.funcModuleCache[clsName] = res;
          return res;
        }
        getObjRef(obj) {
          let index = this.objs.indexOf(obj);
          if (index < 0) {
            index = this.objs.length;
            this.objs.push(obj);
          }
          return `O[${index}]`;
        }
        setValueType(codeArray, defaultValue, srcValue, targetExpression) {
          const assignments = Assignments.pool.get(targetExpression);
          let fastDefinedProps = defaultValue.constructor.__props__;
          if (!fastDefinedProps) {
            fastDefinedProps = Object.keys(defaultValue);
          }
          for (let i = 0; i < fastDefinedProps.length; i++) {
            const propName = fastDefinedProps[i];
            const prop = srcValue[propName];
            if (defaultValue[propName] === prop) {
              continue;
            }
            const expression = this.enumerateField(srcValue, propName, prop);
            assignments.append(propName, expression);
          }
          assignments.writeCode(codeArray);
          Assignments.pool.put(assignments);
        }
        enumerateCCClass(codeArray, obj, klass) {
          const props = klass.__values__;
          const attrs = CCClass.Attr.getClassAttrs(klass);
          for (let p = 0; p < props.length; p++) {
            const key = props[p];
            const val = obj[key];
            let defaultValue = attrs[key + DEFAULT];
            if (equalsToDefault(defaultValue, val)) {
              continue;
            }
            if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
              defaultValue = CCClass.getDefault(defaultValue);
              if (defaultValue && defaultValue.constructor === val.constructor) {
                const targetExpression = LOCAL_OBJ + getPropAccessor(key);
                this.setValueType(codeArray, defaultValue, val, targetExpression);
                continue;
              }
            }
            this.setObjProp(codeArray, obj, key, val);
          }
        }
        instantiateArray(value) {
          if (value.length === 0) {
            return '[]';
          }
          const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          const declaration = new Declaration(arrayVar, `new Array(${value.length})`);
          const codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);
          for (let i = 0; i < value.length; ++i) {
            const statement = `${arrayVar}[${i}]=`;
            const expression = this.enumerateField(value, i, value[i]);
            writeAssignment(codeArray, statement, expression);
          }
          return codeArray;
        }
        instantiateTypedArray(value) {
          const type = value.constructor.name;
          if (value.length === 0) {
            return `new ${type}`;
          }
          const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          const declaration = new Declaration(arrayVar, `new ${type}(${value.length})`);
          const codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);
          for (let i = 0; i < value.length; ++i) {
            if (value[i] !== 0) {
              const statement = `${arrayVar}[${i}]=`;
              writeAssignment(codeArray, statement, value[i]);
            }
          }
          return codeArray;
        }
        enumerateField(obj, key, value) {
          if (typeof value === 'object' && value) {
            const _iN$t = value._iN$t;
            if (_iN$t) {
              let globalVar = _iN$t.globalVar;
              if (!globalVar) {
                globalVar = _iN$t.globalVar = `v${++this.globalVariableId}`;
                this.globalVariables.push(globalVar);
                const line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(`${globalVar}=`, line);
              }
              return globalVar;
            } else if (ArrayBuffer.isView(value)) {
              return this.instantiateTypedArray(value);
            } else if (Array.isArray(value)) {
              return this.instantiateArray(value);
            } else {
              return this.instantiateObj(value);
            }
          } else if (typeof value === 'function') {
            return this.getFuncModule(value);
          } else if (typeof value === 'string') {
            return escapeForJS(value);
          } else {
            if (key === '_objFlags' && isCCObject(obj)) {
              value &= PersistentMask$1;
            }
            return value;
          }
        }
        setObjProp(codeArray, obj, key, value) {
          const statement = `${LOCAL_OBJ + getPropAccessor(key)}=`;
          const expression = this.enumerateField(obj, key, value);
          writeAssignment(codeArray, statement, expression);
        }
        enumerateObject(codeArray, obj) {
          const klass = obj.constructor;
          if (isCCClassOrFastDefined(klass)) {
            this.enumerateCCClass(codeArray, obj, klass);
          } else {
            for (const key in obj) {
              if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                continue;
              }
              const value = obj[key];
              if (typeof value === 'object' && value && value === obj._iN$t) {
                continue;
              }
              this.setObjProp(codeArray, obj, key, value);
            }
          }
        }
        instantiateObj(obj) {
          if (obj instanceof legacyCC.ValueType) {
            return CCClass.getNewValueTypeCode(obj);
          }
          if (obj instanceof legacyCC.Asset) {
            return this.getObjRef(obj);
          }
          if (obj._objFlags & Destroyed$1) {
            return null;
          }
          let createCode;
          const ctor = obj.constructor;
          if (isCCClassOrFastDefined(ctor)) {
            if (this.parent) {
              if (this.parent instanceof legacyCC.Component) {
                if (obj instanceof legacyCC.Node || obj instanceof legacyCC.Component) {
                  return this.getObjRef(obj);
                }
              } else if (this.parent instanceof legacyCC.Node) {
                if (obj instanceof legacyCC.Node) {
                  if (!obj.isChildOf(this.parent)) {
                    return this.getObjRef(obj);
                  }
                } else if (obj instanceof legacyCC.Component) {
                  var _obj$node;
                  if (!((_obj$node = obj.node) !== null && _obj$node !== void 0 && _obj$node.isChildOf(this.parent))) {
                    return this.getObjRef(obj);
                  }
                }
              }
            }
            createCode = new Declaration(LOCAL_OBJ, `new ${this.getFuncModule(ctor, true)}()`);
          } else if (ctor === Object) {
            createCode = new Declaration(LOCAL_OBJ, '{}');
          } else if (!ctor) {
            createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
          } else {
            return this.getObjRef(obj);
          }
          const codeArray = [createCode];
          obj._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(codeArray, obj);
          return ['(function(){', codeArray, 'return o;})();'];
        }
      }
      function equalsToDefault(def, value) {
        if (typeof def === 'function') {
          try {
            def = def();
          } catch (e) {
            return false;
          }
        }
        if (def === value) {
          return true;
        }
        if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
          if (def instanceof legacyCC.ValueType) {
            if (def.equals(value)) {
              return true;
            }
          } else if (Array.isArray(def)) {
            return def.length === 0 && value.length === 0;
          } else if (def.constructor === Object) {
            return isEmptyObject(def) && isEmptyObject(value);
          }
        }
        return false;
      }
      function compile(node) {
        const root = node instanceof legacyCC.Node && node;
        const parser = new Parser$1(node, root);
        return parser.result;
      }

      var _dec$1C, _class$1z, _class2$1s, _initializer$1n, _initializer2$1b, _initializer3$X, _class3$B;
      const OptimizationPolicy = Enum({
        AUTO: 0,
        SINGLE_INSTANCE: 1,
        MULTI_INSTANCE: 2
      });
      let Prefab = exports('Prefab', (_dec$1C = ccclass$6('cc.Prefab'), _dec$1C(_class$1z = (_class2$1s = (_class3$B = class Prefab extends Asset {
        constructor() {
          super();
          this.data = _initializer$1n && _initializer$1n();
          this.optimizationPolicy = _initializer2$1b && _initializer2$1b();
          this.persistent = _initializer3$X && _initializer3$X();
          this._createFunction = void 0;
          this._instantiatedTimes = void 0;
          this._createFunction = null;
          this._instantiatedTimes = 0;
        }
        createNode(cb) {
          const node = legacyCC.instantiate(this);
          node.name = this.name;
          cb(null, node);
        }
        compileCreateFunction() {
          this._createFunction = compile(this.data);
        }
        _doInstantiate(rootToRedirect) {
          if (!this.data._prefab) {
            warnID(3700);
          }
          if (!this._createFunction) {
            this.compileCreateFunction();
          }
          return this._createFunction(rootToRedirect);
        }
        _instantiate() {
          let node;
          let useJit = false;
          {
            if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
              useJit = false;
            } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
              useJit = true;
            } else {
              useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
            }
          }
          if (useJit) {
            node = this._doInstantiate();
            this.data._instantiate(node);
          } else {
            node = this.data._instantiate();
          }
          ++this._instantiatedTimes;
          return node;
        }
        initDefault(uuid) {
          super.initDefault(uuid);
          this.data = new Node$1();
          this.data.name = '(Missing Node)';
          const prefabInfo = new legacyCC._PrefabInfo();
          prefabInfo.asset = this;
          prefabInfo.root = this.data;
          this.data._prefab = prefabInfo;
        }
        validate() {
          return !!this.data;
        }
        onLoaded() {
          const rootNode = this.data;
          expandNestedPrefabInstanceNode(rootNode);
          applyTargetOverrides(rootNode);
          {
            updateChildrenForDeserialize(rootNode);
          }
        }
      }, _class3$B.OptimizationPolicy = OptimizationPolicy, _class3$B.OptimizationPolicyThreshold = 3, _class3$B), (_initializer$1n = applyDecoratedInitializer(_class2$1s.prototype, "data", [serializable$6], function () {
        return null;
      }), _initializer2$1b = applyDecoratedInitializer(_class2$1s.prototype, "optimizationPolicy", [serializable$6], function () {
        return OptimizationPolicy.AUTO;
      }), _initializer3$X = applyDecoratedInitializer(_class2$1s.prototype, "persistent", [serializable$6], function () {
        return false;
      })), _class2$1s)) || _class$1z));
      value(Prefab, '_utils', utils$1);
      legacyCC.Prefab = Prefab;
      {
        obsolete(legacyCC, 'cc._Prefab', 'Prefab');
      }

      class UIRendererManager {
        constructor() {
          this._allRenderers = [];
          this._dirtyRenderers = [];
          this._dirtyVersion = 0;
        }
        addRenderer(uiRenderer) {
          if (uiRenderer._internalId === -1) {
            uiRenderer._internalId = this._allRenderers.length;
            this._allRenderers.push(uiRenderer);
          }
        }
        removeRenderer(uiRenderer) {
          if (uiRenderer._internalId !== -1) {
            {
              assert(this._allRenderers[uiRenderer._internalId] === uiRenderer);
            }
            const id = uiRenderer._internalId;
            this._allRenderers[this._allRenderers.length - 1]._internalId = id;
            fastRemoveAt$2(this._allRenderers, id);
            uiRenderer._internalId = -1;
            if (uiRenderer._dirtyVersion === this._dirtyVersion) {
              fastRemove(this._dirtyRenderers, uiRenderer);
              uiRenderer._dirtyVersion = -1;
            }
          }
        }
        markDirtyRenderer(uiRenderer) {
          if (uiRenderer._dirtyVersion !== this._dirtyVersion && uiRenderer._internalId !== -1) {
            this._dirtyRenderers.push(uiRenderer);
            uiRenderer._dirtyVersion = this._dirtyVersion;
          }
        }
        updateAllDirtyRenderers() {
          const length = this._dirtyRenderers.length;
          const dirtyRenderers = this._dirtyRenderers;
          for (let i = 0; i < length; i++) {
            {
              assert(dirtyRenderers[i]._internalId !== -1);
            }
            dirtyRenderers[i].updateRenderer();
          }
          this._dirtyRenderers.length = 0;
          this._dirtyVersion++;
        }
      }
      const uiRendererManager = new UIRendererManager();

      const isMatchByWord = (path, test) => {
        if (path.length > test.length) {
          const nextAscii = path.charCodeAt(test.length);
          return nextAscii === 47;
        }
        return true;
      };
      const processOptions = options => {
        let uuids = options.uuids;
        const paths = options.paths;
        const types = options.types;
        const bundles = options.deps;
        const realEntries = options.paths = Object.create(null);
        if (options.debug === false) {
          for (let i = 0, l = uuids.length; i < l; i++) {
            uuids[i] = decodeUuid(uuids[i]);
          }
          for (const id in paths) {
            const entry = paths[id];
            const type = entry[1];
            entry[1] = types[type];
          }
        } else {
          const out = Object.create(null);
          for (let i = 0, l = uuids.length; i < l; i++) {
            const uuid = uuids[i];
            uuids[i] = out[uuid] = decodeUuid(uuid);
          }
          uuids = out;
        }
        for (const id in paths) {
          const entry = paths[id];
          realEntries[uuids[id]] = entry;
        }
        const scenes = options.scenes;
        for (const name in scenes) {
          const uuid = scenes[name];
          scenes[name] = uuids[uuid];
        }
        const packs = options.packs;
        for (const packId in packs) {
          const packedIds = packs[packId];
          for (let j = 0; j < packedIds.length; ++j) {
            packedIds[j] = uuids[packedIds[j]];
          }
        }
        const versions = options.versions;
        if (versions) {
          for (const folder in versions) {
            const entries = versions[folder];
            for (let i = 0; i < entries.length; i += 2) {
              const uuid = entries[i];
              entries[i] = uuids[uuid] || uuid;
            }
          }
        }
        const redirect = options.redirect;
        if (redirect) {
          for (let i = 0; i < redirect.length; i += 2) {
            redirect[i] = uuids[redirect[i]];
            redirect[i + 1] = bundles[redirect[i + 1]];
          }
        }
        const extensionMap = options.extensionMap;
        if (extensionMap) {
          for (const ext in options.extensionMap) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              continue;
            }
            options.extensionMap[ext].forEach((uuid, index) => {
              options.extensionMap[ext][index] = uuids[uuid] || uuid;
            });
          }
        }
      };
      class Config {
        constructor() {
          this.name = '';
          this.base = '';
          this.importBase = '';
          this.nativeBase = '';
          this.deps = null;
          this.assetInfos = new Cache();
          this.scenes = new Cache();
          this.paths = new Cache();
        }
        init(options) {
          processOptions(options);
          this.importBase = options.importBase || '';
          this.nativeBase = options.nativeBase || '';
          this.base = options.base || '';
          this.name = options.name || '';
          this.deps = options.deps || [];
          this._initUuid(options.uuids);
          this._initPath(options.paths);
          this._initScene(options.scenes);
          this._initPackage(options.packs);
          this._initVersion(options.versions);
          this._initRedirect(options.redirect);
          for (const ext in options.extensionMap) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              continue;
            }
            options.extensionMap[ext].forEach(uuid => {
              const assetInfo = this.assetInfos.get(uuid);
              if (assetInfo) {
                assetInfo.extension = ext;
              }
            });
          }
        }
        getInfoWithPath(path, type) {
          if (!path) {
            return null;
          }
          path = normalize(path);
          const items = this.paths.get(path);
          if (items) {
            if (type) {
              for (let i = 0, l = items.length; i < l; i++) {
                const assetInfo = items[i];
                if (isChildClassOf(assetInfo.ctor, type)) {
                  return assetInfo;
                }
              }
            } else {
              return items[0];
            }
          }
          return null;
        }
        getDirWithPath(path, type, out) {
          path = normalize(path);
          if (path[path.length - 1] === '/') {
            path = path.slice(0, -1);
          }
          const infos = out || [];
          this.paths.forEach((items, p) => {
            if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
              for (let i = 0, l = items.length; i < l; i++) {
                const entry = items[i];
                if (!type || isChildClassOf(entry.ctor, type)) {
                  infos.push(entry);
                }
              }
            }
          });
          return infos;
        }
        getAssetInfo(uuid) {
          return this.assetInfos.get(uuid) || null;
        }
        getSceneInfo(name) {
          if (!name.endsWith('.scene')) {
            name += '.scene';
          }
          if (name[0] !== '/' && !name.startsWith('db://')) {
            name = `/${name}`;
          }
          const info = this.scenes.find((val, key) => key.endsWith(name));
          return info;
        }
        destroy() {
          this.paths.destroy();
          this.scenes.destroy();
          this.assetInfos.destroy();
        }
        _initUuid(uuidList) {
          if (!uuidList) {
            return;
          }
          this.assetInfos.clear();
          for (let i = 0, l = uuidList.length; i < l; i++) {
            const uuid = uuidList[i];
            this.assetInfos.add(uuid, {
              uuid
            });
          }
        }
        _initPath(pathList) {
          if (!pathList) {
            return;
          }
          const paths = this.paths;
          paths.clear();
          for (const uuid in pathList) {
            const info = pathList[uuid];
            const path = info[0];
            const type = info[1];
            const isSubAsset = info.length === 3;
            const assetInfo = this.assetInfos.get(uuid);
            assetInfo.path = path;
            assetInfo.ctor = getClassById(type);
            if (paths.has(path)) {
              if (isSubAsset) {
                paths.get(path).push(assetInfo);
              } else {
                paths.get(path).unshift(assetInfo);
              }
            } else {
              paths.add(path, [assetInfo]);
            }
          }
        }
        _initScene(sceneList) {
          if (!sceneList) {
            return;
          }
          const scenes = this.scenes;
          scenes.clear();
          const assetInfos = this.assetInfos;
          for (const sceneName in sceneList) {
            const uuid = sceneList[sceneName];
            const assetInfo = assetInfos.get(uuid);
            assetInfo.url = sceneName;
            scenes.add(sceneName, assetInfo);
          }
        }
        _initPackage(packageList) {
          if (!packageList) {
            return;
          }
          const assetInfos = this.assetInfos;
          for (const packUuid in packageList) {
            const uuids = packageList[packUuid];
            const pack = {
              uuid: packUuid,
              packedUuids: uuids,
              ext: '.json'
            };
            assetInfos.add(packUuid, pack);
            for (let i = 0, l = uuids.length; i < l; i++) {
              const uuid = uuids[i];
              const assetInfo = assetInfos.get(uuid);
              const assetPacks = assetInfo.packs;
              if (assetPacks) {
                if (l === 1) {
                  assetPacks.unshift(pack);
                } else {
                  assetPacks.push(pack);
                }
              } else {
                assetInfo.packs = [pack];
              }
            }
          }
        }
        _initVersion(versions) {
          if (!versions) {
            return;
          }
          const assetInfos = this.assetInfos;
          let entries = versions.import;
          if (entries) {
            for (let i = 0, l = entries.length; i < l; i += 2) {
              const uuid = entries[i];
              const assetInfo = assetInfos.get(uuid);
              assetInfo.ver = entries[i + 1];
            }
          }
          entries = versions.native;
          if (entries) {
            for (let i = 0, l = entries.length; i < l; i += 2) {
              const uuid = entries[i];
              const assetInfo = assetInfos.get(uuid);
              assetInfo.nativeVer = entries[i + 1];
            }
          }
        }
        _initRedirect(redirect) {
          if (!redirect) {
            return;
          }
          const assetInfos = this.assetInfos;
          for (let i = 0, l = redirect.length; i < l; i += 2) {
            const uuid = redirect[i];
            const assetInfo = assetInfos.get(uuid);
            assetInfo.redirect = redirect[i + 1];
          }
        }
      }

      function visitAsset(asset, deps) {
        if (!asset._uuid) {
          return;
        }
        deps.push(asset._uuid);
      }
      function visitComponent(comp, deps) {
        const props = Object.getOwnPropertyNames(comp);
        for (let i = 0; i < props.length; i++) {
          const propName = props[i];
          if (propName === 'node' || propName === '__eventTargets') {
            continue;
          }
          const value = comp[propName];
          if (typeof value === 'object' && value) {
            if (Array.isArray(value)) {
              for (let j = 0; j < value.length; j++) {
                const val = value[j];
                if (val instanceof Asset) {
                  visitAsset(val, deps);
                }
              }
            } else if (!value.constructor || value.constructor === Object) {
              const keys = Object.getOwnPropertyNames(value);
              for (let j = 0; j < keys.length; j++) {
                const val = value[keys[j]];
                if (val instanceof Asset) {
                  visitAsset(val, deps);
                }
              }
            } else if (value instanceof Asset) {
              visitAsset(value, deps);
            }
          }
        }
      }
      function visitNode$1(node, deps) {
        for (let i = 0; i < node._components.length; i++) {
          visitComponent(node._components[i], deps);
        }
        for (let i = 0; i < node._children.length; i++) {
          visitNode$1(node._children[i], deps);
        }
      }
      function descendOpRef(asset, refs, exclude, op) {
        exclude.push(asset._uuid);
        const depends = dependUtil.getDeps(asset._uuid);
        for (let i = 0, l = depends.length; i < l; i++) {
          const dependAsset = assets.get(depends[i]);
          if (!dependAsset) {
            continue;
          }
          const uuid = dependAsset._uuid;
          if (!(uuid in refs)) {
            refs[uuid] = dependAsset.refCount + op;
          } else {
            refs[uuid] += op;
          }
          if (exclude.includes(uuid)) {
            continue;
          }
          descendOpRef(dependAsset, refs, exclude, op);
        }
      }
      const _temp = [];
      function checkCircularReference(asset) {
        const refs = Object.create(null);
        refs[asset._uuid] = asset.refCount;
        descendOpRef(asset, refs, _temp, -1);
        _temp.length = 0;
        if (refs[asset._uuid] !== 0) {
          return refs[asset._uuid];
        }
        for (const uuid in refs) {
          if (refs[uuid] !== 0) {
            descendOpRef(assets.get(uuid), refs, _temp, 1);
          }
        }
        _temp.length = 0;
        return refs[asset._uuid];
      }
      class ReleaseManager {
        constructor() {
          this._persistNodeDeps = new Cache();
          this._toDelete = new Cache();
          this._eventListener = false;
          this._dontDestroyAssets = [];
        }
        addIgnoredAsset(asset) {
          this._dontDestroyAssets.push(asset._uuid);
        }
        init() {
          this._persistNodeDeps.clear();
          this._toDelete.clear();
        }
        _addPersistNodeRef(node) {
          const deps = [];
          visitNode$1(node, deps);
          for (let i = 0, l = deps.length; i < l; i++) {
            const dependAsset = assets.get(deps[i]);
            if (dependAsset) {
              dependAsset.addRef();
            }
          }
          this._persistNodeDeps.add(node.uuid, deps);
        }
        _removePersistNodeRef(node) {
          if (!this._persistNodeDeps.has(node.uuid)) {
            return;
          }
          const deps = this._persistNodeDeps.get(node.uuid);
          for (let i = 0, l = deps.length; i < l; i++) {
            const dependAsset = assets.get(deps[i]);
            if (dependAsset) {
              dependAsset.decRef();
            }
          }
          this._persistNodeDeps.remove(node.uuid);
        }
        _autoRelease(oldScene, newScene, persistNodes) {
          if (oldScene) {
            const childs = dependUtil.getDeps(oldScene.uuid);
            for (let i = 0, l = childs.length; i < l; i++) {
              const asset = assets.get(childs[i]);
              if (asset) {
                asset.decRef(oldScene.autoReleaseAssets);
              }
            }
            const dependencies = dependUtil._depends.get(oldScene.uuid);
            if (dependencies && dependencies.persistDeps) {
              const persistDeps = dependencies.persistDeps;
              for (let i = 0, l = persistDeps.length; i < l; i++) {
                const asset = assets.get(persistDeps[i]);
                if (asset) {
                  asset.decRef(oldScene.autoReleaseAssets);
                }
              }
            }
            if (oldScene.uuid !== newScene.uuid) {
              dependUtil.remove(oldScene.uuid);
            }
          }
          const sceneDeps = dependUtil._depends.get(newScene.uuid);
          if (sceneDeps) {
            sceneDeps.persistDeps = [];
          }
          for (const key in persistNodes) {
            const node = persistNodes[key];
            const deps = this._persistNodeDeps.get(node.uuid);
            for (const dep of deps) {
              const dependAsset = assets.get(dep);
              if (dependAsset) {
                dependAsset.addRef();
              }
            }
            if (!sceneDeps) {
              continue;
            }
            sceneDeps.persistDeps.push(...deps);
          }
        }
        tryRelease(asset, force = false) {
          if (!(asset instanceof Asset)) {
            return;
          }
          if (force) {
            this._free(asset, force);
            return;
          }
          this._toDelete.add(asset._uuid, asset);
          if (!this._eventListener) {
            this._eventListener = true;
            callInNextTick(this._freeAssets.bind(this));
          }
        }
        _freeAssets() {
          this._eventListener = false;
          this._toDelete.forEach(asset => {
            this._free(asset);
          });
          this._toDelete.clear();
        }
        _free(asset, force = false) {
          const uuid = asset._uuid;
          this._toDelete.remove(uuid);
          if (!isValid(asset, true) || this._dontDestroyAssets.indexOf(uuid) !== -1) {
            return;
          }
          if (!force) {
            if (asset.refCount > 0) {
              if (checkCircularReference(asset) > 0) {
                return;
              }
            }
          }
          assets.remove(uuid);
          const depends = dependUtil.getDeps(uuid);
          for (let i = 0, l = depends.length; i < l; i++) {
            const dependAsset = assets.get(depends[i]);
            if (dependAsset) {
              dependAsset.decRef(false);
              {
                this._free(dependAsset, false);
              }
            }
          }
          {
            asset.destroy();
          }
          dependUtil.remove(uuid);
        }
      }
      const releaseManager = new ReleaseManager();

      let defaultProgressCallback = null;
      function setDefaultProgressCallback(onProgress) {
        defaultProgressCallback = onProgress;
      }
      function clear(task, clearRef) {
        for (let i = 0, l = task.input.length; i < l; i++) {
          const item = task.input[i];
          if (clearRef) {
            if (!item.isNative && item.content instanceof Asset) {
              item.content.decRef(false);
            }
          }
          item.recycle();
        }
        task.input = null;
      }
      function urlAppendTimestamp(url, append) {
        if (append) {
          if (/\?/.test(url)) {
            return `${url}&_t=${Date.now()}`;
          }
          return `${url}?_t=${Date.now()}`;
        }
        return url;
      }
      function retry(process, times, wait, onComplete, index = 0) {
        process(index, (err, result) => {
          index++;
          if (!err || index > times) {
            if (onComplete) {
              onComplete(err, result);
            }
          } else {
            setTimeout(() => {
              retry(process, times, wait, onComplete, index);
            }, wait);
          }
        });
      }
      function getDepends(uuid, data, exclude, depends, config) {
        try {
          const info = dependUtil.parse(uuid, data);
          for (let i = 0, l = info.deps.length; i < l; i++) {
            const dep = info.deps[i];
            if (!(dep in exclude)) {
              exclude[dep] = true;
              depends.push({
                uuid: dep,
                bundle: config && config.name
              });
            }
          }
          if (info.nativeDep) {
            if (config) {
              info.nativeDep.bundle = config.name;
            }
            depends.push({
              ...info.nativeDep
            });
          }
        } catch (e) {
          error(e.message, e.stack);
        }
      }
      function cache(id, asset, cacheAsset) {
        if (!asset) {
          return;
        }
        cacheAsset = cacheAsset !== undefined ? cacheAsset : legacyCC.assetManager.cacheAsset;
        if (!isScene(asset) && cacheAsset && !asset.isDefault) {
          assets.add(id, asset);
        }
      }
      function setProperties(uuid, asset, assetsMap) {
        let missingAsset = false;
        const depends = dependMap.get(asset);
        if (depends) {
          for (let i = 0, l = depends.length; i < l; i++) {
            const depend = depends[i];
            const dependAsset = assetsMap[`${depend.uuid}@import`];
            if (!dependAsset) {
              {
                error(`The asset ${depend.uuid} is missing!`);
              }
              legacyCC.assetManager.dispatchAssetMissing(asset, depend.owner, depend.prop, depend.uuid);
              if (depend.type && depend.type !== Asset) {
                const placeHolder = new depend.type();
                placeHolder.initDefault(depend.uuid);
                depend.owner[depend.prop] = placeHolder;
              }
              missingAsset = true;
            } else {
              depend.owner[depend.prop] = dependAsset.addRef();
            }
          }
          dependMap.delete(asset);
        }
        if (nativeDependMap.has(asset)) {
          if (assetsMap[`${uuid}@native`]) {
            asset._nativeAsset = assetsMap[`${uuid}@native`];
          } else {
            missingAsset = true;
            console.error(`the native asset of ${uuid} is missing!`);
          }
          nativeDependMap.delete(asset);
        }
        return missingAsset;
      }
      function gatherAsset(task) {
        const source = task.source;
        if (!task.options.__outputAsArray__ && source.length === 1) {
          task.output = source[0].content;
        } else {
          const output = task.output = [];
          for (let i = 0, l = source.length; i < l; i++) {
            output.push(source[i].content);
          }
        }
      }
      function forEach(array, process, onComplete) {
        let count = 0;
        const errs = [];
        const length = array.length;
        if (length === 0 && onComplete) {
          onComplete(errs);
        }
        const cb = err => {
          if (err) {
            errs.push(err);
          }
          count++;
          if (count === length) {
            if (onComplete) {
              onComplete(errs);
            }
          }
        };
        for (let i = 0; i < length; i++) {
          process(array[i], cb);
        }
      }
      function parseParameters(options, onProgress, onComplete) {
        let optionsOut = options;
        let onProgressOut = onProgress;
        let onCompleteOut = onComplete;
        if (onComplete === undefined) {
          const isCallback = typeof options === 'function';
          if (onProgress) {
            onCompleteOut = onProgress;
            if (!isCallback) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && isCallback) {
            onCompleteOut = options;
            optionsOut = null;
            onProgressOut = null;
          }
          if (onProgress !== undefined && isCallback) {
            onProgressOut = options;
            optionsOut = null;
          }
        }
        return {
          options: optionsOut || Object.create(null),
          onProgress: onProgressOut,
          onComplete: onCompleteOut
        };
      }
      function parseLoadResArgs(type, onProgress, onComplete) {
        let typeOut = type;
        let onProgressOut = onProgress;
        let onCompleteOut = onComplete;
        if (onComplete === undefined) {
          const isValidType = isChildClassOf(type, Asset);
          if (onProgress) {
            onCompleteOut = onProgress;
            if (isValidType) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && !isValidType) {
            onCompleteOut = type;
            onProgressOut = null;
            typeOut = null;
          }
          if (onProgress !== undefined && !isValidType) {
            onProgressOut = type;
            typeOut = null;
          }
        }
        return {
          type: typeOut,
          onProgress: onProgressOut || defaultProgressCallback,
          onComplete: onCompleteOut
        };
      }
      function checkCircleReference(owner, uuid, map, checked = {}) {
        const item = map[uuid];
        if (!item || checked[uuid]) {
          return false;
        }
        checked[uuid] = true;
        let result = false;
        const deps = dependUtil.getDeps(uuid);
        if (deps) {
          for (let i = 0, l = deps.length; i < l; i++) {
            const dep = deps[i];
            if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
              result = true;
              break;
            }
          }
        }
        return result;
      }
      function asyncify(cb) {
        return (p1, p2) => {
          if (!cb) {
            return;
          }
          const refs = [];
          if (Array.isArray(p2)) {
            p2.forEach(x => x instanceof Asset && refs.push(x.addRef()));
          } else if (p2 instanceof Asset) {
            refs.push(p2.addRef());
          }
          callInNextTick(() => {
            refs.forEach(x => x.decRef(false));
            cb(p1, p2);
          });
        };
      }

      class Bundle {
        constructor() {
          this._config = new Config();
        }
        get config() {
          return this._config;
        }
        get name() {
          return this._config.name;
        }
        get deps() {
          return this._config.deps;
        }
        get base() {
          return this._config.base;
        }
        getInfoWithPath(path, type) {
          return this._config.getInfoWithPath(path, type);
        }
        getDirWithPath(path, type, out) {
          return this._config.getDirWithPath(path, type, out);
        }
        getAssetInfo(uuid) {
          return this._config.getAssetInfo(uuid);
        }
        getSceneInfo(name) {
          return this._config.getSceneInfo(name);
        }
        init(options) {
          this._config.init(options);
          bundles.add(options.name, this);
        }
        load(paths, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          const options = {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name,
            __outputAsArray__: Array.isArray(paths)
          };
          legacyCC.assetManager.loadAny(paths, options, onProg, onComp);
        }
        preload(paths, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.preloadAny(paths, {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        }
        loadDir(dir, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.loadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name,
            __outputAsArray__: true
          }, onProg, onComp);
        }
        preloadDir(dir, type, onProgress, onComplete) {
          const {
            type: _type,
            onProgress: onProg,
            onComplete: onComp
          } = parseLoadResArgs(type, onProgress, onComplete);
          legacyCC.assetManager.preloadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        }
        loadScene(sceneName, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'scene';
          opts.bundle = this.name;
          legacyCC.assetManager.loadAny({
            scene: sceneName
          }, opts, onProg, (err, sceneAsset) => {
            if (err) {
              error(err.message, err.stack);
            } else if (sceneAsset.scene) {
              const scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene.name = sceneAsset.name;
            } else {
              err = new Error(`The asset ${sceneAsset._uuid} is not a scene`);
            }
            if (onComp) {
              onComp(err, sceneAsset);
            }
          });
        }
        preloadScene(sceneName, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.bundle = this.name;
          legacyCC.assetManager.preloadAny({
            scene: sceneName
          }, opts, onProg, err => {
            if (err) {
              errorID(1210, sceneName, err.message);
            }
            if (onComp) {
              onComp(err);
            }
          });
        }
        get(path, type) {
          const info = this.getInfoWithPath(path, type);
          if (info) {
            return assets.get(info.uuid) || null;
          }
          return null;
        }
        release(path, type) {
          const asset = this.get(path, type);
          if (asset) {
            releaseManager.tryRelease(asset, true);
          }
        }
        releaseUnusedAssets() {
          assets.forEach(asset => {
            const info = this.getAssetInfo(asset._uuid);
            if (info && !info.redirect) {
              releaseManager.tryRelease(asset);
            }
          });
        }
        releaseAll() {
          assets.forEach(asset => {
            const info = this.getAssetInfo(asset._uuid);
            if (info && !info.redirect) {
              releaseManager.tryRelease(asset, true);
            }
          });
        }
        _destroy() {
          this._config.destroy();
        }
      }
      const resources = exports('resources', new Bundle());
      legacyCC.resources = resources;

      class CacheManager {
        constructor() {
          this.cacheDir = void 0;
          this.cacheEnabled = void 0;
          this.autoClear = void 0;
          this.cacheInterval = void 0;
          this.deleteInterval = void 0;
          this.cachedFiles = void 0;
        }
      }

      function downloadDomImage(url, options, onComplete) {
        const img = new ccwindow$1.Image();
        if (ccwindow$1.location.protocol !== 'file:' || XIAOMI) {
          img.crossOrigin = 'anonymous';
        }
        function loadCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);
          if (onComplete) {
            onComplete(null, img);
          }
        }
        function errorCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);
          if (onComplete) {
            onComplete(new Error(getError(4930, url)));
          }
        }
        img.addEventListener('load', loadCallback);
        img.addEventListener('error', errorCallback);
        img.src = url;
        return img;
      }

      function downloadFile(url, options, onProgress, onComplete) {
        const xhr = new XMLHttpRequest();
        const errInfo = `download failed: ${url}, status: `;
        xhr.open('GET', url, true);
        if (options.xhrResponseType !== undefined) {
          xhr.responseType = options.xhrResponseType;
        }
        if (options.xhrWithCredentials !== undefined) {
          xhr.withCredentials = options.xhrWithCredentials;
        }
        if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
          xhr.overrideMimeType(options.xhrMimeType);
        }
        if (options.xhrTimeout !== undefined) {
          xhr.timeout = options.xhrTimeout;
        }
        if (options.xhrHeader) {
          for (const header in options.xhrHeader) {
            xhr.setRequestHeader(header, options.xhrHeader[header]);
          }
        }
        xhr.onload = () => {
          if (xhr.status === 200 || xhr.status === 0) {
            if (onComplete) {
              onComplete(null, xhr.response);
            }
          } else if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(no response)`));
          }
        };
        if (onProgress) {
          xhr.onprogress = e => {
            if (e.lengthComputable) {
              onProgress(e.loaded, e.total);
            }
          };
        }
        xhr.onerror = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(error)`));
          }
        };
        xhr.ontimeout = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(time out)`));
          }
        };
        xhr.onabort = () => {
          if (onComplete) {
            onComplete(new Error(`${errInfo}${xhr.status}(abort)`));
          }
        };
        xhr.send(null);
        return xhr;
      }

      const ccdocument$3 = ccwindow$1.document;
      const downloaded = {};
      function downloadScript(url, options, onComplete) {
        if (downloaded[url]) {
          if (onComplete) {
            onComplete(null);
          }
          return null;
        }
        const script = ccdocument$3.createElement('script');
        if (ccwindow$1.location.protocol !== 'file:') {
          script.crossOrigin = 'anonymous';
        }
        script.async = options.scriptAsyncLoading || false;
        script.src = url;
        function loadHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);
          downloaded[url] = true;
          if (onComplete) {
            onComplete(null);
          }
        }
        function errorHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);
          if (onComplete) {
            onComplete(new Error(getError(4928, url)));
          }
        }
        script.addEventListener('load', loadHandler, false);
        script.addEventListener('error', errorHandler, false);
        ccdocument$3.body.appendChild(script);
        return script;
      }

      const REGEX = /^(?:\w+:\/\/|\.+\/).+/;
      const downloadImage = (url, options, onComplete) => {
        const func = sys.hasFeature(sys.Feature.IMAGE_BITMAP) && legacyCC.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
        func(url, options, onComplete);
      };
      const downloadBlob = (url, options, onComplete) => {
        options.xhrResponseType = 'blob';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadJson = (url, options, onComplete) => {
        options.xhrResponseType = 'json';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadArrayBuffer = (url, options, onComplete) => {
        options.xhrResponseType = 'arraybuffer';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadCCON = (url, options, onComplete) => {
        downloader._downloadJson(url, options, (err, json) => {
          if (err) {
            onComplete(err);
            return;
          }
          const cconPreface = parseCCONJson(json);
          const chunkPromises = Promise.all(cconPreface.chunks.map(chunk => new Promise((resolve, reject) => {
            downloader._downloadArrayBuffer(`${mainFileName(url)}${chunk}`, {}, (errChunk, chunkBuffer) => {
              if (err) {
                reject(err);
              } else {
                resolve(new Uint8Array(chunkBuffer));
              }
            });
          })));
          chunkPromises.then(chunks => {
            const ccon = new CCON(cconPreface.document, chunks);
            onComplete(null, ccon);
          }).catch(err => {
            onComplete(err);
          });
        });
      };
      const downloadCCONB = (url, options, onComplete) => {
        downloader._downloadArrayBuffer(url, options, (err, arrayBuffer) => {
          if (err) {
            onComplete(err);
            return;
          }
          try {
            const ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
            onComplete(null, ccon);
          } catch (err) {
            onComplete(err);
          }
        });
      };
      const downloadText = (url, options, onComplete) => {
        options.xhrResponseType = 'text';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };
      const downloadBundle = (nameOrUrl, options, onComplete) => {
        const bundleName = basename(nameOrUrl);
        let url = nameOrUrl;
        if (!REGEX.test(url)) {
          if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
            url = `${downloader.remoteServerAddress}remote/${bundleName}`;
          } else {
            url = `assets/${bundleName}`;
          }
        }
        const version = options.version || downloader.bundleVers[bundleName];
        let count = 0;
        const config = `${url}/config.${version ? `${version}.` : ''}json`;
        let out = null;
        let error = null;
        downloadJson(config, options, (err, response) => {
          error = err || error;
          out = response;
          if (out) {
            out.base = `${url}/`;
          }
          if (++count === 2) {
            onComplete(error, out);
          }
        });
        const jspath = `${url}/index.${version ? `${version}.` : ''}js`;
        downloadScript(jspath, options, err => {
          error = err || error;
          if (++count === 2) {
            onComplete(error, out);
          }
        });
      };
      class Downloader {
        static get instance() {
          if (!Downloader._instance) {
            Downloader._instance = new Downloader();
          }
          return Downloader._instance;
        }
        get remoteServerAddress() {
          return this._remoteServerAddress;
        }
        init(remoteServerAddress = '', bundleVers = {}, remoteBundles = []) {
          this._downloading.clear();
          this._queue.length = 0;
          this._remoteServerAddress = remoteServerAddress;
          this.bundleVers = bundleVers;
          this.remoteBundles = remoteBundles;
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._downloaders, type);
          } else {
            this._downloaders[type] = handler;
          }
        }
        download(id, url, type, options, onComplete) {
          const file = files.get(id);
          if (file) {
            onComplete(null, file);
            return;
          }
          const downloadCallbacks = this._downloading.get(id);
          if (downloadCallbacks) {
            downloadCallbacks.push(onComplete);
            const request = this._queue.find(x => x.id === id);
            if (!request) {
              return;
            }
            const priority = options.priority || 0;
            if (request.priority < priority) {
              request.priority = priority;
              this._queueDirty = true;
            }
            return;
          }
          const maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
          const maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
          const maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
          const handler = this._downloaders[type] || this._downloaders.default;
          const process = (index, callback) => {
            if (index === 0) {
              this._downloading.add(id, [onComplete]);
            }
            if (!this.limited) {
              handler(urlAppendTimestamp(url, this.appendTimeStamp), options, callback);
              return;
            }
            this._updateTime();
            const done = (err, data) => {
              this._totalNum--;
              this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              callback(err, data);
            };
            if (this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
              handler(urlAppendTimestamp(url, this.appendTimeStamp), options, done);
              this._totalNum++;
              this._totalNumThisPeriod++;
            } else {
              this._queue.push({
                id,
                priority: options.priority || 0,
                url,
                options,
                done,
                handler
              });
              this._queueDirty = true;
              if (this._totalNum < maxConcurrency) {
                this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              }
            }
          };
          const finale = (err, result) => {
            if (!err) {
              files.add(id, result);
            }
            const callbacks = this._downloading.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          };
          retry(process, maxRetryCount, this.retryInterval, finale);
        }
        loadSubpackage(name, completeCallback) {
          legacyCC.assetManager.loadBundle(name, null, completeCallback);
        }
        constructor() {
          this.maxConcurrency = 15;
          this.maxRequestsPerFrame = 15;
          this.maxRetryCount = 3 ;
          this.appendTimeStamp = !!EDITOR_NOT_IN_PREVIEW;
          this.limited = !EDITOR;
          this.retryInterval = 2000;
          this.bundleVers = {};
          this.remoteBundles = [];
          this.downloadDomImage = downloadDomImage;
          this.downloadDomAudio = null;
          this.downloadFile = downloadFile;
          this.downloadScript = downloadScript;
          this._downloadArrayBuffer = downloadArrayBuffer;
          this._downloadJson = downloadJson;
          this._downloaders = {
            '.png': downloadImage,
            '.jpg': downloadImage,
            '.bmp': downloadImage,
            '.jpeg': downloadImage,
            '.gif': downloadImage,
            '.ico': downloadImage,
            '.tiff': downloadImage,
            '.webp': downloadImage,
            '.image': downloadImage,
            '.pvr': downloadArrayBuffer,
            '.pkm': downloadArrayBuffer,
            '.astc': downloadArrayBuffer,
            '.txt': downloadText,
            '.xml': downloadText,
            '.vsh': downloadText,
            '.fsh': downloadText,
            '.atlas': downloadText,
            '.tmx': downloadText,
            '.tsx': downloadText,
            '.json': downloadJson,
            '.ExportJson': downloadJson,
            '.plist': downloadText,
            '.ccon': downloadCCON,
            '.cconb': downloadCCONB,
            '.fnt': downloadText,
            '.binary': downloadArrayBuffer,
            '.bin': downloadArrayBuffer,
            '.dbbin': downloadArrayBuffer,
            '.skel': downloadArrayBuffer,
            '.js': downloadScript,
            bundle: downloadBundle,
            default: downloadText
          };
          this._downloading = new Cache();
          this._queue = [];
          this._queueDirty = false;
          this._totalNum = 0;
          this._totalNumThisPeriod = 0;
          this._lastDate = -1;
          this._checkNextPeriod = false;
          this._remoteServerAddress = '';
          this._maxInterval = 1 / 30;
        }
        _updateTime() {
          const now = performance.now();
          const deltaTime = legacyCC.game.deltaTime;
          const interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;
          if (now - this._lastDate > interval * 1000) {
            this._totalNumThisPeriod = 0;
            this._lastDate = now;
          }
        }
        _handleQueue(maxConcurrency, maxRequestsPerFrame) {
          this._checkNextPeriod = false;
          this._updateTime();
          while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
            if (this._queueDirty) {
              this._queue.sort((a, b) => a.priority - b.priority);
              this._queueDirty = false;
            }
            const request = this._queue.pop();
            if (!request) {
              break;
            }
            this._totalNum++;
            this._totalNumThisPeriod++;
            request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
          }
          this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
        }
        _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
          if (!this._checkNextPeriod && this._queue.length > 0) {
            callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
            this._checkNextPeriod = true;
          }
        }
      }
      Downloader._instance = void 0;
      const downloader = Downloader.instance;
      var downloader$1 = Downloader.instance;

      var _dec$1B, _class$1y, _class2$1r, _initializer$1m;
      let JsonAsset = exports('JsonAsset', (_dec$1B = ccclass$6('cc.JsonAsset'), _dec$1B(_class$1y = (_class2$1r = class JsonAsset extends Asset {
        constructor(...args) {
          super(...args);
          this.json = _initializer$1m && _initializer$1m();
        }
      }, (_initializer$1m = applyDecoratedInitializer(_class2$1r.prototype, "json", [serializable$6], function () {
        return null;
      })), _class2$1r)) || _class$1y));
      legacyCC.JsonAsset = JsonAsset;

      var _dec$1A, _class$1x, _class2$1q, _initializer$1l;
      let TextAsset = exports('TextAsset', (_dec$1A = ccclass$6('cc.TextAsset'), _dec$1A(_class$1x = (_class2$1q = class TextAsset extends Asset {
        constructor(...args) {
          super(...args);
          this.text = _initializer$1l && _initializer$1l();
        }
        toString() {
          return this.text;
        }
      }, (_initializer$1l = applyDecoratedInitializer(_class2$1q.prototype, "text", [serializable$6], function () {
        return '';
      })), _class2$1q)) || _class$1x));
      legacyCC.TextAsset = TextAsset;

      const BufferAsset = exports('BufferAsset', jsb.BufferAsset);
      legacyCC.BufferAsset = jsb.BufferAsset;
      patch_cc_BufferAsset({
        BufferAsset
      });

      function createImageAsset(id, data, options, onComplete) {
        let out = null;
        let err = null;
        try {
          out = new ImageAsset$1();
          out._nativeUrl = id;
          out._nativeAsset = data;
        } catch (e) {
          err = e;
        }
        onComplete(err, out);
      }
      function createJsonAsset(id, data, options, onComplete) {
        const out = new JsonAsset();
        out.json = data;
        onComplete(null, out);
      }
      function createTextAsset(id, data, options, onComplete) {
        const out = new TextAsset();
        out.text = data;
        onComplete(null, out);
      }
      function createBufferAsset(id, data, options, onComplete) {
        const out = new BufferAsset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      function createAsset(id, data, options, onComplete) {
        const out = new Asset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      function createBundle(id, data, options, onComplete) {
        let bundle = bundles.get(data.name);
        if (!bundle) {
          bundle = data.name === BuiltinBundleName.RESOURCES ? resources : new Bundle();
          data.base = data.base || `${id}/`;
          bundle.init(data);
        }
        {
          module.import(`virtual:///prerequisite-imports/${bundle.name}`).then(() => {
            onComplete(null, bundle);
          }).catch(onComplete);
        }
      }
      class Factory {
        constructor() {
          this._creating = new Cache();
          this._producers = {
            '.png': createImageAsset,
            '.jpg': createImageAsset,
            '.bmp': createImageAsset,
            '.jpeg': createImageAsset,
            '.gif': createImageAsset,
            '.ico': createImageAsset,
            '.tiff': createImageAsset,
            '.webp': createImageAsset,
            '.image': createImageAsset,
            '.pvr': createImageAsset,
            '.pkm': createImageAsset,
            '.txt': createTextAsset,
            '.xml': createTextAsset,
            '.vsh': createTextAsset,
            '.fsh': createTextAsset,
            '.atlas': createTextAsset,
            '.tmx': createTextAsset,
            '.tsx': createTextAsset,
            '.fnt': createTextAsset,
            '.json': createJsonAsset,
            '.ExportJson': createJsonAsset,
            '.binary': createBufferAsset,
            '.bin': createBufferAsset,
            '.dbbin': createBufferAsset,
            '.skel': createBufferAsset,
            bundle: createBundle,
            default: createAsset
          };
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._producers, type);
          } else {
            this._producers[type] = handler;
          }
        }
        create(id, data, type, options, onComplete) {
          const handler = this._producers[type] || this._producers.default;
          const asset = assets.get(id);
          if (!options.reloadAsset && asset) {
            onComplete(null, asset);
            return;
          }
          const creating = this._creating.get(id);
          if (creating) {
            creating.push(onComplete);
            return;
          }
          this._creating.add(id, [onComplete]);
          handler(id, data, options, (err, result) => {
            if (!err && result instanceof Asset) {
              result._uuid = id;
              cache(id, result, options.cacheAsset);
            }
            const callbacks = this._creating.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          });
        }
      }
      var factory = new Factory();

      class PackManager {
        constructor() {
          this._loading = new Cache();
          this._unpackers = {
            '.json': this.unpackJson
          };
        }
        unpackJson(pack, json, options, onComplete) {
          const out = createMap(true);
          let err = null;
          if (Array.isArray(json)) {
            json = unpackJSONs(json);
            if (json.length !== pack.length) {
              errorID(4915);
            }
            for (let i = 0; i < pack.length; i++) {
              out[`${pack[i]}@import`] = json[i];
            }
          } else {
            const textureType = getClassId(Texture2D$1);
            const imageAssetType = getClassId(ImageAsset$1);
            if (json.type === textureType && json.data) {
              const datas = json.data;
              if (datas.length !== pack.length) {
                errorID(4915);
              }
              for (let i = 0; i < pack.length; i++) {
                out[`${pack[i]}@import`] = packCustomObjData(textureType, {
                  base: datas[i][0],
                  mipmaps: datas[i][1]
                });
              }
            } else if (json.type === imageAssetType && json.data) {
              const datas = json.data;
              if (datas.length !== pack.length) {
                errorID(4915);
              }
              for (let i = 0; i < pack.length; i++) {
                out[`${pack[i]}@import`] = datas[i];
              }
            } else {
              err = new Error('unmatched type pack!');
              onComplete(err, null);
              return;
            }
          }
          onComplete(err, out);
        }
        init() {
          this._loading.clear();
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._unpackers, type);
          } else {
            this._unpackers[type] = handler;
          }
        }
        unpack(pack, data, type, options, onComplete) {
          if (!data) {
            onComplete(new Error('package data is wrong!'));
            return;
          }
          const unpacker = this._unpackers[type];
          unpacker(pack, data, options, onComplete);
        }
        load(item, options, onComplete) {
          if (item.isNative || !item.info || !item.info.packs) {
            downloader$1.download(item.id, item.url, item.ext, item.options, onComplete);
            return;
          }
          if (files.has(item.id)) {
            onComplete(null, files.get(item.id));
            return;
          }
          const packs = item.info.packs;
          const loadingPack = packs.find(val => this._loading.has(val.uuid));
          if (loadingPack) {
            const req = this._loading.get(loadingPack.uuid);
            assertIsTrue(req);
            req.push({
              onComplete,
              id: item.id
            });
            return;
          }
          const pack = packs[0];
          this._loading.add(pack.uuid, [{
            onComplete,
            id: item.id
          }]);
          assertIsTrue(item.config);
          const url = transform(pack.uuid, {
            ext: pack.ext,
            bundle: item.config.name
          });
          downloader$1.download(pack.uuid, url, pack.ext, item.options, (err, data) => {
            files.remove(pack.uuid);
            if (err) {
              error(err.message, err.stack);
            }
            this.unpack(pack.packedUuids, data, pack.ext, item.options, (err2, result) => {
              if (!err2) {
                for (const id in result) {
                  files.add(id, result[id]);
                }
              }
              const callbacks = this._loading.remove(pack.uuid);
              assertIsTrue(callbacks);
              for (let i = 0, l = callbacks.length; i < l; i++) {
                const cb = callbacks[i];
                if (err || err2) {
                  cb.onComplete(err || err2);
                  continue;
                }
                const unpackedData = result[cb.id];
                if (!unpackedData) {
                  cb.onComplete(new Error('can not retrieve data from package'));
                } else {
                  cb.onComplete(null, unpackedData);
                }
              }
            });
          });
        }
      }
      var packManager = new PackManager();

      function fetch(task, done) {
        let firstTask = false;
        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }
        const {
          options,
          progress
        } = task;
        const depends = [];
        const total = progress.total;
        const exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, (item, cb) => {
          if (!item.isNative && assets.has(item.uuid)) {
            const asset = assets.get(item.uuid);
            item.content = asset.addRef();
            task.output.push(item);
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            cb();
            return;
          }
          packManager.load(item, task.options, (err, data) => {
            if (err) {
              if (!task.isFinished) {
                if (!legacyCC.assetManager.force || firstTask) {
                  error(err.message, err.stack);
                  progress.canInvoke = false;
                  done(err);
                } else {
                  task.output.push(item);
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                }
              }
            } else if (!task.isFinished) {
              item.file = data;
              task.output.push(item);
              if (!item.isNative) {
                exclude[item.uuid] = true;
                getDepends(item.uuid, data, exclude, depends, item.config);
                progress.total = total + depends.length;
              }
              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total, item);
              }
            }
            cb();
          });
        }, () => {
          if (task.isFinished) {
            clear(task, true);
            task.dispatch('error');
            return;
          }
          if (depends.length > 0) {
            const subTask = Task.create({
              input: depends,
              progress,
              options,
              onProgress: task.onProgress,
              onError: Task.prototype.recycle,
              onComplete: err => {
                if (!err) {
                  task.output.push(...subTask.output);
                  subTask.recycle();
                }
                if (firstTask) {
                  decreaseRef(task);
                }
                done(err);
              }
            });
            fetchPipeline.async(subTask);
            return;
          }
          if (firstTask) {
            decreaseRef(task);
          }
          done();
        });
      }
      function decreaseRef(task) {
        const output = task.output;
        for (let i = 0, l = output.length; i < l; i++) {
          if (output[i].content) {
            output[i].content.decRef(false);
          }
        }
      }

      class SAXParser {
        constructor() {
          this._parser = null;
          if (globalThis.DOMParser) {
            this._parser = new DOMParser();
          }
        }
        parse(xmlTxt) {
          return this._parseXML(xmlTxt);
        }
        _parseXML(textxml) {
          if (this._parser) {
            return this._parser.parseFromString(textxml, 'text/xml');
          }
          throw new Error('Dom parser is not supported in this platform!');
        }
      }
      class PlistParser extends SAXParser {
        parse(xmlTxt) {
          const xmlDoc = this._parseXML(xmlTxt);
          const plist = xmlDoc.documentElement;
          if (plist.tagName !== 'plist') {
            warnID(5100);
            return {};
          }
          let node = null;
          for (let i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType === 1) {
              break;
            }
          }
          return this._parseNode(node);
        }
        _parseNode(node) {
          let data = null;
          const tagName = node.tagName;
          if (tagName === 'dict') {
            data = this._parseDict(node);
          } else if (tagName === 'array') {
            data = this._parseArray(node);
          } else if (tagName === 'string') {
            if (node.childNodes.length === 1) {
              data = node.firstChild.nodeValue;
            } else {
              data = '';
              for (let i = 0; i < node.childNodes.length; i++) {
                data += node.childNodes[i].nodeValue;
              }
            }
          } else if (tagName === 'false') {
            data = false;
          } else if (tagName === 'true') {
            data = true;
          } else if (tagName === 'real') {
            data = parseFloat(node.firstChild.nodeValue);
          } else if (tagName === 'integer') {
            data = parseInt(node.firstChild.nodeValue, 10);
          }
          return data;
        }
        _parseArray(node) {
          const data = [];
          for (let i = 0, len = node.childNodes.length; i < len; i++) {
            const child = node.childNodes[i];
            if (child.nodeType !== 1) {
              continue;
            }
            data.push(this._parseNode(child));
          }
          return data;
        }
        _parseDict(node) {
          const data = {};
          let key = '';
          for (let i = 0, len = node.childNodes.length; i < len; i++) {
            const child = node.childNodes[i];
            if (child.nodeType !== 1) {
              continue;
            }
            if (child.tagName === 'key') {
              key = child.firstChild.nodeValue;
            } else {
              data[key] = this._parseNode(child);
            }
          }
          return data;
        }
      }
      const plistParser = new PlistParser();

      class Parser {
        static get instance() {
          if (!this._instance) {
            this._instance = new Parser();
          }
          return this._instance;
        }
        constructor() {
          this._parsing = new Cache();
          this._parsers = {
            '.png': this.parseImage,
            '.jpg': this.parseImage,
            '.bmp': this.parseImage,
            '.jpeg': this.parseImage,
            '.gif': this.parseImage,
            '.ico': this.parseImage,
            '.tiff': this.parseImage,
            '.webp': this.parseImage,
            '.image': this.parseImage,
            '.pvr': this.parsePVRTex,
            '.pkm': this.parsePKMTex,
            '.astc': this.parseASTCTex,
            '.plist': this.parsePlist,
            import: this.parseImport,
            '.ccon': this.parseImport,
            '.cconb': this.parseImport
          };
        }
        parseImage(file, options, onComplete) {
          if (file instanceof HTMLImageElement) {
            onComplete(null, file);
            return;
          }
          createImageBitmap(file, {
            premultiplyAlpha: 'none'
          }).then(result => {
            onComplete(null, result);
          }, err => {
            onComplete(err, null);
          });
        }
        parsePVRTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 0);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parsePKMTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 1);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parseASTCTex(file, options, onComplete) {
          let err = null;
          let out = null;
          try {
            out = ImageAsset$1.parseCompressedTextures(file, 2);
          } catch (e) {
            err = e;
            console.warn(err);
          }
          onComplete(err, out);
        }
        parsePlist(file, options, onComplete) {
          let err = null;
          const result = plistParser.parse(file);
          if (!result) {
            err = new Error('parse failed');
          }
          onComplete(err, result);
        }
        parseImport(file, options, onComplete) {
          if (!file) {
            onComplete(new Error(`The json file of asset ${options.__uuid__} is empty or missing`));
            return;
          }
          let result = null;
          let err = null;
          try {
            result = deserializeAsset(file, options);
          } catch (e) {
            err = e;
          }
          onComplete(err, result);
        }
        init() {
          this._parsing.clear();
        }
        register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._parsers, type);
          } else {
            this._parsers[type] = handler;
          }
        }
        parse(id, file, type, options, onComplete) {
          const parsedAsset = parsed.get(id);
          if (parsedAsset) {
            onComplete(null, parsedAsset);
            return;
          }
          const parsing = this._parsing.get(id);
          if (parsing) {
            parsing.push(onComplete);
            return;
          }
          const parseHandler = this._parsers[type];
          if (!parseHandler) {
            onComplete(null, file);
            return;
          }
          this._parsing.add(id, [onComplete]);
          parseHandler(file, options, (err, data) => {
            if (err) {
              files.remove(id);
            } else if (!isScene(data)) {
              parsed.add(id, data);
            }
            const callbacks = this._parsing.remove(id);
            for (let i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, data);
            }
          });
        }
      }
      Parser._instance = void 0;
      var parser = Parser.instance;

      function load(task, done) {
        let firstTask = false;
        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }
        const {
          options,
          progress
        } = task;
        options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, (item, cb) => {
          const subTask = Task.create({
            input: item,
            onProgress: task.onProgress,
            options,
            progress,
            onComplete: (err, result) => {
              if (err && !task.isFinished) {
                if (!legacyCC.assetManager.force || firstTask) {
                  {
                    error(err.message, err.stack);
                  }
                  progress.canInvoke = false;
                  done(err);
                } else if (progress.canInvoke) {
                  task.dispatch('progress', ++progress.finish, progress.total, item);
                }
              }
              task.output.push(result);
              subTask.recycle();
              cb(null);
            }
          });
          loadOneAssetPipeline.async(subTask);
        }, () => {
          options.__exclude__ = null;
          if (task.isFinished) {
            clear(task, true);
            task.dispatch('error');
            return;
          }
          gatherAsset(task);
          clear(task, true);
          done();
        });
      }
      const loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
        const item = task.output = task.input;
        const {
          options,
          isNative,
          uuid,
          file
        } = item;
        const {
          reloadAsset
        } = options;
        if (file || !reloadAsset && !isNative && assets.has(uuid)) {
          done();
          return;
        }
        packManager.load(item, task.options, (err, data) => {
          item.file = data;
          done(err);
        });
      }, function parse(task, done) {
        const item = task.output = task.input;
        const progress = task.progress;
        const exclude = task.options.__exclude__;
        const {
          id,
          file,
          options
        } = item;
        if (item.isNative) {
          parser.parse(id, file, item.ext, options, (err, asset) => {
            if (err) {
              done(err);
              return;
            }
            item.content = asset;
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            files.remove(id);
            parsed.remove(id);
            done();
          });
        } else {
          const {
            uuid
          } = item;
          if (uuid in exclude) {
            const {
              finish,
              content,
              err,
              callbacks
            } = exclude[uuid];
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            if (finish || checkCircleReference(uuid, uuid, exclude)) {
              if (content) {
                content.addRef();
              }
              item.content = content;
              done(err);
            } else {
              callbacks.push({
                done,
                item
              });
            }
          } else if (!options.reloadAsset && assets.has(uuid)) {
            const asset = assets.get(uuid);
            item.content = asset.addRef();
            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }
            done();
          } else {
            options.__uuid__ = uuid;
            parser.parse(id, file, 'import', options, (err, asset) => {
              if (err) {
                done(err);
                return;
              }
              loadDepends(task, asset, done);
            });
          }
        }
      }]);
      function loadDepends(task, asset, done) {
        const {
          input: item,
          progress
        } = task;
        const {
          uuid,
          id,
          options,
          config
        } = item;
        const {
          cacheAsset
        } = options;
        const depends = [];
        if (asset.addRef) {
          asset.addRef();
        }
        getDepends(uuid, asset, Object.create(null), depends, config);
        if (progress.canInvoke) {
          task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
        }
        const repeatItem = task.options.__exclude__[uuid] = {
          content: asset,
          finish: false,
          callbacks: [{
            done,
            item
          }]
        };
        const subTask = Task.create({
          input: depends,
          options: task.options,
          onProgress: task.onProgress,
          onError: Task.prototype.recycle,
          progress,
          onComplete: err => {
            if (asset.decRef) {
              asset.decRef(false);
            }
            repeatItem.finish = true;
            repeatItem.err = err;
            if (!err) {
              const output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
              const map = Object.create(null);
              for (const dependAsset of output) {
                if (!dependAsset) {
                  continue;
                }
                map[dependAsset instanceof Asset ? `${dependAsset._uuid}@import` : `${uuid}@native`] = dependAsset;
              }
              setProperties(uuid, asset, map);
              try {
                if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                  asset.onLoaded();
                  onLoadedInvokedMap.add(asset);
                }
              } catch (e) {
                error(`The asset ${uuid} is invalid for some reason, detail message: ${e.message}, stack: ${e.stack}`);
              }
              files.remove(id);
              parsed.remove(id);
              cache(uuid, asset, cacheAsset);
              subTask.recycle();
            }
            const callbacks = repeatItem.callbacks;
            for (let i = 0, l = callbacks.length; i < l; i++) {
              const cb = callbacks[i];
              if (asset.addRef) {
                asset.addRef();
              }
              cb.item.content = asset;
              cb.done(err);
            }
            callbacks.length = 0;
          }
        });
        pipeline.async(subTask);
      }

      function preprocess(task, done) {
        const options = task.options;
        const subOptions = Object.create(null);
        const leftOptions = Object.create(null);
        for (const op in options) {
          switch (op) {
            case RequestType.PATH:
            case RequestType.UUID:
            case RequestType.DIR:
            case RequestType.SCENE:
            case RequestType.URL:
              break;
            case '__requestType__':
            case '__isNative__':
            case 'ext':
            case 'type':
            case '__nativeName__':
            case 'audioLoadMode':
            case 'bundle':
              subOptions[op] = options[op];
              break;
            case '__exclude__':
            case '__outputAsArray__':
              leftOptions[op] = options[op];
              break;
            default:
              subOptions[op] = options[op];
              leftOptions[op] = options[op];
              break;
          }
        }
        task.options = leftOptions;
        const subTask = Task.create({
          input: task.input,
          options: subOptions
        });
        let err = null;
        try {
          task.output = task.source = transformPipeline.sync(subTask);
        } catch (e) {
          err = e;
          for (let i = 0, l = subTask.output.length; i < l; i++) {
            subTask.output[i].recycle();
          }
        }
        subTask.recycle();
        done(err);
      }

      class RequestItem {
        constructor() {
          this.uuid = '';
          this.overrideUuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);
          this._id = '';
        }
        get id() {
          if (!this._id) {
            this._id = `${this.overrideUuid || this.uuid}@${this.isNative ? 'native' : 'import'}`;
          }
          return this._id;
        }
        static create() {
          let out;
          if (RequestItem._deadPool.length !== 0) {
            out = RequestItem._deadPool.pop();
          } else {
            out = new RequestItem();
          }
          return out;
        }
        recycle() {
          if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
            return;
          }
          this._id = '';
          this.uuid = '';
          this.overrideUuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);
          RequestItem._deadPool.push(this);
        }
      }
      RequestItem.MAX_DEAD_NUM = 500;
      RequestItem._deadPool = [];

      const infos = [];
      function parse(task) {
        var _info2;
        const options = task.options;
        const input = Array.isArray(task.input) ? task.input : [task.input];
        task.output = [];
        for (let i = 0; i < input.length; i++) {
          let item = input[i];
          let out = RequestItem.create();
          let config = null;
          let info = null;
          if (typeof item === 'string') {
            item = Object.create(null);
            item[options.__requestType__ || RequestType.UUID] = input[i];
          }
          if (typeof item === 'object') {
            addon(item, options);
            if (item.preset) {
              addon(item, presets[item.preset]);
            }
            for (const key in item) {
              switch (key) {
                case RequestType.UUID:
                  {
                    var _info;
                    const uuid = out.uuid = decodeUuid(item.uuid);
                    if (!item.bundle) {
                      const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
                      item.bundle = bundle && bundle.name;
                    }
                    if (bundles.has(item.bundle)) {
                      config = bundles.get(item.bundle).config;
                      info = config.getAssetInfo(uuid);
                      if (info && info.redirect) {
                        if (!bundles.has(info.redirect)) {
                          throw new Error(`Please load bundle ${info.redirect} first`);
                        }
                        config = bundles.get(info.redirect).config;
                        info = config.getAssetInfo(uuid);
                      }
                      out.config = config;
                      out.info = info;
                    }
                    out.ext = item.ext || ((_info = info) === null || _info === void 0 ? void 0 : _info.extension) || '.json';
                    break;
                  }
                case '__requestType__':
                case 'ext':
                case 'bundle':
                case 'preset':
                case 'type':
                  break;
                case RequestType.DIR:
                  if (bundles.has(item.bundle)) {
                    bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);
                    for (const assetInfo of infos) {
                      input.push({
                        uuid: assetInfo.uuid,
                        __isNative__: false,
                        ext: assetInfo.extension || '.json',
                        bundle: item.bundle
                      });
                    }
                    infos.length = 0;
                  }
                  out.recycle();
                  out = null;
                  break;
                case RequestType.PATH:
                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getInfoWithPath(item.path, item.type);
                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error(`you need to load bundle ${info.redirect} first`);
                      }
                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }
                    if (!info) {
                      out.recycle();
                      throw new Error(`Bundle ${item.bundle} doesn't contain ${item.path}`);
                    }
                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }
                  out.ext = item.ext || ((_info2 = info) === null || _info2 === void 0 ? void 0 : _info2.extension) || '.json';
                  break;
                case RequestType.SCENE:
                  if (!item.bundle) {
                    const bundle = bundles.find(bundle => !!bundle.getSceneInfo(item.scene));
                    item.bundle = bundle && bundle.name;
                  }
                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getSceneInfo(item.scene);
                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error(`you need to load bundle ${info.redirect} first`);
                      }
                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }
                    if (!info) {
                      out.recycle();
                      throw new Error(`Bundle ${config.name} doesn't contain scene ${item.scene}`);
                    }
                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }
                  break;
                case '__isNative__':
                  out.isNative = item.__isNative__;
                  break;
                case RequestType.URL:
                  out.url = item.url;
                  out.uuid = item.uuid || item.url;
                  out.ext = item.ext || extname(item.url);
                  out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                  break;
                default:
                  out.options[key] = item[key];
              }
              if (!out) {
                break;
              }
            }
          }
          if (!out) {
            continue;
          }
          task.output.push(out);
          if (!out.uuid && !out.url) {
            throw new Error(`Can not parse this input:${JSON.stringify(item)}`);
          }
        }
        return null;
      }
      function replaceOverrideAsset(task) {
        const input = task.output = task.input;
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          if (assetsOverrideMap.has(item.uuid)) {
            const uuid = assetsOverrideMap.get(item.uuid);
            const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
            if (bundle) {
              var _info3;
              item.overrideUuid = uuid;
              let config = bundle.config;
              let info = config.getAssetInfo(uuid);
              if (info && info.redirect) {
                if (!bundles.has(info.redirect)) {
                  throw new Error(`Please load bundle ${info.redirect} first`);
                }
                config = bundles.get(info.redirect).config;
                info = config.getAssetInfo(uuid);
              }
              item.config = config;
              item.info = info;
              item.ext = item.isNative ? item.ext : ((_info3 = info) === null || _info3 === void 0 ? void 0 : _info3.extension) || '.json';
            } else {
              warnID(16201, uuid, item.uuid);
            }
          }
        }
      }
      function combine(task) {
        const input = task.output = task.input;
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          if (item.url) {
            continue;
          }
          let url = '';
          let base = '';
          const config = item.config;
          if (item.isNative) {
            base = config && config.nativeBase ? config.base + config.nativeBase : legacyCC.assetManager.generalNativeBase;
          } else {
            base = config && config.importBase ? config.base + config.importBase : legacyCC.assetManager.generalImportBase;
          }
          const uuid = item.overrideUuid || item.uuid;
          let ver = '';
          if (item.info) {
            if (item.isNative) {
              ver = item.info.nativeVer ? `.${item.info.nativeVer}` : '';
            } else {
              ver = item.info.ver ? `.${item.info.ver}` : '';
            }
          }
          if (item.ext === '.ttf') {
            url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}/${item.options.__nativeName__}`;
          } else {
            url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}${item.ext}`;
          }
          item.url = url;
        }
        return null;
      }

      const EVENT_ASSET_MISSING = 'asset-missing';
      class AssetManager {
        static get instance() {
          if (!this._instance) {
            this._instance = new AssetManager();
          }
          return this._instance;
        }
        constructor() {
          this.pipeline = pipeline.append(preprocess).append(load);
          this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch);
          this.transformPipeline = transformPipeline.append(parse).append(replaceOverrideAsset).append(combine);
          this.bundles = bundles;
          this.assets = assets;
          this.assetsOverrideMap = assetsOverrideMap;
          this.generalImportBase = '';
          this.generalNativeBase = '';
          this.dependUtil = dependUtil;
          this.force = PREVIEW;
          this.allowImageBitmap = false;
          this.utils = helper;
          this.downloader = downloader$1;
          this.parser = parser;
          this.packManager = packManager;
          this.cacheAsset = true;
          this.cacheManager = null;
          this.presets = presets;
          this.factory = factory;
          this.preprocessPipe = preprocess;
          this.fetchPipe = fetch;
          this.loadPipe = load;
          this.references = references;
          this._releaseManager = releaseManager;
          this._files = files;
          this._parsed = parsed;
          this._parsePipeline = null ;
          this._projectBundles = [];
          this._eventTarget = new EventTarget();
        }
        get main() {
          return bundles.get(BuiltinBundleName.MAIN) || null;
        }
        get resources() {
          return bundles.get(BuiltinBundleName.RESOURCES) || null;
        }
        onAssetMissing(func, target) {
          this._eventTarget.on(EVENT_ASSET_MISSING, func, target);
        }
        offAssetMissing(func, target) {
          this._eventTarget.off(EVENT_ASSET_MISSING, func, target);
        }
        dispatchAssetMissing(parentAsset, owner, propName, uuid) {
          this._eventTarget.emit(EVENT_ASSET_MISSING, parentAsset, owner, propName, uuid);
        }
        init(options = {}) {
          const server = options.server || settings.querySettings(Settings.Category.ASSETS, 'server') || '';
          const bundleVers = options.bundleVers || settings.querySettings(Settings.Category.ASSETS, 'bundleVers') || {};
          const remoteBundles = options.remoteBundles || settings.querySettings(Settings.Category.ASSETS, 'remoteBundles') || [];
          const downloadMaxConcurrency = options.downloadMaxConcurrency || settings.querySettings(Settings.Category.ASSETS, 'downloadMaxConcurrency');
          if (downloadMaxConcurrency && downloadMaxConcurrency > 0) {
            this.downloader.maxConcurrency = downloadMaxConcurrency;
          }
          this._files.clear();
          this._parsed.clear();
          this._releaseManager.init();
          this.assets.clear();
          this.bundles.clear();
          this.packManager.init();
          this.downloader.init(server, bundleVers, remoteBundles);
          this.parser.init();
          this.dependUtil.init();
          let importBase = options.importBase || settings.querySettings(Settings.Category.ASSETS, 'importBase') || '';
          if (importBase && importBase.endsWith('/')) {
            importBase = importBase.substr(0, importBase.length - 1);
          }
          let nativeBase = options.nativeBase || settings.querySettings(Settings.Category.ASSETS, 'nativeBase') || '';
          if (nativeBase && nativeBase.endsWith('/')) {
            nativeBase = nativeBase.substr(0, nativeBase.length - 1);
          }
          this.generalImportBase = importBase;
          this.generalNativeBase = nativeBase;
          this._projectBundles = settings.querySettings(Settings.Category.ASSETS, 'projectBundles') || [];
          const assetsOverride = settings.querySettings(Settings.Category.ASSETS, 'assetsOverrides') || {};
          for (const key in assetsOverride) {
            this.assetsOverrideMap.set(key, assetsOverride[key]);
          }
        }
        getBundle(name) {
          return bundles.get(name) || null;
        }
        removeBundle(bundle) {
          bundle._destroy();
          bundles.remove(bundle.name);
        }
        loadAny(requests, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'default';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          const task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          pipeline.async(task);
        }
        preloadAny(requests, options, onProgress, onComplete) {
          const {
            options: opts,
            onProgress: onProg,
            onComplete: onComp
          } = parseParameters(options, onProgress, onComplete);
          opts.preset = opts.preset || 'preload';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          const task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          fetchPipeline.async(task);
        }
        loadRemote(url, options, onComplete) {
          const {
            options: opts,
            onComplete: onComp
          } = parseParameters(options, undefined, onComplete);
          if (!opts.reloadAsset && this.assets.has(url)) {
            asyncify(onComp)(null, this.assets.get(url));
            return;
          }
          opts.__isNative__ = true;
          opts.preset = opts.preset || 'remote';
          this.loadAny({
            url
          }, opts, null, (err, data) => {
            if (err) {
              error(err.message, err.stack);
              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(url, data, opts.ext || extname(url), opts, (p1, p2) => {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        }
        loadBundle(nameOrUrl, options, onComplete) {
          const {
            options: opts,
            onComplete: onComp
          } = parseParameters(options, undefined, onComplete);
          const bundleName = basename(nameOrUrl);
          if (this.bundles.has(bundleName)) {
            asyncify(onComp)(null, this.getBundle(bundleName));
            return;
          }
          opts.preset = opts.preset || 'bundle';
          opts.ext = 'bundle';
          opts.__isNative__ = true;
          this.loadAny({
            url: nameOrUrl
          }, opts, null, (err, data) => {
            if (err) {
              error(err.message, err.stack);
              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(nameOrUrl, data, 'bundle', opts, (p1, p2) => {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        }
        releaseAsset(asset) {
          releaseManager.tryRelease(asset, true);
        }
        releaseUnusedAssets() {
          assets.forEach(asset => {
            releaseManager.tryRelease(asset);
          });
        }
        releaseAll() {
          assets.forEach(asset => {
            releaseManager.tryRelease(asset, true);
          });
        }
        loadWithJson(json, options, onProgress, onComplete) {
          {
            throw new Error('Only valid in Editor');
          }
        }
      } exports('AssetManager', AssetManager);
      AssetManager._instance = void 0;
      AssetManager.Pipeline = Pipeline;
      AssetManager.Task = Task;
      AssetManager.Cache = Cache;
      AssetManager.RequestItem = RequestItem;
      AssetManager.Bundle = Bundle;
      AssetManager.BuiltinBundleName = BuiltinBundleName;
      AssetManager.CacheManager = CacheManager;
      AssetManager.Downloader = Downloader;
      AssetManager.Parser = Parser;
      AssetManager.DependUtil = DependUtil;
      const assetManager = exports('assetManager', legacyCC.assetManager = AssetManager.instance);
      legacyCC.AssetManager = AssetManager;

      const ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
      const AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];
      function GetTrue() {
        return true;
      }
      const md5Pipe = {
        transformURL(url) {
          const uuid = getUuidFromURL(url);
          if (!uuid) {
            return url;
          }
          const bundle = bundles.find(b => !!b.getAssetInfo(uuid));
          if (!bundle) {
            return url;
          }
          let hashValue = '';
          const info = bundle.getAssetInfo(uuid);
          if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
            hashValue = info.nativeVer || '';
          } else {
            hashValue = info.ver || '';
          }
          if (!hashValue || url.indexOf(hashValue) !== -1) {
            return url;
          }
          let hashPatchInFolder = false;
          if (extname(url) === '.ttf') {
            hashPatchInFolder = true;
          }
          if (hashPatchInFolder) {
            const dirname$1 = dirname(url);
            const basename$1 = basename(url);
            url = `${dirname$1}.${hashValue}/${basename$1}`;
          } else {
            url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, (match, uuid) => `${match}.${hashValue}`);
          }
          return url;
        }
      };
      class CCLoader {
        constructor() {
          this._autoReleaseSetting = Object.create(null);
          this._parseLoadResArgs = parseLoadResArgs;
        }
        set onProgress(val) {
          setDefaultProgressCallback(val);
        }
        get _cache() {
          if (assets instanceof Cache) {
            return assets.map;
          } else {
            const map = {};
            assets.forEach((val, key) => {
              map[key] = val;
            });
            return map;
          }
        }
        load(res, progressCallback, completeCallback) {
          if (completeCallback === undefined) {
            if (progressCallback !== undefined) {
              completeCallback = progressCallback;
              progressCallback = null;
            }
          }
          const requests = Array.isArray(res) ? res : [res];
          for (let i = 0; i < requests.length; i++) {
            const item = requests[i];
            if (typeof item === 'string') {
              requests[i] = {
                url: item,
                __isNative__: true
              };
            } else {
              if (item.type) {
                item.ext = `.${item.type}`;
                item.type = undefined;
              }
              if (item.url) {
                item.__isNative__ = true;
              }
            }
          }
          const images = [];
          const audios = [];
          assetManager.loadAny(requests, null, (finish, total, item) => {
            if (item.content) {
              if (ImageFmts.includes(item.ext)) {
                images.push(item.content);
              } else if (AudioFmts.includes(item.ext)) {
                audios.push(item.content);
              }
            }
            if (progressCallback) {
              progressCallback(finish, total, item);
            }
          }, (err, native) => {
            let out = null;
            if (!err) {
              native = Array.isArray(native) ? native : [native];
              for (let i = 0; i < native.length; i++) {
                const item = native[i];
                if (!(item instanceof Asset)) {
                  let asset = item;
                  const url = requests[i].url;
                  if (images.includes(asset)) {
                    factory.create(url, item, '.png', {}, (err, image) => {
                      asset = native[i] = image;
                    });
                  } else if (audios.includes(asset)) {
                    factory.create(url, item, '.mp3', {}, (err, audio) => {
                      asset = native[i] = audio;
                    });
                  }
                  assets.add(url, asset);
                }
              }
              if (native.length > 1) {
                const map = Object.create(null);
                native.forEach(asset => {
                  map[asset._uuid] = asset;
                });
                out = {
                  isCompleted: GetTrue,
                  _map: map
                };
              } else {
                out = native[0];
              }
            }
            if (completeCallback) {
              completeCallback(err, out);
            }
          });
        }
        getXMLHttpRequest() {
          return new XMLHttpRequest();
        }
        getItem(id) {
          return assetManager.assets.has(id) ? {
            content: assetManager.assets.get(id)
          } : null;
        }
        loadRes(url, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          const extname$1 = extname(url);
          if (extname$1 && !resources.getInfoWithPath(url, _type)) {
            url = url.slice(0, -extname$1.length);
          }
          resources.load(url, _type, onProgress, onComplete);
        }
        loadResArray(urls, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          urls.forEach((url, i) => {
            const extname$1 = extname(url);
            if (extname$1 && !resources.getInfoWithPath(url, _type)) {
              urls[i] = url.slice(0, -extname$1.length);
            }
          });
          resources.load(urls, _type, onProgress, onComplete);
        }
        loadResDir(url, type, progressCallback, completeCallback) {
          const {
            type: _type,
            onProgress,
            onComplete
          } = this._parseLoadResArgs(type, progressCallback, completeCallback);
          resources.loadDir(url, _type, onProgress, (err, out) => {
            let urls = [];
            if (!err) {
              const infos = resources.getDirWithPath(url, _type);
              urls = infos.map(info => info.path);
            }
            if (onComplete) {
              onComplete(err, out, urls);
            }
          });
        }
        getRes(url, type) {
          return assets.has(url) ? assets.get(url) : resources.get(url, type);
        }
        getResCount() {
          return assets.count;
        }
        getDependsRecursively(owner) {
          if (!owner) {
            return [];
          }
          const uuid = typeof owner === 'string' ? owner : owner._uuid;
          return dependUtil.getDepsRecursively(uuid).concat([uuid]);
        }
        get md5Pipe() {
          return md5Pipe;
        }
        get downloader() {
          return downloader$1;
        }
        get loader() {
          return assetManager.parser;
        }
        addDownloadHandlers(extMap) {
          const handler = Object.create(null);
          for (const type in extMap) {
            const func = extMap[type];
            handler[`.${type}`] = (url, options, onComplete) => {
              func({
                url
              }, onComplete);
            };
          }
          downloader$1.register(handler);
        }
        addLoadHandlers(extMap) {
          const handler = Object.create(null);
          for (const type in extMap) {
            const func = extMap[type];
            handler[`.${type}`] = (file, options, onComplete) => {
              func({
                content: file
              }, onComplete);
            };
          }
          parser.register(handler);
        }
        release(asset) {
          if (Array.isArray(asset)) {
            for (let i = 0; i < asset.length; i++) {
              let key = asset[i];
              if (typeof key === 'string') {
                key = assets.get(key);
              }
              assetManager.releaseAsset(key);
            }
          } else if (asset) {
            if (typeof asset === 'string') {
              asset = assets.get(asset);
            }
            assetManager.releaseAsset(asset);
          }
        }
        releaseAsset(asset) {
          assetManager.releaseAsset(asset);
        }
        releaseRes(res, type) {
          resources.release(res, type);
        }
        releaseAll() {
          assetManager.releaseAll();
          assets.clear();
        }
        removeItem(id) {
          return !!assets.remove(id);
        }
        setAutoRelease(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          this._autoReleaseSetting[asset] = !!autoRelease;
        }
        setAutoReleaseRecursively(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          autoRelease = !!autoRelease;
          this._autoReleaseSetting[asset] = autoRelease;
          const depends = dependUtil.getDepsRecursively(asset);
          for (let i = 0; i < depends.length; i++) {
            this._autoReleaseSetting[depends[i]] = autoRelease;
          }
        }
        isAutoRelease(asset) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }
          return !!this._autoReleaseSetting[asset];
        }
      } exports('CCLoader', CCLoader);
      const loader = exports('loader', new CCLoader());
      const AssetLibrary = exports('AssetLibrary', {
        init(options) {
          options.importBase = options.libraryPath;
          options.nativeBase = options.rawAssetsBase ;
          assetManager.init(options);
          if (options.rawAssets) {
            resources.init({
              base: '',
              deps: [],
              scenes: {},
              redirect: [],
              debug: true,
              packs: {},
              types: [],
              versions: {
                import: [],
                native: []
              },
              name: BuiltinBundleName.RESOURCES,
              importBase: options.importBase,
              nativeBase: options.nativeBase,
              paths: options.rawAssets.assets,
              uuids: Object.keys(options.rawAssets.assets),
              extensionMap: {}
            });
          }
        },
        loadAsset(uuid, callback, options) {
          assetManager.loadAny(uuid, callback);
        }
      });
      const url = exports('url', {});
      replaceProperty(url, 'url', [{
        name: 'normalize',
        target: assetManager.utils,
        targetName: 'assetManager.utils',
        newName: 'normalize'
      }, {
        name: 'raw',
        targetName: 'Asset.prototype',
        newName: 'nativeUrl',
        customFunction: url => {
          if (url.startsWith('resources/')) {
            return transform({
              path: changeExtname(url.substr(10)),
              bundle: BuiltinBundleName.RESOURCES,
              __isNative__: true,
              ext: extname(url)
            });
          }
          return '';
        }
      }]);
      removeProperty(AssetLibrary, 'AssetLibrary', [{
        name: 'getLibUrlNoExt',
        suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead'
      }, {
        name: 'queryAssetInfo',
        suggest: 'AssetLibrary.queryAssetInfo was removed'
      }]);
      removeProperty(loader, 'loader', [{
        name: 'releaseResDir',
        suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
      }, {
        name: 'flowInDeps',
        suggest: 'loader.flowInDeps was removed'
      }, {
        name: 'assetLoader',
        suggest: 'loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline'
      }]);
      replaceProperty(legacyCC, 'cc', [{
        name: 'loader',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: () => loader
      }, {
        name: 'AssetLibrary',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: () => AssetLibrary
      }, {
        name: 'Pipeline',
        target: AssetManager,
        targetName: 'AssetManager',
        newName: 'Pipeline',
        logTimes: 1
      }, {
        name: 'url',
        targetName: 'assetManager',
        newName: 'utils',
        logTimes: 1,
        customGetter: () => url
      }]);
      removeProperty(legacyCC, 'cc', [{
        name: 'LoadingItems',
        suggest: getError(1400, 'LoadingItems', 'AssetManager.Task')
      }]);
      replaceProperty(macro, 'macro', [{
        name: 'DOWNLOAD_MAX_CONCURRENT',
        target: downloader$1,
        targetName: 'assetManager.downloader',
        newName: 'maxConcurrency'
      }]);
      const _autoRelease = releaseManager._autoRelease;
      releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
        _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);
        const releaseSettings = loader._autoReleaseSetting;
        const keys = Object.keys(releaseSettings);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (releaseSettings[key] === true) {
            const asset = assets.get(key);
            if (asset) {
              releaseManager.tryRelease(asset);
            }
          }
        }
      };

      const Texture2D = jsb.Texture2D;
      const ImageAsset = jsb.ImageAsset;
      const BuiltinResMgr = jsb.BuiltinResMgr;
      const builtinResMgrProto = BuiltinResMgr.prototype;
      builtinResMgrProto.init = function () {
        this._resources = {};
        this._materialsToBeCompiled = [];
        const resources = this._resources;
        const len = 2;
        const numChannels = 4;
        const blackValueView = new Uint8Array(len * len * numChannels);
        for (let i = 0; i < len * len; i++) {
          const offset = i * numChannels;
          blackValueView[offset] = 0;
          blackValueView[offset + 1] = 0;
          blackValueView[offset + 2] = 0;
          blackValueView[offset + 3] = 255;
        }
        const blackMemImageSource = {
          width: len,
          height: len,
          _data: blackValueView,
          _compressed: false,
          format: Texture2D.PixelFormat.RGBA8888
        };
        const imgAsset = new ImageAsset(blackMemImageSource);
        const blackTexture = new Texture2D();
        blackTexture._uuid = 'black-texture';
        blackTexture.image = imgAsset;
        resources[blackTexture._uuid] = blackTexture;
        if (legacyCC.SpriteFrame) {
          const spriteFrame = new legacyCC.SpriteFrame();
          const image = imgAsset;
          const texture = new Texture2D();
          texture.image = image;
          spriteFrame.texture = texture;
          spriteFrame._uuid = 'default-spriteframe';
          resources[spriteFrame._uuid] = spriteFrame;
        }
        this.initBuiltinRes();
      };
      builtinResMgrProto.get = function (uuid) {
        const res = this._resources[uuid];
        return res || this.getAsset(uuid);
      };
      builtinResMgrProto.compileBuiltinMaterial = function () {
        for (let i = 0; i < this._materialsToBeCompiled.length; ++i) {
          const mat = this._materialsToBeCompiled[i];
          for (let j = 0; j < mat.passes.length; ++j) {
            mat.passes[j].tryCompile();
          }
        }
        this._materialsToBeCompiled.length = 0;
      };
      builtinResMgrProto.loadBuiltinAssets = function () {
        const builtinAssets = settings.querySettings(Settings.Category.ENGINE, 'builtinAssets');
        if (!builtinAssets) return Promise.resolve();
        const resources = this._resources;
        return new Promise((resolve, reject) => {
          assetManager.loadBundle(BuiltinBundleName.INTERNAL, (err, bundle) => {
            if (err) {
              reject(err);
              return;
            }
            assetManager.loadAny(builtinAssets, (err, assets) => {
              if (err) {
                reject(err);
              } else {
                assets.forEach(asset => {
                  resources[asset.name] = asset;
                  asset.nativeUrl;
                  releaseManager.addIgnoredAsset(asset);
                  this.addAsset(asset.name, asset);
                  if (asset instanceof legacyCC.Material) {
                    this._materialsToBeCompiled.push(asset);
                  }
                });
                resolve();
              }
            });
          });
        });
      };
      const builtinResMgr = exports('builtinResMgr', legacyCC.builtinResMgr = BuiltinResMgr.getInstance());

      class Director extends EventTarget {
        constructor() {
          super();
          this._compScheduler = void 0;
          this._nodeActivator = void 0;
          this._invalid = void 0;
          this._paused = void 0;
          this._root = void 0;
          this._loadingScene = void 0;
          this._scene = void 0;
          this._totalFrames = void 0;
          this._scheduler = void 0;
          this._systems = void 0;
          this._persistRootNodes = {};
          this._invalid = false;
          this._paused = false;
          this._root = null;
          this._loadingScene = '';
          this._scene = null;
          this._totalFrames = 0;
          this._scheduler = new Scheduler();
          this._compScheduler = new ComponentScheduler();
          this._nodeActivator = new NodeActivator();
          this._systems = [];
        }
        calculateDeltaTime(now) {}
        end() {
          this.once(Director.EVENT_END_FRAME, () => {
            this.purgeDirector();
          });
        }
        pause() {
          if (this._paused) {
            return;
          }
          this._paused = true;
        }
        purgeDirector() {
          this._scheduler.unscheduleAll();
          this._compScheduler.unscheduleAll();
          this._nodeActivator.reset();
          {
            if (isValid(this._scene)) {
              this._scene.destroy();
            }
            this._scene = null;
          }
          this.stopAnimation();
          assetManager.releaseAll();
        }
        reset() {
          var _this$getScene;
          this.purgeDirector();
          for (const id in this._persistRootNodes) {
            this.removePersistRootNode(this._persistRootNodes[id]);
          }
          (_this$getScene = this.getScene()) === null || _this$getScene === void 0 ? void 0 : _this$getScene.destroy();
          this.emit(Director.EVENT_RESET);
          this.startAnimation();
        }
        runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(scene instanceof Scene, 1216);
          {
            console.time('InitScene');
          }
          scene._load();
          {
            console.timeEnd('InitScene');
          }
          {
            console.time('AttachPersist');
          }
          const persistNodeList = Object.keys(this._persistRootNodes).map(x => this._persistRootNodes[x]);
          for (let i = 0; i < persistNodeList.length; i++) {
            const node = persistNodeList[i];
            node.emit(Node$1.EventType.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
            const existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);
            if (existNode) {
              const index = existNode.getSiblingIndex();
              node.hideFlags &= ~CCObject.Flags.DontSave;
              node.hideFlags |= CCObject.Flags.DontSave & existNode.hideFlags;
              existNode._destroyImmediate();
              scene.insertChild(node, index);
            } else {
              node.hideFlags |= CCObject.Flags.DontSave;
              node.parent = scene;
            }
          }
          {
            console.timeEnd('AttachPersist');
          }
          const oldScene = this._scene;
          {
            console.time('Destroy');
          }
          if (isValid(oldScene)) {
            oldScene.destroy();
          }
          {
            {
              console.time('AutoRelease');
            }
            releaseManager._autoRelease(oldScene, scene, this._persistRootNodes);
            {
              console.timeEnd('AutoRelease');
            }
          }
          this._scene = null;
          CCObject._deferredDestroy();
          {
            console.timeEnd('Destroy');
          }
          if (onBeforeLoadScene) {
            onBeforeLoadScene();
          }
          this.emit(Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
          this._scene = scene;
          {
            console.time('Activate');
          }
          scene._activate();
          {
            console.timeEnd('Activate');
          }
          if (this._root) {
            this._root.resetCumulativeTime();
          }
          this.startAnimation();
          if (onLaunched) {
            onLaunched(null, scene);
          }
          this.emit(Director.EVENT_AFTER_SCENE_LAUNCH, scene);
        }
        runScene(scene, onBeforeLoadScene, onLaunched) {
          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(Boolean(scene), 1205);
          assertID(scene instanceof Scene, 1216);
          this.once(Director.EVENT_END_FRAME, () => {
            this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
          });
        }
        loadScene(sceneName, onLaunched, onUnloaded) {
          if (this._loadingScene) {
            warnID(1208, sceneName, this._loadingScene);
            return false;
          }
          const bundle = assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));
          if (bundle) {
            this.emit(Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            this._loadingScene = sceneName;
            console.time(`LoadScene ${sceneName}`);
            bundle.loadScene(sceneName, (err, scene) => {
              console.timeEnd(`LoadScene ${sceneName}`);
              this._loadingScene = '';
              if (err) {
                error(err);
                if (onLaunched) {
                  onLaunched(err);
                }
              } else {
                this.runSceneImmediate(scene, onUnloaded, onLaunched);
              }
            });
            return true;
          } else {
            errorID(1209, sceneName);
            return false;
          }
        }
        preloadScene(sceneName, onProgress, onLoaded) {
          const bundle = assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));
          if (bundle) {
            bundle.preloadScene(sceneName, null, onProgress, onLoaded);
          } else {
            const err = `Can not preload the scene "${sceneName}" because it is not in the build settings.`;
            if (onLoaded) {
              onLoaded(new Error(err));
            }
            error(`preloadScene: ${err}`);
          }
        }
        resume() {
          if (!this._paused) {
            return;
          }
          this._paused = false;
        }
        get root() {
          return this._root;
        }
        getScene() {
          return this._scene;
        }
        getDeltaTime() {
          return legacyCC.game.deltaTime;
        }
        getTotalTime() {
          return legacyCC.game.totalTime;
        }
        getCurrentTime() {
          return legacyCC.game.frameStartTime;
        }
        getTotalFrames() {
          return this._totalFrames;
        }
        isPaused() {
          return this._paused;
        }
        getScheduler() {
          return this._scheduler;
        }
        setScheduler(scheduler) {
          if (this._scheduler !== scheduler) {
            this.unregisterSystem(this._scheduler);
            this._scheduler = scheduler;
            this.registerSystem(Scheduler.ID, scheduler, 200);
          }
        }
        registerSystem(name, sys, priority) {
          sys.id = name;
          sys.priority = priority;
          this._systems.push(sys);
          this._systems.sort(System.sortByPriority);
        }
        unregisterSystem(sys) {
          fastRemove(this._systems, sys);
          this._systems.sort(System.sortByPriority);
        }
        getSystem(name) {
          return this._systems.find(sys => sys.id === name);
        }
        getAnimationManager() {
          return this.getSystem(legacyCC.AnimationManager.ID);
        }
        startAnimation() {
          this._invalid = false;
        }
        stopAnimation() {
          this._invalid = true;
        }
        mainLoop(now) {
          let dt;
          {
            dt = legacyCC.game._calculateDT(now);
          }
          this.tick(dt);
        }
        tick(dt) {
          if (!this._invalid) {
            this.emit(Director.EVENT_BEGIN_FRAME);
            {
              input._frameDispatchEvents();
            }
            if (!this._paused) {
              this.emit(Director.EVENT_BEFORE_UPDATE);
              this._compScheduler.startPhase();
              this._compScheduler.updatePhase(dt);
              for (let i = 0; i < this._systems.length; ++i) {
                this._systems[i].update(dt);
              }
              this._compScheduler.lateUpdatePhase(dt);
              this.emit(Director.EVENT_AFTER_UPDATE);
              CCObject._deferredDestroy();
              for (let i = 0; i < this._systems.length; ++i) {
                this._systems[i].postUpdate(dt);
              }
            }
            this.emit(Director.EVENT_BEFORE_DRAW);
            uiRendererManager.updateAllDirtyRenderers();
            this._root.frameMove(dt);
            this.emit(Director.EVENT_AFTER_DRAW);
            Node$1.resetHasChangedFlags();
            Node$1.clearNodeArray();
            scalableContainerManager.update(dt);
            this.emit(Director.EVENT_END_FRAME);
            this._totalFrames++;
          }
        }
        buildRenderPipeline() {
          if (this._root) {
            this._root.customPipeline.beginSetup();
            const builder = legacyCC.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
            builder.setup(this._root.cameraList, this._root.customPipeline);
            this._root.customPipeline.endSetup();
          }
        }
        setupRenderPipelineBuilder() {
          if (macro.CUSTOM_PIPELINE_NAME !== '' && legacyCC.rendering && this._root && this._root.usesCustomPipeline) {
            this.on(Director.EVENT_BEFORE_RENDER, this.buildRenderPipeline, this);
          }
        }
        init() {
          this._totalFrames = 0;
          this._paused = false;
          this.registerSystem(Scheduler.ID, this._scheduler, 200);
          this._root = new Root(deviceManager.gfxDevice);
          const rootInfo = {};
          this._root.initialize(rootInfo);
          this.setupRenderPipelineBuilder();
          for (let i = 0; i < this._systems.length; i++) {
            this._systems[i].init();
          }
          this.emit(Director.EVENT_INIT);
        }
        addPersistRootNode(node) {
          if (!Node$1.isNode(node) || !node.uuid) {
            warnID(3800);
            return;
          }
          const id = node.uuid;
          if (!this._persistRootNodes[id]) {
            const scene = this._scene;
            if (isValid(scene)) {
              if (!node.parent) {
                node.parent = scene;
                node._originalSceneId = scene.uuid;
              } else if (!(node.parent instanceof Scene)) {
                warnID(3801);
                return;
              } else if (node.parent !== scene) {
                warnID(3802);
                return;
              } else {
                node._originalSceneId = scene.uuid;
              }
            }
            this._persistRootNodes[id] = node;
            node._persistNode = true;
            releaseManager._addPersistNodeRef(node);
          }
        }
        removePersistRootNode(node) {
          const id = node.uuid || '';
          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
            node._originalSceneId = '';
            releaseManager._removePersistNodeRef(node);
          }
        }
        isPersistRootNode(node) {
          return !!node._persistNode;
        }
      } exports('Director', Director);
      Director.EVENT_INIT = 'director_init';
      Director.EVENT_RESET = 'director_reset';
      Director.EVENT_BEFORE_SCENE_LOADING = 'director_before_scene_loading';
      Director.EVENT_BEFORE_SCENE_LAUNCH = 'director_before_scene_launch';
      Director.EVENT_AFTER_SCENE_LAUNCH = 'director_after_scene_launch';
      Director.EVENT_BEFORE_UPDATE = 'director_before_update';
      Director.EVENT_AFTER_UPDATE = 'director_after_update';
      Director.EVENT_BEFORE_DRAW = 'director_before_draw';
      Director.EVENT_AFTER_DRAW = 'director_after_draw';
      Director.EVENT_BEFORE_COMMIT = 'director_before_commit';
      Director.EVENT_BEFORE_RENDER = 'director_before_render';
      Director.EVENT_AFTER_RENDER = 'director_after_render';
      Director.EVENT_BEFORE_PHYSICS = 'director_before_physics';
      Director.EVENT_AFTER_PHYSICS = 'director_after_physics';
      Director.EVENT_BEGIN_FRAME = 'director_begin_frame';
      Director.EVENT_END_FRAME = 'director_end_frame';
      Director.instance = void 0;
      legacyCC.Director = Director;
      const director = exports('director', Director.instance = legacyCC.director = new Director());

      const ccwindow = typeof globalThis.jsb !== 'undefined' ? typeof jsb.window !== 'undefined' ? jsb.window : window : window;
      const ccdocument$2 = ccwindow.document;
      function findCanvas() {
        const container = ccdocument$2.createElement('div');
        const frame = ccdocument$2.documentElement;
        const canvas = ccwindow.__canvas;
        return {
          frame,
          canvas,
          container
        };
      }
      function loadJsFile(path) {
        if (window.oh && window.scriptEngineType === 'napi') {
          window.oh.loadModule(path);
          return Promise.resolve();
        } else {
          return require(`${path}`);
        }
      }

      class Pacer {
        constructor() {
          this._rafHandle = 0;
          this._onTick = null;
          this._targetFrameRate = 60;
          this._isPlaying = false;
          this._updateCallback = void 0;
          this._updateCallback = () => {
            if (this._isPlaying) {
              this._rafHandle = requestAnimationFrame(this._updateCallback);
            }
            if (this._onTick) {
              this._onTick();
            }
          };
        }
        get targetFrameRate() {
          return this._targetFrameRate;
        }
        set targetFrameRate(val) {
          if (this._targetFrameRate !== val) {
            assertIsTrue(val > 0);
            this._targetFrameRate = val;
            jsb.setPreferredFramesPerSecond(this._targetFrameRate);
            if (this._isPlaying) {
              this.stop();
              this.start();
            }
          }
        }
        set onTick(val) {
          this._onTick = val;
        }
        get onTick() {
          return this._onTick;
        }
        start() {
          if (this._isPlaying) return;
          this._rafHandle = requestAnimationFrame(this._updateCallback);
          this._isPlaying = true;
        }
        stop() {
          if (!this._isPlaying) return;
          cancelAnimationFrame(this._rafHandle);
          this._rafHandle = 0;
          this._isPlaying = false;
        }
      }

      let XREye;
      (function (XREye) {
        XREye[XREye["NONE"] = -1] = "NONE";
        XREye[XREye["LEFT"] = 0] = "LEFT";
        XREye[XREye["RIGHT"] = 1] = "RIGHT";
      })(XREye || (XREye = {}));
      let XRConfigKey;
      (function (XRConfigKey) {
        XRConfigKey[XRConfigKey["SESSION_RUNNING"] = 2] = "SESSION_RUNNING";
        XRConfigKey[XRConfigKey["VIEW_COUNT"] = 6] = "VIEW_COUNT";
        XRConfigKey[XRConfigKey["SWAPCHAIN_WIDTH"] = 7] = "SWAPCHAIN_WIDTH";
        XRConfigKey[XRConfigKey["SWAPCHAIN_HEIGHT"] = 8] = "SWAPCHAIN_HEIGHT";
        XRConfigKey[XRConfigKey["DEVICE_IPD"] = 37] = "DEVICE_IPD";
        XRConfigKey[XRConfigKey["SPLIT_AR_GLASSES"] = 42] = "SPLIT_AR_GLASSES";
      })(XRConfigKey || (XRConfigKey = {}));
      let XRPoseType;
      (function (XRPoseType) {
        XRPoseType[XRPoseType["VIEW_LEFT"] = 0] = "VIEW_LEFT";
        XRPoseType[XRPoseType["HAND_LEFT"] = 1] = "HAND_LEFT";
        XRPoseType[XRPoseType["AIM_LEFT"] = 2] = "AIM_LEFT";
        XRPoseType[XRPoseType["VIEW_RIGHT"] = 3] = "VIEW_RIGHT";
        XRPoseType[XRPoseType["HAND_RIGHT"] = 4] = "HAND_RIGHT";
        XRPoseType[XRPoseType["AIM_RIGHT"] = 5] = "AIM_RIGHT";
        XRPoseType[XRPoseType["HEAD_MIDDLE"] = 6] = "HEAD_MIDDLE";
      })(XRPoseType || (XRPoseType = {}));

      const v2_0 = new Vec2();
      class SplashScreen {
        get isFinished() {
          return this._curTime >= this.settings.totalTime;
        }
        set curTime(val) {
          this._curTime = val;
        }
        get curTime() {
          return this._curTime;
        }
        init() {
          var _settings$querySettin, _settings$querySettin2, _settings$querySettin3, _settings$querySettin4, _settings$querySettin5, _settings$querySettin6;
          this.settings = {
            displayRatio: (_settings$querySettin = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'displayRatio')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : 0.4,
            totalTime: (_settings$querySettin2 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'totalTime')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 3000,
            watermarkLocation: (_settings$querySettin3 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'watermarkLocation')) !== null && _settings$querySettin3 !== void 0 ? _settings$querySettin3 : 'default',
            autoFit: (_settings$querySettin4 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'autoFit')) !== null && _settings$querySettin4 !== void 0 ? _settings$querySettin4 : true,
            logo: (_settings$querySettin5 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'logo')) !== null && _settings$querySettin5 !== void 0 ? _settings$querySettin5 : undefined,
            background: (_settings$querySettin6 = settings.querySettings(Settings.Category.SPLASH_SCREEN, 'background')) !== null && _settings$querySettin6 !== void 0 ? _settings$querySettin6 : undefined
          };
          this._curTime = 0;
          if (this.settings.totalTime <= 0 || this.settings.logo === undefined || this.settings.background === undefined) {
            this.settings.totalTime = 0;
          } else {
            this.device = legacyCC.director.root.device;
            this.swapchain = legacyCC.director.root.mainWindow.swapchain;
            this.preInit();
            this.initLayout();
            if (this.settings.logo.type === 'default') {
              this.initWaterMark();
            }
            let bgPromise = Promise.resolve();
            let logoPromise = Promise.resolve();
            if (this.settings.background.type === 'custom') {
              bgPromise = new Promise((resolve, reject) => {
                this.bgImage = new ccwindow$1.Image();
                this.bgImage.onload = () => {
                  this.initBG();
                  resolve();
                };
                this.bgImage.onerror = () => {
                  reject();
                };
                this.bgImage.src = this.settings.background.base64;
              });
            }
            if (this.settings.logo.type !== 'none') {
              logoPromise = new Promise((resolve, reject) => {
                this.logoImage = new ccwindow$1.Image();
                this.logoImage.onload = () => {
                  this.initLogo();
                  resolve();
                };
                this.logoImage.onerror = () => {
                  reject();
                };
                this.logoImage.src = this.settings.logo.base64;
              });
            }
            return Promise.all([bgPromise, logoPromise]);
          }
          return Promise.resolve([]);
        }
        preInit() {
          var _this$settings$backgr;
          const clearColor = (_this$settings$backgr = this.settings.background) === null || _this$settings$backgr === void 0 ? void 0 : _this$settings$backgr.color;
          this.clearColors = clearColor ? [new Color(clearColor.x, clearColor.y, clearColor.z, clearColor.w)] : [new Color(0, 0, 0, 1)];
          const {
            device,
            swapchain
          } = this;
          this.renderArea = new Rect(0, 0, swapchain.width, swapchain.height);
          this.cmdBuff = device.commandBuffer;
          const verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
          const vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
          const vbSize = vbStride * 4;
          this.vertexBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));
          this.vertexBuffers.update(verts);
          const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
          const ibStride = Uint16Array.BYTES_PER_ELEMENT;
          const ibSize = ibStride * 6;
          this.indicesBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));
          this.indicesBuffers.update(indices);
          const attributes = [new Attribute('a_position', Format.RG32F), new Attribute('a_texCoord', Format.RG32F)];
          const IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
          this.quadAssmebler = device.createInputAssembler(IAInfo);
          this.projection = new Mat4();
          Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
          this.isMobile = sys.isMobile;
        }
        initLayout() {
          if (this.isMobile) {
            this.bgWidth = 812;
            this.bgHeight = 375;
            this.logoWidthTemp = 70;
            this.logoHeightTemp = 100;
            this.textSize = 12;
            this.textHeight = this.textSize + this.textExpandSize;
            this.textXTrans = 1 / 2;
            this.textYExtraTrans = 16;
          } else {
            this.bgWidth = 1920;
            this.bgHeight = 1080;
            this.logoWidthTemp = 140;
            this.logoHeightTemp = 200;
            this.textSize = 24;
            this.textHeight = this.textSize + this.textExpandSize;
            this.textXTrans = 1 / 2;
            this.textYExtraTrans = 32;
          }
          this.logoXTrans = 1 / 2;
          this.logoYTrans = 1 / 6 + 2.5 / 6;
          this.initScale();
        }
        initScale() {
          const dw = this.swapchain.width;
          const dh = this.swapchain.height;
          let desiredWidth = this.isMobile ? 375 : 1080;
          let desiredHeight = this.isMobile ? 812 : 1920;
          if (dw > dh) {
            const temp = desiredHeight;
            desiredHeight = desiredWidth;
            desiredWidth = temp;
          }
          if (dw / dh > 16 / 9) {
            this.scaleSize = dh / desiredHeight;
          } else {
            this.scaleSize = dw / desiredWidth;
          }
        }
        update(deltaTime) {
          const settings = this.settings;
          const {
            device,
            swapchain
          } = this;
          Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
          const dw = swapchain.width;
          const dh = swapchain.height;
          this.initScale();
          this._curTime += deltaTime * 1000;
          const percent = clamp01(this._curTime / settings.totalTime);
          const u_p = cubicOut(percent);
          let scaleX = 1;
          let scaleY = 1;
          if (this.settings.background.type === 'custom') {
            if (dw < dh) {
              scaleX = dh * this.bgRatio;
              scaleY = dh;
            } else {
              scaleX = dw;
              scaleY = dw * this.bgRatio;
            }
            this.bgMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.bgMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.bgMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.5), 0);
            this.bgMat.setProperty('percent', 1.0);
            this.bgMat.setProperty('u_projection', this.projection);
            this.bgMat.passes[0].update();
          }
          const logoYTrans = dh * this.logoYTrans;
          if (this.settings.logo.type !== 'none') {
            scaleX = this.logoWidth * this.scaleSize * settings.displayRatio;
            scaleY = this.logoHeight * this.scaleSize * settings.displayRatio;
            this.logoMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.logoMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.logoMat.setProperty('translate', v2_0.set(dw * this.logoXTrans, logoYTrans), 0);
            this.logoMat.setProperty('percent', u_p);
            this.logoMat.setProperty('u_projection', this.projection);
            this.logoMat.passes[0].update();
          }
          if (this.settings.logo.type === 'default' && this.watermarkMat) {
            const watermarkTW = this.watermarkTexture.width;
            const watermarkTH = this.watermarkTexture.height;
            scaleX = watermarkTW;
            scaleY = watermarkTH;
            const textYTrans = logoYTrans - (this.logoHeight * 0.5 * settings.displayRatio + this.textYExtraTrans) * this.scaleSize - watermarkTH * 0.5;
            this.watermarkMat.setProperty('resolution', v2_0.set(dw, dh), 0);
            this.watermarkMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
            this.watermarkMat.setProperty('translate', v2_0.set(dw * this.textXTrans, textYTrans), 0);
            this.watermarkMat.setProperty('percent', u_p);
            this.watermarkMat.setProperty('u_projection', this.projection);
            this.watermarkMat.passes[0].update();
          }
          this.frame();
        }
        initBG() {
          const device = this.device;
          this.bgMat = new Material();
          this.bgMat.initialize({
            effectName: 'util/splash-screen'
          });
          const samplerInfo = new SamplerInfo();
          samplerInfo.addressU = Address.CLAMP;
          samplerInfo.addressV = Address.CLAMP;
          samplerInfo.addressW = Address.CLAMP;
          this.sampler = device.getSampler(samplerInfo);
          this.bgTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.bgImage.width, this.bgImage.height));
          const pass = this.bgMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.bgTexture);
          this.shader = pass.getShaderVariant();
          const descriptorSet = pass.descriptorSet;
          descriptorSet.bindSampler(binding, this.sampler);
          descriptorSet.update();
          const region = new BufferTextureCopy();
          region.texExtent.width = this.bgImage.width;
          region.texExtent.height = this.bgImage.height;
          region.texExtent.depth = 1;
          device.copyTexImagesToTexture([this.bgImage], this.bgTexture, [region]);
        }
        initLogo() {
          const device = this.device;
          this.logoMat = new Material();
          this.logoMat.initialize({
            effectName: 'util/splash-screen'
          });
          const samplerInfo = new SamplerInfo();
          samplerInfo.addressU = Address.CLAMP;
          samplerInfo.addressV = Address.CLAMP;
          samplerInfo.addressW = Address.CLAMP;
          this.sampler = device.getSampler(samplerInfo);
          this.logoTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.logoImage.width, this.logoImage.height));
          const pass = this.logoMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.logoTexture);
          this.shader = pass.getShaderVariant();
          const descriptorSet = pass.descriptorSet;
          descriptorSet.bindSampler(binding, this.sampler);
          descriptorSet.update();
          const region = new BufferTextureCopy();
          region.texExtent.width = this.logoImage.width;
          region.texExtent.height = this.logoImage.height;
          region.texExtent.depth = 1;
          device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
          const logoRatio = this.logoImage.width / this.logoImage.height;
          if (logoRatio < 1) {
            this.logoWidth = this.logoWidthTemp;
            this.logoHeight = this.logoWidthTemp / logoRatio;
          } else {
            this.logoWidth = this.logoHeightTemp * logoRatio;
            this.logoHeight = this.logoHeightTemp;
          }
        }
        initWaterMark() {
          const watermarkImg = ccwindow$1.document.createElement('canvas');
          watermarkImg.height = this.textHeight * this.scaleSize;
          watermarkImg.style.width = `${watermarkImg.width}`;
          watermarkImg.style.height = `${watermarkImg.height}`;
          const text = 'Created with Cocos';
          const ctx = watermarkImg.getContext('2d');
          ctx.font = `${this.textSize * this.scaleSize}px Arial`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#707070';
          const textLength = ctx.measureText(text).width + 10;
          watermarkImg.width = textLength;
          ctx.font = `${this.textSize * this.scaleSize}px Arial`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#707070';
          ctx.fillText(text, watermarkImg.width / 2, 0);
          const region = new BufferTextureCopy();
          region.texExtent.width = watermarkImg.width;
          region.texExtent.height = watermarkImg.height;
          region.texExtent.depth = 1;
          this.watermarkTexture = this.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, watermarkImg.width, watermarkImg.height));
          this.device.copyTexImagesToTexture([watermarkImg], this.watermarkTexture, [region]);
          this.watermarkMat = new Material();
          this.watermarkMat.initialize({
            effectName: 'util/splash-screen'
          });
          const pass = this.watermarkMat.passes[0];
          const binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.watermarkTexture);
          pass.descriptorSet.update();
        }
        frame() {
          const {
            device,
            swapchain
          } = this;
          if (!sys.isXR || xr.entry.isRenderAllowable()) {
            const renderSize = sys.isXR ? 2 : 1;
            for (let xrEye = 0; xrEye < renderSize; xrEye++) {
              if (sys.isXR) {
                xr.entry.renderLoopStart(xrEye);
                const xrFov = xr.entry.getEyeFov(xrEye);
                let radioLeft = 1.0;
                let radioRight = 1.0;
                if (xrEye === XREye.LEFT) {
                  radioLeft = Math.abs(Math.tan(xrFov[0])) / Math.abs(Math.tan(xrFov[1]));
                } else if (xrEye === XREye.RIGHT) {
                  radioRight = Math.abs(Math.tan(xrFov[1])) / Math.abs(Math.tan(xrFov[0]));
                }
                Mat4.ortho(this.projection, -radioLeft, radioRight, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
                this.projection.m00 = preTransforms[swapchain.surfaceTransform][0];
                this.projection.m05 = preTransforms[swapchain.surfaceTransform][3] * device.capabilities.clipSpaceSignY;
                if (this.settings.background.type === 'custom') {
                  this.bgMat.setProperty('u_projection', this.projection);
                  this.bgMat.passes[0].update();
                }
                if (this.settings.logo.type !== 'none') {
                  this.logoMat.setProperty('u_projection', this.projection);
                  this.logoMat.passes[0].update();
                }
                if (this.settings.logo.type === 'default' && this.watermarkMat) {
                  this.watermarkMat.setProperty('u_projection', this.projection);
                  this.watermarkMat.passes[0].update();
                }
              }
              device.enableAutoBarrier(true);
              device.acquire([swapchain]);
              const cmdBuff = this.cmdBuff;
              const framebuffer = legacyCC.director.root.mainWindow.framebuffer;
              const renderArea = this.renderArea;
              renderArea.width = swapchain.width;
              renderArea.height = swapchain.height;
              cmdBuff.begin();
              cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
              if (this.settings.background.type === 'custom') {
                const bgPass = this.bgMat.passes[0];
                const bgPso = PipelineStateManager.getOrCreatePipelineState(device, bgPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(bgPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, bgPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              if (this.settings.logo.type !== 'none') {
                const logoPass = this.logoMat.passes[0];
                const logoPso = PipelineStateManager.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(logoPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, logoPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              if (this.settings.logo.type === 'default' && this.watermarkMat) {
                const wartermarkPass = this.watermarkMat.passes[0];
                const watermarkPso = PipelineStateManager.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(watermarkPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, wartermarkPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);
              }
              cmdBuff.endRenderPass();
              cmdBuff.end();
              device.flushCommands([cmdBuff]);
              device.queue.submit([cmdBuff]);
              device.present();
              device.enableAutoBarrier(!legacyCC.rendering);
              if (sys.isXR) {
                xr.entry.renderLoopEnd(xrEye);
              }
            }
          }
        }
        destroy() {
          this.device = null;
          this.swapchain = null;
          this.clearColors = null;
          if (this.settings.background.type === 'custom') {
            if (this.bgImage.destroy) this.bgImage.destroy();
            this.bgImage = null;
            this.bgMat.destroy();
            this.bgMat = null;
            this.bgTexture.destroy();
            this.bgTexture = null;
          }
          if (this.settings.logo.type !== 'none') {
            if (this.logoImage.destroy) this.logoImage.destroy();
            this.logoImage = null;
            this.logoMat.destroy();
            this.logoMat = null;
            this.logoTexture.destroy();
            this.logoTexture = null;
          }
          this.renderArea = null;
          this.cmdBuff = null;
          this.shader = null;
          this.quadAssmebler.destroy();
          this.quadAssmebler = null;
          this.vertexBuffers.destroy();
          this.vertexBuffers = null;
          this.indicesBuffers.destroy();
          this.indicesBuffers = null;
          this.sampler = null;
          if (this.settings.logo.type === 'default' && this.watermarkTexture) {
            this.watermarkMat.destroy();
            this.watermarkMat = null;
            this.watermarkTexture.destroy();
            this.watermarkTexture = null;
          }
          this.settings = null;
        }
        static get instance() {
          if (!SplashScreen._ins) {
            SplashScreen._ins = new SplashScreen();
          }
          return SplashScreen._ins;
        }
        constructor() {
          this.settings = void 0;
          this._curTime = 0;
          this.device = void 0;
          this.swapchain = void 0;
          this.shader = void 0;
          this.sampler = void 0;
          this.cmdBuff = void 0;
          this.quadAssmebler = void 0;
          this.vertexBuffers = void 0;
          this.indicesBuffers = void 0;
          this.renderArea = void 0;
          this.clearColors = void 0;
          this.projection = void 0;
          this.isMobile = false;
          this.bgMat = void 0;
          this.bgImage = void 0;
          this.bgTexture = void 0;
          this.logoMat = void 0;
          this.logoImage = void 0;
          this.logoTexture = void 0;
          this.watermarkMat = void 0;
          this.watermarkTexture = void 0;
          this.bgWidth = 1920;
          this.bgHeight = 1080;
          this.bgRatio = 16 / 9;
          this.logoWidthTemp = 140;
          this.logoHeightTemp = 200;
          this.logoWidth = 0;
          this.logoHeight = 0;
          this.logoXTrans = 1 / 2;
          this.logoYTrans = 1 / 6 + 2.5 / 6;
          this.textSize = 24;
          this.textHeight = 24;
          this.textXTrans = 1 / 2;
          this.textYExtraTrans = 32;
          this.textExpandSize = 4;
          this.scaleSize = 1;
        }
      }
      SplashScreen._ins = void 0;
      legacyCC.internal.SplashScreen = SplashScreen;

      class EffectSettings {
        constructor() {
          this._data = null;
        }
        init(path = '') {
          if (!legacyCC.rendering || !legacyCC.rendering.enableEffectImport || !path) {
            return Promise.resolve();
          }
          return new Promise((resolve, reject) => {
            if (!path.startsWith('http')) {
              fsUtils.readArrayBuffer(path, (err, arrayBuffer) => {
                if (err) {
                  reject(err);
                  return;
                }
                this._data = arrayBuffer;
                resolve();
              });
            } else {
              const xhr = new XMLHttpRequest();
              xhr.open('GET', path);
              xhr.responseType = 'arraybuffer';
              xhr.onload = () => {
                this._data = xhr.response;
                resolve();
              };
              xhr.onerror = () => {
                reject(new Error('request effect settings failed!'));
              };
              xhr.send(null);
            }
          });
        }
        get data() {
          return this._data;
        }
      }
      const effectSettings = new EffectSettings();
      legacyCC.effectSettings = effectSettings;

      class Game extends EventTarget {
        constructor(...args) {
          super(...args);
          this.frame = null;
          this.container = null;
          this.canvas = null;
          this.renderType = -1;
          this.eventTargetOn = super.on;
          this.eventTargetOnce = super.once;
          this.config = {};
          this.onStart = null;
          this.frameTime = 1000 / 60;
          this._isCloning = false;
          this._inited = false;
          this._engineInited = false;
          this._rendererInitialized = false;
          this._paused = true;
          this._pausedByEngine = false;
          this._frameRate = 60;
          this._pacer = null;
          this._initTime = 0;
          this._startTime = 0;
          this._deltaTime = 0.0;
          this._useFixedDeltaTime = false;
          this._shouldLoadLaunchScene = true;
          this.onPreBaseInitDelegate = new AsyncDelegate();
          this.onPostBaseInitDelegate = new AsyncDelegate();
          this.onPreInfrastructureInitDelegate = new AsyncDelegate();
          this.onPostInfrastructureInitDelegate = new AsyncDelegate();
          this.onPreSubsystemInitDelegate = new AsyncDelegate();
          this.onPostSubsystemInitDelegate = new AsyncDelegate();
          this.onPreProjectInitDelegate = new AsyncDelegate();
          this.onPostProjectInitDelegate = new AsyncDelegate();
        }
        get inited() {
          return this._inited;
        }
        get frameRate() {
          return this._frameRate;
        }
        set frameRate(frameRate) {
          if (typeof frameRate !== 'number') {
            frameRate = parseInt(frameRate, 10);
            if (Number.isNaN(frameRate)) {
              frameRate = 60;
            }
          }
          this._frameRate = frameRate;
          this.frameTime = 1000 / frameRate;
          if (this._pacer) this._pacer.targetFrameRate = this._frameRate;
        }
        get deltaTime() {
          return this._useFixedDeltaTime ? this.frameTime / 1000 : this._deltaTime;
        }
        get totalTime() {
          return performance.now() - this._initTime;
        }
        get frameStartTime() {
          return this._startTime;
        }
        setFrameRate(frameRate) {
          this.frameRate = frameRate;
        }
        getFrameRate() {
          return this.frameRate;
        }
        step() {
          director.tick(this._calculateDT(true));
        }
        pauseByEngine() {
          if (this._paused) {
            return;
          }
          this._pausedByEngine = true;
          this.pause();
        }
        resumeByEngine() {
          if (this._pausedByEngine) {
            this.resume();
            this._pausedByEngine = false;
          }
        }
        pause() {
          var _this$_pacer;
          if (this._paused) {
            return;
          }
          this._paused = true;
          (_this$_pacer = this._pacer) === null || _this$_pacer === void 0 ? void 0 : _this$_pacer.stop();
          this.emit(Game.EVENT_PAUSE);
        }
        resume() {
          var _this$_pacer2;
          if (!this._paused) {
            return;
          }
          input._clearEvents();
          this._paused = false;
          (_this$_pacer2 = this._pacer) === null || _this$_pacer2 === void 0 ? void 0 : _this$_pacer2.start();
          this.emit(Game.EVENT_RESUME);
        }
        isPaused() {
          return this._paused;
        }
        restart() {
          const endFramePromise = new Promise(resolve => {
            director.once(Director.EVENT_END_FRAME, () => resolve());
          });
          return endFramePromise.then(() => {
            director.reset();
            legacyCC.Object._deferredDestroy();
            this.pause();
            this.resume();
            this._shouldLoadLaunchScene = true;
            SplashScreen.instance.curTime = 0;
            this._safeEmit(Game.EVENT_RESTART);
          });
        }
        end() {
          systemInfo.close();
        }
        on(type, callback, target, once) {
          if (this.canRegisterEvent(type)) {
            callback.call(target);
          }
          return this.eventTargetOn(type, callback, target, once);
        }
        once(type, callback, target) {
          if (this.canRegisterEvent(type)) {
            return callback.call(target);
          }
          return this.eventTargetOnce(type, callback, target);
        }
        canRegisterEvent(type) {
          return this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED;
        }
        init(config) {
          this._compatibleWithOldParams(config);
          return Promise.resolve().then(() => {
            this.emit(Game.EVENT_PRE_BASE_INIT);
            return this.onPreBaseInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Base');
            }
            const debugMode = config.debugMode || DebugMode.NONE;
            _resetDebugSetting(debugMode);
          }).then(() => sys.init()).then(() => {
            this._initEvents();
          }).then(() => settings.init(config.settingsPath, config.overrideSettings)).then(() => {
            {
              console.timeEnd('Init Base');
            }
            this.emit(Game.EVENT_POST_BASE_INIT);
            return this.onPostBaseInitDelegate.dispatch();
          }).then(() => {
            this.emit(Game.EVENT_PRE_INFRASTRUCTURE_INIT);
            return this.onPreInfrastructureInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Infrastructure');
            }
            macro.init();
            this._initXR();
            const adapter = findCanvas();
            if (adapter) {
              this.canvas = adapter.canvas;
              this.frame = adapter.frame;
              this.container = adapter.container;
            }
            screen.init();
            garbageCollectionManager.init();
            deviceManager.init(this.canvas, bindingMappingInfo);
            const renderPipelineUuid = settings.querySettings(Settings.Category.RENDERING, 'renderPipeline');
            if (renderPipelineUuid === 'ca127c79-69d6-4afd-8183-d712d7b80e14') {
              if (!macro.CUSTOM_PIPELINE_NAME) {
                macro.CUSTOM_PIPELINE_NAME = 'Forward';
              }
            }
            if (macro.CUSTOM_PIPELINE_NAME === '') {
              legacyCC.rendering = undefined;
            }
            assetManager.init();
            builtinResMgr.init();
            Layers.init();
            this.initPacer();
            {
              console.timeEnd('Init Infrastructure');
            }
          }).then(() => {
            this.emit(Game.EVENT_POST_INFRASTRUCTURE_INIT);
            return this.onPostInfrastructureInitDelegate.dispatch();
          }).then(() => {
            this.emit(Game.EVENT_PRE_SUBSYSTEM_INIT);
            return this.onPreSubsystemInitDelegate.dispatch();
          }).then(() => effectSettings.init(settings.querySettings(Settings.Category.RENDERING, 'effectSettingsPath'))).then(() => {
            if (!legacyCC.rendering || !legacyCC.rendering.enableEffectImport) {
              return;
            }
            const renderMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode');
            if (renderMode === LegacyRenderMode.HEADLESS) {
              legacyCC.rendering.init(deviceManager.gfxDevice, null);
              return;
            }
            const data = effectSettings.data;
            if (data === null) {
              errorID(1102);
              return;
            }
            legacyCC.rendering.init(deviceManager.gfxDevice, data);
          }).then(() => {
            const scriptPackages = settings.querySettings(Settings.Category.SCRIPTING, 'scriptPackages');
            if (scriptPackages) {
              return Promise.all(scriptPackages.map(pack => module.import(pack)));
            }
            return Promise.resolve([]);
          }).then(() => {
            {
              console.time('Init SubSystem');
            }
            director.init();
            return builtinResMgr.loadBuiltinAssets();
          }).then(() => {
            {
              console.timeEnd('Init SubSystem');
            }
            this.emit(Game.EVENT_POST_SUBSYSTEM_INIT);
            return this.onPostSubsystemInitDelegate.dispatch();
          }).then(() => {
            log(`Cocos Creator v${engineVersion}`);
            this.emit(Game.EVENT_ENGINE_INITED);
            this._engineInited = true;
          }).then(() => {
            this.emit(Game.EVENT_PRE_PROJECT_INIT);
            return this.onPreProjectInitDelegate.dispatch();
          }).then(() => {
            {
              console.time('Init Project');
            }
            const jsList = settings.querySettings(Settings.Category.PLUGINS, 'jsList');
            let promise = Promise.resolve();
            if (jsList) {
              jsList.forEach(jsListFile => {
                promise = promise.then(() => loadJsFile(`${'src'}/${jsListFile}`));
              });
            }
            return promise;
          }).then(() => this._loadProjectBundles()).then(() => this._loadCCEScripts()).then(() => this._setupRenderPipeline()).then(() => this._loadPreloadAssets()).then(() => {
            builtinResMgr.compileBuiltinMaterial();
            return SplashScreen.instance.init();
          }).then(() => {
            {
              console.timeEnd('Init Project');
            }
            this.emit(Game.EVENT_POST_PROJECT_INIT);
            return this.onPostProjectInitDelegate.dispatch();
          }).then(() => {
            this._inited = true;
            this._safeEmit(Game.EVENT_GAME_INITED);
          });
        }
        _initXR() {
          var _settings$querySettin;
          if (typeof globalThis.__globalXR === 'undefined') {
            globalThis.__globalXR = {};
          }
          const globalXR = globalThis.__globalXR;
          globalXR.webxrCompatible = (_settings$querySettin = settings.querySettings(Settings.Category.XR, 'webxrCompatible')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : false;
          if (sys.isXR) {
            var _settings$querySettin2, _settings$querySettin3;
            xr.entry = xr.XrEntry.getInstance();
            const xrMSAA = (_settings$querySettin2 = settings.querySettings(Settings.Category.RENDERING, 'msaa')) !== null && _settings$querySettin2 !== void 0 ? _settings$querySettin2 : 1;
            const xrRenderingScale = (_settings$querySettin3 = settings.querySettings(Settings.Category.RENDERING, 'renderingScale')) !== null && _settings$querySettin3 !== void 0 ? _settings$querySettin3 : 1.0;
            xr.entry.setMultisamplesRTT(xrMSAA);
            xr.entry.setRenderingScale(xrRenderingScale);
          }
        }
        _compatibleWithOldParams(config) {
          const overrideSettings = config.overrideSettings = config.overrideSettings || {};
          if ('showFPS' in config) {
            overrideSettings.profiling = overrideSettings.profiling || {};
            overrideSettings.profiling.showFPS = config.showFPS;
          }
          if ('frameRate' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.frameRate = config.frameRate;
          }
          if ('renderMode' in config) {
            overrideSettings.rendering = overrideSettings.rendering || {};
            overrideSettings.rendering.renderMode = config.renderMode;
          }
          if ('renderPipeline' in config) {
            overrideSettings.rendering = overrideSettings.rendering || {};
            overrideSettings.rendering.renderPipeline = config.renderPipeline;
          }
          if ('assetOptions' in config) {
            overrideSettings.assets = overrideSettings.assets || {};
            Object.assign(overrideSettings.assets, config.assetOptions);
          }
          if ('customJointTextureLayouts' in config) {
            overrideSettings.animation = overrideSettings.animation || {};
            overrideSettings.animation.customJointTextureLayouts = config.customJointTextureLayouts;
          }
          if ('physics' in config) {
            overrideSettings.physics = overrideSettings.physics || {};
            Object.assign(overrideSettings.physics, config.physics);
          }
          if ('orientation' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.orientation = config.orientation;
          }
          if ('exactFitScreen' in config) {
            overrideSettings.screen = overrideSettings.screen || {};
            overrideSettings.screen.exactFitScreen = config.exactFitScreen;
          }
        }
        _loadPreloadAssets() {
          const preloadAssets = settings.querySettings(Settings.Category.ASSETS, 'preloadAssets');
          if (!preloadAssets) return Promise.resolve([]);
          return Promise.all(preloadAssets.map(uuid => new Promise((resolve, reject) => {
            assetManager.loadAny(uuid, err => {
              if (err) {
                reject(err);
                return;
              }
              resolve();
            });
          })));
        }
        _loadCCEScripts() {
          return new Promise((resolve, reject) => {
            {
              resolve();
            }
          });
        }
        _loadProjectBundles() {
          const preloadBundles = settings.querySettings(Settings.Category.ASSETS, 'preloadBundles');
          if (!preloadBundles) return Promise.resolve([]);
          return Promise.all(preloadBundles.map(({
            bundle,
            version
          }) => new Promise((resolve, reject) => {
            const opts = {};
            if (version) opts.version = version;
            assetManager.loadBundle(bundle, opts, err => {
              if (err) {
                reject(err);
                return;
              }
              resolve();
            });
          })));
        }
        run(onStart) {
          if (onStart) {
            this.onStart = onStart;
          }
          if (!this._inited || EDITOR_NOT_IN_PREVIEW) {
            return;
          }
          this.resume();
        }
        _calculateDT(useFixedDeltaTime) {
          this._useFixedDeltaTime = useFixedDeltaTime;
          if (useFixedDeltaTime) {
            this._startTime = performance.now();
            return this.frameTime / 1000;
          }
          const now = performance.now();
          this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;
          if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
            this._deltaTime = this.frameTime / 1000;
          }
          this._startTime = now;
          return this._deltaTime;
        }
        _updateCallback() {
          if (!this._inited) return;
          if (!SplashScreen.instance.isFinished) {
            SplashScreen.instance.update(this._calculateDT(false));
          } else if (this._shouldLoadLaunchScene) {
            this._shouldLoadLaunchScene = false;
            const launchScene = settings.querySettings(Settings.Category.LAUNCH, 'launchScene');
            if (launchScene) {
              director.loadScene(launchScene, () => {
                var _this$onStart;
                logID(1103, launchScene);
                this._initTime = performance.now();
                director.startAnimation();
                (_this$onStart = this.onStart) === null || _this$onStart === void 0 ? void 0 : _this$onStart.call(this);
              });
            } else {
              var _this$onStart2;
              this._initTime = performance.now();
              director.startAnimation();
              (_this$onStart2 = this.onStart) === null || _this$onStart2 === void 0 ? void 0 : _this$onStart2.call(this);
            }
          } else {
            director.tick(this._calculateDT(false));
          }
        }
        initPacer() {
          var _settings$querySettin4;
          const frameRate = (_settings$querySettin4 = settings.querySettings(Settings.Category.SCREEN, 'frameRate')) !== null && _settings$querySettin4 !== void 0 ? _settings$querySettin4 : 60;
          assert(typeof frameRate === 'number');
          this._pacer = new Pacer();
          this._pacer.onTick = this._updateCallback.bind(this);
          this.frameRate = frameRate;
        }
        _initEvents() {
          systemInfo.on('show', this._onShow, this);
          systemInfo.on('hide', this._onHide, this);
          systemInfo.on('close', this._onClose, this);
        }
        _onHide() {
          this.emit(Game.EVENT_HIDE);
          this.pauseByEngine();
        }
        _onShow() {
          this.emit(Game.EVENT_SHOW);
          this.resumeByEngine();
        }
        _onClose() {
          this.emit(Game.EVENT_CLOSE);
          systemInfo.exit();
        }
        addPersistRootNode(node) {
          director.addPersistRootNode(node);
        }
        removePersistRootNode(node) {
          director.removePersistRootNode(node);
        }
        isPersistRootNode(node) {
          return director.isPersistRootNode(node);
        }
        _setupRenderPipeline() {
          const renderPipeline = settings.querySettings(Settings.Category.RENDERING, 'renderPipeline');
          if (!renderPipeline || renderPipeline === 'ca127c79-69d6-4afd-8183-d712d7b80e14') {
            return this._setRenderPipeline();
          }
          return new Promise((resolve, reject) => {
            assetManager.loadAny(renderPipeline, (err, asset) => err || !(asset instanceof RenderPipeline) ? reject(err) : resolve(asset));
          }).then(asset => {
            this._setRenderPipeline(asset);
          }).catch(reason => {
            warn(reason);
            warn(`Failed load render pipeline: ${renderPipeline}, engine failed to initialize, will fallback to default pipeline`);
            this._setRenderPipeline();
          });
        }
        _setRenderPipeline(rppl) {
          if (!director.root.setRenderPipeline(rppl)) {
            this._setRenderPipeline();
          }
          this._rendererInitialized = true;
          this._safeEmit(Game.EVENT_RENDERER_INITED);
        }
        _safeEmit(event) {
          {
            this.emit(event);
          }
        }
      } exports('Game', Game);
      Game.EVENT_HIDE = 'game_on_hide';
      Game.EVENT_SHOW = 'game_on_show';
      Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
      Game.EVENT_GAME_INITED = 'game_inited';
      Game.EVENT_ENGINE_INITED = 'engine_inited';
      Game.EVENT_RENDERER_INITED = 'renderer_inited';
      Game.EVENT_PRE_BASE_INIT = 'pre_base_init';
      Game.EVENT_POST_BASE_INIT = 'post_base_init';
      Game.EVENT_PRE_INFRASTRUCTURE_INIT = 'pre_infrastructure_init';
      Game.EVENT_POST_INFRASTRUCTURE_INIT = 'post_infrastructure_init';
      Game.EVENT_PRE_SUBSYSTEM_INIT = 'pre_subsystem_init';
      Game.EVENT_POST_SUBSYSTEM_INIT = 'post_subsystem_init';
      Game.EVENT_PRE_PROJECT_INIT = 'pre_project_init';
      Game.EVENT_POST_PROJECT_INIT = 'post_project_init';
      Game.EVENT_RESTART = 'game_on_restart';
      Game.EVENT_PAUSE = 'game_on_pause';
      Game.EVENT_RESUME = 'game_on_resume';
      Game.EVENT_CLOSE = 'game_on_close';
      Game.RENDER_TYPE_CANVAS = 0;
      Game.RENDER_TYPE_WEBGL = 1;
      Game.RENDER_TYPE_OPENGL = 2;
      Game.RENDER_TYPE_HEADLESS = 3;
      Game.DEBUG_DT_THRESHOLD = 1;
      legacyCC.Game = Game;
      const game = exports('game', legacyCC.game = new Game());

      markAsWarning(Director.prototype, 'director', [{
        name: 'calculateDeltaTime'
      }, {
        name: 'getDeltaTime',
        suggest: 'Use game.deltaTime instead'
      }, {
        name: 'getTotalTime',
        suggest: 'Use game.totalTime instead'
      }, {
        name: 'getCurrentTime',
        suggest: 'Use game.frameStartTime instead'
      }]);
      removeProperty(Director.prototype, 'director', [{
        name: 'setAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getRunningScene',
        suggest: 'please use getScene instead'
      }, {
        name: 'setDepthTest',
        suggest: 'please use camera API instead'
      }, {
        name: 'setClearColor',
        suggest: 'please use camera API instead'
      }, {
        name: 'getWinSize',
        suggest: 'please use view.getVisibleSize instead'
      }, {
        name: 'getWinSizeInPixels'
      }, {
        name: 'purgeCachedData',
        suggest: 'please use assetManager.releaseAll instead'
      }, {
        name: 'convertToGL'
      }, {
        name: 'convertToUI'
      }]);
      replaceProperty(director, 'director', [{
        name: '_getSceneUuid',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customFunction: sceneName => {
          if (assetManager.main) {
            var _assetManager$main$ge;
            return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
          }
          return '';
        }
      }]);
      markAsWarning(game, 'game', [{
        name: 'collisionMatrix'
      }, {
        name: 'groupList'
      }]);
      replaceProperty(game, 'game', [{
        name: '_sceneInfos',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customGetter: () => {
          const scenes = [];
          if (assetManager.main) {
            assetManager.main.config.scenes.forEach(val => {
              scenes.push(val);
            });
          }
          return scenes;
        }
      }]);

      class DynamicAtlasManager extends System {
        constructor(...args) {
          super(...args);
          this._atlases = [];
          this._atlasIndex = -1;
          this._maxAtlasCount = 5;
          this._textureSize = 2048;
          this._maxFrameSize = 512;
          this._textureBleeding = true;
          this._enabled = false;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(value) {
          if (this._enabled === value) return;
          if (value) {
            this.reset();
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
          } else {
            this.reset();
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
          }
          this._enabled = value;
        }
        get maxAtlasCount() {
          return this._maxAtlasCount;
        }
        set maxAtlasCount(value) {
          this._maxAtlasCount = value;
        }
        get atlasCount() {
          return this._atlases.length;
        }
        get textureBleeding() {
          return this._textureBleeding;
        }
        set textureBleeding(enable) {
          this._textureBleeding = enable;
        }
        get textureSize() {
          return this._textureSize;
        }
        set textureSize(value) {
          this._textureSize = value;
        }
        get maxFrameSize() {
          return this._maxFrameSize;
        }
        set maxFrameSize(value) {
          this._maxFrameSize = value;
        }
        newAtlas() {
          let atlas = this._atlases[++this._atlasIndex];
          if (!atlas) {
            atlas = new Atlas(this._textureSize, this._textureSize);
            this._atlases.push(atlas);
          }
          return atlas;
        }
        beforeSceneLoad() {
          this.reset();
        }
        init() {
          this.enabled = !macro.CLEANUP_IMAGE_CACHE;
        }
        insertSpriteFrame(spriteFrame) {
          if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
          if (!spriteFrame.packable) return null;
          const sampler = spriteFrame.texture.getSamplerInfo();
          if (sampler.minFilter !== Filter.LINEAR || sampler.magFilter !== Filter.LINEAR || sampler.mipFilter !== Filter.NONE) {
            return null;
          }
          let atlas = this._atlases[this._atlasIndex];
          if (!atlas) {
            atlas = this.newAtlas();
          }
          const frame = atlas.insertSpriteFrame(spriteFrame);
          if (!frame && this._atlasIndex !== this._maxAtlasCount) {
            atlas = this.newAtlas();
            return atlas.insertSpriteFrame(spriteFrame);
          }
          return frame;
        }
        reset() {
          for (let i = 0, l = this._atlases.length; i < l; i++) {
            this._atlases[i].destroy();
          }
          this._atlases.length = 0;
          this._atlasIndex = -1;
        }
        deleteAtlasSpriteFrame(spriteFrame) {
          if (!spriteFrame._original) return;
          let atlas;
          for (let i = this._atlases.length - 1; i >= 0; i--) {
            atlas = this._atlases[i];
            fastRemove(atlas._innerSpriteFrames, spriteFrame);
          }
          const texture = spriteFrame._original._texture;
          this.deleteAtlasTexture(texture);
        }
        deleteAtlasTexture(texture) {
          if (texture) {
            for (let i = this._atlases.length - 1; i >= 0; i--) {
              this._atlases[i].deleteInnerTexture(texture);
              if (this._atlases[i].isEmpty()) {
                this._atlases[i].destroy();
                this._atlases.splice(i, 1);
                this._atlasIndex--;
              }
            }
          }
        }
        packToDynamicAtlas(comp, frame) {
          if (!this._enabled) return;
          if (frame && !frame._original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
            const packedFrame = this.insertSpriteFrame(frame);
            if (packedFrame) {
              frame._setDynamicAtlasFrame(packedFrame);
            }
          }
        }
      } exports('DynamicAtlasManager', DynamicAtlasManager);
      DynamicAtlasManager.instance = void 0;
      const dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
      director.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);
      legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

      function toPPM(buffer, w, h) {
        return `P3 ${w} ${h} 255\n${buffer.filter((e, i) => i % 4 < 3).toString()}\n`;
      }

      const _typeMap = {
        [FormatType.UNORM]: 'Uint',
        [FormatType.SNORM]: 'Int',
        [FormatType.UINT]: 'Uint',
        [FormatType.INT]: 'Int',
        [FormatType.UFLOAT]: 'Float',
        [FormatType.FLOAT]: 'Float',
        default: 'Uint'
      };
      function _getDataViewType(info) {
        const type = _typeMap[info.type] || _typeMap.default;
        const bytes = info.size / info.count * 8;
        return `${type}${bytes}`;
      }
      function writeBuffer(target, data, format = Format.R32F, offset = 0, stride = 0) {
        const info = FormatInfos[format];
        if (!stride) {
          stride = info.size;
        }
        const writer = `set${_getDataViewType(info)}`;
        const componentBytesLength = info.size / info.count;
        const nSeg = Math.floor(data.length / info.count);
        const isLittleEndian = sys.isLittleEndian;
        for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
          const x = offset + stride * iSeg;
          for (let iComponent = 0; iComponent < info.count; ++iComponent) {
            const y = x + componentBytesLength * iComponent;
            target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
          }
        }
      }
      function readBuffer(target, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out = []) {
        const info = FormatInfos[format];
        if (!stride) {
          stride = info.size;
        }
        const reader = `get${_getDataViewType(info)}`;
        const componentBytesLength = info.size / info.count;
        const nSeg = Math.floor(length / stride);
        const isLittleEndian = sys.isLittleEndian;
        for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
          const x = offset + stride * iSeg;
          for (let iComponent = 0; iComponent < info.count; ++iComponent) {
            const y = x + componentBytesLength * iComponent;
            out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
          }
        }
        return out;
      }
      function mapBuffer(target, callback, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out) {
        if (!out) {
          out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
        }
        const info = FormatInfos[format];
        if (!stride) {
          stride = info.size;
        }
        const writer = `set${_getDataViewType(info)}`;
        const reader = `get${_getDataViewType(info)}`;
        const componentBytesLength = info.size / info.count;
        const nSeg = Math.floor(length / stride);
        const isLittleEndian = sys.isLittleEndian;
        for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
          const x = offset + stride * iSeg;
          for (let iComponent = 0; iComponent < info.count; ++iComponent) {
            const y = x + componentBytesLength * iComponent;
            const cur = target[reader](y, isLittleEndian);
            out[writer](y, callback(cur, iComponent, target), isLittleEndian);
          }
        }
        return out;
      }

      var _keyMap;
      (function (_keyMap) {
        _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
        _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
        _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
        _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
      })(_keyMap || (_keyMap = {}));
      function readMesh(mesh, iPrimitive = 0) {
        const out = {
          positions: []
        };
        const dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
        const struct = mesh.struct;
        const primitive = struct.primitives[iPrimitive];
        for (const idx of primitive.vertexBundelIndices) {
          const bundle = struct.vertexBundles[idx];
          let offset = bundle.view.offset;
          const {
            length,
            stride
          } = bundle.view;
          for (const attr of bundle.attributes) {
            const name = _keyMap[attr.name];
            if (name) {
              out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
            }
            offset += FormatInfos[attr.format].size;
          }
        }
        const view = primitive.indexView;
        out.indices = readBuffer(dataView, Format[`R${view.stride * 8}UI`], view.offset, view.length);
        return out;
      }

      const MeshUtils = jsb.MeshUtils;
      const createMesh = MeshUtils.createMesh;
      MeshUtils.createDynamicMesh;
      legacyCC.MeshUtils = jsb.MeshUtils;

      var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        find: find,
        toPPM: toPPM,
        readMesh: readMesh,
        createMesh: createMesh,
        MeshUtils: MeshUtils,
        readBuffer: readBuffer,
        writeBuffer: writeBuffer,
        mapBuffer: mapBuffer
      });
      exports('utils', utils);

      var _dec$1z, _class$1w, _class2$1p;
      const INSET_LEFT = 0;
      const INSET_TOP = 1;
      const INSET_RIGHT = 2;
      const INSET_BOTTOM = 3;
      const temp_vec3 = new Vec3();
      const temp_matrix = new Mat4();
      var MeshType;
      (function (MeshType) {
        MeshType[MeshType["RECT"] = 0] = "RECT";
        MeshType[MeshType["POLYGON"] = 1] = "POLYGON";
      })(MeshType || (MeshType = {}));
      const temp_uvs = [{
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }];
      let SpriteFrame = exports('SpriteFrame', (_dec$1z = ccclass$6('cc.SpriteFrame'), _dec$1z(_class$1w = (_class2$1p = class SpriteFrame extends Asset {
        static createWithImage(imageSourceOrImageAsset) {
          const img = imageSourceOrImageAsset instanceof ImageAsset$1 ? imageSourceOrImageAsset : new ImageAsset$1(imageSourceOrImageAsset);
          const tex = new Texture2D$1();
          tex.image = img;
          const spf = new SpriteFrame();
          spf.texture = tex;
          return spf;
        }
        get insetTop() {
          return this._capInsets[INSET_TOP];
        }
        set insetTop(value) {
          if (this._capInsets[INSET_TOP] === value) {
            return;
          }
          this._capInsets[INSET_TOP] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetBottom() {
          return this._capInsets[INSET_BOTTOM];
        }
        set insetBottom(value) {
          if (this._capInsets[INSET_BOTTOM] === value) {
            return;
          }
          this._capInsets[INSET_BOTTOM] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetLeft() {
          return this._capInsets[INSET_LEFT];
        }
        set insetLeft(value) {
          if (this._capInsets[INSET_LEFT] === value) {
            return;
          }
          this._capInsets[INSET_LEFT] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get insetRight() {
          return this._capInsets[INSET_RIGHT];
        }
        set insetRight(value) {
          if (this._capInsets[INSET_RIGHT] === value) {
            return;
          }
          this._capInsets[INSET_RIGHT] = value;
          if (this._texture) {
            this._calculateSlicedUV();
          }
        }
        get rect() {
          return this._rect;
        }
        set rect(value) {
          if (this._rect.equals(value)) {
            return;
          }
          this._rect.set(value);
          if (this._texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        get originalSize() {
          return this._originalSize;
        }
        set originalSize(value) {
          if (this._originalSize.equals(value)) {
            return;
          }
          this._originalSize.set(value);
          if (this._texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        get offset() {
          return this._offset;
        }
        set offset(value) {
          this._offset.set(value);
          this._calcTrimmedBorder();
        }
        get rotated() {
          return this._rotated;
        }
        set rotated(rotated) {
          if (this._rotated === rotated) {
            return;
          }
          this._rotated = rotated;
          if (this._texture) {
            this._calculateUV();
          }
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (!value) {
            warnID(3122, this.name);
            return;
          }
          if (value === this._texture) {
            return;
          }
          this.reset({
            texture: value
          }, true);
        }
        get atlasUuid() {
          return this._atlasUuid;
        }
        set atlasUuid(value) {
          this._atlasUuid = value;
        }
        get width() {
          return this._texture.width;
        }
        get height() {
          return this._texture.height;
        }
        set _textureSource(value) {
          if (globalThis.Build) {
            this._texture = value;
            return;
          }
          if (value) {
            this._refreshTexture(value);
            this._calculateUV();
          }
        }
        get flipUVX() {
          return this._isFlipUVX;
        }
        set flipUVX(value) {
          this._isFlipUVX = value;
          this._calculateUV();
        }
        get flipUVY() {
          return this._isFlipUVY;
        }
        set flipUVY(value) {
          this._isFlipUVY = value;
          this._calculateUV();
        }
        get packable() {
          return this._packable;
        }
        set packable(value) {
          this._packable = value;
        }
        get original() {
          return this._original;
        }
        get pixelsToUnit() {
          return this._pixelsToUnit;
        }
        get pivot() {
          return this._pivot;
        }
        get mesh() {
          return this._mesh;
        }
        get trimmedBorder() {
          return this._trimmedBorder;
        }
        constructor() {
          super();
          this.vertices = null;
          this.uv = [];
          this.unbiasUV = [];
          this.uvSliced = [];
          this._rect = new Rect$1();
          this._trimmedBorder = new Vec4();
          this._offset = new Vec2();
          this._originalSize = new Size$1();
          this._rotated = false;
          this._capInsets = [0, 0, 0, 0];
          this._atlasUuid = '';
          this._texture = void 0;
          this._isFlipUVY = false;
          this._isFlipUVX = false;
          this._original = null;
          this._packable = true;
          this._pixelsToUnit = 100;
          this._pivot = new Vec2(0.5, 0.5);
          this._meshType = MeshType.RECT;
          this._extrude = 0;
          this._customOutLine = [];
          this._minPos = new Vec3();
          this._maxPos = new Vec3();
        }
        textureLoaded() {
          return !!this.texture;
        }
        isRotated() {
          return this._rotated;
        }
        setRotated(rotated) {
          this.rotated = rotated;
        }
        getRect(out) {
          if (out) {
            out.set(this._rect);
            return out;
          }
          return this._rect.clone();
        }
        setRect(rect) {
          this.rect = rect;
        }
        getOriginalSize(out) {
          if (out) {
            out.set(this._originalSize);
            return out;
          }
          return this._originalSize.clone();
        }
        setOriginalSize(size) {
          this.originalSize = size;
        }
        getOffset(out) {
          if (out) {
            out.set(this._offset);
            return out;
          }
          return this._offset.clone();
        }
        setOffset(offset) {
          this.offset = offset;
        }
        getGFXTexture() {
          return this._texture.getGFXTexture();
        }
        getGFXSampler() {
          return this._texture.getGFXSampler();
        }
        getHash() {
          return this._texture.getHash();
        }
        getSamplerInfo() {
          return this._texture.getSamplerInfo();
        }
        reset(info, clearData = false) {
          let calUV = false;
          if (clearData) {
            this._originalSize.set(0, 0);
            this._rect.set(0, 0, 0, 0);
            this._offset.set(0, 0);
            this._capInsets = [0, 0, 0, 0];
            this._rotated = false;
            calUV = true;
          }
          if (info) {
            if (info.texture) {
              this._rect.x = this._rect.y = 0;
              this._rect.width = info.texture.width;
              this._rect.height = info.texture.height;
              this._refreshTexture(info.texture);
              this.checkRect(this._texture);
            }
            if (info.originalSize) {
              this._originalSize.set(info.originalSize);
            }
            if (info.rect) {
              this._rect.set(info.rect);
            }
            if (info.offset) {
              this._offset.set(info.offset);
            }
            if (info.borderTop !== undefined) {
              this._capInsets[INSET_TOP] = info.borderTop;
            }
            if (info.borderBottom !== undefined) {
              this._capInsets[INSET_BOTTOM] = info.borderBottom;
            }
            if (info.borderLeft !== undefined) {
              this._capInsets[INSET_LEFT] = info.borderLeft;
            }
            if (info.borderRight !== undefined) {
              this._capInsets[INSET_RIGHT] = info.borderRight;
            }
            if (info.isRotate !== undefined) {
              this._rotated = !!info.isRotate;
            }
            if (info.isFlipUv !== undefined) {
              this._isFlipUVY = !!info.isFlipUv;
            }
            calUV = true;
          }
          if (calUV && this.texture) {
            this._calculateUV();
          }
          this._calcTrimmedBorder();
        }
        checkRect(texture) {
          const rect = this._rect;
          let maxX = rect.x;
          let maxY = rect.y;
          if (this._rotated) {
            maxX += rect.height;
            maxY += rect.width;
          } else {
            maxX += rect.width;
            maxY += rect.height;
          }
          if (maxX > texture.width) {
            errorID(3300, `${this.name}/${texture.name}`, maxX, texture.width);
            return false;
          }
          if (maxY > texture.height) {
            errorID(3301, `${this.name}/${texture.name}`, maxY, texture.height);
            return false;
          }
          return true;
        }
        _calcTrimmedBorder() {
          const ow = this._originalSize.width;
          const oh = this._originalSize.height;
          const rw = this._rect.width;
          const rh = this._rect.height;
          const halfTrimmedWidth = (ow - rw) * 0.5;
          const halfTrimmedHeight = (oh - rh) * 0.5;
          this._trimmedBorder.x = this._offset.x + halfTrimmedWidth;
          this._trimmedBorder.y = this._offset.x - halfTrimmedWidth;
          this._trimmedBorder.z = this._offset.y + halfTrimmedHeight;
          this._trimmedBorder.w = this._offset.y - halfTrimmedHeight;
        }
        ensureMeshData() {
          if (this._mesh) return;
          this._initVertices();
          this._createMesh();
        }
        destroy() {
          if (this._packable && dynamicAtlasManager) {
            dynamicAtlasManager.deleteAtlasSpriteFrame(this);
          }
          return super.destroy();
        }
        _calculateSlicedUV() {
          const rect = this._rect;
          const tex = this.texture;
          const atlasWidth = tex.width;
          const atlasHeight = tex.height;
          const leftWidth = this._capInsets[INSET_LEFT];
          const rightWidth = this._capInsets[INSET_RIGHT];
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = this._capInsets[INSET_TOP];
          const bottomHeight = this._capInsets[INSET_BOTTOM];
          const centerHeight = rect.height - topHeight - bottomHeight;
          const uvSliced = this.uvSliced;
          uvSliced.length = 0;
          if (this._rotated) {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
            temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
            temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
            for (let row = 0; row < 4; ++row) {
              const rowD = temp_uvs[row];
              for (let col = 0; col < 4; ++col) {
                const colD = temp_uvs[3 - col];
                uvSliced.push({
                  u: rowD.u,
                  v: colD.v
                });
              }
            }
          } else {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
            for (let row = 0; row < 4; ++row) {
              const rowD = temp_uvs[row];
              for (let col = 0; col < 4; ++col) {
                const colD = temp_uvs[col];
                uvSliced.push({
                  u: colD.u,
                  v: rowD.v
                });
              }
            }
          }
          this.emit(SpriteFrame.EVENT_UV_UPDATED, this);
        }
        _calculateUV() {
          const rect = this._rect;
          const uv = this.uv;
          const unbiasUV = this.unbiasUV;
          const tex = this.texture;
          const texw = tex.width;
          const texh = tex.height;
          if (this._rotated) {
            const l = texw === 0 ? 0 : rect.x / texw;
            const r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            const t = texh === 0 ? 0 : rect.y / texh;
            const b = texh === 0 ? 1 : (rect.y + rect.width) / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = b;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = r;
              uv[7] = t;
            } else {
              uv[0] = l;
              uv[1] = t;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = r;
              uv[7] = b;
            }
            const ul = texw === 0 ? 0 : rect.x / texw;
            const ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            const ut = texh === 0 ? 0 : rect.y / texh;
            const ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            }
          } else {
            const l = texw === 0 ? 0 : rect.x / texw;
            const r = texw === 0 ? 1 : (rect.x + rect.width) / texw;
            const b = texh === 0 ? 1 : (rect.y + rect.height) / texh;
            const t = texh === 0 ? 0 : rect.y / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = t;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = r;
              uv[7] = b;
            } else {
              uv[0] = l;
              uv[1] = b;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = r;
              uv[7] = t;
            }
            const ul = texw === 0 ? 0 : rect.x / texw;
            const ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;
            const ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;
            const ut = texh === 0 ? 0 : rect.y / texh;
            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            }
          }
          this._calculateSlicedUV();
        }
        _setDynamicAtlasFrame(frame) {
          if (!frame) return;
          this._original = {
            _texture: this._texture,
            _x: this._rect.x,
            _y: this._rect.y
          };
          this._texture = frame.texture;
          this._rect.x = frame.x;
          this._rect.y = frame.y;
          this._calculateUV();
        }
        _resetDynamicAtlasFrame() {
          if (!this._original) return;
          this._rect.x = this._original._x;
          this._rect.y = this._original._y;
          this._texture = this._original._texture;
          this._original = null;
          this._calculateUV();
        }
        _checkPackable() {
          const dynamicAtlas = dynamicAtlasManager;
          if (!dynamicAtlas) return;
          const texture = this._texture;
          if (!(texture instanceof Texture2D$1) || texture.isCompressed) {
            this._packable = false;
            return;
          }
          const w = this.width;
          const h = this.height;
          if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
            this._packable = false;
            return;
          }
          const CanvasElement = ccwindow$1.HTMLCanvasElement;
          if (texture.image && texture.image instanceof CanvasElement) {
            this._packable = true;
          }
        }
        _serialize(ctxForExporting) {
          return null;
        }
        _deserialize(serializeData, handle) {
          const data = serializeData;
          const rect = data.rect;
          if (rect) {
            this._rect = new Rect$1(rect.x, rect.y, rect.width, rect.height);
          }
          const offset = data.offset;
          if (data.offset) {
            this._offset = new Vec2(offset.x, offset.y);
          }
          const originalSize = data.originalSize;
          if (data.originalSize) {
            this._originalSize = new Size$1(originalSize.width, originalSize.height);
          }
          this._rotated = !!data.rotated;
          this._name = data.name;
          this._packable = !!data.packable;
          this._pixelsToUnit = data.pixelsToUnit;
          const pivot = data.pivot;
          if (pivot) {
            this._pivot = new Vec2(pivot.x, pivot.y);
          }
          this._meshType = data.meshType;
          const capInsets = data.capInsets;
          if (capInsets) {
            this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
            this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
            this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
            this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
          }
          const vertices = data.vertices;
          if (vertices) {
            if (!this.vertices) {
              this.vertices = {
                rawPosition: [],
                positions: [],
                indexes: vertices.indexes,
                uv: vertices.uv,
                nuv: vertices.nuv,
                minPos: new Vec3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),
                maxPos: new Vec3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z)
              };
            }
            this.vertices.rawPosition.length = 0;
            const rawPosition = vertices.rawPosition;
            for (let i = 0; i < rawPosition.length; i += 3) {
              this.vertices.rawPosition.push(new Vec3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));
            }
            this._updateMeshVertices();
          }
        }
        clone() {
          const sp = new SpriteFrame();
          const v = this.vertices;
          sp.vertices = v ? {
            rawPosition: v.rawPosition.slice(0),
            positions: v.positions.slice(0),
            indexes: v.indexes.slice(0),
            uv: v.uv.slice(0),
            nuv: v.nuv.slice(0),
            minPos: v.minPos.clone(),
            maxPos: v.maxPos.clone()
          } : null;
          sp.uv.splice(0, sp.uv.length, ...this.uv);
          sp.unbiasUV.splice(0, sp.unbiasUV.length, ...this.unbiasUV);
          sp.uvSliced.splice(0, sp.uvSliced.length, ...this.uvSliced);
          sp._rect.set(this._rect);
          sp._trimmedBorder.set(this._trimmedBorder);
          sp._offset.set(this._offset);
          sp._originalSize.set(this._originalSize);
          sp._rotated = this._rotated;
          sp._capInsets.splice(0, sp._capInsets.length, ...this._capInsets);
          sp._atlasUuid = this._atlasUuid;
          sp._texture = this._texture;
          sp._isFlipUVX = this._isFlipUVX;
          sp._isFlipUVY = this._isFlipUVY;
          if (this._original) {
            sp._original = {
              _texture: this._original._texture,
              _x: this._original._x,
              _y: this._original._y
            };
          } else {
            sp._original = null;
          }
          sp._packable = this._packable;
          sp._pixelsToUnit = this._pixelsToUnit;
          sp._pivot.set(this._pivot);
          sp._meshType = this._meshType;
          sp._extrude = this._extrude;
          sp._customOutLine.splice(0, sp._customOutLine.length, ...this._customOutLine);
          sp._minPos = this._minPos;
          sp._maxPos = this._maxPos;
          if (this._mesh) {
            sp._createMesh();
          }
          return sp;
        }
        _refreshTexture(texture) {
          this._texture = texture;
          const tex = this._texture;
          const config = {};
          let isReset = false;
          if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
            config.rect = new Rect$1(0, 0, tex.width, tex.height);
            isReset = true;
          }
          if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
            config.originalSize = new Size$1(tex.width, tex.height);
            isReset = true;
          }
          if (isReset) {
            this.reset(config);
          }
          this._checkPackable();
          if (this._mesh) {
            this._updateMesh();
          }
        }
        onLoaded() {
          this._calcTrimmedBorder();
        }
        initDefault(uuid) {
          super.initDefault(uuid);
          const texture = new Texture2D$1();
          texture.initDefault();
          this._refreshTexture(texture);
          this._calculateUV();
        }
        validate() {
          return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
        }
        _initVertices() {
          if (!this.vertices) {
            this.vertices = {
              rawPosition: [],
              positions: [],
              indexes: [],
              uv: [],
              nuv: [],
              minPos: new Vec3(),
              maxPos: new Vec3()
            };
          } else {
            this.vertices.rawPosition.length = 0;
            this.vertices.positions.length = 0;
            this.vertices.indexes.length = 0;
            this.vertices.uv.length = 0;
            this.vertices.nuv.length = 0;
            this.vertices.minPos.set(0, 0, 0);
            this.vertices.maxPos.set(0, 0, 0);
          }
          if (this._meshType === MeshType.POLYGON) ; else {
            const tex = this.texture;
            const texw = tex.width;
            const texh = tex.height;
            const rect = this.rect;
            const width = rect.width;
            const height = rect.height;
            const rectX = rect.x;
            const rectY = texh - rect.y - height;
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const l = texw === 0 ? 0 : rectX / texw;
            const r = texw === 0 ? 1 : (rectX + width) / texw;
            const t = texh === 0 ? 1 : (rectY + height) / texh;
            const b = texh === 0 ? 0 : rect.y / texh;
            temp_vec3.set(-halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(b);
            this.vertices.minPos.set(temp_vec3);
            temp_vec3.set(halfWidth, -halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY + height);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(b);
            temp_vec3.set(-halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(l);
            this.vertices.nuv.push(t);
            temp_vec3.set(halfWidth, halfHeight, 0);
            this.vertices.rawPosition.push(temp_vec3.clone());
            this.vertices.uv.push(rectX + width);
            this.vertices.uv.push(rectY);
            this.vertices.nuv.push(r);
            this.vertices.nuv.push(t);
            this.vertices.maxPos.set(temp_vec3);
            this.vertices.indexes.push(0);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(2);
            this.vertices.indexes.push(1);
            this.vertices.indexes.push(3);
          }
          this._updateMeshVertices();
        }
        _updateMeshVertices() {
          temp_matrix.identity();
          const units = 1 / this._pixelsToUnit;
          const PosX = -(this._pivot.x - 0.5) * this.rect.width * units;
          const PosY = -(this._pivot.y - 0.5) * this.rect.height * units;
          const temp_vec3 = new Vec3(PosX, PosY, 0);
          temp_matrix.transform(temp_vec3);
          temp_vec3.set(units, units, 1);
          temp_matrix.scale(temp_vec3);
          const vertices = this.vertices;
          for (let i = 0; i < vertices.rawPosition.length; i++) {
            const pos = vertices.rawPosition[i];
            Vec3.transformMat4(temp_vec3, pos, temp_matrix);
            Vec3.toArray(vertices.positions, temp_vec3, 3 * i);
          }
          Vec3.transformMat4(this._minPos, vertices.minPos, temp_matrix);
          Vec3.transformMat4(this._maxPos, vertices.maxPos, temp_matrix);
        }
        _createMesh() {
          this._mesh = createMesh({
            primitiveMode: PrimitiveMode.TRIANGLE_LIST,
            positions: this.vertices.positions,
            uvs: this.vertices.nuv,
            indices: this.vertices.indexes,
            minPos: this._minPos,
            maxPos: this._maxPos,
            attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)]
          });
        }
        _updateMesh() {
          if (this._mesh) {
            this._mesh.destroy();
          }
          this._initVertices();
          this._createMesh();
        }
      }, _class2$1p.EVENT_UV_UPDATED = 'uv_updated', _class2$1p.MeshType = MeshType, _class2$1p)) || _class$1w));
      legacyCC.SpriteFrame = SpriteFrame;

      removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
        name: 'hasPremultipliedAlpha'
      }, {
        name: 'setPremultiplyAlpha'
      }, {
        name: 'setFlipY'
      }]);
      replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
        name: 'getGFXWindow',
        customFunction() {
          return this.window;
        }
      }]);

      const RenderingSubMesh = exports('RenderingSubMesh', jsb.RenderingSubMesh);
      const renderingSubMeshProto = RenderingSubMesh.prototype;
      renderingSubMeshProto._ctor = function (vertexBuffers, attributes, primitiveMode, indexBuffer = null, indirectBuffer = null) {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._attributes = attributes;
        this._vertexBuffers = vertexBuffers;
        this._indexBuffer = indexBuffer;
        this._indirectBuffer = indirectBuffer;
      };
      Object.defineProperty(renderingSubMeshProto, 'geometricInfo', {
        configurable: true,
        enumerable: true,
        get() {
          let r = this.getGeometricInfo();
          if (!r.positions && !r.indices) {
            r.positions = new Float32Array();
            r.indices = new Uint8Array();
          }
          return r;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'attributes', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._attributes) {
            this._attributes = this.getAttributes();
          }
          return this._attributes;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'vertexBuffers', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._vertexBuffers) {
            this._vertexBuffers = this.getVertexBuffers();
          }
          return this._vertexBuffers;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'indexBuffer', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._indexBuffer) {
            this._indexBuffer = this.getIndexBuffer();
          }
          return this._indexBuffer;
        }
      });
      Object.defineProperty(renderingSubMeshProto, 'indirectBuffer', {
        configurable: true,
        enumerable: true,
        get() {
          if (!this._indirectBuffer) {
            this._indirectBuffer = this.getIndexBuffer();
          }
          return this._indirectBuffer;
        }
      });

      var _dec$1y, _class$1v, _class2$1o, _initializer$1k;
      let SpriteAtlas = exports('SpriteAtlas', (_dec$1y = ccclass$6('cc.SpriteAtlas'), _dec$1y(_class$1v = (_class2$1o = class SpriteAtlas extends Asset {
        constructor(...args) {
          super(...args);
          this.spriteFrames = _initializer$1k && _initializer$1k();
        }
        getTexture() {
          const keys = Object.keys(this.spriteFrames);
          if (keys.length > 0) {
            const spriteFrame = this.spriteFrames[keys[0]];
            return spriteFrame && spriteFrame.texture;
          } else {
            return null;
          }
        }
        getSpriteFrame(key) {
          const sf = this.spriteFrames[key];
          if (!sf) {
            return null;
          }
          if (!sf.name) {
            sf.name = key;
          }
          return sf;
        }
        getSpriteFrames() {
          const frames = [];
          const spriteFrames = this.spriteFrames;
          for (const key of Object.keys(spriteFrames)) {
            frames.push(spriteFrames[key]);
          }
          return frames;
        }
        _serialize(ctxForExporting) {
        }
        _deserialize(serializeData, handle) {
          const data = serializeData;
          this._name = data.name;
          const frames = data.spriteFrames;
          this.spriteFrames = createMap();
          for (let i = 0; i < frames.length; i += 2) {
            handle.result.push(this.spriteFrames, frames[i], frames[i + 1], getClassId(SpriteFrame));
          }
        }
      }, (_initializer$1k = applyDecoratedInitializer(_class2$1o.prototype, "spriteFrames", [serializable$6], function () {
        return createMap();
      })), _class2$1o)) || _class$1v));
      legacyCC.SpriteAtlas = SpriteAtlas;

      var _dec$1x, _class$1u;
      let Font = exports('Font', (_dec$1x = ccclass$6('cc.Font'), _dec$1x(_class$1u = class Font extends Asset {}) || _class$1u));
      legacyCC.Font = Font;

      var _dec$1w, _class$1t, _class2$1n, _initializer$1j;
      let TTFFont = exports('TTFFont', (_dec$1w = ccclass$6('cc.TTFFont'), _dec$1w(_class$1t = (_class2$1n = class TTFFont extends Font {
        constructor(...args) {
          super(...args);
          this._fontFamily = _initializer$1j && _initializer$1j();
        }
        get _nativeAsset() {
          return this._fontFamily;
        }
        set _nativeAsset(value) {
          this._fontFamily = value || 'Arial';
        }
        get _nativeDep() {
          return {
            uuid: this._uuid,
            __nativeName__: this._native,
            ext: extname(this._native),
            __isNative__: true
          };
        }
        initDefault(uuid) {
          this._fontFamily = 'Arial';
          super.initDefault(uuid);
        }
      }, (_initializer$1j = applyDecoratedInitializer(_class2$1n.prototype, "_fontFamily", [serializable$6], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$1n.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "_nativeAsset"), _class2$1n.prototype), _applyDecoratedDescriptor(_class2$1n.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "_nativeDep"), _class2$1n.prototype)), _class2$1n)) || _class$1t));
      legacyCC.TTFFont = TTFFont;

      const BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
      let _BASELINE_OFFSET$1 = 0;
      const MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
      function getBaselineOffset() {
        return _BASELINE_OFFSET$1;
      }
      const MAX_CACHE_SIZE = 100;
      const pool = new Pool$1(2);
      pool.get = function () {
        return this._get() || {
          key: '',
          value: 0,
          prev: null,
          next: null
        };
      };
      class LRUCache {
        constructor(size) {
          this.count = 0;
          this.limit = 0;
          this.datas = {};
          this.limit = size;
        }
        moveToHead(node) {
          node.next = this.head;
          node.prev = null;
          if (this.head) this.head.prev = node;
          this.head = node;
          if (!this.tail) this.tail = node;
          this.count++;
          this.datas[node.key] = node;
        }
        put(key, value) {
          const node = pool.get();
          node.key = key;
          node.value = value;
          if (this.count >= this.limit) {
            const discard = this.tail;
            delete this.datas[discard.key];
            this.count--;
            this.tail = discard.prev;
            this.tail.next = null;
            discard.prev = null;
            discard.next = null;
            pool.put(discard);
          }
          this.moveToHead(node);
        }
        remove(node) {
          if (node.prev) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }
          if (node.next) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }
          delete this.datas[node.key];
          this.count--;
        }
        get(key) {
          const node = this.datas[key];
          if (node) {
            this.remove(node);
            this.moveToHead(node);
            return node.value;
          }
          return null;
        }
        clear() {
          this.count = 0;
          this.datas = {};
          this.head = null;
          this.tail = null;
        }
        has(key) {
          return !!this.datas[key];
        }
        delete(key) {
          const node = this.datas[key];
          this.remove(node);
        }
      } exports('LRUCache', LRUCache);
      const measureCache = new LRUCache(MAX_CACHE_SIZE);
      const WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/;
      const SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/;
      const LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+|\S)$/;
      const LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+$/;
      const FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]/;
      function isUnicodeCJK(ch) {
        const __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        const __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        const __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      }
      function isUnicodeSpace(ch) {
        const chCode = ch.charCodeAt(0);
        return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
      }
      function safeMeasureText(ctx, string, desc) {
        const font = desc || ctx.font;
        const key = `${font}\uD83C\uDFAE${string}`;
        const cache = measureCache.get(key);
        if (cache !== null) {
          return cache;
        }
        const metric = ctx.measureText(string);
        const width = metric && metric.width || 0;
        measureCache.put(key, width);
        return width;
      }
      function getSymbolLength(str) {
        const length = str.length;
        let count = 0;
        let charCode = 0;
        for (let i = 0; i < length; i++) {
          charCode = str.charCodeAt(i);
          if (charCode === 0x200d) {
            continue;
          }
          if (charCode >= 0xd800 && charCode <= 0xdbff) {
            charCode = str.charCodeAt(i + 1);
            if (charCode >= 0xdc00 && charCode <= 0xdfff) {
              if (i + 2 >= length || str.charCodeAt(i + 2) !== 0x200d) {
                count++;
              }
              i++;
              continue;
            }
          }
          count++;
        }
        return count;
      }
      function getSymbolAt(str, index) {
        const length = str.length;
        let len = 0;
        let count = 0;
        let start = 0;
        let charCode = 0;
        for (let i = 0; i < length; i++) {
          charCode = str.charCodeAt(i);
          if (charCode === 0x200d) {
            len++;
            continue;
          }
          if (charCode >= 0xd800 && charCode <= 0xdbff) {
            len++;
            charCode = str.charCodeAt(i + 1);
            if (charCode >= 0xdc00 && charCode <= 0xdfff) {
              len++;
              if (i + 2 >= length || str.charCodeAt(i + 2) !== 0x200d) {
                if (index === count) {
                  return str.slice(start, start + len);
                }
                start += len;
                count++;
                len = 0;
              }
              i++;
              continue;
            }
          }
          if (index === count) {
            return str.charAt(i);
          }
          start = i + 1;
          count++;
          len = 0;
        }
        return '';
      }
      function getSymbolCodeAt(str, index) {
        const char = getSymbolAt(str, index);
        if (char.length === 1) {
          return `${char.charCodeAt(0)}`;
        }
        let charCodes = '';
        for (let j = 0; j < char.length; j++) {
          charCodes += `${char.charCodeAt(j)}`;
        }
        return `${charCodes}`;
      }
      function getSymbolStartIndex(targetString, index) {
        if (index >= targetString.length) {
          return targetString.length;
        }
        let startCheckIndex = index;
        let startChar = targetString[startCheckIndex];
        while (startCheckIndex >= 0) {
          if (startChar === '\u200d') {
            startCheckIndex--;
            startChar = targetString[startCheckIndex];
          }
          if (startChar >= '\uDC00' && startChar <= '\uDFFF') {
            if (startCheckIndex - 1 >= 0) {
              startCheckIndex--;
              startChar = targetString[startCheckIndex];
            }
          }
          if (startChar >= '\uD800' && startChar <= '\uDBFF') {
            if (startCheckIndex - 1 >= 0 && targetString[startCheckIndex - 1] === '\u200d') {
              startCheckIndex--;
              startChar = targetString[startCheckIndex];
            } else {
              break;
            }
          } else {
            break;
          }
        }
        return startCheckIndex;
      }
      function getSymbolEndIndex(targetString, index) {
        let newEndIndex = index;
        let endCheckIndex = index;
        let endChar = targetString[endCheckIndex];
        while (endCheckIndex < targetString.length) {
          if (endChar === '\u200d') {
            endCheckIndex++;
            newEndIndex++;
            endChar = targetString[endCheckIndex];
            if (endChar >= '\uD800' && endChar <= '\uDBFF') {
              endCheckIndex++;
              newEndIndex++;
              endChar = targetString[endCheckIndex];
            }
          }
          if (endChar >= '\uD800' && endChar <= '\uDBFF') {
            endCheckIndex++;
            newEndIndex++;
            endChar = targetString[endCheckIndex];
          } else if (endChar >= '\uDC00' && endChar <= '\uDFFF') {
            endCheckIndex++;
            endChar = targetString[endCheckIndex];
            if (endCheckIndex < targetString.length && targetString[endCheckIndex] === '\u200d') {
              newEndIndex++;
              endChar = targetString[endCheckIndex];
            } else {
              break;
            }
          } else {
            break;
          }
        }
        return newEndIndex;
      }
      function _safeSubstring(targetString, startIndex, endIndex) {
        let newStartIndex = getSymbolStartIndex(targetString, startIndex);
        if (newStartIndex < startIndex) {
          newStartIndex = getSymbolEndIndex(targetString, startIndex) + 1;
        }
        let newEndIndex = endIndex;
        if (endIndex !== undefined) {
          endIndex = Math.max(0, endIndex - 1);
          newEndIndex = getSymbolEndIndex(targetString, endIndex);
          const newStartEndIndex = getSymbolStartIndex(targetString, endIndex);
          if (newStartEndIndex < newStartIndex || newStartEndIndex === newStartIndex && startIndex > newStartIndex) {
            newEndIndex = newStartIndex;
          } else {
            newEndIndex += 1;
          }
        }
        return targetString.substring(newStartIndex, newEndIndex);
      }
      function isEnglishWordPartAtFirst(stringToken) {
        return FIRST_ENGLISH_REG.test(stringToken);
      }
      function isEnglishWordPartAtLast(stringToken) {
        return LAST_ENGLISH_REG.test(stringToken);
      }
      function getEnglishWordPartAtFirst(stringToken) {
        const result = FIRST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function getEnglishWordPartAtLast(stringToken) {
        const result = LAST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        const wrappedWords = [];
        if (stringToken.length === 0 || maxWidth < 0) {
          wrappedWords.push('');
          return wrappedWords;
        }
        let text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          let fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          let tmpText = _safeSubstring(text, fuzzyLen);
          let width = allWidth - measureText(tmpText);
          let sLine = tmpText;
          let pushNum = 0;
          let checkWhile = 0;
          const checkCount = 100;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (tmpText && width <= maxWidth && checkWhile++ < checkCount) {
            const exec = WORD_REG.exec(tmpText);
            pushNum = exec ? exec[0].length : 1;
            sLine = tmpText;
            fuzzyLen += pushNum;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (fuzzyLen === 0) {
            fuzzyLen = 1;
            sLine = _safeSubstring(text, 1);
          } else if (fuzzyLen === 1 && text[0] >= '\uD800' && text[0] <= '\uDBFF') {
            fuzzyLen = 2;
            sLine = _safeSubstring(text, 2);
          }
          let sText = _safeSubstring(text, 0, fuzzyLen);
          let result;
          {
            if (SYMBOL_REG.test(sLine || tmpText)) {
              result = LAST_WORD_REG.exec(sText);
              fuzzyLen -= result ? result[0].length : 0;
              if (fuzzyLen === 0) {
                fuzzyLen = 1;
              }
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }
          if (FIRST_ENGLISH_REG.test(sLine)) {
            result = LAST_ENGLISH_REG.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }
          if (wrappedWords.length === 0) {
            wrappedWords.push(sText);
          } else {
            sText = sText.trim();
            if (sText.length > 0) {
              wrappedWords.push(sText);
            }
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (wrappedWords.length === 0) {
          wrappedWords.push(text);
        } else {
          text = text.trim();
          if (text.length > 0) {
            wrappedWords.push(text);
          }
        }
        return wrappedWords;
      }

      const ccdocument$1 = ccwindow$1.document;
      let _canvasContext = null;
      let _intervalId = -1;
      const _testString = 'BES bswy:->@123\u4E01\u3041\u1101';
      const _fontFaces = Object.create(null);
      const _loadingFonts = [];
      const _timeout = 3000;
      const useNativeCheck = (() => {
        let nativeCheck;
        return () => {
          if (nativeCheck === undefined) {
            if ('FontFace' in ccwindow$1) {
              const match = /Gecko.*Firefox\/(\d+)/.exec(ccwindow$1.navigator.userAgent);
              const safari10Match = /OS X.*Version\/10\..*Safari/.exec(ccwindow$1.navigator.userAgent) && /Apple/.exec(ccwindow$1.navigator.vendor);
              if (match) {
                nativeCheck = parseInt(match[1], 10) > 42;
              } else if (safari10Match) {
                nativeCheck = false;
              } else {
                nativeCheck = true;
              }
            } else {
              nativeCheck = false;
            }
          }
          return nativeCheck;
        };
      })();
      function checkFontLoaded() {
        let allFontsLoaded = true;
        const now = Date.now();
        for (let i = _loadingFonts.length - 1; i >= 0; i--) {
          const fontLoadHandle = _loadingFonts[i];
          const fontFamily = fontLoadHandle.fontFamilyName;
          if (now - fontLoadHandle.startTime > _timeout) {
            warnID(4933, fontFamily);
            fontLoadHandle.onComplete(null, fontFamily);
            _loadingFonts.splice(i, 1);
            continue;
          }
          const oldWidth = fontLoadHandle.refWidth;
          const fontDesc = `40px ${fontFamily}`;
          _canvasContext.font = fontDesc;
          const newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
          if (oldWidth !== newWidth) {
            _loadingFonts.splice(i, 1);
            fontLoadHandle.onComplete(null, fontFamily);
          } else {
            allFontsLoaded = false;
          }
        }
        if (allFontsLoaded) {
          clearInterval(_intervalId);
          _intervalId = -1;
        }
      }
      function nativeCheckFontLoaded(start, font, callback) {
        const loader = new Promise((resolve, reject) => {
          const check = () => {
            const now = Date.now();
            if (now - start >= _timeout) {
              reject();
            } else {
              ccdocument$1.fonts.load(`40px ${font}`).then(fonts => {
                if (fonts.length >= 1) {
                  resolve();
                } else {
                  setTimeout(check, 100);
                }
              }, () => {
                reject();
              });
            }
          };
          check();
        });
        let timeoutId = null;
        const timer = new Promise((resolve, reject) => {
          timeoutId = setTimeout(reject, _timeout);
        });
        Promise.race([timer, loader]).then(() => {
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          callback(null, font);
        }, () => {
          warnID(4933, font);
          callback(null, font);
        });
      }
      function loadFont(url, options, onComplete) {
        const fontFamilyName = getFontFamily(url);
        if (_fontFaces[fontFamilyName]) {
          onComplete(null, fontFamilyName);
          return;
        }
        if (!_canvasContext) {
          const labelCanvas = ccdocument$1.createElement('canvas');
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext('2d');
        }
        const fontDesc = `40px ${fontFamilyName}`;
        const fontStyle = ccdocument$1.createElement('style');
        fontStyle.type = 'text/css';
        let fontStr = '';
        if (Number.isNaN(fontFamilyName)) {
          fontStr += `@font-face { font-family:${fontFamilyName}; src:`;
        } else {
          fontStr += `@font-face { font-family:"${fontFamilyName}"; src:`;
        }
        fontStr += `url("${url}");`;
        fontStyle.textContent = `${fontStr}}`;
        ccdocument$1.body.appendChild(fontStyle);
        const preloadDiv = ccdocument$1.createElement('div');
        const divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = '.';
        divStyle.position = 'absolute';
        divStyle.left = '-100px';
        divStyle.top = '-100px';
        ccdocument$1.body.appendChild(preloadDiv);
        if (useNativeCheck()) {
          nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
        } else {
          const refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
          const fontLoadHandle = {
            fontFamilyName,
            refWidth,
            onComplete,
            startTime: Date.now()
          };
          _loadingFonts.push(fontLoadHandle);
          if (_intervalId === -1) {
            _intervalId = setInterval(checkFontLoaded, 100);
          }
        }
        _fontFaces[fontFamilyName] = fontStyle;
      }
      function getFontFamily(fontHandle) {
        const ttfIndex = fontHandle.lastIndexOf('.ttf');
        if (ttfIndex === -1) {
          return fontHandle;
        }
        const slashPos = fontHandle.lastIndexOf('/');
        let fontFamilyName;
        if (slashPos === -1) {
          fontFamilyName = `${fontHandle.substring(0, ttfIndex)}_LABEL`;
        } else {
          fontFamilyName = `${fontHandle.substring(slashPos + 1, ttfIndex)}_LABEL`;
        }
        if (fontFamilyName.indexOf(' ') !== -1) {
          fontFamilyName = `"${fontFamilyName}"`;
        }
        return fontFamilyName;
      }
      function createFont(id, data, options, onComplete) {
        const out = new TTFFont();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }
      downloader$1.register({
        '.font': loadFont,
        '.eot': loadFont,
        '.ttf': loadFont,
        '.woff': loadFont,
        '.svg': loadFont,
        '.ttc': loadFont
      });
      factory.register({
        '.font': createFont,
        '.eot': createFont,
        '.ttf': createFont,
        '.woff': createFont,
        '.svg': createFont,
        '.ttc': createFont
      });

      const eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
      const imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
      class HtmlTextParser {
        constructor() {
          this._specialSymbolArray = [];
          this._stack = [];
          this._resultObjectArray = [];
          this._specialSymbolArray.push([/&lt;/g, '<']);
          this._specialSymbolArray.push([/&gt;/g, '>']);
          this._specialSymbolArray.push([/&amp;/g, '&']);
          this._specialSymbolArray.push([/&quot;/g, '"']);
          this._specialSymbolArray.push([/&apos;/g, '\'']);
        }
        parse(htmlString) {
          this._resultObjectArray.length = 0;
          this._stack.length = 0;
          let startIndex = 0;
          const length = htmlString.length;
          while (startIndex < length) {
            let tagEndIndex = htmlString.indexOf('>', startIndex);
            let tagBeginIndex = -1;
            if (tagEndIndex >= 0) {
              tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
              const noTagBegin = tagBeginIndex < startIndex - 1;
              if (noTagBegin) {
                tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
              }
            }
            if (tagBeginIndex < 0) {
              this._stack.pop();
              this._processResult(htmlString.substring(startIndex));
              startIndex = length;
            } else {
              let newStr = htmlString.substring(startIndex, tagBeginIndex);
              const tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
              if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);
              this._processResult(newStr);
              if (tagEndIndex === -1) {
                tagEndIndex = tagBeginIndex;
              } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                this._stack.pop();
              } else {
                this._addToStack(tagStr);
              }
              startIndex = tagEndIndex + 1;
            }
          }
          return this._resultObjectArray;
        }
        _attributeToObject(attribute) {
          attribute = attribute.trim();
          const obj = {};
          let header = /^(color|size)(\s)*=/.exec(attribute);
          let tagName = '';
          let nextSpace = 0;
          let eventHandlerString = '';
          if (header) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();
            if (attribute === '') {
              return obj;
            }
            nextSpace = attribute.indexOf(' ');
            switch (tagName[0]) {
              case 'c':
                if (nextSpace > -1) {
                  obj.color = attribute.substring(0, nextSpace).trim();
                } else {
                  obj.color = attribute;
                }
                break;
              case 's':
                obj.size = parseInt(attribute);
                break;
            }
            if (nextSpace > -1) {
              eventHandlerString = attribute.substring(nextSpace + 1).trim();
              obj.event = this._processEventHandler(eventHandlerString);
            }
            return obj;
          }
          header = /^(br(\s)*\/)/.exec(attribute);
          if (header && header[0].length > 0) {
            tagName = header[0].trim();
            if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
              obj.isNewLine = true;
              this._resultObjectArray.push({
                text: '',
                style: {
                  isNewLine: true
                }
              });
              return obj;
            }
          }
          header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
          let remainingArgument = '';
          let rightQuot = -1;
          if (header && header[0].length > 0) {
            tagName = header[0].trim();
            if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
              header = imageAttrReg.exec(attribute);
              let tagValue;
              let isValidImageTag = false;
              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                const originTagNameLength = tagName.length;
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                remainingArgument = attribute.substring(originTagNameLength).trim();
                if (tagName === 'src') {
                  rightQuot = this.getRightQuotationIndex(remainingArgument);
                } else {
                  rightQuot = -1;
                }
                nextSpace = remainingArgument.indexOf(' ', rightQuot + 1 >= remainingArgument.length ? -1 : rightQuot + 1);
                tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                attribute = remainingArgument.substring(nextSpace).trim();
                if (tagValue.endsWith('/')) {
                  tagValue = tagValue.slice(0, -1);
                }
                if (tagName === 'src') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      isValidImageTag = true;
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }
                  obj.isImage = true;
                  obj.src = tagValue;
                } else if (tagName === 'height') {
                  obj.imageHeight = parseInt(tagValue);
                } else if (tagName === 'width') {
                  obj.imageWidth = parseInt(tagValue);
                } else if (tagName === 'align') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }
                  obj.imageAlign = tagValue.toLowerCase();
                } else if (tagName === 'offset') {
                  obj.imageOffset = tagValue;
                } else if (tagName === 'click') {
                  obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                }
                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }
                header = imageAttrReg.exec(attribute);
              }
              if (isValidImageTag && obj.isImage) {
                this._resultObjectArray.push({
                  text: '',
                  style: obj
                });
              }
              return {};
            }
          }
          header = /^(outline(\s)*[^>]*)/.exec(attribute);
          if (header) {
            attribute = header[0].substring('outline'.length).trim();
            const defaultOutlineObject = {
              color: '#ffffff',
              width: 1
            };
            if (attribute) {
              const outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
              header = outlineAttrReg.exec(attribute);
              let tagValue;
              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                remainingArgument = attribute.substring(tagName.length).trim();
                nextSpace = remainingArgument.indexOf(' ');
                if (nextSpace > -1) {
                  tagValue = remainingArgument.substr(0, nextSpace);
                } else {
                  tagValue = remainingArgument;
                }
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                attribute = remainingArgument.substring(nextSpace).trim();
                if (tagName === 'click') {
                  obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                } else if (tagName === 'color') {
                  defaultOutlineObject.color = tagValue;
                } else if (tagName === 'width') {
                  defaultOutlineObject.width = parseInt(tagValue);
                }
                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }
                header = outlineAttrReg.exec(attribute);
              }
            }
            obj.outline = defaultOutlineObject;
          }
          header = /^(on|u|b|i)(\s)*/.exec(attribute);
          if (header && header[0].length > 0) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();
            switch (tagName[0]) {
              case 'u':
                obj.underline = true;
                break;
              case 'i':
                obj.italic = true;
                break;
              case 'b':
                obj.bold = true;
                break;
            }
            if (attribute === '') {
              return obj;
            }
            obj.event = this._processEventHandler(attribute);
          }
          return obj;
        }
        getRightQuotationIndex(remainingArgument) {
          let leftQuot = -1;
          let rightQuot = -1;
          const leftSingleQuot = remainingArgument.indexOf('\'');
          const leftDoubleQuot = remainingArgument.indexOf('"');
          const useSingleQuot = leftSingleQuot > -1 && (leftSingleQuot < leftDoubleQuot || leftDoubleQuot === -1);
          const useDoubleQuot = leftDoubleQuot > -1 && (leftDoubleQuot < leftSingleQuot || leftSingleQuot === -1);
          if (useSingleQuot) {
            leftQuot = leftSingleQuot;
            rightQuot = remainingArgument.indexOf('\'', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          } else if (useDoubleQuot) {
            leftQuot = leftDoubleQuot;
            rightQuot = remainingArgument.indexOf('"', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          }
          return rightQuot;
        }
        _processEventHandler(eventString) {
          const obj = {};
          let index = 0;
          let isValidTag = false;
          let eventNames = eventRegx.exec(eventString);
          while (eventNames) {
            let eventName = eventNames[0];
            let eventValue = '';
            isValidTag = false;
            eventString = eventString.substring(eventName.length).trim();
            if (eventString.charAt(0) === '"') {
              index = eventString.indexOf('"', 1);
              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }
              index++;
            } else if (eventString.charAt(0) === '\'') {
              index = eventString.indexOf('\'', 1);
              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }
              index++;
            } else {
              const match = /(\S)+/.exec(eventString);
              if (match) {
                eventValue = match[0];
              } else {
                eventValue = '';
              }
              index = eventValue.length;
            }
            if (isValidTag) {
              eventName = eventName.substring(0, eventName.length - 1).trim();
              obj[eventName] = eventValue;
            }
            eventString = eventString.substring(index).trim();
            eventNames = eventRegx.exec(eventString);
          }
          return obj;
        }
        _addToStack(attribute) {
          const obj = this._attributeToObject(attribute);
          if (this._stack.length === 0) {
            this._stack.push(obj);
          } else {
            if (obj.isNewLine || obj.isImage) {
              return;
            }
            const previousTagObj = this._stack[this._stack.length - 1];
            for (const key in previousTagObj) {
              if (!obj[key]) {
                obj[key] = previousTagObj[key];
              }
            }
            this._stack.push(obj);
          }
        }
        _processResult(value) {
          if (value.length === 0) {
            return;
          }
          value = this._escapeSpecialSymbol(value);
          if (this._stack.length > 0) {
            this._resultObjectArray.push({
              text: value,
              style: this._stack[this._stack.length - 1]
            });
          } else {
            this._resultObjectArray.push({
              text: value
            });
          }
        }
        _escapeSpecialSymbol(str) {
          for (const symbolArr of this._specialSymbolArray) {
            const key = symbolArr[0];
            const value = symbolArr[1];
            str = str.replace(key, value);
          }
          return str;
        }
      } exports('HtmlTextParser', HtmlTextParser);

      var _dec$1v, _dec2$1m, _class2$1m, _class3$A, _initializer$1i, _initializer2$1a, _initializer3$W, _initializer4$P;
      class FontLetterDefinition$1 {
        constructor() {
          this.u = 0;
          this.v = 0;
          this.w = 0;
          this.h = 0;
          this.offsetX = 0;
          this.offsetY = 0;
          this.textureID = 0;
          this.valid = false;
          this.xAdvance = 0;
        }
      }
      class FontAtlas {
        constructor(texture) {
          this.letterDefinitions = {};
          this.texture = texture;
        }
        addLetterDefinitions(letter, letterDefinition) {
          this.letterDefinitions[letter] = letterDefinition;
        }
        cloneLetterDefinition() {
          const copyLetterDefinitions = {};
          for (const key of Object.keys(this.letterDefinitions)) {
            const value = new FontLetterDefinition$1();
            mixin(value, this.letterDefinitions[key]);
            copyLetterDefinitions[key] = value;
          }
          return copyLetterDefinitions;
        }
        getTexture() {
          return this.texture;
        }
        getLetter(key) {
          return this.letterDefinitions[key];
        }
        getLetterDefinitionForChar(char, labelInfo) {
          const key = getSymbolCodeAt(char, 0);
          const hasKey = this.letterDefinitions.hasOwnProperty(key);
          let letter;
          if (hasKey) {
            letter = this.letterDefinitions[key];
          } else {
            letter = null;
          }
          return letter;
        }
        clear() {
          this.letterDefinitions = {};
        }
      }
      let BitmapFont = exports('BitmapFont', (_dec$1v = ccclass$6('cc.BitmapFont'), _dec2$1m = type$6(SpriteFrame), _dec$1v(_class2$1m = (_class3$A = class BitmapFont extends Font {
        constructor(...args) {
          super(...args);
          this.fntDataStr = _initializer$1i && _initializer$1i();
          this.spriteFrame = _initializer2$1a && _initializer2$1a();
          this.fontSize = _initializer3$W && _initializer3$W();
          this.fntConfig = _initializer4$P && _initializer4$P();
        }
        onLoaded() {
          const spriteFrame = this.spriteFrame;
          if (!this.fontDefDictionary && spriteFrame) {
            this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
          }
          const fntConfig = this.fntConfig;
          if (!fntConfig) {
            warn('The fnt config is not exists!');
            return;
          }
          const fontDict = fntConfig.fontDefDictionary;
          for (const fontDef in fontDict) {
            const letter = new FontLetterDefinition$1();
            const rect = fontDict[fontDef].rect;
            letter.offsetX = fontDict[fontDef].xOffset;
            letter.offsetY = fontDict[fontDef].yOffset;
            letter.w = rect.width;
            letter.h = rect.height;
            letter.u = rect.x;
            letter.v = rect.y;
            letter.textureID = 0;
            letter.valid = true;
            letter.xAdvance = fontDict[fontDef].xAdvance;
            this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
          }
        }
      }, (_initializer$1i = applyDecoratedInitializer(_class3$A.prototype, "fntDataStr", [serializable$6], function () {
        return '';
      }), _initializer2$1a = applyDecoratedInitializer(_class3$A.prototype, "spriteFrame", [_dec2$1m], function () {
        return null;
      }), _initializer3$W = applyDecoratedInitializer(_class3$A.prototype, "fontSize", [serializable$6], function () {
        return -1;
      }), _initializer4$P = applyDecoratedInitializer(_class3$A.prototype, "fntConfig", [serializable$6], function () {
        return null;
      })), _class3$A)) || _class2$1m));
      legacyCC.BitmapFont = BitmapFont;

      var _dec$1u, _class$1s;
      let LabelAtlas = exports('LabelAtlas', (_dec$1u = ccclass$6('cc.LabelAtlas'), _dec$1u(_class$1s = class LabelAtlas extends BitmapFont {}) || _class$1s));
      legacyCC.LabelAtlas = LabelAtlas;

      let _canvasPool;
      class CanvasPool {
        constructor() {
          this.pool = [];
        }
        static getInstance() {
          if (!_canvasPool) {
            _canvasPool = new CanvasPool();
          }
          return _canvasPool;
        }
        get() {
          let data = this.pool.pop();
          if (!data) {
            const canvas = ccwindow$1.document.createElement('canvas');
            const context = canvas.getContext('2d');
            data = {
              canvas,
              context
            };
          }
          return data;
        }
        put(canvas) {
          if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
            return;
          }
          this.pool.push(canvas);
        }
      }
      const WHITE$1 = Color$1.WHITE.clone();
      const space = 0;
      const bleed = 2;
      class FontLetterDefinition {
        constructor() {
          this.u = 0;
          this.v = 0;
          this.w = 0;
          this.h = 0;
          this.texture = null;
          this.offsetX = 0;
          this.offsetY = 0;
          this.valid = false;
          this.xAdvance = 0;
        }
      }
      const _backgroundStyle = `rgba(255, 255, 255, ${(1 / 255).toFixed(3)})`;
      const BASELINE_OFFSET = getBaselineOffset();
      class LetterTexture {
        constructor(char, labelInfo) {
          this.image = null;
          this.labelInfo = void 0;
          this.char = void 0;
          this.data = null;
          this.canvas = null;
          this.context = null;
          this.width = 0;
          this.height = 0;
          this.offsetY = 0;
          this.hash = void 0;
          this.char = char;
          this.labelInfo = labelInfo;
          this.hash = `${getSymbolCodeAt(char, 0)}${labelInfo.hash}`;
        }
        updateRenderData() {
          this._updateProperties();
          this._updateTexture();
        }
        destroy() {
          this.image = null;
          CanvasPool.getInstance().put(this.data);
        }
        _updateProperties() {
          this.data = CanvasPool.getInstance().get();
          this.canvas = this.data.canvas;
          this.context = this.data.context;
          if (this.context) {
            const fontScale = this.labelInfo.fontScale;
            this.context.font = this.labelInfo.fontDesc;
            const width = safeMeasureText(this.context, this.char, this.labelInfo.fontDesc);
            const blank = this.labelInfo.margin * 2 + bleed;
            this.width = parseFloat(width.toFixed(2)) * fontScale + blank;
            this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize * fontScale + blank;
            this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) * fontScale / 2;
          }
          if (this.canvas.width !== this.width) {
            this.canvas.width = this.width;
          }
          if (this.canvas.height !== this.height) {
            this.canvas.height = this.height;
          }
          if (!this.image) {
            this.image = new ImageAsset$1();
          }
          this.image.reset(this.canvas);
        }
        _updateTexture() {
          if (!this.context || !this.canvas) {
            return;
          }
          const context = this.context;
          const labelInfo = this.labelInfo;
          const width = this.canvas.width;
          const height = this.canvas.height;
          const fontScale = labelInfo.fontScale;
          context.textAlign = 'center';
          context.textBaseline = 'alphabetic';
          context.clearRect(0, 0, width, height);
          context.fillStyle = _backgroundStyle;
          context.fillRect(0, 0, width, height);
          context.font = labelInfo.fontDesc.replace(/(\d+)(\.\d+)?(px|em|rem|pt)/g, (w, m, n, u) => (+m * fontScale + (+n || 0) * fontScale).toString() + u);
          const fontSize = labelInfo.fontSize * fontScale;
          const startX = width / 2;
          const startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
          const color = labelInfo.color;
          context.lineJoin = 'round';
          context.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${1})`;
          if (labelInfo.isOutlined) {
            const strokeColor = labelInfo.out || WHITE$1;
            context.strokeStyle = `rgba(${strokeColor.r}, ${strokeColor.g}, ${strokeColor.b}, ${strokeColor.a / 255})`;
            context.lineWidth = labelInfo.margin * 2 * fontScale;
            context.strokeText(this.char, startX, startY);
          }
          context.fillText(this.char, startX, startY);
        }
      }
      class LetterRenderTexture extends Texture2D$1 {
        initWithSize(width, height, format = PixelFormat.RGBA8888) {
          this.reset({
            width,
            height,
            format
          });
        }
        drawTextureAt(image, x, y) {
          const gfxTexture = this.getGFXTexture();
          if (!image || !gfxTexture) {
            return;
          }
          const gfxDevice = this._getGFXDevice();
          if (!gfxDevice) {
            log('Unable to get device');
            return;
          }
          const region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        }
      }
      class LetterAtlas {
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        constructor(width, height) {
          this._x = space;
          this._y = space;
          this._nextY = space;
          this._width = 0;
          this._height = 0;
          this._halfBleed = 0;
          this._dirty = false;
          const texture = new LetterRenderTexture();
          texture.initWithSize(width, height);
          this.fontDefDictionary = new FontAtlas(texture);
          this._halfBleed = bleed / 2;
          this._width = width;
          this._height = height;
          director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }
        insertLetterTexture(letterTexture) {
          const texture = letterTexture.image;
          const device = director.root.device;
          if (!texture || !this.fontDefDictionary || !device) {
            return null;
          }
          const width = texture.width;
          const height = texture.height;
          if (this._x + width + space > this._width) {
            this._x = space;
            this._y = this._nextY;
          }
          if (this._y + height > this._nextY) {
            this._nextY = this._y + height + space;
          }
          if (this._nextY > this._height) {
            warnID(12100);
            return null;
          }
          this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
          this._dirty = true;
          const letterDefinition = new FontLetterDefinition();
          letterDefinition.u = this._x + this._halfBleed;
          letterDefinition.v = this._y + this._halfBleed;
          letterDefinition.texture = this.fontDefDictionary.texture;
          letterDefinition.valid = true;
          letterDefinition.w = letterTexture.width - bleed;
          letterDefinition.h = letterTexture.height - bleed;
          letterDefinition.xAdvance = letterDefinition.w;
          letterDefinition.offsetY = letterTexture.offsetY;
          this._x += width + space;
          this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
          return letterDefinition;
        }
        update() {
          if (!this._dirty) {
            return;
          }
          this._dirty = false;
        }
        reset() {
          this._x = space;
          this._y = space;
          this._nextY = space;
          this.fontDefDictionary.clear();
        }
        destroy() {
          this.reset();
          if (this.fontDefDictionary) {
            this.fontDefDictionary.texture.destroy();
            this.fontDefDictionary.texture = null;
          }
        }
        getTexture() {
          return this.fontDefDictionary.getTexture();
        }
        beforeSceneLoad() {
          this.clearAllCache();
        }
        clearAllCache() {
          this.destroy();
          const texture = new LetterRenderTexture();
          texture.initWithSize(this._width, this._height);
          this.fontDefDictionary.texture = texture;
        }
        getLetter(key) {
          return this.fontDefDictionary.letterDefinitions[key];
        }
        getLetterDefinitionForChar(char, labelInfo) {
          const hash = getSymbolCodeAt(char, 0) + labelInfo.hash;
          let letter = this.fontDefDictionary.letterDefinitions[hash];
          if (!letter) {
            const temp = new LetterTexture(char, labelInfo);
            temp.updateRenderData();
            letter = this.insertLetterTexture(temp);
            temp.destroy();
          }
          return letter;
        }
      }
      const shareLabelInfo = {
        fontAtlas: null,
        fontSize: 0,
        lineHeight: 0,
        hAlign: 0,
        vAlign: 0,
        hash: '',
        fontFamily: '',
        fontDesc: 'Arial',
        color: Color$1.WHITE.clone(),
        isOutlined: false,
        out: Color$1.WHITE.clone(),
        margin: 0,
        fontScale: 1
      };
      function computeHash(labelInfo) {
        const hashData = '';
        const color = labelInfo.color.toHEX();
        let out = '';
        if (labelInfo.isOutlined && labelInfo.margin > 0) {
          out = out + labelInfo.margin + labelInfo.out.toHEX();
        }
        return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
      }

      const vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
      const vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      const vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      const vfmtPosUvColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      const vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
      const vfmtPosUvTwoColor4B = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA8, true)];
      function getComponentPerVertex(attrs) {
        let count = 0;
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          const info = FormatInfos[attr.format];
          count += info.count;
        }
        return count;
      }
      function getAttributeStride(attrs) {
        let count = 0;
        for (let i = 0; i < attrs.length; i++) {
          const attr = attrs[i];
          const info = FormatInfos[attr.format];
          count += info.size;
        }
        return count;
      }
      legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
      legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;
      legacyCC.internal.vfmtPosUvColor4B = vfmtPosUvColor4B;
      legacyCC.internal.vfmtPosUvTwoColor4B = vfmtPosUvTwoColor4B;

      var vertexFormat = /*#__PURE__*/Object.freeze({
        __proto__: null,
        vfmt: vfmt,
        vfmtPosColor: vfmtPosColor,
        vfmtPosUvColor: vfmtPosUvColor,
        vfmtPosUvColor4B: vfmtPosUvColor4B,
        vfmtPosUvTwoColor: vfmtPosUvTwoColor,
        vfmtPosUvTwoColor4B: vfmtPosUvTwoColor4B,
        getComponentPerVertex: getComponentPerVertex,
        getAttributeStride: getAttributeStride
      });
      exports('UIVertexFormat', vertexFormat);

      const NativeRenderDrawInfo = n2d.RenderDrawInfo;
      n2d.Batcher2d;
      const NativeUIMeshBuffer = n2d.UIMeshBuffer;
      const NativeRenderEntity = n2d.RenderEntity;
      const NativeUIModelProxy = n2d.UIModelProxy;
      n2d.StencilManager;

      var MeshBufferSharedBufferView;
      (function (MeshBufferSharedBufferView) {
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["byteOffset"] = 0] = "byteOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["vertexOffset"] = 1] = "vertexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["indexOffset"] = 2] = "indexOffset";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["dirty"] = 3] = "dirty";
        MeshBufferSharedBufferView[MeshBufferSharedBufferView["count"] = 4] = "count";
      })(MeshBufferSharedBufferView || (MeshBufferSharedBufferView = {}));
      const IA_POOL_USED_SCALE = 1 / 2;
      class MeshBuffer {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get byteOffset() {
          return this._byteOffset;
        }
        set byteOffset(val) {
          this._byteOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.byteOffset] = val;
          }
        }
        get vertexOffset() {
          return this._vertexOffset;
        }
        set vertexOffset(val) {
          this._vertexOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.vertexOffset] = val;
          }
        }
        get indexOffset() {
          return this._indexOffset;
        }
        set indexOffset(val) {
          this._indexOffset = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.indexOffset] = val;
          }
        }
        get dirty() {
          return this._dirty;
        }
        set dirty(val) {
          this._dirty = val;
          {
            this._sharedBuffer[MeshBufferSharedBufferView.dirty] = val ? 1 : 0;
          }
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        set floatsPerVertex(val) {
          this._floatsPerVertex = val;
        }
        get vData() {
          return this._vData;
        }
        set vData(val) {
          this._vData = val;
          {
            this._nativeObj.vData = val;
          }
        }
        get iData() {
          return this._iData;
        }
        set iData(val) {
          this._iData = val;
          {
            this._nativeObj.iData = val;
          }
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get sharedBuffer() {
          return this._sharedBuffer;
        }
        initSharedBuffer() {
          {
            this._sharedBuffer = new Uint32Array(MeshBufferSharedBufferView.count);
          }
        }
        syncSharedBufferToNative() {
          {
            this._nativeObj.syncSharedBufferToNative(this._sharedBuffer);
          }
        }
        constructor() {
          this._byteOffset = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._dirty = false;
          this._floatsPerVertex = 0;
          this._vData = null;
          this._iData = null;
          this._vertexFormatBytes = 0;
          this._initVDataCount = 0;
          this._initIDataCount = 0;
          this._attributes = null;
          this._iaPool = [];
          this._iaInfo = null;
          this._nextFreeIAHandle = 0;
          {
            this._nativeObj = new NativeUIMeshBuffer();
          }
          this.initSharedBuffer();
          this.syncSharedBufferToNative();
        }
        initialize(device, attrs, vFloatCount, iCount) {
          this._initVDataCount = vFloatCount;
          this._initIDataCount = iCount;
          this._attributes = attrs;
          this.floatsPerVertex = getAttributeStride(attrs) >> 2;
          assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));
          if (!this.vData || !this.iData) {
            this.vData = new Float32Array(this._initVDataCount);
            this.iData = new Uint16Array(this._initIDataCount);
          }
          this._iaPool.push(this.createNewIA(device));
          {
            this._nativeObj.initialize(attrs);
          }
        }
        reset() {
          this._nextFreeIAHandle = 0;
          this.dirty = false;
        }
        destroy() {
          this.reset();
          this._attributes = null;
          this._iaInfo = null;
          this.vData = null;
          this.iData = null;
          for (let i = 0; i < this._iaPool.length; ++i) {
            const iaRef = this._iaPool[i];
            if (iaRef.vertexBuffers[0]) {
              iaRef.vertexBuffers[0].destroy();
            }
            if (iaRef.indexBuffer) {
              iaRef.indexBuffer.destroy();
            }
            iaRef.ia.destroy();
          }
          this._iaPool.length = 0;
        }
        setDirty() {
          this.dirty = true;
        }
        request(vertexCount, indexCount) {
          warnID(9002);
          return false;
        }
        requireFreeIA(device) {
          if (this._iaPool.length <= this._nextFreeIAHandle) {
            this._iaPool.push(this.createNewIA(device));
          }
          const ia = this._iaPool[this._nextFreeIAHandle++].ia;
          return ia;
        }
        recycleIA(ia) {
          const pool = this._iaPool;
          for (let i = 0; i < this._nextFreeIAHandle; ++i) {
            if (ia === pool[i].ia) {
              const iaRef = pool[i];
              pool[i] = pool[--this._nextFreeIAHandle];
              pool[this._nextFreeIAHandle] = iaRef;
              return;
            }
          }
        }
        checkCapacity(vertexCount, indexCount) {
          const maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
          const maxIndex = this.indexOffset + indexCount;
          if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
            return false;
          }
          return true;
        }
        uploadBuffers() {
          if (this.byteOffset === 0 || !this._dirty) {
            return;
          }
          const iOS14 = sys.__isWebIOS14OrIPadOS14Env;
          const submitCount = iOS14 ? this._nextFreeIAHandle : 1;
          if (iOS14 && submitCount / this._iaPool.length < IA_POOL_USED_SCALE) {
            const count = submitCount / IA_POOL_USED_SCALE;
            const length = this._iaPool.length;
            for (let i = length - 1; i >= count; i--) {
              const iaRef = this._iaPool[i];
              if (iaRef.vertexBuffers[0]) {
                iaRef.vertexBuffers[0].destroy();
              }
              if (iaRef.indexBuffer) {
                iaRef.indexBuffer.destroy();
              }
              iaRef.ia.destroy();
            }
            this._iaPool.length = count;
          }
          const byteCount = this.byteOffset;
          const indexCount = this.indexOffset;
          for (let i = 0; i < submitCount; ++i) {
            const iaRef = this._iaPool[i];
            const verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
            const indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
            const vertexBuffer = iaRef.vertexBuffers[0];
            if (byteCount > vertexBuffer.size) {
              vertexBuffer.resize(byteCount);
            }
            vertexBuffer.update(verticesData);
            if (indexCount * 2 > iaRef.indexBuffer.size) {
              iaRef.indexBuffer.resize(indexCount * 2);
            }
            iaRef.indexBuffer.update(indicesData);
          }
          this.dirty = false;
        }
        createNewIA(device) {
          let ia;
          let vertexBuffers;
          let indexBuffer;
          if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            const vbStride = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
            const ibStride = Uint16Array.BYTES_PER_ELEMENT;
            const vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride));
            indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
            vertexBuffers = [vertexBuffer];
            this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
            ia = device.createInputAssembler(this._iaInfo);
          } else {
            ia = device.createInputAssembler(this._iaInfo);
            vertexBuffers = this._iaInfo.vertexBuffers;
            indexBuffer = this._iaInfo.indexBuffer;
          }
          return {
            ia,
            vertexBuffers,
            indexBuffer
          };
        }
      } exports('MeshBuffer', MeshBuffer);

      class BufferAccessor {
        get attributes() {
          return this._attributes;
        }
        get vertexFormatBytes() {
          return this._vertexFormatBytes;
        }
        get floatsPerVertex() {
          return this._floatsPerVertex;
        }
        constructor(device, attributes) {
          this._device = null;
          this._attributes = null;
          this._vertexFormatBytes = void 0;
          this._floatsPerVertex = void 0;
          this._buffers = [];
          this._device = device;
          this._attributes = attributes;
          this._floatsPerVertex = getAttributeStride(attributes) >> 2;
          this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
        }
        initialize() {}
        reset() {}
        request(vertexCount = 4, indexCount = 6) {}
        appendBuffers(vertices, indices) {}
        uploadBuffers() {}
        destroy() {
          this._attributes.length = 0;
        }
      }

      const _entryPool = new Pool(() => ({
        offset: 0,
        length: 0
      }), 32);
      class StaticVBChunk {
        get ib() {
          return this._ib;
        }
        constructor(vertexAccessor, bufferId, meshBuffer, vertexOffset, vb, indexCount) {
          this._ib = void 0;
          this.vertexAccessor = vertexAccessor;
          this.bufferId = bufferId;
          this.meshBuffer = meshBuffer;
          this.vertexOffset = vertexOffset;
          this.vb = vb;
          this.indexCount = indexCount;
          this._ib = new Uint16Array(indexCount);
          assertIsTrue(meshBuffer === vertexAccessor.getMeshBuffer(bufferId));
        }
        setIndexBuffer(indices) {
          {
            assertIsTrue(indices.length === this.ib.length);
            for (let i = 0; i < indices.length; ++i) {
              const vid = indices[i];
              this._ib[i] = this.vertexOffset + vid;
            }
          }
        }
      }
      class StaticVBAccessor extends BufferAccessor {
        get id() {
          return this._id;
        }
        constructor(device, attributes, vCount, iCount) {
          super(device, attributes);
          this._freeLists = [];
          this._vCount = 0;
          this._iCount = 0;
          this._id = 0;
          this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / this._vertexFormatBytes);
          this._iCount = iCount || this._vCount * StaticVBAccessor.IB_SCALE;
          this._id = StaticVBAccessor.generateID();
          this._allocateBuffer();
        }
        destroy() {
          for (let i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
            const freeList = this._freeLists[i];
            for (let j = 0; j < freeList.length; ++j) {
              _entryPool.free(freeList[j]);
            }
          }
          this._buffers.length = 0;
          this._freeLists.length = 0;
          super.destroy();
        }
        reset() {
          for (let i = 0; i < this._buffers.length; ++i) {
            const buffer = this._buffers[i];
            buffer.indexOffset = 0;
            buffer.reset();
          }
        }
        getVertexBuffer(bid) {
          return this._buffers[bid].vData;
        }
        getIndexBuffer(bid) {
          return this._buffers[bid].iData;
        }
        getMeshBuffer(bid) {
          return this._buffers[bid];
        }
        uploadBuffers() {
          for (let i = 0; i < this._buffers.length; ++i) {
            const firstEntry = this._freeLists[i][0];
            const buffer = this._buffers[i];
            if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
              buffer.uploadBuffers();
            }
          }
        }
        appendIndices(bufferId, indices) {
          const buf = this._buffers[bufferId];
          const iCount = indices.length;
          if (iCount) {
            const needLength = buf.indexOffset + indices.length;
            if (buf.iData.length < needLength) {
              const expansionLength = Math.floor(1.25 * needLength);
              const newIData = new Uint16Array(expansionLength);
              newIData.set(buf.iData);
              buf.iData = newIData;
            }
            buf.iData.set(indices, buf.indexOffset);
            buf.indexOffset += indices.length;
          }
        }
        allocateChunk(vertexCount, indexCount) {
          const byteLength = vertexCount * this.vertexFormatBytes;
          if (vertexCount > this._vCount || indexCount > this._iCount) {
            errorID(9004, byteLength);
            return null;
          }
          let buf = null;
          let freeList;
          let bid = 0;
          let eid = -1;
          let entry = null;
          for (let i = 0; i < this._buffers.length; ++i) {
            buf = this._buffers[i];
            freeList = this._freeLists[i];
            for (let e = 0; e < freeList.length; ++e) {
              if (freeList[e].length >= byteLength) {
                entry = freeList[e];
                bid = i;
                eid = e;
                break;
              }
            }
            if (entry) break;
          }
          if (!entry) {
            bid = this._allocateBuffer();
            buf = this._buffers[bid];
            if (buf) {
              eid = 0;
              entry = this._freeLists[bid][eid];
            }
          }
          if (entry) {
            const vertexOffset = entry.offset / this.vertexFormatBytes;
            assertIsTrue(Number.isInteger(vertexOffset));
            const vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);
            this._allocateChunkFromEntry(bid, eid, entry, byteLength);
            return new StaticVBChunk(this, bid, buf, vertexOffset, vb, indexCount);
          } else {
            return null;
          }
        }
        recycleChunk(chunk) {
          const freeList = this._freeLists[chunk.bufferId];
          const buf = this._buffers[chunk.bufferId];
          let offset = chunk.vertexOffset * this.vertexFormatBytes;
          let bytes = chunk.vb.byteLength;
          if (bytes === 0) return;
          let recycled = false;
          let i = 0;
          let prevEntry = null;
          let nextEntry = freeList[i];
          while (nextEntry && nextEntry.offset < offset) {
            prevEntry = nextEntry;
            nextEntry = freeList[++i];
          }
          if (prevEntry) {
            const distance = offset - (prevEntry.offset + prevEntry.length);
            assertIsTrue(distance >= 0);
            if (distance === 0) {
              prevEntry.length += bytes;
              offset = prevEntry.offset;
              bytes = prevEntry.length;
              if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                prevEntry.length += nextEntry.length;
                freeList.splice(i, 1);
                _entryPool.free(nextEntry);
                nextEntry = null;
              }
              recycled = true;
            }
          }
          if (!recycled && nextEntry) {
            const distance = nextEntry.offset - (offset + bytes);
            assertIsTrue(distance >= 0);
            if (distance === 0) {
              nextEntry.offset = offset;
              nextEntry.length += bytes;
            } else {
              const newEntry = _entryPool.alloc();
              newEntry.offset = offset;
              newEntry.length = bytes;
              freeList.splice(i, 0, newEntry);
            }
            recycled = true;
          }
          if (recycled) {
            if (offset + bytes === buf.byteOffset) {
              buf.byteOffset = offset;
            }
          } else {
            const newEntry = _entryPool.alloc();
            newEntry.offset = offset;
            newEntry.length = bytes;
            freeList.push(newEntry);
          }
        }
        _allocateChunkFromEntry(bid, eid, entry, bytes) {
          const remaining = entry.length - bytes;
          const offset = entry.offset + bytes;
          const buf = this._buffers[bid];
          if (buf.byteOffset < offset) {
            buf.byteOffset = offset;
          }
          assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);
          if (remaining === 0) {
            this._freeLists[bid].splice(eid, 1);
            _entryPool.free(entry);
          } else {
            entry.offset += bytes;
            entry.length = remaining;
          }
        }
        _allocateBuffer() {
          assertID(this._buffers.length === this._freeLists.length, 9003);
          const buffer = new MeshBuffer();
          const vFloatCount = this._vCount * this._floatsPerVertex;
          buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);
          this._buffers.push(buffer);
          const entry = _entryPool.alloc();
          entry.offset = 0;
          entry.length = buffer.vData.byteLength;
          const freeList = [entry];
          this._freeLists.push(freeList);
          const batcher = director.root.batcher2D;
          batcher.syncMeshBuffersToNative(this.id, this._buffers);
          return this._buffers.length - 1;
        }
        static generateID() {
          return StaticVBAccessor.ID_COUNT++;
        }
      }
      StaticVBAccessor.IB_SCALE = 4;
      StaticVBAccessor.ID_COUNT = 0;

      let AttrUInt8ArrayView;
      (function (AttrUInt8ArrayView) {
        AttrUInt8ArrayView[AttrUInt8ArrayView["DrawInfoType"] = 0] = "DrawInfoType";
        AttrUInt8ArrayView[AttrUInt8ArrayView["VertDirty"] = 1] = "VertDirty";
        AttrUInt8ArrayView[AttrUInt8ArrayView["IsMeshBuffer"] = 2] = "IsMeshBuffer";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Stride"] = 3] = "Stride";
        AttrUInt8ArrayView[AttrUInt8ArrayView["Count"] = 4] = "Count";
      })(AttrUInt8ArrayView || (AttrUInt8ArrayView = {}));
      let AttrUInt16ArrayView;
      (function (AttrUInt16ArrayView) {
        AttrUInt16ArrayView[AttrUInt16ArrayView["BufferID"] = 0] = "BufferID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["AccessorID"] = 1] = "AccessorID";
        AttrUInt16ArrayView[AttrUInt16ArrayView["Count"] = 2] = "Count";
      })(AttrUInt16ArrayView || (AttrUInt16ArrayView = {}));
      let AttrUInt32ArrayView;
      (function (AttrUInt32ArrayView) {
        AttrUInt32ArrayView[AttrUInt32ArrayView["VertexOffset"] = 0] = "VertexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IndexOffset"] = 1] = "IndexOffset";
        AttrUInt32ArrayView[AttrUInt32ArrayView["VBCount"] = 2] = "VBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["IBCount"] = 3] = "IBCount";
        AttrUInt32ArrayView[AttrUInt32ArrayView["DataHash"] = 4] = "DataHash";
        AttrUInt32ArrayView[AttrUInt32ArrayView["Count"] = 5] = "Count";
      })(AttrUInt32ArrayView || (AttrUInt32ArrayView = {}));
      let RenderDrawInfoType;
      (function (RenderDrawInfoType) {
        RenderDrawInfoType[RenderDrawInfoType["COMP"] = 0] = "COMP";
        RenderDrawInfoType[RenderDrawInfoType["MODEL"] = 1] = "MODEL";
        RenderDrawInfoType[RenderDrawInfoType["MIDDLEWARE"] = 2] = "MIDDLEWARE";
        RenderDrawInfoType[RenderDrawInfoType["SUB_NODE"] = 3] = "SUB_NODE";
      })(RenderDrawInfoType || (RenderDrawInfoType = {}));
      class RenderDrawInfo {
        constructor(nativeDrawInfo) {
          this._accId = -1;
          this._bufferId = -1;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vb = null;
          this._ib = null;
          this._vData = null;
          this._iData = null;
          this._vertDirty = false;
          this._vbCount = 0;
          this._ibCount = 0;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._material = null;
          this._texture = null;
          this._sampler = null;
          this._stride = 0;
          this._useLocal = false;
          this._model = null;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._subNode = null;
          this._uint8SharedBuffer = void 0;
          this._uint16SharedBuffer = void 0;
          this._uint32SharedBuffer = void 0;
          this.init(nativeDrawInfo);
          const attrSharedBuffer = this._nativeObj.getAttrSharedBufferForJS();
          let offset = 0;
          this._uint8SharedBuffer = new Uint8Array(attrSharedBuffer, offset, AttrUInt8ArrayView.Count);
          offset += AttrUInt8ArrayView.Count * Uint8Array.BYTES_PER_ELEMENT;
          this._uint16SharedBuffer = new Uint16Array(attrSharedBuffer, offset, AttrUInt16ArrayView.Count);
          offset += AttrUInt16ArrayView.Count * Uint16Array.BYTES_PER_ELEMENT;
          this._uint32SharedBuffer = new Uint32Array(attrSharedBuffer, offset, AttrUInt32ArrayView.Count);
        }
        get nativeObj() {
          return this._nativeObj;
        }
        get render2dBuffer() {
          return this._render2dBuffer;
        }
        init(nativeDrawInfo) {
          {
            if (nativeDrawInfo) {
              this._nativeObj = nativeDrawInfo;
            }
            if (!this._nativeObj) {
              this._nativeObj = new NativeRenderDrawInfo();
            }
          }
        }
        clear() {
          this._bufferId = 0;
          this._vertexOffset = 0;
          this._indexOffset = 0;
          this._vertDirty = false;
        }
        setAccId(accId) {
          {
            if (this._accId !== accId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.AccessorID] = accId;
            }
          }
          this._accId = accId;
        }
        setBufferId(bufferId) {
          {
            if (this._bufferId !== bufferId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.BufferID] = bufferId;
              this._nativeObj.changeMeshBuffer();
            }
          }
          this._bufferId = bufferId;
        }
        setAccAndBuffer(accId, bufferId) {
          {
            if (this._accId !== accId || this._bufferId !== bufferId) {
              this._uint16SharedBuffer[AttrUInt16ArrayView.AccessorID] = accId;
              this._uint16SharedBuffer[AttrUInt16ArrayView.BufferID] = bufferId;
              this._nativeObj.changeMeshBuffer();
            }
          }
          this._bufferId = bufferId;
          this._accId = accId;
        }
        setVertexOffset(vertexOffset) {
          this._vertexOffset = vertexOffset;
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.VertexOffset] = vertexOffset;
          }
        }
        setIndexOffset(indexOffset) {
          this._indexOffset = indexOffset;
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.IndexOffset] = indexOffset;
          }
        }
        setVB(vbBuffer) {
          {
            this._nativeObj.vbBuffer = vbBuffer;
          }
        }
        setIB(ibBuffer) {
          {
            this._nativeObj.ibBuffer = ibBuffer;
          }
        }
        setVData(vDataBuffer) {
          {
            this._nativeObj.vDataBuffer = vDataBuffer;
          }
        }
        setIData(iDataBuffer) {
          {
            this._nativeObj.iDataBuffer = iDataBuffer;
          }
        }
        setVBCount(vbCount) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.VBCount] = vbCount;
          }
          this._vbCount = vbCount;
        }
        setIBCount(ibCount) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.IBCount] = ibCount;
          }
        }
        setVertDirty(val) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.VertDirty] = val ? 1 : 0;
          }
          this._vertDirty = val;
        }
        setDataHash(dataHash) {
          {
            this._uint32SharedBuffer[AttrUInt32ArrayView.DataHash] = dataHash;
          }
          this._dataHash = dataHash;
        }
        setIsMeshBuffer(isMeshBuffer) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.IsMeshBuffer] = isMeshBuffer ? 1 : 0;
          }
          this._isMeshBuffer = isMeshBuffer;
        }
        setMaterial(material) {
          {
            if (this._material !== material) {
              this._nativeObj.material = material;
            }
          }
          this._material = material;
        }
        setTexture(texture) {
          {
            if (this._texture !== texture) {
              this._nativeObj.texture = texture;
            }
          }
          this._texture = texture;
        }
        setSampler(sampler) {
          {
            if (this._sampler !== sampler) {
              this._nativeObj.sampler = sampler;
            }
          }
          this._sampler = sampler;
        }
        setModel(model) {
          {
            if (this._model !== model) {
              this._nativeObj.model = model;
            }
          }
        }
        setDrawInfoType(drawInfoType) {
          {
            if (this._drawInfoType !== drawInfoType) {
              this._uint8SharedBuffer[AttrUInt8ArrayView.DrawInfoType] = drawInfoType;
            }
          }
          this._drawInfoType = drawInfoType;
        }
        setSubNode(node) {
          {
            if (this._subNode !== node) {
              this._nativeObj.subNode = node;
            }
          }
          this._subNode = node;
        }
        setStride(stride) {
          {
            this._uint8SharedBuffer[AttrUInt8ArrayView.Stride] = stride;
          }
          this._stride = stride;
        }
        initRender2dBuffer() {
          {
            this._render2dBuffer = new Float32Array(this._vbCount * this._stride);
            this._nativeObj.setRender2dBufferToNative(this._render2dBuffer);
          }
        }
        fillRender2dBuffer(vertexDataArr) {
          {
            const fillLength = Math.min(this._vbCount, vertexDataArr.length);
            let bufferOffset = 0;
            for (let i = 0; i < fillLength; i++) {
              const temp = vertexDataArr[i];
              this._render2dBuffer[bufferOffset] = temp.x;
              this._render2dBuffer[bufferOffset + 1] = temp.y;
              this._render2dBuffer[bufferOffset + 2] = temp.z;
              bufferOffset += this._stride;
            }
          }
        }
      }

      let Stage;
      (function (Stage) {
        Stage[Stage["DISABLED"] = 0] = "DISABLED";
        Stage[Stage["CLEAR"] = 1] = "CLEAR";
        Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
        Stage[Stage["ENABLED"] = 3] = "ENABLED";
        Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
        Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
        Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
      })(Stage || (Stage = {}));
      let StencilSharedBufferView;
      (function (StencilSharedBufferView) {
        StencilSharedBufferView[StencilSharedBufferView["stencilTest"] = 0] = "stencilTest";
        StencilSharedBufferView[StencilSharedBufferView["func"] = 1] = "func";
        StencilSharedBufferView[StencilSharedBufferView["stencilMask"] = 2] = "stencilMask";
        StencilSharedBufferView[StencilSharedBufferView["writeMask"] = 3] = "writeMask";
        StencilSharedBufferView[StencilSharedBufferView["failOp"] = 4] = "failOp";
        StencilSharedBufferView[StencilSharedBufferView["zFailOp"] = 5] = "zFailOp";
        StencilSharedBufferView[StencilSharedBufferView["passOp"] = 6] = "passOp";
        StencilSharedBufferView[StencilSharedBufferView["ref"] = 7] = "ref";
        StencilSharedBufferView[StencilSharedBufferView["count"] = 8] = "count";
      })(StencilSharedBufferView || (StencilSharedBufferView = {}));
      class StencilManager {
        constructor() {
          this._maskStack = [];
          this._stencilPattern = {
            stencilTest: true,
            func: ComparisonFunc.ALWAYS,
            stencilMask: 0xffff,
            writeMask: 0xffff,
            failOp: StencilOp.KEEP,
            zFailOp: StencilOp.KEEP,
            passOp: StencilOp.KEEP,
            ref: 1
          };
          this._stage = Stage.DISABLED;
          this.stencilStateMap = new Map();
          this.stencilStateMapWithDepth = new Map();
        }
        get stage() {
          return this._stage;
        }
        set stage(val) {
          this._stage = val;
        }
        get pattern() {
          return this._stencilPattern;
        }
        pushMask(mask) {
          this._maskStack.push(mask);
        }
        clear(comp) {
          const isInverted = comp.stencilStage !== Stage.ENTER_LEVEL;
          return isInverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
        }
        enableMask() {
          this.stage = Stage.ENABLED;
        }
        exitMask() {
          if (this._maskStack.length === 0) {
            return;
          }
          this._maskStack.pop();
          if (this._maskStack.length === 0) {
            this.stage = Stage.DISABLED;
          } else {
            this.stage = Stage.ENABLED;
          }
        }
        getWriteMask() {
          return 1 << this._maskStack.length - 1;
        }
        getExitWriteMask() {
          return 1 << this._maskStack.length;
        }
        getStencilRef() {
          let result = 0;
          for (let i = 0; i < this._maskStack.length; ++i) {
            result += 0x00000001 << i;
          }
          return result;
        }
        getMaskStackSize() {
          return this._maskStack.length;
        }
        reset() {
          this._maskStack.length = 0;
          this.stage = Stage.DISABLED;
        }
        destroy() {
          this.stencilStateMap.forEach((value, key) => {
            value.destroy();
          });
          this.stencilStateMap.clear();
        }
        getStencilStage(stage, mat) {
          let key = 0;
          let depthTest = false;
          let depthWrite = false;
          let depthFunc = ComparisonFunc.LESS;
          let cacheMap = this.stencilStateMap;
          if (mat && mat.passes[0]) {
            const pass = mat.passes[0];
            const dss = pass.depthStencilState;
            let depthTestValue = 0;
            let depthWriteValue = 0;
            if (dss.depthTest) depthTestValue = 1;
            if (dss.depthWrite) depthWriteValue = 1;
            key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
            depthTest = dss.depthTest;
            depthWrite = dss.depthWrite;
            depthFunc = dss.depthFunc;
            cacheMap = this.stencilStateMapWithDepth;
          } else {
            key = stage << 16 | this._maskStack.length;
          }
          if (cacheMap && cacheMap.has(key)) {
            return cacheMap.get(key);
          }
          this.setStateFromStage(stage);
          const depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
          cacheMap.set(key, depthStencilState);
          return depthStencilState;
        }
        getStencilHash(stage) {
          return stage << 8 | this._maskStack.length;
        }
        setStateFromStage(stage) {
          const pattern = this._stencilPattern;
          if (stage === Stage.DISABLED) {
            pattern.stencilTest = false;
            pattern.func = ComparisonFunc.ALWAYS;
            pattern.failOp = StencilOp.KEEP;
            pattern.stencilMask = pattern.writeMask = 0xffff;
            pattern.ref = 1;
          } else {
            pattern.stencilTest = true;
            if (stage === Stage.ENABLED) {
              pattern.func = ComparisonFunc.EQUAL;
              pattern.failOp = StencilOp.KEEP;
              pattern.stencilMask = pattern.ref = this.getStencilRef();
              pattern.writeMask = this.getWriteMask();
            } else if (stage === Stage.CLEAR) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.CLEAR_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            }
          }
        }
      } exports('StencilManager', StencilManager);
      StencilManager.sharedManager = null;
      StencilManager.sharedManager = new StencilManager();

      let RenderEntityType;
      (function (RenderEntityType) {
        RenderEntityType[RenderEntityType["STATIC"] = 0] = "STATIC";
        RenderEntityType[RenderEntityType["DYNAMIC"] = 1] = "DYNAMIC";
        RenderEntityType[RenderEntityType["CROSSED"] = 2] = "CROSSED";
      })(RenderEntityType || (RenderEntityType = {}));
      let RenderEntityFloatSharedBufferView;
      (function (RenderEntityFloatSharedBufferView) {
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["localOpacity"] = 0] = "localOpacity";
        RenderEntityFloatSharedBufferView[RenderEntityFloatSharedBufferView["count"] = 1] = "count";
      })(RenderEntityFloatSharedBufferView || (RenderEntityFloatSharedBufferView = {}));
      let RenderEntityUInt8SharedBufferView;
      (function (RenderEntityUInt8SharedBufferView) {
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorR"] = 0] = "colorR";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorG"] = 1] = "colorG";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorB"] = 2] = "colorB";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["colorA"] = 3] = "colorA";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["maskMode"] = 4] = "maskMode";
        RenderEntityUInt8SharedBufferView[RenderEntityUInt8SharedBufferView["count"] = 5] = "count";
      })(RenderEntityUInt8SharedBufferView || (RenderEntityUInt8SharedBufferView = {}));
      let RenderEntityBoolSharedBufferView;
      (function (RenderEntityBoolSharedBufferView) {
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["colorDirty"] = 0] = "colorDirty";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["enabled"] = 1] = "enabled";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["useLocal"] = 2] = "useLocal";
        RenderEntityBoolSharedBufferView[RenderEntityBoolSharedBufferView["count"] = 3] = "count";
      })(RenderEntityBoolSharedBufferView || (RenderEntityBoolSharedBufferView = {}));
      let MaskMode;
      (function (MaskMode) {
        MaskMode[MaskMode["NONE"] = 0] = "NONE";
        MaskMode[MaskMode["MASK"] = 1] = "MASK";
        MaskMode[MaskMode["MASK_INVERTED"] = 2] = "MASK_INVERTED";
        MaskMode[MaskMode["MASK_NODE"] = 3] = "MASK_NODE";
        MaskMode[MaskMode["MASK_NODE_INVERTED"] = 4] = "MASK_NODE_INVERTED";
      })(MaskMode || (MaskMode = {}));
      class RenderEntity {
        get nativeObj() {
          return this._nativeObj;
        }
        get renderDrawInfoArr() {
          return this._dynamicDrawInfoArr;
        }
        get renderEntityType() {
          return this._renderEntityType;
        }
        get color() {
          return this._color;
        }
        set color(val) {
          this._color = val;
          {
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorR] = val.r;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorG] = val.g;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorB] = val.b;
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.colorA] = val.a;
          }
        }
        get localOpacity() {
          return this._localOpacity;
        }
        set localOpacity(val) {
          this._localOpacity = val;
          {
            this._floatSharedBuffer[RenderEntityFloatSharedBufferView.localOpacity] = val;
          }
        }
        get colorDirty() {
          {
            this._colorDirty = !!this._boolSharedBuffer[RenderEntityBoolSharedBufferView.colorDirty];
          }
          return this._colorDirty;
        }
        set colorDirty(val) {
          this._colorDirty = val;
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.colorDirty] = val ? 1 : 0;
          }
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(val) {
          this._enabled = val;
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.enabled] = val ? 1 : 0;
          }
        }
        constructor(entityType) {
          this._renderEntityType = RenderEntityType.STATIC;
          this._dynamicDrawInfoArr = [];
          this._node = null;
          this._renderTransform = null;
          this._stencilStage = Stage.DISABLED;
          this._useLocal = false;
          this._maskMode = MaskMode.NONE;
          this._color = Color$1.WHITE;
          this._localOpacity = 255;
          this._colorDirty = true;
          this._enabled = false;
          {
            if (!this._nativeObj) {
              this._nativeObj = new NativeRenderEntity(entityType);
            }
            this._renderEntityType = entityType;
            this.initSharedBuffer();
          }
        }
        addDynamicRenderDrawInfo(renderDrawInfo) {
          {
            if (renderDrawInfo) {
              this._dynamicDrawInfoArr.push(renderDrawInfo);
              this._nativeObj.addDynamicRenderDrawInfo(renderDrawInfo.nativeObj);
            }
          }
        }
        removeDynamicRenderDrawInfo() {
          {
            this._dynamicDrawInfoArr.pop();
            this._nativeObj.removeDynamicRenderDrawInfo();
          }
        }
        clearDynamicRenderDrawInfos() {
          {
            this._dynamicDrawInfoArr.length = 0;
            this._nativeObj.clearDynamicRenderDrawInfos();
          }
        }
        clearStaticRenderDrawInfos() {
          {
            this._nativeObj.clearStaticRenderDrawInfos();
          }
        }
        setDynamicRenderDrawInfo(renderDrawInfo, index) {
          {
            if (renderDrawInfo) {
              if (this._dynamicDrawInfoArr.length < index + 1) {
                this._dynamicDrawInfoArr.push(renderDrawInfo);
                this._nativeObj.addDynamicRenderDrawInfo(renderDrawInfo.nativeObj);
              } else {
                this._dynamicDrawInfoArr[index] = renderDrawInfo;
                this._nativeObj.setDynamicRenderDrawInfo(renderDrawInfo.nativeObj, index);
              }
            }
          }
        }
        setMaskMode(mode) {
          {
            this._uint8SharedBuffer[RenderEntityUInt8SharedBufferView.maskMode] = mode;
          }
          this._maskMode = mode;
        }
        getStaticRenderDrawInfo() {
          {
            const nativeDrawInfo = this._nativeObj.getStaticRenderDrawInfo(this._nativeObj.staticDrawInfoSize++);
            const drawInfo = new RenderDrawInfo(nativeDrawInfo);
            return drawInfo;
          }
        }
        setNode(node) {
          {
            if (this._node !== node) {
              this._nativeObj.node = node;
            }
          }
          this._node = node;
        }
        setRenderTransform(renderTransform) {
          {
            if (this._renderTransform !== renderTransform) {
              this._nativeObj.renderTransform = renderTransform;
            }
          }
          this._renderTransform = renderTransform;
        }
        setStencilStage(stage) {
          {
            if (this._stencilStage !== stage) {
              this._nativeObj.stencilStage = stage;
            }
          }
          this._stencilStage = stage;
        }
        setUseLocal(useLocal) {
          {
            this._boolSharedBuffer[RenderEntityBoolSharedBufferView.useLocal] = useLocal ? 1 : 0;
          }
          this._useLocal = useLocal;
        }
        initSharedBuffer() {
          {
            const buffer = this._nativeObj.getEntitySharedBufferForJS();
            let offset = 0;
            this._floatSharedBuffer = new Float32Array(buffer, offset, RenderEntityFloatSharedBufferView.count);
            offset += RenderEntityFloatSharedBufferView.count * 4;
            this._uint8SharedBuffer = new Uint8Array(buffer, offset, RenderEntityUInt8SharedBufferView.count);
            offset += RenderEntityUInt8SharedBufferView.count * 1;
            this._boolSharedBuffer = new Uint8Array(buffer, offset, RenderEntityBoolSharedBufferView.count);
          }
        }
      }

      const DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;
      class BaseRenderData {
        get vertexCount() {
          return this._vc;
        }
        get indexCount() {
          return this._ic;
        }
        get stride() {
          return this._floatStride << 2;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vertexFormat() {
          return this._vertexFormat;
        }
        get drawInfoType() {
          return this._drawInfoType;
        }
        set drawInfoType(type) {
          this._drawInfoType = type;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setDrawInfoType(type);
          }
        }
        get renderDrawInfo() {
          return this._renderDrawInfo;
        }
        get material() {
          return this._material;
        }
        set material(val) {
          this._material = val;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setMaterial(val);
          }
        }
        get dataHash() {
          return this._dataHash;
        }
        set dataHash(val) {
          this._dataHash = val;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.setDataHash(val);
          }
        }
        get multiOwner() {
          return this._multiOwner;
        }
        set multiOwner(val) {
          this._multiOwner = val;
        }
        get batcher() {
          if (!this._batcher) {
            this._batcher = director.root.batcher2D;
          }
          return this._batcher;
        }
        constructor(vertexFormat = vfmtPosUvColor) {
          this.chunk = null;
          this._renderDrawInfo = null;
          this._material = null;
          this._dataHash = 0;
          this._isMeshBuffer = false;
          this._vc = 0;
          this._ic = 0;
          this._floatStride = 0;
          this._vertexFormat = vfmtPosUvColor;
          this._drawInfoType = RenderDrawInfoType.COMP;
          this._multiOwner = false;
          this._batcher = null;
          this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          this._vertexFormat = vertexFormat;
        }
        isValid() {
          return this._ic > 0 && this.chunk.vertexAccessor;
        }
        initRenderDrawInfo(comp, drawInfoType = RenderDrawInfoType.COMP) {
          {
            const renderEntity = comp.renderEntity;
            if (renderEntity.renderEntityType === RenderEntityType.STATIC) {
              if (!this._renderDrawInfo) {
                const drawInfo = renderEntity.getStaticRenderDrawInfo();
                if (drawInfo) {
                  this._renderDrawInfo = drawInfo;
                }
              }
            } else if (this.multiOwner === false) {
              if (!this._renderDrawInfo) {
                this._renderDrawInfo = new RenderDrawInfo();
                renderEntity.addDynamicRenderDrawInfo(this._renderDrawInfo);
              }
            }
            this.drawInfoType = drawInfoType;
            this.setRenderDrawInfoAttributes();
          }
        }
        removeRenderDrawInfo(comp) {
          {
            const renderEntity = comp.renderEntity;
            if (renderEntity.renderEntityType === RenderEntityType.DYNAMIC) {
              renderEntity.removeDynamicRenderDrawInfo();
            } else if (renderEntity.renderEntityType === RenderEntityType.STATIC) {
              renderEntity.clearStaticRenderDrawInfos();
            }
          }
        }
        setRenderDrawInfoAttributes() {
          {
            if (!this._renderDrawInfo) {
              return;
            }
            if (this.chunk) {
              this._renderDrawInfo.setBufferId(this.chunk.bufferId);
              this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset);
              this._renderDrawInfo.setVB(this.chunk.vb);
              this._renderDrawInfo.setIB(this.chunk.ib);
              if (this.chunk.meshBuffer) {
                this._renderDrawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
                this._renderDrawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
                this._renderDrawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
              }
            }
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
            this._renderDrawInfo.setDataHash(this.dataHash);
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer);
            this._renderDrawInfo.setMaterial(this.material);
            this._renderDrawInfo.setDrawInfoType(this._drawInfoType);
          }
        }
      } exports('BaseRenderData', BaseRenderData);
      class RenderData extends BaseRenderData {
        static add(vertexFormat = vfmtPosUvColor, accessor) {
          const rd = new RenderData(vertexFormat, accessor);
          if (!accessor) {
            const batcher = director.root.batcher2D;
            accessor = batcher.switchBufferAccessor(rd._vertexFormat);
          }
          rd._accessor = accessor;
          return rd;
        }
        static remove(data) {
          data.clear();
          data._accessor = null;
        }
        get dataLength() {
          return this._data.length;
        }
        set dataLength(length) {
          const data = this._data;
          if (data.length !== length) {
            for (let i = data.length; i < length; i++) {
              data.push({
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color$1.WHITE.clone()
              });
            }
            data.length = length;
          }
          this.syncRender2dBuffer();
        }
        get data() {
          return this._data;
        }
        get vertDirty() {
          return this._vertDirty;
        }
        set vertDirty(val) {
          this._vertDirty = val;
          if (this._renderDrawInfo && val) {
            this._renderDrawInfo.setVertDirty(val);
          }
        }
        get textureHash() {
          return this._textureHash;
        }
        set textureHash(val) {
          this._textureHash = val;
        }
        set frame(val) {
          this._frame = val;
          if (this._renderDrawInfo) {
            if (this._frame) {
              this._renderDrawInfo.setTexture(this._frame.getGFXTexture());
              this._renderDrawInfo.setSampler(this._frame.getGFXSampler());
            } else {
              this._renderDrawInfo.setTexture(null);
              this._renderDrawInfo.setSampler(null);
            }
          }
        }
        get frame() {
          return this._frame;
        }
        get accessor() {
          return this._accessor;
        }
        constructor(vertexFormat = vfmtPosUvColor, accessor) {
          super(vertexFormat);
          this._vertDirty = true;
          this._textureHash = 0;
          this.indices = null;
          this.layer = 0;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this._data = [];
          this._frame = null;
          this._accessor = null;
          this.vertexRow = 1;
          this.vertexCol = 1;
          if (!accessor) {
            accessor = this.batcher.switchBufferAccessor(this._vertexFormat);
          }
          this._accessor = accessor;
        }
        resize(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          if (this.chunk) {
            this._accessor.recycleChunk(this.chunk);
            this.chunk = null;
          }
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          this.updateHash();
          if (this.multiOwner === false && this._renderDrawInfo) {
            this._renderDrawInfo.setDrawInfoType(this._drawInfoType);
            this._renderDrawInfo.setBufferId(this.chunk.bufferId);
            this._renderDrawInfo.setVertexOffset(this.chunk.vertexOffset);
            this._renderDrawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
            this._renderDrawInfo.setVB(this.chunk.vb);
            this._renderDrawInfo.setIB(this.chunk.ib);
            this._renderDrawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
            this._renderDrawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
          }
        }
        setRenderDrawInfoAttributes() {
          {
            if (!this._renderDrawInfo) {
              return;
            }
            this._renderDrawInfo.setAccId(this._accessor.id);
            super.setRenderDrawInfoAttributes();
            this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);
            this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
          }
        }
        fillDrawInfoAttributes(drawInfo) {
          {
            if (!drawInfo) {
              return;
            }
            drawInfo.setDrawInfoType(this._drawInfoType);
            drawInfo.setAccAndBuffer(this._accessor.id, this.chunk.bufferId);
            drawInfo.setVertexOffset(this.chunk.vertexOffset);
            drawInfo.setIndexOffset(this.chunk.meshBuffer.indexOffset);
            drawInfo.setVB(this.chunk.vb);
            drawInfo.setIB(this.chunk.ib);
            drawInfo.setVData(this.chunk.meshBuffer.vData.buffer);
            drawInfo.setIData(this.chunk.meshBuffer.iData.buffer);
            drawInfo.setVBCount(this._vc);
            drawInfo.setIBCount(this._ic);
            drawInfo.setDataHash(this.dataHash);
            drawInfo.setIsMeshBuffer(this._isMeshBuffer);
          }
        }
        syncRender2dBuffer() {
          if (this.multiOwner === false) {
            if (!this._renderDrawInfo) {
              return;
            }
            this.renderDrawInfo.setStride(this.floatStride);
            this.renderDrawInfo.setVBCount(this.dataLength);
            this.renderDrawInfo.initRender2dBuffer();
          }
        }
        resizeAndCopy(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          const oldChunk = this.chunk;
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          if (oldChunk) {
            this.chunk.vb.set(oldChunk.vb);
            this._accessor.recycleChunk(oldChunk);
          }
          this.updateHash();
        }
        getMeshBuffer() {
          if (this.chunk && this._accessor) {
            return this._accessor.getMeshBuffer(this.chunk.bufferId);
          } else {
            return null;
          }
        }
        updateNode(comp) {
          this.layer = comp.node.layer;
          this.nodeDirty = false;
          this.hashDirty = true;
        }
        updatePass(comp) {
          this.material = comp.getRenderMaterial(0);
          this.passDirty = false;
          this.hashDirty = true;
        }
        updateTexture(frame) {
          this.frame = frame;
          this.textureHash = frame.getHash();
          this.textureDirty = false;
          this.hashDirty = true;
        }
        updateHash() {
          const bid = this.chunk ? this.chunk.bufferId : -1;
          const hashString = `${bid}${this.layer} ${this.textureHash}`;
          this.dataHash = murmurhash2_32_gc(hashString, 666);
          this.hashDirty = false;
        }
        updateRenderData(comp, frame) {
          if (this.passDirty) {
            this.material = comp.getRenderMaterial(0);
            this.passDirty = false;
            this.hashDirty = true;
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setMaterial(this.material);
            }
          }
          if (this.nodeDirty) {
            const renderScene = comp.node.scene ? comp._getRenderScene() : null;
            this.layer = comp.node.layer;
            if (renderScene !== null) {
              this.nodeDirty = false;
            }
            this.hashDirty = true;
          }
          if (this.textureDirty) {
            this.frame = frame;
            this.textureHash = frame.getHash();
            this.textureDirty = false;
            this.hashDirty = true;
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setTexture(this.frame ? this.frame.getGFXTexture() : null);
              this._renderDrawInfo.setSampler(this.frame ? this.frame.getGFXSampler() : null);
            }
          }
          if (this.hashDirty) {
            this.updateHash();
            if (this._renderDrawInfo) {
              this._renderDrawInfo.setDataHash(this.dataHash);
            }
          }
          if (this.multiOwner === false) {
            {
              assert(this._renderDrawInfo.render2dBuffer.length === this._floatStride * this._data.length, 'Vertex count doesn\'t match.');
            }
            this._renderDrawInfo.fillRender2dBuffer(this._data);
          }
        }
        clear() {
          this.resize(0, 0);
          this._data.length = 0;
          this.indices = null;
          this.vertDirty = true;
          this.material = null;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this.layer = 0;
          this.frame = null;
          this.textureHash = 0;
          this.dataHash = 0;
          if (this._renderDrawInfo) {
            this._renderDrawInfo.clear();
          }
        }
        static createStaticVBAccessor(attributes, vCount, iCount) {
          const device = director.root.device;
          const accessor = new StaticVBAccessor(device, attributes, vCount, iCount);
          return accessor;
        }
      } exports('RenderData', RenderData);
      class MeshRenderData extends BaseRenderData {
        static add(vertexFormat = vfmtPosUvColor) {
          const rd = new MeshRenderData();
          rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          rd._vertexFormat = vertexFormat;
          return rd;
        }
        static remove(data) {
          data.clear();
        }
        set formatByte(value) {}
        get formatByte() {
          return this.stride;
        }
        get floatStride() {
          return this._floatStride;
        }
        get vDataOffset() {
          return this._byteLength >>> 2;
        }
        constructor(vertexFormat = vfmtPosUvColor) {
          super(vertexFormat);
          this._isMeshBuffer = true;
          this.vData = void 0;
          this.iData = void 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.frame = void 0;
          this._byteLength = 0;
          this._vertexBuffers = [];
          this._indexBuffer = null;
          this._iaPool = null;
          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        }
        request(vertexCount, indexCount) {
          const byteOffset = this._byteLength + vertexCount * this.stride;
          const succeed = this.reserve(vertexCount, indexCount);
          if (!succeed) return false;
          this._vc += vertexCount;
          this._ic += indexCount;
          this._byteLength = byteOffset;
          this.vertexRange = this._vc;
          this.indexRange = this._ic;
          return true;
        }
        reserve(vertexCount, indexCount) {
          const newVBytes = this._byteLength + vertexCount * this.stride;
          const newICount = this.indexCount + indexCount;
          if (vertexCount + this.vertexCount > 65535) {
            return false;
          }
          let byteLength = this.vData.byteLength;
          let indicesLength = this.iData.length;
          let vCount = this.vData.length;
          let iCount = this.iData.length;
          if (newVBytes > byteLength || newICount > indicesLength) {
            while (byteLength < newVBytes || indicesLength < newICount) {
              vCount *= 2;
              iCount *= 2;
              byteLength = vCount * 4;
              indicesLength = iCount;
            }
            this._reallocBuffer(vCount, iCount);
          }
          return true;
        }
        resize(vertexCount, indexCount) {
          const byteLength = vertexCount * this.stride;
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
          this._vc = vertexCount;
          this._ic = indexCount;
          this._byteLength = byteLength;
          this.updateRange(0, vertexCount, 0, indexCount);
        }
        updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
          this.vertexStart = vertOffset;
          this.indexStart = indexOffset;
          this.vertexRange = vertexCount;
          this.indexRange = indexCount;
        }
        requestIA(device) {
          this._initIAInfo(device);
          const ia = this._iaPool.add();
          ia.firstIndex = this.indexStart;
          ia.indexCount = this.indexRange;
          return ia;
        }
        uploadBuffers() {
          if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
            return;
          }
          const indexCount = this._ic;
          const verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
          const indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
          const vertexBuffer = this._vertexBuffers[0];
          if (this._byteLength > vertexBuffer.size) {
            vertexBuffer.resize(this._byteLength);
          }
          vertexBuffer.update(verticesData);
          const indexBytes = indexCount << 1;
          if (indexBytes > this._indexBuffer.size) {
            this._indexBuffer.resize(indexBytes);
          }
          this._indexBuffer.update(indicesData);
        }
        freeIAPool() {
          if (this._iaPool) {
            this._iaPool.reset();
          }
        }
        reset() {
          this._vc = 0;
          this._ic = 0;
          this._byteLength = 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.material = null;
          this.freeIAPool();
        }
        clear() {
          this.reset();
          if (this._iaPool) {
            this._iaPool.destroy();
          }
          if (this._vertexBuffers[0]) {
            this._vertexBuffers[0].destroy();
            this._vertexBuffers = [];
          }
          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        }
        _initIAInfo(device) {
          if (!this._iaInfo) {
            const vbStride = this.stride;
            const vbs = this._vertexBuffers;
            if (!vbs.length) {
              vbs.push(device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbStride, vbStride)));
            }
            const ibStride = Uint16Array.BYTES_PER_ELEMENT;
            if (!this._indexBuffer) {
              this._indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibStride, ibStride));
            }
            this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
            this._iaPool = new RecyclePool(() => device.createInputAssembler(this._iaInfo), 1, ia => {
              ia.destroy();
            });
          }
        }
        _reallocBuffer(vCount, iCount) {
          const oldVData = this.vData;
          this.vData = new Float32Array(vCount);
          if (oldVData) {
            this.vData.set(oldVData, 0);
          }
          const oldIData = this.iData;
          this.iData = new Uint16Array(iCount);
          if (oldIData) {
            this.iData.set(oldIData, 0);
          }
        }
        setRenderDrawInfoAttributes() {
          {
            var _this$frame, _this$frame2;
            if (!this._renderDrawInfo) {
              return;
            }
            this._renderDrawInfo.setVData(this.vData.buffer);
            this._renderDrawInfo.setIData(this.iData.buffer);
            this._renderDrawInfo.setVBCount(this._vc);
            this._renderDrawInfo.setIBCount(this._ic);
            this._renderDrawInfo.setVertexOffset(this.vertexStart);
            this._renderDrawInfo.setIndexOffset(this.indexStart);
            this._renderDrawInfo.setIsMeshBuffer(this._isMeshBuffer);
            this._renderDrawInfo.setMaterial(this.material);
            this._renderDrawInfo.setTexture((_this$frame = this.frame) === null || _this$frame === void 0 ? void 0 : _this$frame.getGFXTexture());
            this._renderDrawInfo.setSampler((_this$frame2 = this.frame) === null || _this$frame2 === void 0 ? void 0 : _this$frame2.getGFXSampler());
          }
        }
        particleInitRenderDrawInfo(entity) {
          {
            if (entity.renderEntityType === RenderEntityType.STATIC) {
              if (!this._renderDrawInfo) {
                const drawInfo = entity.getStaticRenderDrawInfo();
                if (drawInfo) {
                  this._renderDrawInfo = drawInfo;
                }
              }
            }
          }
        }
      } exports('MeshRenderData', MeshRenderData);

      var _dec$1t, _dec2$1l, _class$1r, _class2$1l, _initializer$1h, _initializer2$19, _class3$z;
      const _vec2a = new Vec2();
      const _vec2b = new Vec2();
      const _vec3a = new Vec3();
      const _mat4_temp$1 = new Mat4();
      const _matrix$1 = new Mat4();
      const _worldMatrix$1 = new Mat4();
      const _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const _rect = new Rect$1();
      let UITransform = (_dec$1t = ccclass$6('cc.UITransform'), _dec2$1l = executionOrder$1(110), _dec$1t(_class$1r = _dec2$1l(_class$1r = disallowMultiple$1(_class$1r = (_class2$1l = (_class3$z = class UITransform extends Component {
        constructor(...args) {
          super(...args);
          this._priority = 0;
          this._contentSize = _initializer$1h && _initializer$1h();
          this._anchorPoint = _initializer2$19 && _initializer2$19();
        }
        get contentSize() {
          return this._contentSize;
        }
        set contentSize(value) {
          if (this._contentSize.equals(value)) {
            return;
          }
          {
            this._contentSize.set(value);
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get width() {
          return this._contentSize.width;
        }
        set width(value) {
          if (this._contentSize.width === value) {
            return;
          }
          {
            this._contentSize.width = value;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get height() {
          return this._contentSize.height;
        }
        set height(value) {
          if (this.contentSize.height === value) {
            return;
          }
          {
            this._contentSize.height = value;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        get anchorPoint() {
          return this._anchorPoint;
        }
        set anchorPoint(value) {
          if (this._anchorPoint.equals(value)) {
            return;
          }
          this._anchorPoint.set(value);
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get anchorX() {
          return this._anchorPoint.x;
        }
        set anchorX(value) {
          if (this._anchorPoint.x === value) {
            return;
          }
          this._anchorPoint.x = value;
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get anchorY() {
          return this._anchorPoint.y;
        }
        set anchorY(value) {
          if (this._anchorPoint.y === value) {
            return;
          }
          this._anchorPoint.y = value;
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        get priority() {
          return this._priority;
        }
        set priority(value) {
          if (this._priority === value) {
            return;
          }
          if (this.node.getComponent('cc.RenderRoot2D')) {
            warnID(6706);
            return;
          }
          this._priority = value;
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        get visibility() {
          const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
          return camera ? camera.visibility : 0;
        }
        get cameraPriority() {
          const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
          return camera ? camera.priority : 0;
        }
        __preload() {
          this.node._uiProps.uiTransformComp = this;
        }
        onLoad() {
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        onEnable() {
          this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
          this._markRenderDataDirty();
        }
        onDisable() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
        }
        onDestroy() {
          this.node._uiProps.uiTransformComp = null;
        }
        setContentSize(size, height) {
          const locContentSize = this._contentSize;
          let locWidth;
          let locHeight;
          if (height === undefined) {
            size = size;
            if (approx(size.width, locContentSize.width, EPSILON$2) && approx(size.height, locContentSize.height, EPSILON$2)) {
              return;
            }
            locWidth = size.width;
            locHeight = size.height;
          } else {
            size = size;
            if (approx(size, locContentSize.width, EPSILON$2) && approx(height, locContentSize.height, EPSILON$2)) {
              return;
            }
            locWidth = size;
            locHeight = height;
          }
          {
            locContentSize.width = locWidth;
            locContentSize.height = locHeight;
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }
          this._markRenderDataDirty();
        }
        setAnchorPoint(point, y) {
          const locAnchorPoint = this._anchorPoint;
          if (y === undefined) {
            point = point;
            if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
              return;
            }
            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
          } else {
            if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
              return;
            }
            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
          }
          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);
          this._markRenderDataDirty();
        }
        isHit(uiPoint) {
          const w = this._contentSize.width;
          const h = this._contentSize.height;
          const v2WorldPt = _vec2a;
          const testPt = _vec2b;
          const cameras = this._getRenderScene().cameras;
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (!(camera.visibility & this.node.layer)) continue;
            camera.node.getWorldRT(_mat4_temp$1);
            const m12 = _mat4_temp$1.m12;
            const m13 = _mat4_temp$1.m13;
            const center = visibleRect.center;
            _mat4_temp$1.m12 = center.x - (_mat4_temp$1.m00 * m12 + _mat4_temp$1.m04 * m13);
            _mat4_temp$1.m13 = center.y - (_mat4_temp$1.m01 * m12 + _mat4_temp$1.m05 * m13);
            Mat4.invert(_mat4_temp$1, _mat4_temp$1);
            Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp$1);
            this.node.getWorldMatrix(_worldMatrix$1);
            Mat4.invert(_mat4_temp$1, _worldMatrix$1);
            if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
              continue;
            }
            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            let hit = false;
            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }
            if (hit) {
              return true;
            }
          }
          return false;
        }
        hitTest(screenPoint, windowId = 0) {
          const w = this._contentSize.width;
          const h = this._contentSize.height;
          const v3WorldPt = _vec3a;
          const v2WorldPt = _vec2a;
          const testPt = _vec2b;
          const cameras = this._getRenderScene().cameras;
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (!(camera.visibility & this.node.layer) || camera.window && !camera.window.swapchain) {
              continue;
            }
            if (camera.systemWindowId !== windowId) {
              continue;
            }
            Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
            camera.screenToWorld(v3WorldPt, v3WorldPt);
            Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
            this.node.getWorldMatrix(_worldMatrix$1);
            Mat4.invert(_mat4_temp$1, _worldMatrix$1);
            if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
              continue;
            }
            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            let hit = false;
            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }
            if (hit) {
              return true;
            }
          }
          return false;
        }
        _maskTest(pointInWorldSpace) {
          var _this$node, _this$node$eventProce;
          const maskList = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : (_this$node$eventProce = _this$node.eventProcessor) === null || _this$node$eventProce === void 0 ? void 0 : _this$node$eventProce.maskList;
          if (maskList) {
            let parent = this.node;
            const length = maskList.length;
            for (let i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
              const temp = maskList[j];
              if (i === temp.index) {
                if (parent === temp.comp.node) {
                  const comp = temp.comp;
                  if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                    return false;
                  }
                  j++;
                } else {
                  maskList.length = j;
                  break;
                }
              } else if (i > temp.index) {
                maskList.length = j;
                break;
              }
            }
          }
          return true;
        }
        convertToNodeSpaceAR(worldPoint, out) {
          this.node.getWorldMatrix(_worldMatrix$1);
          Mat4.invert(_mat4_temp$1, _worldMatrix$1);
          if (!out) {
            out = new Vec3();
          }
          return Vec3.transformMat4(out, worldPoint, _mat4_temp$1);
        }
        convertToWorldSpaceAR(nodePoint, out) {
          this.node.getWorldMatrix(_worldMatrix$1);
          if (!out) {
            out = new Vec3();
          }
          return Vec3.transformMat4(out, nodePoint, _worldMatrix$1);
        }
        getBoundingBox() {
          const rect = new Rect$1();
          this._selfBoundingBox(rect);
          Mat4.fromSRT(_matrix$1, this.node.rotation, this.node.position, this.node.scale);
          rect.transformMat4(_matrix$1);
          return rect;
        }
        getBoundingBoxToWorld() {
          const rect = new Rect$1();
          const locChildren = this.node.children;
          for (let i = 0; i < locChildren.length; ++i) {
            const child = locChildren[i];
            if (child && child.active) {
              const uiTransform = child.getComponent(UITransform);
              if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                uiTransform._selfBoundingBox(_rect);
                _rect.transformMat4(child.worldMatrix);
                if (rect.width === 0) {
                  rect.set(_rect);
                } else {
                  Rect$1.union(rect, rect, _rect);
                }
              }
            }
          }
          if (this._contentSize.width && this._contentSize.height) {
            this._selfBoundingBox(_rect);
            _rect.transformMat4(this.node.worldMatrix);
            if (rect.width === 0) {
              rect.set(_rect);
            } else {
              Rect$1.union(rect, rect, _rect);
            }
          }
          return rect;
        }
        getBoundingBoxTo(targetMat) {
          const rect = new Rect$1();
          const locChildren = this.node.children;
          Mat4.invert(_mat4_temp$1, targetMat);
          for (let i = 0; i < locChildren.length; ++i) {
            const child = locChildren[i];
            if (child && child.active) {
              const uiTransform = child.getComponent(UITransform);
              if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                uiTransform._selfBoundingBox(_rect);
                Mat4.multiply(_matrix$1, child.worldMatrix, _mat4_temp$1);
                _rect.transformMat4(_matrix$1);
                if (rect.width === 0) {
                  rect.set(_rect);
                } else {
                  Rect$1.union(rect, rect, _rect);
                }
              }
            }
          }
          if (this._contentSize.width && this._contentSize.height) {
            this._selfBoundingBox(_rect);
            Mat4.multiply(_matrix$1, this.node.worldMatrix, _mat4_temp$1);
            _rect.transformMat4(_matrix$1);
            if (rect.width === 0) {
              rect.set(_rect);
            } else {
              Rect$1.union(rect, rect, _rect);
            }
          }
          return rect;
        }
        getComputeAABB(out) {
          const width = this._contentSize.width;
          const height = this._contentSize.height;
          _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          _rect.transformMat4(this.node.worldMatrix);
          const px = _rect.x + _rect.width * 0.5;
          const py = _rect.y + _rect.height * 0.5;
          const pz = this.node.worldPosition.z;
          const w = _rect.width / 2;
          const h = _rect.height / 2;
          const l = 0.001;
          if (out != null) {
            AABB.set(out, px, py, pz, w, h, l);
            return out;
          } else {
            return new AABB(px, py, pz, w, h, l);
          }
        }
        _selfBoundingBox(out) {
          const width = this._contentSize.width;
          const height = this._contentSize.height;
          out.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          return out;
        }
        _parentChanged(node) {
          if (this.node.getComponent('cc.RenderRoot2D')) {
            return;
          }
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        }
        _markRenderDataDirty() {
          const uiComp = this.node._uiProps.uiComp;
          if (uiComp) {
            uiComp.markForUpdateRenderData();
          }
        }
        static insertChangeMap(node) {
          const key = node.uuid;
          if (!UITransform.priorityChangeNodeMap.has(key)) {
            UITransform.priorityChangeNodeMap.set(key, node);
          }
        }
        static _sortChildrenSibling(node) {
          const siblings = node.children;
          if (siblings) {
            siblings.sort((a, b) => {
              const aComp = a._uiProps.uiTransformComp;
              const bComp = b._uiProps.uiTransformComp;
              const ca = aComp ? aComp._priority : 0;
              const cb = bComp ? bComp._priority : 0;
              const diff = ca - cb;
              if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
              return diff;
            });
          }
        }
        static _sortSiblings() {
          UITransform.priorityChangeNodeMap.forEach((node, ID) => {
            UITransform._sortChildrenSibling(node);
            node._updateSiblingIndex();
            node.emit('childrenSiblingOrderChanged');
          });
          UITransform.priorityChangeNodeMap.clear();
        }
        static _cleanChangeMap() {
          UITransform.priorityChangeNodeMap.clear();
        }
      }, _class3$z.EventType = NodeEventType, _class3$z.priorityChangeNodeMap = new Map(), _class3$z), (_initializer$1h = applyDecoratedInitializer(_class2$1l.prototype, "_contentSize", [serializable$6], function () {
        return new Size$1(100, 100);
      }), _initializer2$19 = applyDecoratedInitializer(_class2$1l.prototype, "_anchorPoint", [serializable$6], function () {
        return new Vec2(0.5, 0.5);
      })), _class2$1l)) || _class$1r) || _class$1r) || _class$1r); exports({ UITransform: UITransform, UITransformComponent: UITransform });
      director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
      director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

      const MaterialInstance = jsb.MaterialInstance;
      const materialInstanceProto = jsb.MaterialInstance.prototype;
      Object.defineProperty(materialInstanceProto, 'parent', {
        configurable: true,
        enumerable: true,
        get() {
          return this._parent;
        }
      });
      Object.defineProperty(materialInstanceProto, 'owner', {
        configurable: true,
        enumerable: true,
        get() {
          return this._owner;
        }
      });
      materialInstanceProto._ctor = function (info) {
        jsb.Material.prototype._ctor.apply(this, arguments);
        this._registerListeners();
        this._parent = info.parent;
        this._owner = info.owner || null;
        this._subModelIdx = info.subModelIdx || 0;
        this._passes = this.getPasses();
      };
      materialInstanceProto._onRebuildPSO = function () {
        if (this._owner) {
          this._owner._onRebuildPSO(this._subModelIdx, this);
        }
      };

      var _dec$1s, _dec2$1k, _dec3$12, _class$1q, _class2$1k, _initializer$1g;
      const _matInsInfo$2 = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      const {
        ccclass: ccclass$5,
        serializable: serializable$5,
        disallowMultiple,
        type: type$5,
        displayOrder: displayOrder$2,
        displayName
      } = _decorator;
      let Renderer = exports('Renderer', (_dec$1s = ccclass$5('cc.Renderer'), _dec2$1k = type$5(Material), _dec3$12 = type$5([Material]), _dec$1s(_class$1q = disallowMultiple(_class$1q = (_class2$1k = class Renderer extends Component {
        constructor(...args) {
          super(...args);
          this._materials = _initializer$1g && _initializer$1g();
          this._materialInstances = [];
        }
        get sharedMaterial() {
          return this.getSharedMaterial(0);
        }
        get sharedMaterials() {
          return this._materials;
        }
        set sharedMaterials(val) {
          for (let i = 0; i < val.length; i++) {
            if (val[i] !== this._materials[i]) {
              this.setSharedMaterial(val[i], i);
            }
          }
          if (val.length < this._materials.length) {
            for (let i = val.length; i < this._materials.length; i++) {
              this.setSharedMaterial(null, i);
            }
            this._materials.splice(val.length);
          }
        }
        get material() {
          return this.getMaterialInstance(0);
        }
        set material(val) {
          if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
            return;
          }
          this.setMaterialInstance(val, 0);
        }
        get materials() {
          for (let i = 0; i < this._materials.length; i++) {
            this._materialInstances[i] = this.getMaterialInstance(i);
          }
          return this._materialInstances;
        }
        set materials(val) {
          const newLength = val.length;
          const oldLength = this._materials.length;
          for (let i = newLength; i < oldLength; i++) {
            this.setMaterialInstance(null, i);
          }
          this._materials.length = newLength;
          this._materialInstances.length = newLength;
          for (let i = 0; i < newLength; i++) {
            if (this._materialInstances[i] != val[i]) {
              this.setMaterialInstance(val[i], i);
            }
          }
        }
        getMaterial(idx) {
          return this.getSharedMaterial(idx);
        }
        setMaterial(material, index) {
          this.setSharedMaterial(material, index);
        }
        getSharedMaterial(idx) {
          if (idx < 0 || idx >= this._materials.length) {
            return null;
          }
          return this._materials[idx];
        }
        setSharedMaterial(material, index) {
          if (material && material instanceof MaterialInstance) {
            errorID(12012);
          }
          this._materials[index] = material;
          const inst = this._materialInstances[index];
          if (inst) {
            inst.destroy();
            this._materialInstances[index] = null;
          }
          this._onMaterialModified(index, this._materials[index]);
        }
        getMaterialInstance(idx) {
          const mat = this._materials[idx];
          if (!mat) {
            return null;
          }
          if (!this._materialInstances[idx]) {
            _matInsInfo$2.parent = this._materials[idx];
            _matInsInfo$2.owner = this;
            _matInsInfo$2.subModelIdx = idx;
            const instantiated = new MaterialInstance(_matInsInfo$2);
            _matInsInfo$2.parent = null;
            _matInsInfo$2.owner = null;
            _matInsInfo$2.subModelIdx = 0;
            this.setMaterialInstance(instantiated, idx);
          }
          return this._materialInstances[idx];
        }
        setMaterialInstance(matInst, index) {
          if (typeof matInst === 'number') {
            warnID(12007);
            const temp = matInst;
            matInst = index;
            index = temp;
          }
          const curInst = this._materialInstances[index];
          if (matInst && matInst.parent) {
            if (matInst !== curInst) {
              this._materialInstances[index] = matInst;
              this._onMaterialModified(index, matInst);
            }
            return;
          }
          if (matInst !== this._materials[index] || curInst) {
            this.setSharedMaterial(matInst, index);
          }
        }
        getRenderMaterial(index) {
          return this._materialInstances[index] || this._materials[index];
        }
        _onMaterialModified(index, material) {}
        _onRebuildPSO(index, material) {}
        _clearMaterials() {}
      }, (_applyDecoratedDescriptor(_class2$1k.prototype, "sharedMaterials", [_dec2$1k], Object.getOwnPropertyDescriptor(_class2$1k.prototype, "sharedMaterials"), _class2$1k.prototype), _initializer$1g = applyDecoratedInitializer(_class2$1k.prototype, "_materials", [_dec3$12], function () {
        return [];
      })), _class2$1k)) || _class$1q) || _class$1q));

      var _dec$1r, _dec2$1j, _dec3$11, _dec4$P, _class$1p, _class2$1j, _initializer$1f, _initializer2$18, _initializer3$V, _initializer4$O, _initializer5$G, _class3$y;
      ccenum(BlendFactor);
      ccenum(BlendOp);
      ccenum(ColorMask);
      let InstanceMaterialType; exports('InstanceMaterialType', InstanceMaterialType);
      (function (InstanceMaterialType) {
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
        InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
      })(InstanceMaterialType || (exports('InstanceMaterialType', InstanceMaterialType = {})));
      let UIRenderer = (_dec$1r = ccclass$6('cc.UIRenderer'), _dec2$1j = requireComponent(UITransform), _dec3$11 = type$6(Material), _dec4$P = type$6(Material), _dec$1r(_class$1p = _dec2$1j(_class$1p = (_class2$1j = (_class3$y = class UIRenderer extends Renderer {
        constructor() {
          super();
          this._renderData = null;
          this._materials = _initializer$1f && _initializer$1f();
          this._customMaterial = _initializer2$18 && _initializer2$18();
          this._srcBlendFactor = _initializer3$V && _initializer3$V();
          this._dstBlendFactor = _initializer4$O && _initializer4$O();
          this._color = _initializer5$G && _initializer5$G();
          this._stencilStage = Stage.DISABLED;
          this._assembler = null;
          this._postAssembler = null;
          this._renderDataFlag = true;
          this._renderFlag = true;
          this._renderEntity = void 0;
          this._instanceMaterialType = -1;
          this._srcBlendFactorCache = BlendFactor.SRC_ALPHA;
          this._dstBlendFactorCache = BlendFactor.ONE_MINUS_SRC_ALPHA;
          this._dirtyVersion = -1;
          this._internalId = -1;
          this._flagChangedVersion = -1;
          this._useVertexOpacity = false;
          this._lastParent = null;
          this._renderEntity = this.createRenderEntity();
        }
        get sharedMaterials() {
          return this._materials;
        }
        set sharedMaterials(val) {
          for (let i = 0; i < val.length; i++) {
            if (val[i] !== this._materials[i]) {
              this.setSharedMaterial(val[i], i);
            }
          }
          if (val.length < this._materials.length) {
            for (let i = val.length; i < this._materials.length; i++) {
              this.setSharedMaterial(null, i);
            }
            this._materials.splice(val.length);
          }
        }
        get customMaterial() {
          return this._customMaterial;
        }
        set customMaterial(val) {
          this._customMaterial = val;
          this.updateMaterial();
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color.equals(value)) {
            return;
          }
          this._color.set(value);
          this._updateColor();
        }
        get renderData() {
          return this._renderData;
        }
        setRenderData(renderData) {
          this._renderData = renderData;
        }
        get useVertexOpacity() {
          return this._useVertexOpacity;
        }
        get stencilStage() {
          return this._stencilStage;
        }
        set stencilStage(val) {
          this._stencilStage = val;
          this._renderEntity.setStencilStage(val);
        }
        get srcBlendFactor() {
          return this._srcBlendFactor;
        }
        set srcBlendFactor(srcBlendFactor) {
          this._srcBlendFactor = srcBlendFactor;
        }
        get batcher() {
          return director.root.batcher2D;
        }
        get renderEntity() {
          {
            assert(Boolean(this._renderEntity), 'this._renderEntity should not be invalid');
          }
          return this._renderEntity;
        }
        onLoad() {
          this._renderEntity.setNode(this.node);
        }
        __preload() {
          this.node._uiProps.uiComp = this;
          if (this._flushAssembler) {
            this._flushAssembler();
          }
        }
        onEnable() {
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          this.updateMaterial();
          this._colorDirty();
          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        }
        onRestore() {
          this.updateMaterial();
          this.markForUpdateRenderData();
        }
        onDisable() {
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          uiRendererManager.removeRenderer(this);
          this._renderFlag = false;
          this._renderEntity.enabled = false;
        }
        onDestroy() {
          this._renderEntity.setNode(null);
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
          this.destroyRenderData();
          if (this._materialInstances) {
            for (let i = 0; i < this._materialInstances.length; i++) {
              const instance = this._materialInstances[i];
              if (instance) {
                instance.destroy();
              }
            }
          }
        }
        markForUpdateRenderData(enable = true) {
          if (enable) {
            const renderData = this._renderData;
            if (renderData) {
              renderData.vertDirty = true;
            }
            uiRendererManager.markDirtyRenderer(this);
          }
        }
        requestRenderData(drawInfoType = RenderDrawInfoType.COMP) {
          const data = RenderData.add();
          data.initRenderDrawInfo(this, drawInfoType);
          this._renderData = data;
          return data;
        }
        destroyRenderData() {
          if (!this._renderData) {
            return;
          }
          this._renderData.removeRenderDrawInfo(this);
          RenderData.remove(this._renderData);
          this._renderData = null;
        }
        updateRenderer() {
          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }
          this._renderFlag = this._canRender();
          this._renderEntity.enabled = this._renderFlag;
        }
        fillBuffers(render) {
          if (this._renderFlag) {
            this._render(render);
          }
        }
        postUpdateAssembler(render) {
          if (this._postAssembler && this._renderFlag) {
            this._postRender(render);
          }
        }
        _render(render) {}
        _postRender(render) {}
        _canRender() {
          {
            assert(this.isValid, 'this component should not be invalid!');
          }
          return this.getSharedMaterial(0) !== null && this._enabled && this._color.a > 0;
        }
        _postCanRender() {}
        updateMaterial() {
          if (this._customMaterial) {
            if (this.getSharedMaterial(0) !== this._customMaterial) {
              this.setSharedMaterial(this._customMaterial, 0);
            }
            return;
          }
          const mat = this._updateBuiltinMaterial();
          this.setSharedMaterial(mat, 0);
          if (this.stencilStage === Stage.ENTER_LEVEL || this.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this.getMaterialInstance(0).recompileShaders({
              USE_ALPHA_TEST: true
            });
          }
          this._updateBlendFunc();
        }
        _updateColor() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
          this.setEntityColor(this._color);
          this.setEntityOpacity(this.node._uiProps.localOpacity);
          if (this._assembler) {
            this._assembler.updateColor(this);
            const renderFlag = this._renderFlag;
            this._renderFlag = this._canRender();
            this.setEntityEnabled(this._renderFlag);
            if (renderFlag !== this._renderFlag) {
              const renderData = this.renderData;
              if (renderData) {
                renderData.vertDirty = true;
              }
            }
          }
        }
        static setEntityColorDirtyRecursively(node, dirty) {
          const render = node._uiProps.uiComp;
          if (render && render.color) {
            render._renderEntity.colorDirty = dirty;
          }
          for (let i = 0; i < node.children.length; i++) {
            UIRenderer.setEntityColorDirtyRecursively(node.children[i], dirty);
          }
        }
        setEntityColorDirty(dirty) {
          {
            UIRenderer.setEntityColorDirtyRecursively(this.node, dirty);
          }
        }
        setEntityColor(color) {
          {
            this._renderEntity.color = color;
          }
        }
        setEntityOpacity(opacity) {
          {
            this._renderEntity.localOpacity = opacity;
          }
        }
        setEntityEnabled(enabled) {
          {
            this._renderEntity.enabled = enabled;
          }
        }
        _updateBlendFunc() {
          let target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
          this._dstBlendFactorCache = target.blendDst;
          this._srcBlendFactorCache = target.blendSrc;
          if (this._dstBlendFactorCache !== this._dstBlendFactor || this._srcBlendFactorCache !== this._srcBlendFactor) {
            target = this.getMaterialInstance(0).passes[0].blendState.targets[0];
            target.blend = true;
            target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
            target.blendDst = this._dstBlendFactor;
            target.blendSrc = this._srcBlendFactor;
            const targetPass = this.getMaterialInstance(0).passes[0];
            targetPass.blendState.setTarget(0, target);
            targetPass._updatePassHash();
            this._dstBlendFactorCache = this._dstBlendFactor;
            this._srcBlendFactorCache = this._srcBlendFactor;
          }
        }
        _nodeStateChange(transformType) {
          if (this._renderData) {
            this.markForUpdateRenderData();
          }
          for (let i = 0; i < this.node.children.length; ++i) {
            const child = this.node.children[i];
            const renderComp = child.getComponent(UIRenderer);
            if (renderComp) {
              renderComp.markForUpdateRenderData();
            }
          }
        }
        _colorDirty() {
          this.node._uiProps.colorDirty = true;
          this.setEntityColorDirty(true);
        }
        _onMaterialModified(idx, material) {
          if (this._renderData) {
            this.markForUpdateRenderData();
            this._renderData.passDirty = true;
          }
          super._onMaterialModified(idx, material);
        }
        _updateBuiltinMaterial() {
          let mat;
          switch (this._instanceMaterialType) {
            case InstanceMaterialType.ADD_COLOR:
              mat = builtinResMgr.get(`ui-base-material`);
              break;
            case InstanceMaterialType.GRAYSCALE:
              mat = builtinResMgr.get(`ui-sprite-gray-material`);
              break;
            case InstanceMaterialType.USE_ALPHA_SEPARATED:
              mat = builtinResMgr.get(`ui-sprite-alpha-sep-material`);
              break;
            case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
              mat = builtinResMgr.get(`ui-sprite-gray-alpha-sep-material`);
              break;
            default:
              mat = builtinResMgr.get(`ui-sprite-material`);
              break;
          }
          return mat;
        }
        setNodeDirty() {
          if (this._renderData) {
            this._renderData.nodeDirty = true;
          }
        }
        setTextureDirty() {
          if (this._renderData) {
            this._renderData.textureDirty = true;
          }
        }
        createRenderEntity() {
          return new RenderEntity(RenderEntityType.STATIC);
        }
      }, _class3$y.BlendState = BlendFactor, _class3$y.Assembler = null, _class3$y.PostAssembler = null, _class3$y), (_applyDecoratedDescriptor(_class2$1j.prototype, "sharedMaterials", [override], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "sharedMaterials"), _class2$1j.prototype), _applyDecoratedDescriptor(_class2$1j.prototype, "customMaterial", [_dec3$11], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "customMaterial"), _class2$1j.prototype), _initializer$1f = applyDecoratedInitializer(_class2$1j.prototype, "_materials", [override], function () {
        return [];
      }), _initializer2$18 = applyDecoratedInitializer(_class2$1j.prototype, "_customMaterial", [_dec4$P], function () {
        return null;
      }), _initializer3$V = applyDecoratedInitializer(_class2$1j.prototype, "_srcBlendFactor", [serializable$6], function () {
        return BlendFactor.SRC_ALPHA;
      }), _initializer4$O = applyDecoratedInitializer(_class2$1j.prototype, "_dstBlendFactor", [serializable$6], function () {
        return BlendFactor.ONE_MINUS_SRC_ALPHA;
      }), _initializer5$G = applyDecoratedInitializer(_class2$1j.prototype, "_color", [serializable$6], function () {
        return Color$1.WHITE.clone();
      })), _class2$1j)) || _class$1p) || _class$1p); exports({ UIRenderer: UIRenderer, RenderComponent: UIRenderer, UIRenderable: UIRenderer, Renderable2D: UIRenderer });
      legacyCC.internal.UIRenderer = UIRenderer;

      class TextStyle {
        constructor() {
          this.isBold = false;
          this.isItalic = false;
          this.isUnderline = false;
          this.underlineHeight = 1;
          this.isOutlined = false;
          this.outlineColor = Color$1.WHITE.clone();
          this.outlineWidth = 1;
          this.hasShadow = false;
          this.shadowColor = Color$1.BLACK.clone();
          this.shadowBlur = 2;
          this.shadowOffsetX = 0;
          this.shadowOffsetY = 0;
          this.color = Color$1.WHITE.clone();
          this.fontSize = 40;
          this.actualFontSize = 0;
          this.isSystemFontUsed = false;
          this.originFontSize = 0;
          this.bmfontScale = 1.0;
          this.fontFamily = 'Arial';
          this.fontDesc = '';
          this.fntConfig = null;
          this.spriteFrame = null;
          this.fontScale = 1;
        }
        reset() {
          this.isBold = false;
          this.isItalic = false;
          this.isUnderline = false;
          this.underlineHeight = 1;
          this.isOutlined = false;
          this.outlineColor.set();
          this.outlineWidth = 1;
          this.hasShadow = false;
          this.shadowColor.set();
          this.shadowBlur = 2;
          this.shadowOffsetX = 0;
          this.shadowOffsetY = 0;
        }
      }

      class TextLayout {
        constructor() {
          this.horizontalAlign = 0;
          this.verticalAlign = 0;
          this.wrapping = true;
          this.overFlow = 0;
          this.lineHeight = 10;
          this.maxLineWidth = 0;
          this.spacingX = 0;
          this.textWidthTemp = 0;
          this.textHeightTemp = 0;
          this.textDimensions = new Size$1();
          this.horizontalKerning = [];
          this.numberOfLines = 1;
          this.linesOffsetX = [];
          this.letterOffsetY = 0;
          this.tailoredTopY = 0;
          this.tailoredBottomY = 0;
          this.textDesiredHeight = 0;
          this.linesWidth = [];
        }
        reset() {
          this.horizontalAlign = 0;
          this.verticalAlign = 0;
          this.wrapping = true;
          this.overFlow = 0;
          this.lineHeight = 10;
          this.maxLineWidth = 0;
          this.spacingX = 0;
          this.textWidthTemp = 0;
          this.textHeightTemp = 0;
          this.textDimensions.set();
          this.horizontalKerning.length = 0;
          this.numberOfLines = 1;
          this.linesOffsetX.length = 0;
          this.letterOffsetY = 0;
          this.tailoredTopY = 0;
          this.tailoredBottomY = 0;
          this.textDesiredHeight = 0;
          this.linesWidth.length = 0;
        }
      }

      class TextOutputLayoutData {
        constructor() {
          this.parsedString = [];
          this.nodeContentSize = Size$1.ZERO.clone();
          this.canvasSize = new Size$1();
          this.canvasPadding = new Rect$1();
          this.contentSizeExtend = Size$1.ZERO.clone();
          this.startPosition = Vec2.ZERO.clone();
        }
        reset() {
          this.parsedString.length = 0;
          this.nodeContentSize.set(0, 0);
          this.canvasSize.set();
          this.canvasPadding.set();
          this.contentSizeExtend.set();
          this.startPosition.set();
        }
      }
      class TextOutputRenderData {
        constructor() {
          this.quadCount = 0;
          this.vertexBuffer = [];
          this.texture = null;
          this.uiTransAnchorX = 0.5;
          this.uiTransAnchorY = 0.5;
        }
        reset() {
          this.quadCount = 0;
          this.vertexBuffer.length = 0;
          this.texture = null;
          this.uiTransAnchorX = 0.5;
          this.uiTransAnchorY = 0.5;
        }
      }

      var _dec$1q, _dec2$1i, _dec3$10, _dec4$O, _dec5$I, _dec6$v, _dec7$p, _class$1o, _class2$1i, _initializer$1e, _initializer2$17, _initializer3$U, _initializer4$N, _initializer5$F, _initializer6$x, _initializer7$s, _initializer8$q, _initializer9$n, _initializer10$k, _initializer11$i, _initializer12$f, _initializer13$e, _initializer14$b, _initializer15$8, _initializer16$8, _initializer17$7, _initializer18$7, _initializer19$6, _initializer20$4, _initializer21$4, _initializer22$3, _initializer23$2, _initializer24$2, _class3$x;
      const tempColor$3 = Color$1.WHITE.clone();
      let HorizontalTextAlignment; exports('HorizontalTextAlignment', HorizontalTextAlignment);
      (function (HorizontalTextAlignment) {
        HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
        HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
        HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
      })(HorizontalTextAlignment || (exports('HorizontalTextAlignment', HorizontalTextAlignment = {})));
      ccenum(HorizontalTextAlignment);
      let VerticalTextAlignment; exports('VerticalTextAlignment', VerticalTextAlignment);
      (function (VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
        VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
        VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
      })(VerticalTextAlignment || (exports('VerticalTextAlignment', VerticalTextAlignment = {})));
      ccenum(VerticalTextAlignment);
      let Overflow$1; exports('Overflow', Overflow$1);
      (function (Overflow) {
        Overflow[Overflow["NONE"] = 0] = "NONE";
        Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
        Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
        Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
      })(Overflow$1 || (exports('Overflow', Overflow$1 = {})));
      ccenum(Overflow$1);
      let CacheMode; exports('CacheMode', CacheMode);
      (function (CacheMode) {
        CacheMode[CacheMode["NONE"] = 0] = "NONE";
        CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
        CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
      })(CacheMode || (exports('CacheMode', CacheMode = {})));
      ccenum(CacheMode);
      let Label = (_dec$1q = ccclass$6('cc.Label'), _dec2$1i = executionOrder$1(110), _dec3$10 = type$6(HorizontalTextAlignment), _dec4$O = type$6(VerticalTextAlignment), _dec5$I = type$6(Overflow$1), _dec6$v = type$6(Font), _dec7$p = type$6(CacheMode), _dec$1q(_class$1o = _dec2$1i(_class$1o = (_class2$1i = (_class3$x = class Label extends UIRenderer {
        get string() {
          return this._string;
        }
        set string(value) {
          if (value === null || value === undefined) {
            value = '';
          } else {
            value = value.toString();
          }
          if (this._string === value) {
            return;
          }
          this._string = value;
          this.markForUpdateRenderData();
        }
        get horizontalAlign() {
          return this._horizontalAlign;
        }
        set horizontalAlign(value) {
          if (this._horizontalAlign === value) {
            return;
          }
          this._horizontalAlign = value;
          this.markForUpdateRenderData();
        }
        get verticalAlign() {
          return this._verticalAlign;
        }
        set verticalAlign(value) {
          if (this._verticalAlign === value) {
            return;
          }
          this._verticalAlign = value;
          this.markForUpdateRenderData();
        }
        get actualFontSize() {
          return this._actualFontSize;
        }
        set actualFontSize(value) {
          this._actualFontSize = value;
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (this._fontSize === value) {
            return;
          }
          this._fontSize = value;
          this.markForUpdateRenderData();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          if (this._lineHeight === value) {
            return;
          }
          this._lineHeight = value;
          this.markForUpdateRenderData();
        }
        get spacingX() {
          return this._spacingX;
        }
        set spacingX(value) {
          if (this._spacingX === value) {
            return;
          }
          this._spacingX = value;
          this.markForUpdateRenderData();
        }
        get overflow() {
          return this._overflow;
        }
        set overflow(value) {
          if (this._overflow === value) {
            return;
          }
          this._overflow = value;
          this.markForUpdateRenderData();
        }
        get enableWrapText() {
          return this._enableWrapText;
        }
        set enableWrapText(value) {
          if (this._enableWrapText === value) {
            return;
          }
          this._enableWrapText = value;
          this.markForUpdateRenderData();
        }
        get useSystemFont() {
          return this._isSystemFontUsed;
        }
        set useSystemFont(value) {
          if (this._isSystemFontUsed === value) {
            return;
          }
          this.destroyRenderData();
          this._isSystemFontUsed = !!value;
          if (value) {
            this.font = null;
          }
          this._flushAssembler();
          this.markForUpdateRenderData();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          if (this._fontFamily === value) {
            return;
          }
          this._fontFamily = value;
          this.markForUpdateRenderData();
        }
        get font() {
          return this._font;
        }
        set font(value) {
          if (this._font === value) {
            return;
          }
          this._isSystemFontUsed = !value;
          this._font = value;
          this.destroyRenderData();
          this._fontAtlas = null;
          this.updateRenderData(true);
        }
        get cacheMode() {
          return this._cacheMode;
        }
        set cacheMode(value) {
          if (this._cacheMode === value) {
            return;
          }
          if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();
          }
          if (this._cacheMode === CacheMode.CHAR) {
            this._ttfSpriteFrame = null;
          }
          this._cacheMode = value;
          this.updateRenderData(true);
        }
        get isBold() {
          return this._isBold;
        }
        set isBold(value) {
          if (this._isBold === value) {
            return;
          }
          this._isBold = value;
          this.markForUpdateRenderData();
        }
        get isItalic() {
          return this._isItalic;
        }
        set isItalic(value) {
          if (this._isItalic === value) {
            return;
          }
          this._isItalic = value;
          this.markForUpdateRenderData();
        }
        get isUnderline() {
          return this._isUnderline;
        }
        set isUnderline(value) {
          if (this._isUnderline === value) {
            return;
          }
          this._isUnderline = value;
          this.markForUpdateRenderData();
        }
        get underlineHeight() {
          return this._underlineHeight;
        }
        set underlineHeight(value) {
          if (this._underlineHeight === value) return;
          this._underlineHeight = value;
          this.markForUpdateRenderData();
        }
        get enableOutline() {
          return this._enableOutline;
        }
        set enableOutline(value) {
          if (this._enableOutline === value) return;
          this._enableOutline = value;
          this.markForUpdateRenderData();
        }
        get outlineColor() {
          return this._outlineColor;
        }
        set outlineColor(value) {
          if (this._outlineColor === value) return;
          this._outlineColor.set(value);
          this.markForUpdateRenderData();
        }
        get outlineWidth() {
          return this._outlineWidth;
        }
        set outlineWidth(value) {
          if (this._outlineWidth === value) return;
          this._outlineWidth = value;
          this.markForUpdateRenderData();
        }
        get enableShadow() {
          return this._enableShadow;
        }
        set enableShadow(value) {
          if (this._enableShadow === value) return;
          this._enableShadow = value;
          this.markForUpdateRenderData();
        }
        get shadowColor() {
          return this._shadowColor;
        }
        set shadowColor(value) {
          if (this._shadowColor === value) return;
          this._shadowColor.set(value);
          this.markForUpdateRenderData();
        }
        get shadowOffset() {
          return this._shadowOffset;
        }
        set shadowOffset(value) {
          if (this._shadowOffset === value) return;
          this._shadowOffset.set(value);
          this.markForUpdateRenderData();
        }
        get shadowBlur() {
          return this._shadowBlur;
        }
        set shadowBlur(value) {
          if (this._shadowBlur === value) return;
          this._shadowBlur = value;
          this.markForUpdateRenderData();
        }
        get spriteFrame() {
          return this._texture;
        }
        get ttfSpriteFrame() {
          return this._ttfSpriteFrame;
        }
        get assemblerData() {
          return this._assemblerData;
        }
        get fontAtlas() {
          return this._fontAtlas;
        }
        set fontAtlas(value) {
          this._fontAtlas = value;
        }
        get _bmFontOriginalSize() {
          if (this._font instanceof BitmapFont) {
            return this._font.fontSize;
          } else {
            return -1;
          }
        }
        get textStyle() {
          return this._textStyle;
        }
        get textLayout() {
          return this._textLayout;
        }
        get textRenderData() {
          return this._textRenderData;
        }
        get textLayoutData() {
          return this._textLayoutData;
        }
        get contentWidth() {
          return this._contentWidth;
        }
        set contentWidth(val) {
          this._contentWidth = val;
        }
        constructor() {
          super();
          this._string = _initializer$1e && _initializer$1e();
          this._horizontalAlign = _initializer2$17 && _initializer2$17();
          this._verticalAlign = _initializer3$U && _initializer3$U();
          this._actualFontSize = _initializer4$N && _initializer4$N();
          this._fontSize = _initializer5$F && _initializer5$F();
          this._fontFamily = _initializer6$x && _initializer6$x();
          this._lineHeight = _initializer7$s && _initializer7$s();
          this._overflow = _initializer8$q && _initializer8$q();
          this._enableWrapText = _initializer9$n && _initializer9$n();
          this._font = _initializer10$k && _initializer10$k();
          this._isSystemFontUsed = _initializer11$i && _initializer11$i();
          this._spacingX = _initializer12$f && _initializer12$f();
          this._isItalic = _initializer13$e && _initializer13$e();
          this._isBold = _initializer14$b && _initializer14$b();
          this._isUnderline = _initializer15$8 && _initializer15$8();
          this._underlineHeight = _initializer16$8 && _initializer16$8();
          this._cacheMode = _initializer17$7 && _initializer17$7();
          this._enableOutline = _initializer18$7 && _initializer18$7();
          this._outlineColor = _initializer19$6 && _initializer19$6();
          this._outlineWidth = _initializer20$4 && _initializer20$4();
          this._enableShadow = _initializer21$4 && _initializer21$4();
          this._shadowColor = _initializer22$3 && _initializer22$3();
          this._shadowOffset = _initializer23$2 && _initializer23$2();
          this._shadowBlur = _initializer24$2 && _initializer24$2();
          this._N$file = null;
          this._texture = null;
          this._ttfSpriteFrame = null;
          this._userDefinedFont = null;
          this._assemblerData = null;
          this._fontAtlas = null;
          this._letterTexture = null;
          this._contentWidth = 0;
          this._textStyle = null;
          this._textLayout = null;
          this._textRenderData = null;
          this._textLayoutData = null;
          this._ttfSpriteFrame = null;
          this._textStyle = new TextStyle();
          this._textLayout = new TextLayout();
          this._textLayoutData = new TextOutputLayoutData();
          this._textRenderData = new TextOutputRenderData();
        }
        onEnable() {
          super.onEnable();
          if (!this._font && !this._isSystemFontUsed) {
            this.useSystemFont = true;
          }
          if (this._isSystemFontUsed && !this._fontFamily) {
            this.fontFamily = 'Arial';
          }
          this._applyFontTexture();
        }
        destroyTtfSpriteFrame() {
          if (!this._ttfSpriteFrame) {
            return;
          }
          this._ttfSpriteFrame._resetDynamicAtlasFrame();
          const tex = this._ttfSpriteFrame.texture;
          this._ttfSpriteFrame.destroy();
          if (tex) {
            const tex2d = tex;
            if (tex2d.image) {
              tex2d.image.destroy();
            }
            tex.destroy();
          }
          this._ttfSpriteFrame = null;
        }
        _onPreDestroy() {
          super._onPreDestroy();
          if (!this._isOnLoadCalled) {
            this.destroyTtfSpriteFrame();
          }
        }
        onDestroy() {
          if (this._assembler && this._assembler.resetAssemblerData) {
            this._assembler.resetAssemblerData(this._assemblerData);
          }
          this._assemblerData = null;
          this.destroyTtfSpriteFrame();
          this._letterTexture = null;
          super.onDestroy();
        }
        updateRenderData(force = false) {
          if (force) {
            this._flushAssembler();
            if (this.renderData) this.renderData.vertDirty = true;
            this._applyFontTexture();
          }
          if (this._assembler) {
            this._assembler.updateRenderData(this);
          }
        }
        _render(render) {
          render.commitComp(this, this.renderData, this._texture, this._assembler, null);
        }
        _updateColor() {
          super._updateColor();
          this.markForUpdateRenderData();
        }
        setEntityColor(color) {
          {
            if (this._font instanceof BitmapFont) {
              this._renderEntity.color = color;
            } else {
              tempColor$3.set(255, 255, 255, color.a);
              this._renderEntity.color = tempColor$3;
            }
          }
        }
        _canRender() {
          if (!super._canRender() || !this._string) {
            return false;
          }
          const font = this._font;
          if (font && font instanceof BitmapFont) {
            const spriteFrame = font.spriteFrame;
            if (!spriteFrame || !spriteFrame.texture) {
              return false;
            }
          }
          return true;
        }
        _flushAssembler() {
          const assembler = Label.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
            this.textStyle.reset();
            this.textLayout.reset();
            this.textLayoutData.reset();
            this.textRenderData.reset();
          }
          if (!this.renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this.renderData.material = this.material;
              this._updateColor();
            }
          }
        }
        _applyFontTexture() {
          this.markForUpdateRenderData();
          const font = this._font;
          if (font instanceof BitmapFont) {
            const spriteFrame = font.spriteFrame;
            if (spriteFrame && spriteFrame.texture) {
              this._texture = spriteFrame;
              if (this.renderData) {
                this.renderData.textureDirty = true;
              }
              this.changeMaterialForDefine();
              if (this._assembler) {
                this._assembler.updateRenderData(this);
              }
            }
          } else {
            if (this.cacheMode === CacheMode.CHAR) {
              this._letterTexture = this._assembler.getAssemblerData();
              this._texture = this._letterTexture;
            } else if (!this._ttfSpriteFrame) {
              this._ttfSpriteFrame = new SpriteFrame();
              this._assemblerData = this._assembler.getAssemblerData();
              const image = new ImageAsset$1(this._assemblerData.canvas);
              const texture = new Texture2D$1();
              texture.image = image;
              this._ttfSpriteFrame.texture = texture;
            }
            if (this.cacheMode !== CacheMode.CHAR) {
              this._texture = this._ttfSpriteFrame;
            }
            this.changeMaterialForDefine();
          }
        }
        changeMaterialForDefine() {
          if (!this._texture) {
            return;
          }
          let value = false;
          if (this.cacheMode !== CacheMode.CHAR) {
            const spriteFrame = this._texture;
            const texture = spriteFrame.texture;
            if (texture instanceof TextureBase) {
              const format = texture.getPixelFormat();
              value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
            }
          }
          if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }
          this.updateMaterial();
        }
        _updateBlendFunc() {
          super._updateBlendFunc();
        }
      }, _class3$x.HorizontalAlign = HorizontalTextAlignment, _class3$x.VerticalAlign = VerticalTextAlignment, _class3$x.Overflow = Overflow$1, _class3$x.CacheMode = CacheMode, _class3$x._canvasPool = CanvasPool.getInstance(), _class3$x), (_applyDecoratedDescriptor(_class2$1i.prototype, "horizontalAlign", [_dec3$10], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "horizontalAlign"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "verticalAlign", [_dec4$O], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "verticalAlign"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "overflow", [_dec5$I], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "overflow"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "font", [_dec6$v], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "font"), _class2$1i.prototype), _applyDecoratedDescriptor(_class2$1i.prototype, "cacheMode", [_dec7$p], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "cacheMode"), _class2$1i.prototype), _initializer$1e = applyDecoratedInitializer(_class2$1i.prototype, "_string", [serializable$6], function () {
        return 'label';
      }), _initializer2$17 = applyDecoratedInitializer(_class2$1i.prototype, "_horizontalAlign", [serializable$6], function () {
        return HorizontalTextAlignment.CENTER;
      }), _initializer3$U = applyDecoratedInitializer(_class2$1i.prototype, "_verticalAlign", [serializable$6], function () {
        return VerticalTextAlignment.CENTER;
      }), _initializer4$N = applyDecoratedInitializer(_class2$1i.prototype, "_actualFontSize", [serializable$6], function () {
        return 0;
      }), _initializer5$F = applyDecoratedInitializer(_class2$1i.prototype, "_fontSize", [serializable$6], function () {
        return 40;
      }), _initializer6$x = applyDecoratedInitializer(_class2$1i.prototype, "_fontFamily", [serializable$6], function () {
        return 'Arial';
      }), _initializer7$s = applyDecoratedInitializer(_class2$1i.prototype, "_lineHeight", [serializable$6], function () {
        return 40;
      }), _initializer8$q = applyDecoratedInitializer(_class2$1i.prototype, "_overflow", [serializable$6], function () {
        return Overflow$1.NONE;
      }), _initializer9$n = applyDecoratedInitializer(_class2$1i.prototype, "_enableWrapText", [serializable$6], function () {
        return true;
      }), _initializer10$k = applyDecoratedInitializer(_class2$1i.prototype, "_font", [serializable$6], function () {
        return null;
      }), _initializer11$i = applyDecoratedInitializer(_class2$1i.prototype, "_isSystemFontUsed", [serializable$6], function () {
        return true;
      }), _initializer12$f = applyDecoratedInitializer(_class2$1i.prototype, "_spacingX", [serializable$6], function () {
        return 0;
      }), _initializer13$e = applyDecoratedInitializer(_class2$1i.prototype, "_isItalic", [serializable$6], function () {
        return false;
      }), _initializer14$b = applyDecoratedInitializer(_class2$1i.prototype, "_isBold", [serializable$6], function () {
        return false;
      }), _initializer15$8 = applyDecoratedInitializer(_class2$1i.prototype, "_isUnderline", [serializable$6], function () {
        return false;
      }), _initializer16$8 = applyDecoratedInitializer(_class2$1i.prototype, "_underlineHeight", [serializable$6], function () {
        return 2;
      }), _initializer17$7 = applyDecoratedInitializer(_class2$1i.prototype, "_cacheMode", [serializable$6], function () {
        return CacheMode.NONE;
      }), _initializer18$7 = applyDecoratedInitializer(_class2$1i.prototype, "_enableOutline", [serializable$6], function () {
        return false;
      }), _initializer19$6 = applyDecoratedInitializer(_class2$1i.prototype, "_outlineColor", [serializable$6], function () {
        return new Color$1(0, 0, 0, 255);
      }), _initializer20$4 = applyDecoratedInitializer(_class2$1i.prototype, "_outlineWidth", [serializable$6], function () {
        return 2;
      }), _initializer21$4 = applyDecoratedInitializer(_class2$1i.prototype, "_enableShadow", [serializable$6], function () {
        return false;
      }), _initializer22$3 = applyDecoratedInitializer(_class2$1i.prototype, "_shadowColor", [serializable$6], function () {
        return new Color$1(0, 0, 0, 255);
      }), _initializer23$2 = applyDecoratedInitializer(_class2$1i.prototype, "_shadowOffset", [serializable$6], function () {
        return new Vec2(2, 2);
      }), _initializer24$2 = applyDecoratedInitializer(_class2$1i.prototype, "_shadowBlur", [serializable$6], function () {
        return 2;
      })), _class2$1i)) || _class$1o) || _class$1o); exports({ Label: Label, LabelComponent: Label });
      legacyCC.Label = Label;

      let _stageOffset = 0;
      const _name2stageID = {};
      var config = {
        addStage(name) {
          if (_name2stageID[name] !== undefined) {
            return;
          }
          const stageID = 1 << _stageOffset;
          _name2stageID[name] = stageID;
          _stageOffset += 1;
        },
        stageID(name) {
          const id = _name2stageID[name];
          if (id === undefined) {
            return -1;
          }
          return id;
        },
        stageIDs(nameList) {
          let key = 0;
          for (const name of nameList) {
            const id = _name2stageID[name];
            if (id !== undefined) {
              key |= id;
            }
          }
          return key;
        }
      };

      function createIA(device, data) {
        if (!data.positions) {
          console.error('The data must have positions field');
          return null;
        }
        const verts = [];
        const vcount = data.positions.length / 3;
        for (let i = 0; i < vcount; ++i) {
          verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);
          if (data.normals) {
            verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
          }
          if (data.uvs) {
            verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
          }
          if (data.colors) {
            verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
          }
        }
        const vfmt = [];
        vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));
        if (data.normals) {
          vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
        }
        if (data.uvs) {
          vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
        }
        if (data.colors) {
          vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
        }
        const vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
        vb.update(new Float32Array(verts));
        let ib = null;
        if (data.indices) {
          ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
          ib.update(new Uint16Array(data.indices));
        }
        return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
      }

      let RenderQueue;
      (function (RenderQueue) {
        RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
        RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
        RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
      })(RenderQueue || (RenderQueue = {}));
      let PassStage;
      (function (PassStage) {
        PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
        PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
        PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
      })(PassStage || (PassStage = {}));

      const typeMask = 0xfc000000;
      const bindingMask = 0x03f00000;
      const countMask = 0x000ff000;
      const offsetMask = 0x00000fff;
      const genHandle = (binding, type, count, offset = 0) => type << 26 & typeMask | binding << 20 & bindingMask | count << 12 & countMask | offset & offsetMask;
      const getTypeFromHandle = handle => (handle & typeMask) >>> 26;
      const getBindingFromHandle = handle => (handle & bindingMask) >>> 20;
      const getCountFromHandle = handle => (handle & countMask) >>> 12;
      const getOffsetFromHandle = handle => handle & offsetMask;
      const customizeType = (handle, type) => handle & ~typeMask | type << 26 & typeMask;
      const type2reader = {
        [Type$1.UNKNOWN]: (a, v, idx = 0) => warnID(12010, idx),
        [Type$1.INT]: (a, v, idx = 0) => a[idx],
        [Type$1.INT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
        [Type$1.INT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
        [Type$1.INT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
        [Type$1.FLOAT]: (a, v, idx = 0) => a[idx],
        [Type$1.FLOAT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
        [Type$1.FLOAT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
        [Type$1.FLOAT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
        [Type$1.MAT3]: (a, v, idx = 0) => Mat3.fromArray(v, a, idx),
        [Type$1.MAT4]: (a, v, idx = 0) => Mat4.fromArray(v, a, idx)
      };
      const type2writer = {
        [Type$1.UNKNOWN]: (a, v, idx = 0) => warnID(12010, idx),
        [Type$1.INT]: (a, v, idx = 0) => a[idx] = v,
        [Type$1.INT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
        [Type$1.INT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
        [Type$1.INT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
        [Type$1.FLOAT]: (a, v, idx = 0) => a[idx] = v,
        [Type$1.FLOAT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
        [Type$1.FLOAT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
        [Type$1.FLOAT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
        [Type$1.MAT3]: (a, v, idx = 0) => Mat3.toArray(a, v, idx),
        [Type$1.MAT4]: (a, v, idx = 0) => Mat4.toArray(a, v, idx)
      };
      const type2validator = {
        [Type$1.INT]: v => typeof v === 'number',
        [Type$1.FLOAT]: v => typeof v === 'number',
        [Type$1.INT2]: v => !!(v instanceof Vec2),
        [Type$1.FLOAT2]: v => !!(v instanceof Vec2),
        [Type$1.INT3]: v => !!(v instanceof Vec3),
        [Type$1.FLOAT3]: v => !!(v instanceof Vec3),
        [Type$1.INT4]: v => !!(v instanceof Vec4),
        [Type$1.FLOAT4]: v => !!(v instanceof Vec4 || v instanceof Color$1 || v instanceof Quat),
        [Type$1.MAT3]: v => !!(v instanceof Mat3),
        [Type$1.MAT4]: v => !!(v instanceof Mat4)
      };
      const defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
      function getDefaultFromType(type) {
        switch (type) {
          case Type$1.BOOL:
          case Type$1.INT:
          case Type$1.UINT:
          case Type$1.FLOAT:
            return defaultValues[0];
          case Type$1.BOOL2:
          case Type$1.INT2:
          case Type$1.UINT2:
          case Type$1.FLOAT2:
            return defaultValues[1];
          case Type$1.BOOL4:
          case Type$1.INT4:
          case Type$1.UINT4:
          case Type$1.FLOAT4:
            return defaultValues[2];
          case Type$1.MAT4:
            return defaultValues[3];
          case Type$1.SAMPLER2D:
            return 'default-texture';
          case Type$1.SAMPLER_CUBE:
            return 'default-cube-texture';
          case Type$1.SAMPLER2D_ARRAY:
            return 'default-array-texture';
          case Type$1.SAMPLER3D:
            return 'default-3d-texture';
        }
        return defaultValues[0];
      }
      function getStringFromType(type) {
        switch (type) {
          case Type$1.SAMPLER2D:
            return '-texture';
          case Type$1.SAMPLER_CUBE:
            return '-cube-texture';
          case Type$1.SAMPLER2D_ARRAY:
            return '-array-texture';
          case Type$1.SAMPLER3D:
            return '-3d-texture';
          default:
            return '-unknown';
        }
      }
      function overrideMacros(target, source) {
        const entries = Object.entries(source);
        let isDifferent = false;
        for (let i = 0; i < entries.length; i++) {
          if (target[entries[i][0]] !== entries[i][1]) {
            target[entries[i][0]] = entries[i][1];
            isDifferent = true;
          }
        }
        return isDifferent;
      }

      let BatchingSchemes;
      (function (BatchingSchemes) {
        BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
        BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
      })(BatchingSchemes || (BatchingSchemes = {}));
      const Pass = jsb.Pass;
      const proto = Pass.prototype;
      proto.getUniform = function getUniform(handle, out) {
        const val = this._getUniform(handle);
        if (typeof val === 'object') {
          if (val.type) {
            switch (val.type) {
              case MathType$1.VEC2:
                Vec2.copy(out, val);
                break;
              case MathType$1.VEC3:
                Vec3.copy(out, val);
                break;
              case MathType$1.VEC4:
                Vec4.copy(out, val);
                break;
              case MathType$1.COLOR:
                out.x = val.x;
                out.y = val.y;
                out.z = val.z;
                out.w = val.w;
                break;
              case MathType$1.MAT3:
                Mat3.copy(out, val);
                break;
              case MathType$1.MAT4:
                Mat4.copy(out, val);
                break;
              case MathType$1.QUATERNION:
                Quat.copy(out, val);
                break;
              default:
                console.error(`getUniform, unknown object type: ${val.type}`);
                break;
            }
          } else {
            console.error(`getUniform, unknown object: ${val}`);
          }
        } else if (typeof val === 'number') {
          out = val;
        } else {
          console.error(`getUniform, not supported: ${val}`);
        }
        return out;
      };

      function getDeviceShaderVersion(device) {
        switch (device.gfxAPI) {
          case API.GLES2:
          case API.WEBGL:
            return 'glsl1';
          case API.GLES3:
          case API.WEBGL2:
            return 'glsl3';
          default:
            return 'glsl4';
        }
      }
      const programLib = jsb.ProgramLib.getInstance();
      legacyCC.programLib = programLib;

      function nearestPOT(num) {
        --num;
        num |= num >> 16;
        num |= num >> 8;
        num |= num >> 4;
        num |= num >> 2;
        num |= num >> 1;
        ++num;
        return num;
      }
      function roundUp(n, alignment) {
        return Math.ceil(n / alignment) * alignment;
      }
      class TextureBufferPool {
        constructor(device) {
          this._device = void 0;
          this._format = Format.UNKNOWN;
          this._formatSize = 0;
          this._chunks = [];
          this._chunkCount = 0;
          this._handles = [];
          this._region0 = new BufferTextureCopy();
          this._region1 = new BufferTextureCopy();
          this._region2 = new BufferTextureCopy();
          this._roundUpFn = null;
          this._bufferViewCtor = Uint8Array;
          this._channels = 4;
          this._alignment = 1;
          this._device = device;
        }
        initialize(info) {
          const formatInfo = FormatInfos[info.format];
          this._format = info.format;
          this._formatSize = formatInfo.size;
          this._channels = formatInfo.count;
          this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
          this._roundUpFn = info.roundUpFn || null;
          this._alignment = info.alignment || 1;
          if (info.inOrderFree) {
            this.alloc = this._McDonaldAlloc;
          }
        }
        destroy() {
          for (let i = 0; i < this._chunkCount; ++i) {
            const chunk = this._chunks[i];
            chunk.texture.destroy();
          }
          this._chunks.length = 0;
          this._handles.length = 0;
        }
        alloc(size, chunkIdx) {
          size = roundUp(size, this._alignment);
          let index = -1;
          let start = -1;
          if (chunkIdx !== undefined) {
            index = chunkIdx;
            start = this._findAvailableSpace(size, index);
          }
          if (start < 0) {
            for (let i = 0; i < this._chunkCount; ++i) {
              index = i;
              start = this._findAvailableSpace(size, index);
              if (start >= 0) {
                break;
              }
            }
          }
          if (start >= 0) {
            const chunk = this._chunks[index];
            chunk.start += size;
            const handle = {
              chunkIdx: index,
              start,
              end: start + size,
              texture: chunk.texture
            };
            this._handles.push(handle);
            return handle;
          }
          const targetSize = Math.sqrt(size / this._formatSize);
          const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
          const newChunk = this._chunks[this.createChunk(texLength)];
          newChunk.start += size;
          const texHandle = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: size,
            texture: newChunk.texture
          };
          this._handles.push(texHandle);
          return texHandle;
        }
        free(handle) {
          for (let i = 0; i < this._handles.length; ++i) {
            if (this._handles[i] === handle) {
              this._chunks[handle.chunkIdx].end = handle.end;
              this._handles.splice(i, 1);
              return;
            }
          }
        }
        createChunk(length) {
          const texSize = length * length * this._formatSize;
          debug(`TextureBufferPool: Allocate chunk ${this._chunkCount}, size: ${texSize}, format: ${this._format}`);
          const texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length));
          const chunk = {
            texture,
            size: texSize,
            start: 0,
            end: texSize
          };
          this._chunks[this._chunkCount] = chunk;
          return this._chunkCount++;
        }
        update(handle, buffer) {
          const buffers = [];
          const regions = [];
          const start = handle.start / this._formatSize;
          let remainSize = buffer.byteLength / this._formatSize;
          let offsetX = start % handle.texture.width;
          let offsetY = Math.floor(start / handle.texture.width);
          let copySize = Math.min(handle.texture.width - offsetX, remainSize);
          let begin = 0;
          if (offsetX > 0) {
            this._region0.texOffset.x = offsetX;
            this._region0.texOffset.y = offsetY;
            this._region0.texExtent.width = copySize;
            this._region0.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region0);
            offsetX = 0;
            offsetY += 1;
            remainSize -= copySize;
            begin += copySize;
          }
          if (remainSize > 0) {
            this._region1.texOffset.x = offsetX;
            this._region1.texOffset.y = offsetY;
            if (remainSize > handle.texture.width) {
              this._region1.texExtent.width = handle.texture.width;
              this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
              copySize = this._region1.texExtent.width * this._region1.texExtent.height;
            } else {
              copySize = remainSize;
              this._region1.texExtent.width = copySize;
              this._region1.texExtent.height = 1;
            }
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region1);
            offsetX = 0;
            offsetY += this._region1.texExtent.height;
            remainSize -= copySize;
            begin += copySize;
          }
          if (remainSize > 0) {
            this._region2.texOffset.x = offsetX;
            this._region2.texOffset.y = offsetY;
            this._region2.texExtent.width = remainSize;
            this._region2.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
            regions.push(this._region2);
          }
          this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        }
        _findAvailableSpace(size, chunkIdx) {
          const chunk = this._chunks[chunkIdx];
          let isFound = false;
          let start = chunk.start;
          if (start + size <= chunk.size) {
            isFound = true;
          } else {
            start = 0;
            const handles = this._handles.filter(h => h.chunkIdx === chunkIdx).sort((a, b) => a.start - b.start);
            for (let i = 0; i < handles.length; i++) {
              const handle = handles[i];
              if (start + size <= handle.start) {
                isFound = true;
                break;
              }
              start = handle.end;
            }
            if (!isFound && start + size <= chunk.size) {
              isFound = true;
            }
          }
          return isFound ? start : -1;
        }
        _McDonaldAlloc(size) {
          size = roundUp(size, this._alignment);
          for (let i = 0; i < this._chunkCount; ++i) {
            const chunk = this._chunks[i];
            let isFound = false;
            let start = chunk.start;
            if (start + size <= chunk.end) {
              isFound = true;
            } else if (start > chunk.end) {
              if (start + size <= chunk.size) {
                isFound = true;
              } else if (size <= chunk.end) {
                chunk.start = start = 0;
                isFound = true;
              }
            } else if (start === chunk.end) {
              chunk.start = start = 0;
              chunk.end = chunk.size;
              if (size <= chunk.end) {
                isFound = true;
              }
            }
            if (isFound) {
              chunk.start += size;
              const handle = {
                chunkIdx: i,
                start,
                end: start + size,
                texture: chunk.texture
              };
              this._handles.push(handle);
              return handle;
            }
          }
          const targetSize = Math.sqrt(size / this._formatSize);
          const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
          const newChunk = this._chunks[this.createChunk(texLength)];
          newChunk.start += size;
          const texHandle = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: size,
            texture: newChunk.texture
          };
          this._handles.push(texHandle);
          return texHandle;
        }
      }

      class PassInstance extends Pass {
        get parent() {
          return this._parent;
        }
        constructor(parent, owner) {
          super(parent.root);
          this._parent = void 0;
          this._owner = void 0;
          this._dontNotify = false;
          this._parent = parent;
          this._owner = owner;
          this._doInit(this._parent, true);
          for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
            const u = this._shaderInfo.blocks[i];
            const block = this._blocks[u.binding];
            const parentBlock = this._parent.blocks[u.binding];
            block.set(parentBlock);
          }
          this._rootBufferDirty = true;
          const paren = this._parent;
          for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
            const u = this._shaderInfo.samplerTextures[i];
            for (let j = 0; j < u.count; j++) {
              const sampler = paren._descriptorSet.getSampler(u.binding, j);
              const texture = paren._descriptorSet.getTexture(u.binding, j);
              this._descriptorSet.bindSampler(u.binding, sampler, j);
              this._descriptorSet.bindTexture(u.binding, texture, j);
            }
          }
          super.tryCompile();
        }
        overridePipelineStates(original, overrides) {
          this._bs.reset();
          this._rs.reset();
          this._dss.reset();
          Pass.fillPipelineInfo(this, original);
          Pass.fillPipelineInfo(this, overrides);
          this._onStateChange();
        }
        tryCompile(defineOverrides) {
          if (defineOverrides) {
            if (!overrideMacros(this._defines, defineOverrides)) {
              return false;
            }
          }
          const res = super.tryCompile();
          this._onStateChange();
          return res;
        }
        beginChangeStatesSilently() {
          this._dontNotify = true;
        }
        endChangeStatesSilently() {
          this._dontNotify = false;
        }
        _syncBatchingScheme() {
          this._defines.USE_INSTANCING = false;
          this._batchingScheme = BatchingSchemes.NONE;
        }
        _onStateChange() {
          this._hash = Pass.getPassHash(this);
          this._owner.onPassStateChange(this._dontNotify);
        }
      }

      const NativeBufferPool = jsb.NativeBufferPool;
      jsb.NativeObjectPool;
      jsb.NativeBufferAllocator;

      const contains = (a, t) => {
        for (let i = 0; i < a.length; ++i) {
          if (a[i] === t) return true;
        }
        return false;
      };
      var BufferDataType;
      (function (BufferDataType) {
        BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
        BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
        BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
      })(BufferDataType || (BufferDataType = {}));
      class BufferPool {
        constructor(poolType, dataType, dataMembers, enumType, entryBits = 8) {
          this._dataType = void 0;
          this._dataMembers = void 0;
          this._elementCount = void 0;
          this._entryBits = void 0;
          this._stride = void 0;
          this._entriesPerChunk = void 0;
          this._entryMask = void 0;
          this._chunkMask = void 0;
          this._poolFlag = void 0;
          this._arrayBuffers = [];
          this._freeLists = [];
          this._uint32BufferViews = [];
          this._float32BufferViews = [];
          this._hasUint32 = false;
          this._hasFloat32 = false;
          this._nativePool = void 0;
          this._elementCount = enumType.COUNT;
          this._entryBits = entryBits;
          this._dataType = dataType;
          this._dataMembers = dataMembers;
          const bytesPerElement = 4;
          this._stride = bytesPerElement * this._elementCount;
          this._entriesPerChunk = 1 << entryBits;
          this._entryMask = this._entriesPerChunk - 1;
          this._poolFlag = 1 << 30;
          this._chunkMask = ~(this._entryMask | this._poolFlag);
          this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
          let type = BufferDataType.NEVER;
          let hasFloat32 = false;
          let hasUint32 = false;
          for (const e in dataType) {
            hasFloat32 = this._hasFloat32;
            hasUint32 = this._hasUint32;
            if (hasUint32 && hasFloat32) {
              break;
            }
            type = dataType[e];
            if (!hasFloat32 && type === BufferDataType.FLOAT32) {
              this._hasFloat32 = true;
            } else if (!hasUint32 && type === BufferDataType.UINT32) {
              this._hasUint32 = true;
            }
          }
        }
        alloc() {
          let i = 0;
          for (; i < this._freeLists.length; i++) {
            const list = this._freeLists[i];
            if (list.length) {
              const j = list[list.length - 1];
              list.length--;
              return (i << this._entryBits) + j + this._poolFlag;
            }
          }
          const buffer = this._nativePool.allocateNewChunk();
          const float32BufferViews = [];
          const uint32BufferViews = [];
          const freeList = [];
          const hasFloat32 = this._hasFloat32;
          const hasUint32 = this._hasUint32;
          for (let j = 0; j < this._entriesPerChunk; j++) {
            if (hasFloat32) {
              float32BufferViews.push(new Float32Array(buffer, this._stride * j, this._elementCount));
            }
            if (hasUint32) {
              uint32BufferViews.push(new Uint32Array(buffer, this._stride * j, this._elementCount));
            }
            if (j) {
              freeList.push(j);
            }
          }
          if (hasUint32) {
            this._uint32BufferViews.push(uint32BufferViews);
          }
          if (hasFloat32) {
            this._float32BufferViews.push(float32BufferViews);
          }
          this._freeLists.push(freeList);
          this._arrayBuffers.push(buffer);
          const handle = (i << this._entryBits) + this._poolFlag;
          return handle;
        }
        getBuffer(handle) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          const bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;
          if ((!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }
          return bufferViews[chunk][entry];
        }
        getTypedArray(handle, element) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          const bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;
          if ((!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }
          const index = element;
          const view = bufferViews[chunk][entry];
          const count = this._dataMembers[element];
          return view.subarray(index, index + count);
        }
        free(handle) {
          const chunk = (this._chunkMask & handle) >> this._entryBits;
          const entry = this._entryMask & handle;
          if ((!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return;
          }
          const bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
          bufferViews[chunk][entry].fill(0);
          this._freeLists[chunk].push(entry);
        }
      }
      let PoolType;
      (function (PoolType) {
        PoolType[PoolType["NODE"] = 0] = "NODE";
        PoolType[PoolType["PASS"] = 1] = "PASS";
        PoolType[PoolType["AABB"] = 2] = "AABB";
        PoolType[PoolType["RENDER2D"] = 3] = "RENDER2D";
      })(PoolType || (PoolType = {}));
      const NULL_HANDLE = 0;
      let Render2dView;
      (function (Render2dView) {
        Render2dView[Render2dView["POSITION"] = 0] = "POSITION";
        Render2dView[Render2dView["UV"] = 3] = "UV";
        Render2dView[Render2dView["COLOR"] = 5] = "COLOR";
        Render2dView[Render2dView["COUNT"] = 9] = "COUNT";
      })(Render2dView || (Render2dView = {}));
      const Render2dViewDataType = {
        [Render2dView.POSITION]: BufferDataType.FLOAT32,
        [Render2dView.UV]: BufferDataType.FLOAT32,
        [Render2dView.COLOR]: BufferDataType.UINT32,
        [Render2dView.COUNT]: BufferDataType.NEVER
      };
      const Render2dViewDataMembers = {
        [Render2dView.POSITION]: Render2dView.UV - Render2dView.POSITION,
        [Render2dView.UV]: Render2dView.COLOR - Render2dView.UV,
        [Render2dView.COLOR]: Render2dView.COUNT - Render2dView.COLOR,
        [Render2dView.COUNT]: 1
      };
      const Render2dPool = new BufferPool(PoolType.RENDER2D, Render2dViewDataType, Render2dViewDataMembers, Render2dView);
      let NodeView;
      (function (NodeView) {
        NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
        NodeView[NodeView["LAYER"] = 1] = "LAYER";
        NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
        NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
        NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
        NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
        NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
        NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
        NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
        NodeView[NodeView["COUNT"] = 38] = "COUNT";
      })(NodeView || (NodeView = {}));
      const NodeViewDataType = {
        [NodeView.DIRTY_FLAG]: BufferDataType.UINT32,
        [NodeView.LAYER]: BufferDataType.UINT32,
        [NodeView.WORLD_SCALE]: BufferDataType.FLOAT32,
        [NodeView.WORLD_POSITION]: BufferDataType.FLOAT32,
        [NodeView.WORLD_ROTATION]: BufferDataType.FLOAT32,
        [NodeView.WORLD_MATRIX]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_SCALE]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_POSITION]: BufferDataType.FLOAT32,
        [NodeView.LOCAL_ROTATION]: BufferDataType.FLOAT32,
        [NodeView.COUNT]: BufferDataType.NEVER
      };
      const NodeViewDataMembers = {
        [NodeView.DIRTY_FLAG]: NodeView.LAYER - NodeView.DIRTY_FLAG,
        [NodeView.LAYER]: NodeView.WORLD_SCALE - NodeView.LAYER,
        [NodeView.WORLD_SCALE]: NodeView.WORLD_POSITION - NodeView.WORLD_SCALE,
        [NodeView.WORLD_POSITION]: NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION,
        [NodeView.WORLD_ROTATION]: NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION,
        [NodeView.WORLD_MATRIX]: NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX,
        [NodeView.LOCAL_SCALE]: NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE,
        [NodeView.LOCAL_POSITION]: NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION,
        [NodeView.LOCAL_ROTATION]: NodeView.COUNT - NodeView.LOCAL_ROTATION,
        [NodeView.COUNT]: 1
      };
      const NodePool$1 = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
      let PassView;
      (function (PassView) {
        PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
        PassView[PassView["STAGE"] = 1] = "STAGE";
        PassView[PassView["PHASE"] = 2] = "PHASE";
        PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
        PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
        PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
        PassView[PassView["HASH"] = 6] = "HASH";
        PassView[PassView["COUNT"] = 7] = "COUNT";
      })(PassView || (PassView = {}));
      const PassViewDataType = {
        [PassView.PRIORITY]: BufferDataType.UINT32,
        [PassView.STAGE]: BufferDataType.UINT32,
        [PassView.PHASE]: BufferDataType.UINT32,
        [PassView.PRIMITIVE]: BufferDataType.UINT32,
        [PassView.BATCHING_SCHEME]: BufferDataType.UINT32,
        [PassView.DYNAMIC_STATE]: BufferDataType.UINT32,
        [PassView.HASH]: BufferDataType.UINT32,
        [PassView.COUNT]: BufferDataType.NEVER
      };
      const PassViewDataMembers = {
        [PassView.PRIORITY]: PassView.STAGE - PassView.PRIORITY,
        [PassView.STAGE]: PassView.PHASE - PassView.STAGE,
        [PassView.PHASE]: PassView.PRIMITIVE - PassView.PHASE,
        [PassView.PRIMITIVE]: PassView.BATCHING_SCHEME - PassView.PRIMITIVE,
        [PassView.BATCHING_SCHEME]: PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME,
        [PassView.DYNAMIC_STATE]: PassView.HASH - PassView.DYNAMIC_STATE,
        [PassView.HASH]: PassView.COUNT - PassView.HASH,
        [PassView.COUNT]: 1
      };
      const PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
      let AABBView;
      (function (AABBView) {
        AABBView[AABBView["CENTER"] = 0] = "CENTER";
        AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
        AABBView[AABBView["COUNT"] = 6] = "COUNT";
      })(AABBView || (AABBView = {}));
      const AABBViewDataType = {
        [AABBView.CENTER]: BufferDataType.FLOAT32,
        [AABBView.HALFEXTENTS]: BufferDataType.FLOAT32,
        [AABBView.COUNT]: BufferDataType.NEVER
      };
      const AABBViewDataMembers = {
        [AABBView.CENTER]: AABBView.HALFEXTENTS - AABBView.CENTER,
        [AABBView.HALFEXTENTS]: AABBView.COUNT - AABBView.HALFEXTENTS,
        [AABBView.COUNT]: 1
      };
      const AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

      const renderSceneProto = jsb.RenderScene.prototype;
      Object.defineProperty(renderSceneProto, 'mainLight', {
        enumerable: true,
        configurable: true,
        get() {
          return this.getMainLight();
        }
      });
      const RenderScene = jsb.RenderScene;

      Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      });
      const ShadowType = Enum({
        Planar: 0,
        ShadowMap: 1
      });
      Enum({
        HARD: 0,
        SOFT: 1,
        SOFT_2X: 2,
        SOFT_4X: 3
      });
      const CSMLevel = Enum({
        LEVEL_1: 1,
        LEVEL_2: 2,
        LEVEL_3: 3,
        LEVEL_4: 4
      });
      Enum({
        NONE: 1,
        RemoveDuplicates: 2,
        DisableRotationFix: 3
      });
      const SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
      class Shadows {
        constructor() {
          this.fixedSphere = new Sphere(0.0, 0.0, 0.0, 0.01);
          this.maxReceived = 4;
          this._matLight = new Mat4();
          this._material = null;
          this._instancingMaterial = null;
          this._enabled = false;
          this._type = SHADOW_TYPE_NONE;
          this._distance = 0;
          this._planeBias = 1.0;
          this._normal = new Vec3(0, 1, 0);
          this._shadowColor = new Color$1(0, 0, 0, 76);
          this._size = new Vec2(1024, 1024);
          this._shadowMapDirty = false;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(val) {
          this._enabled = val;
          this.activate();
        }
        get type() {
          return this._type;
        }
        set type(val) {
          this._type = this.enabled ? val : SHADOW_TYPE_NONE;
          this.activate();
        }
        get normal() {
          return this._normal;
        }
        set normal(val) {
          Vec3.copy(this._normal, val);
        }
        get distance() {
          return this._distance;
        }
        set distance(val) {
          this._distance = val;
        }
        get planeBias() {
          return this._planeBias;
        }
        set planeBias(val) {
          this._planeBias = val;
        }
        get shadowColor() {
          return this._shadowColor;
        }
        set shadowColor(color) {
          this._shadowColor = color;
        }
        get size() {
          return this._size;
        }
        set size(val) {
          this._size.set(val);
        }
        get shadowMapDirty() {
          return this._shadowMapDirty;
        }
        set shadowMapDirty(val) {
          this._shadowMapDirty = val;
        }
        get matLight() {
          return this._matLight;
        }
        get material() {
          return this._material;
        }
        get instancingMaterial() {
          return this._instancingMaterial;
        }
        getPlanarShader(patches) {
          if (!this._material) {
            this._material = new Material();
            this._material.initialize({
              effectName: 'pipeline/planar-shadow'
            });
          }
          const passes = this._material.passes;
          {
            assert(passes.length > 0, 'passes should not be empty!');
          }
          return passes.length > 0 ? passes[0].getShaderVariant(patches) : null;
        }
        initialize(shadowsInfo) {
          this._enabled = shadowsInfo.enabled;
          this._type = this.enabled ? shadowsInfo.type : SHADOW_TYPE_NONE;
          this.normal = shadowsInfo.planeDirection;
          this.distance = shadowsInfo.planeHeight;
          this.planeBias = shadowsInfo.planeBias;
          this.shadowColor = shadowsInfo.shadowColor;
          this.maxReceived = shadowsInfo.maxReceived;
          if (shadowsInfo.shadowMapSize !== this._size.x) {
            this.size.set(shadowsInfo.shadowMapSize, shadowsInfo.shadowMapSize);
            this._shadowMapDirty = true;
          }
        }
        activate() {
          if (this._enabled) {
            if (this.type === ShadowType.Planar) {
              this._updatePlanarInfo();
            } else {
              const root = legacyCC.director.root;
              const pipeline = root.pipeline;
              pipeline.macros.CC_SHADOW_TYPE = 2;
              root.onGlobalPipelineStateChanged();
            }
          } else {
            const root = legacyCC.director.root;
            const pipeline = root.pipeline;
            pipeline.macros.CC_SHADOW_TYPE = 0;
            root.onGlobalPipelineStateChanged();
          }
        }
        _updatePlanarInfo() {
          if (!this._material) {
            this._material = new Material();
            this._material.initialize({
              effectName: 'pipeline/planar-shadow'
            });
          }
          const root = legacyCC.director.root;
          const pipeline = root.pipeline;
          pipeline.macros.CC_SHADOW_TYPE = 1;
          root.onGlobalPipelineStateChanged();
        }
        destroy() {
          if (this._material) {
            this._material.destroy();
          }
          if (this._instancingMaterial) {
            this._instancingMaterial.destroy();
          }
          this.fixedSphere.destroy();
        }
      }
      Shadows.MAX_FAR = 2000.0;
      Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
      legacyCC.Shadows = Shadows;

      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastUI2DNode'
      }, {
        name: 'raycastUINode'
      }]);
      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastAll',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllModels',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastSingleModel',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllCanvas',
        suggest: 'using intersect.rayAABB in geometry'
      }, {
        name: 'rayResultCanvas'
      }, {
        name: 'rayResultModels'
      }, {
        name: 'rayResultAll'
      }, {
        name: 'rayResultSingleModel'
      }]);
      removeProperty(Model.prototype, 'Model.prototype', [{
        name: 'isInstancingEnabled'
      }, {
        name: 'instancedAttributes'
      }]);
      const CameraVisFlags = {};
      removeProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.BitMask,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.BitMask,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.BitMask,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.BitMask,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.BitMask,
        targetName: 'UI_2D'
      }]);
      legacyCC.CameraVisFlags = CameraVisFlags;
      const VisibilityFlags = {};
      removeProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'ALWALS',
        newName: 'ALWALS',
        target: Layers.Enum,
        targetName: 'ALWALS'
      }, {
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.Enum,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.Enum,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.Enum,
        targetName: 'UI_2D'
      }]);
      legacyCC.VisibilityFlags = VisibilityFlags;
      replaceProperty(Pass.prototype, 'Pass.prototype', [{
        name: 'getBindingTypeFromHandle',
        newName: 'getDescriptorTypeFromHandle'
      }]);
      removeProperty(Camera$1.prototype, 'Camera.prototype', [{
        name: 'getSplitFrustum'
      }, {
        name: 'setMatView'
      }, {
        name: 'setMatViewInv'
      }, {
        name: 'setMatProjInv'
      }, {
        name: 'setMatViewProjInv'
      }, {
        name: 'setMatProj'
      }, {
        name: 'setMatViewProj'
      }, {
        name: 'getMatViewInv'
      }]);
      removeProperty(Shadows.prototype, 'Shadows.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      removeProperty(SpotLight$1.prototype, 'SpotLight.prototype', [{
        name: 'aspect'
      }]);
      replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'subMeshData',
        newName: 'subMesh'
      }]);
      removeProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'getSubModel',
        suggest: 'Use `subModels[i]` instead'
      }, {
        name: 'subModelNum',
        suggest: 'Use `subModels.length` instead'
      }]);

      const addStage = config.addStage;

      var renderer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addStage: addStage,
        scene: index,
        createIA: createIA,
        programLib: programLib,
        getDeviceShaderVersion: getDeviceShaderVersion,
        get RenderQueue () { return RenderQueue; },
        get PassStage () { return PassStage; },
        genHandle: genHandle,
        getTypeFromHandle: getTypeFromHandle,
        getBindingFromHandle: getBindingFromHandle,
        getCountFromHandle: getCountFromHandle,
        getOffsetFromHandle: getOffsetFromHandle,
        customizeType: customizeType,
        type2reader: type2reader,
        type2writer: type2writer,
        type2validator: type2validator,
        getDefaultFromType: getDefaultFromType,
        getStringFromType: getStringFromType,
        overrideMacros: overrideMacros,
        get BatchingSchemes () { return BatchingSchemes; },
        Pass: Pass,
        nearestPOT: nearestPOT,
        TextureBufferPool: TextureBufferPool,
        MaterialInstance: MaterialInstance,
        PassInstance: PassInstance,
        get PoolType () { return PoolType; },
        NULL_HANDLE: NULL_HANDLE,
        get Render2dView () { return Render2dView; },
        Render2dPool: Render2dPool,
        get NodeView () { return NodeView; },
        NodePool: NodePool$1,
        get PassView () { return PassView; },
        PassPool: PassPool,
        get AABBView () { return AABBView; },
        AABBPool: AABBPool,
        RenderScene: RenderScene,
        CameraVisFlags: CameraVisFlags,
        VisibilityFlags: VisibilityFlags
      });
      exports('renderer', renderer);

      let LineCap;
      (function (LineCap) {
        LineCap[LineCap["BUTT"] = 0] = "BUTT";
        LineCap[LineCap["ROUND"] = 1] = "ROUND";
        LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
      })(LineCap || (LineCap = {}));
      ccenum(LineCap);
      let LineJoin;
      (function (LineJoin) {
        LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
        LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
        LineJoin[LineJoin["MITER"] = 2] = "MITER";
      })(LineJoin || (LineJoin = {}));
      ccenum(LineJoin);
      let PointFlags;
      (function (PointFlags) {
        PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
        PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
        PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
        PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
      })(PointFlags || (PointFlags = {}));
      ccenum(PointFlags);

      const PI$1 = Math.PI;
      const min$1 = Math.min;
      const max$1 = Math.max;
      const cos$1 = Math.cos;
      const sin$1 = Math.sin;
      const abs = Math.abs;
      const sign = Math.sign;
      const KAPPA90 = 0.5522847493;
      function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
        counterclockwise = counterclockwise || false;
        let a = 0;
        let da = 0;
        let hda = 0;
        let kappa = 0;
        let dx = 0;
        let dy = 0;
        let x = 0;
        let y = 0;
        let tanx = 0;
        let tany = 0;
        let px = 0;
        let py = 0;
        let ptanx = 0;
        let ptany = 0;
        let i = 0;
        let ndivs = 0;
        da = endAngle - startAngle;
        if (counterclockwise) {
          if (abs(da) >= PI$1 * 2) {
            da = PI$1 * 2;
          } else {
            while (da < 0) {
              da += PI$1 * 2;
            }
          }
        } else if (abs(da) >= PI$1 * 2) {
          da = -PI$1 * 2;
        } else {
          while (da > 0) {
            da -= PI$1 * 2;
          }
        }
        ndivs = max$1(1, min$1(abs(da) / (PI$1 * 0.5) + 0.5, 5)) | 0;
        hda = da / ndivs / 2.0;
        kappa = abs(4.0 / 3.0 * (1 - cos$1(hda)) / sin$1(hda));
        if (!counterclockwise) {
          kappa = -kappa;
        }
        for (i = 0; i <= ndivs; i++) {
          a = startAngle + da * (i / ndivs);
          dx = cos$1(a);
          dy = sin$1(a);
          x = cx + dx * r;
          y = cy + dy * r;
          tanx = -dy * r * kappa;
          tany = dx * r * kappa;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
          }
          px = x;
          py = y;
          ptanx = tanx;
          ptany = tany;
        }
      }
      function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
        ctx.close();
      }
      function roundRect(ctx, x, y, w, h, r) {
        if (r < 0.1) {
          ctx.rect(x, y, w, h);
        } else {
          const rx = min$1(r, abs(w) * 0.5) * sign(w);
          const ry = min$1(r, abs(h) * 0.5) * sign(h);
          ctx.moveTo(x, y + ry);
          ctx.lineTo(x, y + h - ry);
          ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
          ctx.lineTo(x + w - rx, y + h);
          ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
          ctx.lineTo(x + w, y + ry);
          ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
          ctx.lineTo(x + rx, y);
          ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
          ctx.close();
        }
      }
      function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
        let x12 = 0;
        let y12 = 0;
        let x23 = 0;
        let y23 = 0;
        let x34 = 0;
        let y34 = 0;
        let x123 = 0;
        let y123 = 0;
        let x234 = 0;
        let y234 = 0;
        let x1234 = 0;
        let y1234 = 0;
        let dx = 0;
        let dy = 0;
        let d2 = 0;
        let d3 = 0;
        if (level > 10) {
          return;
        }
        x12 = (x1 + x2) * 0.5;
        y12 = (y1 + y2) * 0.5;
        x23 = (x2 + x3) * 0.5;
        y23 = (y2 + y3) * 0.5;
        x34 = (x3 + x4) * 0.5;
        y34 = (y3 + y4) * 0.5;
        x123 = (x12 + x23) * 0.5;
        y123 = (y12 + y23) * 0.5;
        dx = x4 - x1;
        dy = y4 - y1;
        d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
        d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
        if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
          ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
          return;
        }
        x234 = (x23 + x34) * 0.5;
        y234 = (y23 + y34) * 0.5;
        x1234 = (x123 + x234) * 0.5;
        y1234 = (y123 + y234) * 0.5;
        tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
        tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
      }

      class Point extends Vec2 {
        constructor(...args) {
          super(...args);
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        }
        reset() {
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        }
      }
      class Path {
        constructor() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points = [];
        }
        reset() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points.length = 0;
        }
      }
      class Impl {
        constructor(comp) {
          this.dataOffset = 0;
          this.updatePathOffset = false;
          this.pathLength = 0;
          this.pathOffset = 0;
          this.paths = [];
          this.tessTol = 0.25;
          this.distTol = 0.01;
          this.fillColor = Color$1.WHITE.clone();
          this.lineCap = LineCap.BUTT;
          this.strokeColor = Color$1.BLACK.clone();
          this.lineJoin = LineJoin.MITER;
          this.lineWidth = 0;
          this.pointsOffset = 0;
          this._commandX = 0;
          this._commandY = 0;
          this._points = [];
          this._renderDataList = [];
          this._curPath = null;
          this._comp = void 0;
          this._comp = comp;
        }
        moveTo(x, y) {
          if (this.updatePathOffset) {
            this.pathOffset = this.pathLength;
            this.updatePathOffset = false;
          }
          this._addPath();
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        lineTo(x, y) {
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          const path = this._curPath;
          const last = path.points[path.points.length - 1];
          if (!last) {
            return;
          }
          if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
            this.lineTo(x, y);
            return;
          }
          tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        }
        quadraticCurveTo(cx, cy, x, y) {
          const x0 = this._commandX;
          const y0 = this._commandY;
          this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
        }
        arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        }
        ellipse(cx, cy, rx, ry) {
          ellipse(this, cx, cy, rx, ry);
          this._curPath.complex = false;
        }
        circle(cx, cy, r) {
          ellipse(this, cx, cy, r, r);
          this._curPath.complex = false;
        }
        rect(x, y, w, h) {
          this.moveTo(x, y);
          this.lineTo(x + w, y);
          this.lineTo(x + w, y + h);
          this.lineTo(x, y + h);
          this.close();
          this._curPath.complex = false;
        }
        roundRect(x, y, w, h, r) {
          roundRect(this, x, y, w, h, r);
          this._curPath.complex = false;
        }
        clear() {
          this.pathLength = 0;
          this.pathOffset = 0;
          this.pointsOffset = 0;
          this.dataOffset = 0;
          this._curPath = null;
          this.paths.length = 0;
          this._points.length = 0;
          const dataList = this._renderDataList;
          for (let i = 0, l = dataList.length; i < l; i++) {
            const data = dataList[i];
            if (!data) {
              continue;
            }
            MeshRenderData.remove(data);
            data.removeRenderDrawInfo(this._comp);
          }
          this._renderDataList.length = 0;
        }
        close() {
          this._curPath.closed = true;
        }
        requestRenderData() {
          const renderData = MeshRenderData.add();
          this._renderDataList.push(renderData);
          {
            renderData.initRenderDrawInfo(this._comp, RenderDrawInfoType.MODEL);
            renderData.material = this._comp.getMaterialInstance(0);
            this._comp.setRenderData(renderData);
          }
          return renderData;
        }
        getRenderDataList() {
          if (this._renderDataList.length === 0) {
            this.requestRenderData();
          }
          return this._renderDataList;
        }
        addPoint(x, y, flags) {
          const path = this._curPath;
          if (!path) {
            return;
          }
          const points = this._points;
          const pathPoints = path.points;
          const offset = this.pointsOffset++;
          let pt = points[offset];
          if (!pt) {
            pt = new Point(x, y);
            points.push(pt);
          } else {
            pt.x = x;
            pt.y = y;
          }
          pt.flags = flags;
          pathPoints.push(pt);
        }
        _addPath() {
          const offset = this.pathLength;
          let path = this.paths[offset];
          if (!path) {
            path = new Path();
            this.paths.push(path);
          } else {
            path.reset();
          }
          this.pathLength++;
          this._curPath = path;
          return path;
        }
      }

      var _dec$1p, _dec2$1h, _dec3$$, _dec4$N, _class$1n, _class2$1h, _initializer$1d, _initializer2$16, _initializer3$T, _initializer4$M, _initializer5$E, _initializer6$w, _class3$w;
      const attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
      const componentPerVertex = getComponentPerVertex(attributes);
      const stride = getAttributeStride(attributes);
      let Graphics = (_dec$1p = ccclass$6('cc.Graphics'), _dec2$1h = executionOrder$1(110), _dec3$$ = type$6(LineJoin), _dec4$N = type$6(LineCap), _dec$1p(_class$1n = _dec2$1h(_class$1n = (_class2$1h = (_class3$w = class Graphics extends UIRenderer {
        get lineWidth() {
          return this._lineWidth;
        }
        set lineWidth(value) {
          this._lineWidth = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineWidth = value;
        }
        get lineJoin() {
          return this._lineJoin;
        }
        set lineJoin(value) {
          this._lineJoin = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineJoin = value;
        }
        get lineCap() {
          return this._lineCap;
        }
        set lineCap(value) {
          this._lineCap = value;
          if (!this.impl) {
            return;
          }
          this.impl.lineCap = value;
        }
        get strokeColor() {
          return this._strokeColor;
        }
        set strokeColor(value) {
          if (!this.impl) {
            return;
          }
          this._strokeColor.set(value);
          this.impl.strokeColor = this._strokeColor;
        }
        get fillColor() {
          return this._fillColor;
        }
        set fillColor(value) {
          if (!this.impl) {
            return;
          }
          this._fillColor.set(value);
          this.impl.fillColor = this._fillColor;
        }
        get miterLimit() {
          return this._miterLimit;
        }
        set miterLimit(value) {
          this._miterLimit = value;
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
        }
        get graphicsNativeProxy() {
          return this._graphicsNativeProxy;
        }
        constructor() {
          super();
          this.impl = null;
          this.model = null;
          this._lineWidth = _initializer$1d && _initializer$1d();
          this._strokeColor = _initializer2$16 && _initializer2$16();
          this._lineJoin = _initializer3$T && _initializer3$T();
          this._lineCap = _initializer4$M && _initializer4$M();
          this._fillColor = _initializer5$E && _initializer5$E();
          this._miterLimit = _initializer6$w && _initializer6$w();
          this._isDrawing = false;
          this._isNeedUploadData = true;
          this._graphicsUseSubMeshes = [];
          this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
          this.impl = new Impl(this);
          {
            this._graphicsNativeProxy = new NativeUIModelProxy();
          }
        }
        onRestore() {
          if (!this.impl) {
            this._flushAssembler();
          }
        }
        onLoad() {
          super.onLoad();
          {
            this._graphicsNativeProxy.initModel(this.node);
            this.model = this._graphicsNativeProxy.getModel();
          }
          this._flushAssembler();
        }
        onEnable() {
          super.onEnable();
          this._updateMtlForGraphics();
        }
        onDestroy() {
          this._sceneGetter = null;
          {
            this._graphicsNativeProxy.destroy();
            this.model = null;
          }
          if (this.impl) {
            this._isDrawing = false;
            this.impl.clear();
            this.impl = null;
          }
          super.onDestroy();
        }
        moveTo(x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.moveTo(x, y);
        }
        lineTo(x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.lineTo(x, y);
        }
        bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        }
        quadraticCurveTo(cx, cy, x, y) {
          if (!this.impl) {
            return;
          }
          this.impl.quadraticCurveTo(cx, cy, x, y);
        }
        arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          if (!this.impl) {
            return;
          }
          this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        }
        ellipse(cx, cy, rx, ry) {
          if (!this.impl) {
            return;
          }
          this.impl.ellipse(cx, cy, rx, ry);
        }
        circle(cx, cy, r) {
          if (!this.impl) {
            return;
          }
          this.impl.circle(cx, cy, r);
        }
        rect(x, y, w, h) {
          if (!this.impl) {
            return;
          }
          this.impl.rect(x, y, w, h);
        }
        roundRect(x, y, w, h, r) {
          if (!this.impl) {
            return;
          }
          this.impl.roundRect(x, y, w, h, r);
        }
        fillRect(x, y, w, h) {
          this.rect(x, y, w, h);
          this.fill();
        }
        clear() {
          if (!this.impl) {
            return;
          }
          this.impl.clear();
          this._isDrawing = false;
          {
            this._graphicsNativeProxy.clear();
          }
          this.markForUpdateRenderData();
        }
        close() {
          if (!this.impl) {
            return;
          }
          this.impl.close();
        }
        stroke() {
          if (!this._assembler) {
            this._flushAssembler();
          }
          this._isDrawing = true;
          this._isNeedUploadData = true;
          this._assembler.stroke(this);
        }
        fill() {
          if (!this._assembler) {
            this._flushAssembler();
          }
          this._isDrawing = true;
          this._isNeedUploadData = true;
          this._assembler.fill(this);
        }
        _updateMtlForGraphics() {
          let mat;
          if (this._customMaterial) {
            mat = this.getMaterialInstance(0);
          } else {
            mat = builtinResMgr.get('ui-graphics-material');
            this.setSharedMaterial(mat, 0);
            mat = this.getMaterialInstance(0);
            mat.recompileShaders({
              USE_LOCAL: true
            });
          }
        }
        activeSubModel(idx) {
          if (!this.model) {
            warnID(4500, this.node.name);
            return;
          }
          if (this.model.subModels.length <= idx) {
            const gfxDevice = deviceManager.gfxDevice;
            const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
            const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
            const renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            renderMesh.subMeshIdx = 0;
            this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));
            this._graphicsUseSubMeshes.push(renderMesh);
          }
        }
        _uploadData() {
          const impl = this.impl;
          if (!impl) {
            return;
          }
          const renderDataList = impl && impl.getRenderDataList();
          if (renderDataList.length <= 0 || !this.model) {
            return;
          }
          const subModelList = this.model.subModels;
          for (let i = 0; i < renderDataList.length; i++) {
            const renderData = renderDataList[i];
            const ia = subModelList[i].inputAssembler;
            if (renderData.lastFilledVertex === renderData.vertexStart) {
              continue;
            }
            const vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
            ia.vertexBuffers[0].update(vb);
            ia.vertexCount = renderData.vertexStart;
            const ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indexStart);
            ia.indexBuffer.update(ib);
            ia.indexCount = renderData.indexStart;
            renderData.lastFilledVertex = renderData.vertexStart;
            renderData.lastFilledIndex = renderData.indexStart;
          }
          this._isNeedUploadData = false;
        }
        _render(render) {
          if (this._isNeedUploadData) {
            if (this.impl) {
              const renderDataList = this.impl.getRenderDataList();
              const len = this.model.subModels.length;
              if (renderDataList.length > len) {
                for (let i = len; i < renderDataList.length; i++) {
                  this.activeSubModel(i);
                }
              }
            }
            this._uploadData();
          }
          render.commitModel(this, this.model, this.getMaterialInstance(0));
        }
        _flushAssembler() {
          const assembler = Graphics.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
        }
        _canRender() {
          if (!super._canRender()) {
            return false;
          }
          {
            return this._isDrawing;
          }
        }
        updateRenderer() {
          super.updateRenderer();
          {
            if (this._isNeedUploadData) {
              if (this.impl) {
                const renderDataList = this.impl.getRenderDataList();
                for (let i = 0; i < renderDataList.length; i++) {
                  renderDataList[i].setRenderDrawInfoAttributes();
                }
                this._graphicsNativeProxy.activeSubModels();
              }
              this._graphicsNativeProxy.uploadData();
              this._isNeedUploadData = false;
            }
          }
        }
        createRenderEntity() {
          return new RenderEntity(RenderEntityType.DYNAMIC);
        }
      }, _class3$w.LineJoin = LineJoin, _class3$w.LineCap = LineCap, _class3$w), (_applyDecoratedDescriptor(_class2$1h.prototype, "lineJoin", [_dec3$$], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "lineJoin"), _class2$1h.prototype), _applyDecoratedDescriptor(_class2$1h.prototype, "lineCap", [_dec4$N], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "lineCap"), _class2$1h.prototype), _applyDecoratedDescriptor(_class2$1h.prototype, "color", [override], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "color"), _class2$1h.prototype), _initializer$1d = applyDecoratedInitializer(_class2$1h.prototype, "_lineWidth", [serializable$6], function () {
        return 1;
      }), _initializer2$16 = applyDecoratedInitializer(_class2$1h.prototype, "_strokeColor", [serializable$6], function () {
        return Color$1.BLACK.clone();
      }), _initializer3$T = applyDecoratedInitializer(_class2$1h.prototype, "_lineJoin", [serializable$6], function () {
        return LineJoin.MITER;
      }), _initializer4$M = applyDecoratedInitializer(_class2$1h.prototype, "_lineCap", [serializable$6], function () {
        return LineCap.BUTT;
      }), _initializer5$E = applyDecoratedInitializer(_class2$1h.prototype, "_fillColor", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer6$w = applyDecoratedInitializer(_class2$1h.prototype, "_miterLimit", [serializable$6], function () {
        return 10;
      })), _class2$1h)) || _class$1n) || _class$1n); exports({ Graphics: Graphics, GraphicsComponent: Graphics });
      legacyCC.Graphics = Graphics;

      var _dec$1o, _dec2$1g, _dec3$_, _dec4$M, _dec5$H, _dec6$u, _dec7$o, _class$1m, _class2$1g, _initializer$1c, _initializer2$15, _initializer3$S, _initializer4$L, _initializer5$D, _initializer6$v, _initializer7$r, _initializer8$p, _initializer9$m, _initializer10$j, _class3$v;
      let SpriteType$1;
      (function (SpriteType) {
        SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
        SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
        SpriteType[SpriteType["TILED"] = 2] = "TILED";
        SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
      })(SpriteType$1 || (SpriteType$1 = {}));
      ccenum(SpriteType$1);
      var FillType$2;
      (function (FillType) {
        FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
        FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
        FillType[FillType["RADIAL"] = 2] = "RADIAL";
      })(FillType$2 || (FillType$2 = {}));
      ccenum(FillType$2);
      var SizeMode$1;
      (function (SizeMode) {
        SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
        SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
        SizeMode[SizeMode["RAW"] = 2] = "RAW";
      })(SizeMode$1 || (SizeMode$1 = {}));
      ccenum(SizeMode$1);
      var EventType$5;
      (function (EventType) {
        EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
      })(EventType$5 || (EventType$5 = {}));
      let Sprite = (_dec$1o = ccclass$6('cc.Sprite'), _dec2$1g = executionOrder$1(110), _dec3$_ = type$6(SpriteAtlas), _dec4$M = type$6(SpriteFrame), _dec5$H = type$6(SpriteType$1), _dec6$u = type$6(FillType$2), _dec7$o = type$6(SizeMode$1), _dec$1o(_class$1m = _dec2$1g(_class$1m = (_class2$1g = (_class3$v = class Sprite extends UIRenderer {
        constructor(...args) {
          super(...args);
          this._spriteFrame = _initializer$1c && _initializer$1c();
          this._type = _initializer2$15 && _initializer2$15();
          this._fillType = _initializer3$S && _initializer3$S();
          this._sizeMode = _initializer4$L && _initializer4$L();
          this._fillCenter = _initializer5$D && _initializer5$D();
          this._fillStart = _initializer6$v && _initializer6$v();
          this._fillRange = _initializer7$r && _initializer7$r();
          this._isTrimmedMode = _initializer8$p && _initializer8$p();
          this._useGrayscale = _initializer9$m && _initializer9$m();
          this._atlas = _initializer10$j && _initializer10$j();
        }
        get spriteAtlas() {
          return this._atlas;
        }
        set spriteAtlas(value) {
          if (this._atlas === value) {
            return;
          }
          this._atlas = value;
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          const lastSprite = this._spriteFrame;
          this._spriteFrame = value;
          this.markForUpdateRenderData();
          this._applySpriteFrame(lastSprite);
        }
        get type() {
          return this._type;
        }
        set type(value) {
          if (this._type !== value) {
            this._type = value;
            this._flushAssembler();
          }
        }
        get fillType() {
          return this._fillType;
        }
        set fillType(value) {
          if (this._fillType !== value) {
            if (value === FillType$2.RADIAL || this._fillType === FillType$2.RADIAL) {
              this.destroyRenderData();
            } else if (this.renderData) {
              this.markForUpdateRenderData(true);
            }
          }
          this._fillType = value;
          this._flushAssembler();
        }
        get fillCenter() {
          return this._fillCenter;
        }
        set fillCenter(value) {
          this._fillCenter.x = value.x;
          this._fillCenter.y = value.y;
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
          }
        }
        get fillStart() {
          return this._fillStart;
        }
        set fillStart(value) {
          this._fillStart = clamp$1(value, 0, 1);
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
            this._updateUVs();
          }
        }
        get fillRange() {
          return this._fillRange;
        }
        set fillRange(value) {
          this._fillRange = clamp$1(value, -1, 1);
          if (this._type === SpriteType$1.FILLED && this.renderData) {
            this.markForUpdateRenderData();
            this._updateUVs();
          }
        }
        get trim() {
          return this._isTrimmedMode;
        }
        set trim(value) {
          if (this._isTrimmedMode === value) {
            return;
          }
          this._isTrimmedMode = value;
          if (this._type === SpriteType$1.SIMPLE && this.renderData) {
            this.markForUpdateRenderData(true);
          }
        }
        get grayscale() {
          return this._useGrayscale;
        }
        set grayscale(value) {
          if (this._useGrayscale === value) {
            return;
          }
          this._useGrayscale = value;
          this.changeMaterialForDefine();
          this.updateMaterial();
        }
        get sizeMode() {
          return this._sizeMode;
        }
        set sizeMode(value) {
          if (this._sizeMode === value) {
            return;
          }
          this._sizeMode = value;
          if (value !== SizeMode$1.CUSTOM) {
            this._applySpriteSize();
          }
        }
        __preload() {
          this.changeMaterialForDefine();
          super.__preload();
        }
        onEnable() {
          super.onEnable();
          this._activateMaterial();
          const spriteFrame = this._spriteFrame;
          if (spriteFrame) {
            this._updateUVs();
            if (this._type === SpriteType$1.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
        onDisable() {
          super.onDisable();
          if (this._spriteFrame && this._type === SpriteType$1.SLICED) {
            this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
        }
        onDestroy() {
          super.onDestroy();
        }
        changeSpriteFrameFromAtlas(name) {
          if (!this._atlas) {
            console.warn('SpriteAtlas is null.');
            return;
          }
          const sprite = this._atlas.getSpriteFrame(name);
          this.spriteFrame = sprite;
        }
        changeMaterialForDefine() {
          let texture;
          const lastInstanceMaterialType = this._instanceMaterialType;
          if (this._spriteFrame) {
            texture = this._spriteFrame.texture;
          }
          let value = false;
          if (texture instanceof TextureBase) {
            const format = texture.getPixelFormat();
            value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
          }
          if (value && this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
          } else if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else if (this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }
          if (lastInstanceMaterialType !== this._instanceMaterialType) {
            this.updateMaterial();
          }
        }
        _updateBuiltinMaterial() {
          let mat = super._updateBuiltinMaterial();
          if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
            const defines = {
              SAMPLE_FROM_RT: true,
              ...mat.passes[0].defines
            };
            const renderMat = new Material();
            renderMat.initialize({
              effectAsset: mat.effectAsset,
              defines
            });
            mat = renderMat;
          }
          return mat;
        }
        _render(render) {
          render.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
        }
        _canRender() {
          if (!super._canRender()) {
            return false;
          }
          const spriteFrame = this._spriteFrame;
          if (!spriteFrame || !spriteFrame.texture) {
            return false;
          }
          return true;
        }
        _flushAssembler() {
          const assembler = Sprite.Assembler.getAssembler(this);
          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }
          if (!this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this._renderData.material = this.getRenderMaterial(0);
              this.markForUpdateRenderData();
              if (this.spriteFrame) {
                this._assembler.updateUVs(this);
              }
              this._updateColor();
            }
          }
          if (this._spriteFrame) {
            if (this._type === SpriteType$1.SLICED) {
              this._spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            } else {
              this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
        _applySpriteSize() {
          if (this._spriteFrame) {
            {
              if (SizeMode$1.RAW === this._sizeMode) {
                const size = this._spriteFrame.originalSize;
                this.node._uiProps.uiTransformComp.setContentSize(size);
              } else if (SizeMode$1.TRIMMED === this._sizeMode) {
                const rect = this._spriteFrame.rect;
                this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
              }
            }
          }
        }
        _resized() {
          {
            return;
          }
        }
        _activateMaterial() {
          const spriteFrame = this._spriteFrame;
          const material = this.getRenderMaterial(0);
          if (spriteFrame) {
            if (material) {
              this.markForUpdateRenderData();
            }
          }
          if (this.renderData) {
            this.renderData.material = material;
          }
        }
        _updateUVs() {
          if (this._assembler) {
            this._assembler.updateUVs(this);
          }
        }
        _applySpriteFrame(oldFrame) {
          const spriteFrame = this._spriteFrame;
          if (oldFrame && this._type === SpriteType$1.SLICED) {
            oldFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
          let textureChanged = false;
          if (spriteFrame) {
            if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
              textureChanged = true;
            }
            if (textureChanged) {
              if (this.renderData) this.renderData.textureDirty = true;
              this.changeMaterialForDefine();
            }
            this._applySpriteSize();
            if (this._type === SpriteType$1.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        }
      }, _class3$v.FillType = FillType$2, _class3$v.Type = SpriteType$1, _class3$v.SizeMode = SizeMode$1, _class3$v.EventType = EventType$5, _class3$v), (_applyDecoratedDescriptor(_class2$1g.prototype, "spriteAtlas", [_dec3$_], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "spriteAtlas"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "spriteFrame", [_dec4$M], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "spriteFrame"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "type", [_dec5$H], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "type"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "fillType", [_dec6$u], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "fillType"), _class2$1g.prototype), _applyDecoratedDescriptor(_class2$1g.prototype, "sizeMode", [_dec7$o], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "sizeMode"), _class2$1g.prototype), _initializer$1c = applyDecoratedInitializer(_class2$1g.prototype, "_spriteFrame", [serializable$6], function () {
        return null;
      }), _initializer2$15 = applyDecoratedInitializer(_class2$1g.prototype, "_type", [serializable$6], function () {
        return SpriteType$1.SIMPLE;
      }), _initializer3$S = applyDecoratedInitializer(_class2$1g.prototype, "_fillType", [serializable$6], function () {
        return FillType$2.HORIZONTAL;
      }), _initializer4$L = applyDecoratedInitializer(_class2$1g.prototype, "_sizeMode", [serializable$6], function () {
        return SizeMode$1.TRIMMED;
      }), _initializer5$D = applyDecoratedInitializer(_class2$1g.prototype, "_fillCenter", [serializable$6], function () {
        return new Vec2(0, 0);
      }), _initializer6$v = applyDecoratedInitializer(_class2$1g.prototype, "_fillStart", [serializable$6], function () {
        return 0;
      }), _initializer7$r = applyDecoratedInitializer(_class2$1g.prototype, "_fillRange", [serializable$6], function () {
        return 0;
      }), _initializer8$p = applyDecoratedInitializer(_class2$1g.prototype, "_isTrimmedMode", [serializable$6], function () {
        return true;
      }), _initializer9$m = applyDecoratedInitializer(_class2$1g.prototype, "_useGrayscale", [serializable$6], function () {
        return false;
      }), _initializer10$j = applyDecoratedInitializer(_class2$1g.prototype, "_atlas", [serializable$6], function () {
        return null;
      })), _class2$1g)) || _class$1m) || _class$1m); exports({ Sprite: Sprite, SpriteComponent: Sprite });
      legacyCC.Sprite = Sprite;

      var _dec$1n, _dec2$1f, _dec3$Z, _class$1l, _class2$1f, _initializer$1b, _initializer2$14, _initializer3$R, _initializer4$K, _class3$u;
      const _worldMatrix = new Mat4();
      const _vec2_temp = new Vec2();
      const _mat4_temp = new Mat4();
      const _circlePoints = [];
      function _calculateCircle(center, radius, segments) {
        _circlePoints.length = 0;
        const anglePerStep = Math.PI * 2 / segments;
        for (let step = 0; step < segments; ++step) {
          _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
        }
        return _circlePoints;
      }
      let MaskType;
      (function (MaskType) {
        MaskType[MaskType["GRAPHICS_RECT"] = 0] = "GRAPHICS_RECT";
        MaskType[MaskType["GRAPHICS_ELLIPSE"] = 1] = "GRAPHICS_ELLIPSE";
        MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
        MaskType[MaskType["SPRITE_STENCIL"] = 3] = "SPRITE_STENCIL";
      })(MaskType || (MaskType = {}));
      ccenum(MaskType);
      const SEGMENTS_MIN = 3;
      const SEGMENTS_MAX = 10000;
      let Mask = (_dec$1n = ccclass$6('cc.Mask'), _dec2$1f = executionOrder$1(110), _dec3$Z = type$6(MaskType), _dec$1n(_class$1l = _dec2$1f(_class$1l = (_class2$1f = (_class3$u = class Mask extends Component {
        constructor(...args) {
          super(...args);
          this._type = _initializer$1b && _initializer$1b();
          this._inverted = _initializer2$14 && _initializer2$14();
          this._segments = _initializer3$R && _initializer3$R();
          this._alphaThreshold = _initializer4$K && _initializer4$K();
          this._sprite = null;
          this._graphics = null;
          this._stencilStage = Stage.DISABLED;
        }
        get type() {
          return this._type;
        }
        set type(value) {
          if (this._type === value) {
            return;
          }
          this._type = value;
          if (this._type !== MaskType.SPRITE_STENCIL) {
            if (this._sprite) {
              this.node.removeComponent(Sprite);
              this._sprite._destroyImmediate();
              this._sprite = null;
            }
            this._changeRenderType();
            this._updateGraphics();
            {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          } else {
            if (this._graphics) {
              this._graphics.clear();
              this.node.removeComponent(Graphics);
              this._graphics._destroyImmediate();
              this._graphics = null;
            }
            this._changeRenderType();
            {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          }
        }
        get inverted() {
          return this._inverted;
        }
        set inverted(value) {
          this._inverted = value;
          this.subComp.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
          {
            this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
          }
        }
        get segments() {
          return this._segments;
        }
        set segments(value) {
          if (this._segments === value) {
            return;
          }
          this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);
          this._updateGraphics();
        }
        get spriteFrame() {
          if (this._sprite) {
            return this._sprite.spriteFrame;
          }
          return null;
        }
        set spriteFrame(value) {
          if (this._sprite) {
            this._sprite.spriteFrame = value;
          } else {
            error('please change type to sprite_stencil first');
          }
        }
        get alphaThreshold() {
          return this._alphaThreshold;
        }
        set alphaThreshold(value) {
          if (this._alphaThreshold === value) {
            return;
          }
          this._alphaThreshold = value;
          if (this.type === MaskType.SPRITE_STENCIL && this._sprite) {
            const mat = this._sprite.getMaterialInstance(0);
            mat.setProperty('alphaThreshold', this._alphaThreshold);
          }
        }
        get subComp() {
          return this._graphics || this._sprite;
        }
        onLoad() {
          this._changeRenderType();
          {
            if (this.subComp) {
              this.subComp.renderEntity.setMaskMode(this._inverted ? MaskMode.MASK_INVERTED : MaskMode.MASK);
            }
          }
        }
        onEnable() {
          this._changeRenderType();
          this._updateGraphics();
          this._enableRender();
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        }
        onRestore() {
          this._changeRenderType();
          this._updateGraphics();
        }
        onDisable() {
          this._disableRender();
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
        }
        onDestroy() {
          this._removeMaskNode();
        }
        isHit(worldPt) {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const size = uiTrans.contentSize;
          const w = size.width;
          const h = size.height;
          const testPt = _vec2_temp;
          this.node.getWorldMatrix(_worldMatrix);
          Mat4.invert(_mat4_temp, _worldMatrix);
          Vec2.transformMat4(testPt, worldPt, _mat4_temp);
          const ap = uiTrans.anchorPoint;
          testPt.x += ap.x * w;
          testPt.y += ap.y * h;
          let result = false;
          if (this.type === MaskType.GRAPHICS_RECT || this.type === MaskType.GRAPHICS_STENCIL || this.type === MaskType.SPRITE_STENCIL) {
            result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
          } else if (this.type === MaskType.GRAPHICS_ELLIPSE) {
            const rx = w / 2;
            const ry = h / 2;
            const px = testPt.x - 0.5 * w;
            const py = testPt.y - 0.5 * h;
            result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
          }
          if (this._inverted) {
            result = !result;
          }
          return result;
        }
        _nodeStateChange(type) {
          this._updateGraphics();
        }
        _changeRenderType() {
          const isGraphics = this._type !== MaskType.SPRITE_STENCIL;
          if (isGraphics) {
            this._createGraphics();
          } else {
            this._createSprite();
          }
        }
        _createSprite() {
          if (!this._sprite) {
            let sprite = this._sprite = this.node.getComponent(Sprite);
            if (!sprite) {
              const node = this.node;
              sprite = this._sprite = node.addComponent(Sprite);
            }
          }
          this._sprite.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
          this._sprite.updateMaterial();
        }
        _createGraphics() {
          if (!this._graphics) {
            let graphics = this._graphics = this.node.getComponent(Graphics);
            if (!graphics) {
              const node = this.node;
              graphics = this._graphics = node.addComponent(Graphics);
            }
            graphics.lineWidth = 1;
            const color = Color$1.WHITE.clone();
            color.a = 0;
            graphics.fillColor = color;
          }
          this._graphics.stencilStage = this.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
        }
        _updateGraphics() {
          if (!this._graphics || this._type !== MaskType.GRAPHICS_RECT && this._type !== MaskType.GRAPHICS_ELLIPSE) {
            return;
          }
          const uiTrans = this.node._uiProps.uiTransformComp;
          const graphics = this._graphics;
          graphics.clear();
          const size = uiTrans.contentSize;
          const width = size.width;
          const height = size.height;
          const ap = uiTrans.anchorPoint;
          const x = -width * ap.x;
          const y = -height * ap.y;
          if (this._type === MaskType.GRAPHICS_RECT) {
            graphics.rect(x, y, width, height);
          } else if (this._type === MaskType.GRAPHICS_ELLIPSE) {
            const center = new Vec3(x + width / 2, y + height / 2, 0);
            const radius = new Vec3(width / 2, height / 2, 0);
            const points = _calculateCircle(center, radius, this._segments);
            for (let i = 0; i < points.length; ++i) {
              const point = points[i];
              if (i === 0) {
                graphics.moveTo(point.x, point.y);
              } else {
                graphics.lineTo(point.x, point.y);
              }
            }
            graphics.close();
          }
          graphics.fill();
        }
        _enableRender() {
          if (this.subComp) {
            this.subComp.enabled = true;
          }
        }
        _disableRender() {
          if (this.subComp) {
            this.subComp.stencilStage = Stage.DISABLED;
            this.subComp.updateMaterial();
            if (this.node.activeInHierarchy) {
              this.subComp.enabled = false;
            }
          }
        }
        _removeMaskNode() {
          if (this._sprite) {
            this._sprite = null;
          }
          if (this._graphics) {
            this._graphics = null;
          }
        }
        get customMaterial() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.customMaterial;
          }
          return null;
        }
        set customMaterial(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.customMaterial = val;
          }
        }
        get color() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.color;
          }
          return null;
        }
        set color(value) {
          warnID(9007);
          if (this.subComp && value) {
            this.subComp.color = value;
          }
        }
        markForUpdateRenderData(enable = true) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.markForUpdateRenderData(enable);
          }
        }
        requestRenderData(any) {
          warnID(9007);
        }
        destroyRenderData() {
          warnID(9007);
        }
        updateRenderer() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.updateRenderer();
          }
        }
        fillBuffers(render) {
          warnID(9007);
        }
        postUpdateAssembler(render) {
          warnID(9007);
        }
        setNodeDirty() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setNodeDirty();
          }
        }
        setTextureDirty() {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setTextureDirty();
          }
        }
        get sharedMaterial() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.sharedMaterial;
          }
          return null;
        }
        get sharedMaterials() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.sharedMaterials;
          }
          return null;
        }
        set sharedMaterials(val) {
          warnID(9007);
          if (this.subComp && val) {
            this.subComp.sharedMaterials = val;
          }
        }
        get material() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.material;
          }
          return null;
        }
        set material(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.material = val;
          }
        }
        get materials() {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.materials;
          }
          return [null];
        }
        set materials(val) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.materials = val;
          }
        }
        getMaterial(idx) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getSharedMaterial(idx);
          }
          return null;
        }
        setMaterial(material, index) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setMaterial(material, index);
          }
        }
        getMaterialInstance(idx) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getMaterialInstance(idx);
          }
          return null;
        }
        setMaterialInstance(matInst, index) {
          warnID(9007);
          if (this.subComp) {
            this.subComp.setMaterialInstance(matInst, index);
          }
        }
        getRenderMaterial(index) {
          warnID(9007);
          if (this.subComp) {
            return this.subComp.getRenderMaterial(index);
          }
          return null;
        }
      }, _class3$u.Type = MaskType, _class3$u), (_applyDecoratedDescriptor(_class2$1f.prototype, "type", [_dec3$Z], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "type"), _class2$1f.prototype), _initializer$1b = applyDecoratedInitializer(_class2$1f.prototype, "_type", [serializable$6], function () {
        return MaskType.GRAPHICS_RECT;
      }), _initializer2$14 = applyDecoratedInitializer(_class2$1f.prototype, "_inverted", [serializable$6], function () {
        return false;
      }), _initializer3$R = applyDecoratedInitializer(_class2$1f.prototype, "_segments", [serializable$6], function () {
        return 64;
      }), _initializer4$K = applyDecoratedInitializer(_class2$1f.prototype, "_alphaThreshold", [serializable$6], function () {
        return 0.1;
      })), _class2$1f)) || _class$1l) || _class$1l); exports({ Mask: Mask, MaskComponent: Mask });
      NodeEventProcessor._maskComp = Mask;
      legacyCC.Mask = Mask;

      var _dec$1m, _dec2$1e, _dec3$Y, _class$1k;
      let LabelOutline = (_dec$1m = ccclass$6('cc.LabelOutline'), _dec2$1e = executionOrder$1(110), _dec3$Y = requireComponent(Label), _dec$1m(_class$1k = _dec2$1e(_class$1k = _dec3$Y(_class$1k = class LabelOutline extends Component {
        get color() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          return label.outlineColor;
        }
        set color(value) {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.outlineColor = value;
        }
        get width() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          return label.outlineWidth;
        }
        set width(value) {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.outlineWidth = value;
        }
        onEnable() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.enableOutline = true;
        }
        onDisable() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.enableOutline = false;
        }
      }) || _class$1k) || _class$1k) || _class$1k); exports({ LabelOutline: LabelOutline, LabelOutlineComponent: LabelOutline });
      legacyCC.LabelOutline = LabelOutline;

      deprecateModuleExportedName({
        RenderComponent: {
          newName: 'UIRenderer',
          since: '1.2.0',
          removed: true
        },
        UITransformComponent: {
          newName: 'UITransform',
          since: '1.2.0',
          removed: false
        },
        CanvasComponent: {
          newName: 'Canvas',
          since: '1.2.0',
          removed: false
        }
      });

      deprecateModuleExportedName({
        UIRenderable: {
          newName: 'UIRenderer',
          since: '3.0.0',
          removed: true
        }
      });

      deprecateModuleExportedName({
        Renderable2D: {
          newName: 'UIRenderer',
          since: '3.6.0',
          removed: false
        }
      });

      var _dec$1l, _class$1j, _class2$1e, _initializer$1a, _initializer2$13, _initializer3$Q, _class3$t;
      let PostProcess = (_dec$1l = ccclass$6('cc.PostProcess'), _dec$1l(_class$1j = disallowMultiple$1(_class$1j = (_class2$1e = (_class3$t = class PostProcess extends Component {
        constructor(...args) {
          super(...args);
          this.global = _initializer$1a && _initializer$1a();
          this._shadingScale = _initializer2$13 && _initializer2$13();
          this.enableShadingScaleInEditor = _initializer3$Q && _initializer3$Q();
          this.settings = new Map();
        }
        get shadingScale() {
          return this._shadingScale;
        }
        set shadingScale(v) {
          this._shadingScale = v;
        }
        addSetting(setting) {
          this.settings.set(setting.constructor, setting);
        }
        removeSetting(setting) {
          this.settings.delete(setting.constructor);
        }
        getSetting(ctor) {
          return this.settings.get(ctor);
        }
        onEnable() {
          PostProcess.all.push(this);
        }
        onDisable() {
          const idx = PostProcess.all.indexOf(this);
          if (idx !== -1) {
            PostProcess.all.splice(idx, 1);
          }
        }
      }, _class3$t.all = [], _class3$t), (_initializer$1a = applyDecoratedInitializer(_class2$1e.prototype, "global", [property$2, serializable$6], function () {
        return true;
      }), _initializer2$13 = applyDecoratedInitializer(_class2$1e.prototype, "_shadingScale", [serializable$6], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$1e.prototype, "shadingScale", [property$2], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "shadingScale"), _class2$1e.prototype), _initializer3$Q = applyDecoratedInitializer(_class2$1e.prototype, "enableShadingScaleInEditor", [property$2, serializable$6], function () {
        return false;
      })), _class2$1e)) || _class$1j) || _class$1j);

      var _dec$1k, _dec2$1d, _dec3$X, _dec4$L, _dec5$G, _dec6$t, _dec7$n, _dec8$j, _dec9$g, _dec10$b, _class$1i, _class2$1d, _initializer$19, _initializer2$12, _initializer3$P, _initializer4$J, _initializer5$C, _initializer6$u, _initializer7$q, _initializer8$o, _initializer9$l, _initializer10$i, _initializer11$h, _initializer12$e, _initializer13$d, _initializer14$a, _initializer15$7, _initializer16$7, _initializer17$6, _initializer18$6, _initializer19$5, _initializer20$3, _initializer21$3, _initializer22$2, _class3$s;
      const _temp_vec3_1$1 = new Vec3();
      const ProjectionType = Enum(CameraProjection);
      const FOVAxis = Enum(CameraFOVAxis);
      const Aperture = Enum(CameraAperture);
      const Shutter = Enum(CameraShutter);
      const ISO = Enum(CameraISO);
      const ClearFlag = Enum({
        SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
        SOLID_COLOR: ClearFlagBit.ALL,
        DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
        DONT_CLEAR: ClearFlagBit.NONE
      });
      let Camera = (_dec$1k = ccclass$6('cc.Camera'), _dec2$1d = type$6(Layers.BitMask), _dec3$X = type$6(ClearFlag), _dec4$L = type$6(ProjectionType), _dec5$G = type$6(FOVAxis), _dec6$t = type$6(Aperture), _dec7$n = type$6(Shutter), _dec8$j = type$6(ISO), _dec9$g = type$6(RenderTexture), _dec10$b = type$6(PostProcess), _dec$1k(_class$1i = (_class2$1d = (_class3$s = class Camera extends Component {
        constructor(...args) {
          super(...args);
          this._projection = _initializer$19 && _initializer$19();
          this._priority = _initializer2$12 && _initializer2$12();
          this._fov = _initializer3$P && _initializer3$P();
          this._fovAxis = _initializer4$J && _initializer4$J();
          this._orthoHeight = _initializer5$C && _initializer5$C();
          this._near = _initializer6$u && _initializer6$u();
          this._far = _initializer7$q && _initializer7$q();
          this._color = _initializer8$o && _initializer8$o();
          this._depth = _initializer9$l && _initializer9$l();
          this._stencil = _initializer10$i && _initializer10$i();
          this._clearFlags = _initializer11$h && _initializer11$h();
          this._rect = _initializer12$e && _initializer12$e();
          this._aperture = _initializer13$d && _initializer13$d();
          this._shutter = _initializer14$a && _initializer14$a();
          this._iso = _initializer15$7 && _initializer15$7();
          this._screenScale = _initializer16$7 && _initializer16$7();
          this._visibility = _initializer17$6 && _initializer17$6();
          this._targetTexture = _initializer18$6 && _initializer18$6();
          this._postProcess = _initializer19$5 && _initializer19$5();
          this._usePostProcess = _initializer20$3 && _initializer20$3();
          this._camera = null;
          this._inEditorMode = false;
          this._flows = undefined;
          this._cameraType = _initializer21$3 && _initializer21$3();
          this._trackingType = _initializer22$2 && _initializer22$2();
        }
        get camera() {
          return this._camera;
        }
        get priority() {
          return this._priority;
        }
        set priority(val) {
          this._priority = val;
          if (this._camera) {
            this._camera.priority = val;
          }
        }
        get visibility() {
          return this._visibility;
        }
        set visibility(val) {
          this._visibility = val;
          if (this._camera) {
            this._camera.visibility = val;
          }
        }
        get clearFlags() {
          return this._clearFlags;
        }
        set clearFlags(val) {
          this._clearFlags = val;
          if (this._camera) {
            this._camera.clearFlag = val;
          }
        }
        get clearColor() {
          return this._color;
        }
        set clearColor(val) {
          this._color.set(val);
          if (this._camera) {
            this._camera.clearColor = this._color;
          }
        }
        get clearDepth() {
          return this._depth;
        }
        set clearDepth(val) {
          this._depth = val;
          if (this._camera) {
            this._camera.clearDepth = val;
          }
        }
        get clearStencil() {
          return this._stencil;
        }
        set clearStencil(val) {
          this._stencil = val;
          if (this._camera) {
            this._camera.clearStencil = val;
          }
        }
        get projection() {
          return this._projection;
        }
        set projection(val) {
          this._projection = val;
          if (this._camera) {
            this._camera.projectionType = val;
          }
        }
        get fovAxis() {
          return this._fovAxis;
        }
        set fovAxis(val) {
          if (val === this._fovAxis) {
            return;
          }
          this._fovAxis = val;
          if (this._camera) {
            this._camera.fovAxis = val;
            if (val === CameraFOVAxis.VERTICAL) {
              this.fov = this._fov * this._camera.aspect;
            } else {
              this.fov = this._fov / this._camera.aspect;
            }
          }
        }
        get fov() {
          return this._fov;
        }
        set fov(val) {
          this._fov = val;
          if (this._camera) {
            this._camera.fov = toRadian(val);
          }
        }
        get orthoHeight() {
          return this._orthoHeight;
        }
        set orthoHeight(val) {
          this._orthoHeight = val;
          if (this._camera) {
            this._camera.orthoHeight = val;
          }
        }
        get near() {
          return this._near;
        }
        set near(val) {
          this._near = val;
          if (this._camera) {
            this._camera.nearClip = val;
          }
        }
        get far() {
          return this._far;
        }
        set far(val) {
          this._far = val;
          if (this._camera) {
            this._camera.farClip = val;
          }
        }
        get aperture() {
          return this._aperture;
        }
        set aperture(val) {
          this._aperture = val;
          if (this._camera) {
            this._camera.aperture = val;
          }
        }
        get shutter() {
          return this._shutter;
        }
        set shutter(val) {
          this._shutter = val;
          if (this._camera) {
            this._camera.shutter = val;
          }
        }
        get iso() {
          return this._iso;
        }
        set iso(val) {
          this._iso = val;
          if (this._camera) {
            this._camera.iso = val;
          }
        }
        get rect() {
          return this._rect;
        }
        set rect(val) {
          this._rect = val;
          if (this._camera) {
            this._camera.setViewportInOrientedSpace(val);
          }
        }
        get targetTexture() {
          return this._targetTexture;
        }
        set targetTexture(value) {
          if (this._targetTexture === value) {
            return;
          }
          const old = this._targetTexture;
          this._targetTexture = value;
          this._checkTargetTextureEvent(old);
          this._updateTargetTexture();
          if (!value && this._camera) {
            this._camera.changeTargetWindow(null);
            this._camera.isWindowSize = true;
          }
          this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
        }
        get usePostProcess() {
          return this._usePostProcess;
        }
        set usePostProcess(v) {
          this._usePostProcess = v;
          if (this._camera) {
            this._camera.usePostProcess = v;
          }
        }
        get postProcess() {
          return this._postProcess;
        }
        set postProcess(v) {
          this._postProcess = v;
          if (this._camera) {
            this._camera.postProcess = v;
          }
        }
        get screenScale() {
          return this._screenScale;
        }
        set screenScale(val) {
          this._screenScale = val;
          if (this._camera) {
            this._camera.screenScale = val;
          }
        }
        get inEditorMode() {
          return this._inEditorMode;
        }
        set inEditorMode(value) {
          this._inEditorMode = value;
          if (this._camera) {
            this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
          }
        }
        get cameraType() {
          return this._cameraType;
        }
        set cameraType(val) {
          if (this._cameraType === val) {
            return;
          }
          this._cameraType = val;
          if (this.camera) {
            this.camera.cameraType = val;
          }
        }
        get trackingType() {
          return this._trackingType;
        }
        set trackingType(val) {
          if (this._trackingType === val) {
            return;
          }
          this._trackingType = val;
          if (this.camera) {
            this.camera.trackingType = val;
          }
        }
        onLoad() {
          this._createCamera();
        }
        onEnable() {
          this.node.hasChangedFlags |= TransformBit.POSITION;
          if (this._camera) {
            this._attachToScene();
          }
        }
        onDisable() {
          if (this._camera) {
            this._detachFromScene();
          }
        }
        onDestroy() {
          if (this._camera) {
            this._camera.destroy();
            this._camera = null;
          }
          if (this._targetTexture) {
            this._targetTexture.off('resize');
          }
        }
        screenPointToRay(x, y, out) {
          if (!out) {
            out = Ray.create();
          }
          if (this._camera) {
            this._camera.screenPointToRay(out, x, y);
          }
          return out;
        }
        worldToScreen(worldPos, out) {
          if (!out) {
            out = new Vec3();
          }
          if (this._camera) {
            this._camera.worldToScreen(out, worldPos);
          }
          return out;
        }
        screenToWorld(screenPos, out) {
          if (!out) {
            out = this.node.getWorldPosition();
          }
          if (this._camera) {
            this._camera.screenToWorld(out, screenPos);
          }
          return out;
        }
        convertToUINode(wpos, uiNode, out) {
          if (!out) {
            out = new Vec3();
          }
          if (!this._camera) {
            return out;
          }
          this.worldToScreen(wpos, _temp_vec3_1$1);
          const cmp = uiNode.getComponent('cc.UITransform');
          const designSize = legacyCC.view.getVisibleSize();
          const xoffset = _temp_vec3_1$1.x - this._camera.width * 0.5;
          const yoffset = _temp_vec3_1$1.y - this._camera.height * 0.5;
          _temp_vec3_1$1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
          _temp_vec3_1$1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;
          if (cmp) {
            cmp.convertToNodeSpaceAR(_temp_vec3_1$1, out);
          }
          return out;
        }
        _createCamera() {
          if (!this._camera) {
            this._camera = legacyCC.director.root.createCamera();
            this._camera.initialize({
              name: this.node.name,
              node: this.node,
              projection: this._projection,
              window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
              priority: this._priority,
              cameraType: this.cameraType,
              trackingType: this.trackingType
            });
            this._camera.setViewportInOrientedSpace(this._rect);
            this._camera.fovAxis = this._fovAxis;
            this._camera.fov = toRadian(this._fov);
            this._camera.orthoHeight = this._orthoHeight;
            this._camera.nearClip = this._near;
            this._camera.farClip = this._far;
            this._camera.clearColor = this._color;
            this._camera.clearDepth = this._depth;
            this._camera.clearStencil = this._stencil;
            this._camera.clearFlag = this._clearFlags;
            this._camera.visibility = this._visibility;
            this._camera.aperture = this._aperture;
            this._camera.shutter = this._shutter;
            this._camera.iso = this._iso;
            this._camera.postProcess = this._postProcess;
            this._camera.usePostProcess = this._usePostProcess;
          }
          this._updateTargetTexture();
        }
        _attachToScene() {
          if (!this.node.scene || !this._camera) {
            return;
          }
          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }
          const rs = this._getRenderScene();
          rs.addCamera(this._camera);
        }
        _detachFromScene() {
          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }
        }
        _checkTargetTextureEvent(old) {
          if (old) {
            old.off('resize');
          }
          if (this._targetTexture) {
            this._targetTexture.on('resize', window => {
              if (this._camera) {
                this._camera.setFixedSize(window.width, window.height);
              }
            }, this);
          }
        }
        _updateTargetTexture() {
          if (!this._camera) {
            return;
          }
          if (this._targetTexture) {
            const window = this._targetTexture.window;
            this._camera.changeTargetWindow(window);
            this._camera.setFixedSize(window.width, window.height);
          }
        }
      }, _class3$s.ProjectionType = ProjectionType, _class3$s.FOVAxis = FOVAxis, _class3$s.ClearFlag = ClearFlag, _class3$s.Aperture = Aperture, _class3$s.Shutter = Shutter, _class3$s.ISO = ISO, _class3$s.TARGET_TEXTURE_CHANGE = 'tex-change', _class3$s), (_initializer$19 = applyDecoratedInitializer(_class2$1d.prototype, "_projection", [serializable$6], function () {
        return ProjectionType.PERSPECTIVE;
      }), _initializer2$12 = applyDecoratedInitializer(_class2$1d.prototype, "_priority", [serializable$6], function () {
        return 0;
      }), _initializer3$P = applyDecoratedInitializer(_class2$1d.prototype, "_fov", [serializable$6], function () {
        return 45;
      }), _initializer4$J = applyDecoratedInitializer(_class2$1d.prototype, "_fovAxis", [serializable$6], function () {
        return FOVAxis.VERTICAL;
      }), _initializer5$C = applyDecoratedInitializer(_class2$1d.prototype, "_orthoHeight", [serializable$6], function () {
        return 10;
      }), _initializer6$u = applyDecoratedInitializer(_class2$1d.prototype, "_near", [serializable$6], function () {
        return 1;
      }), _initializer7$q = applyDecoratedInitializer(_class2$1d.prototype, "_far", [serializable$6], function () {
        return 1000;
      }), _initializer8$o = applyDecoratedInitializer(_class2$1d.prototype, "_color", [serializable$6], function () {
        return new Color$1('#333333');
      }), _initializer9$l = applyDecoratedInitializer(_class2$1d.prototype, "_depth", [serializable$6], function () {
        return 1;
      }), _initializer10$i = applyDecoratedInitializer(_class2$1d.prototype, "_stencil", [serializable$6], function () {
        return 0;
      }), _initializer11$h = applyDecoratedInitializer(_class2$1d.prototype, "_clearFlags", [serializable$6], function () {
        return ClearFlag.SOLID_COLOR;
      }), _initializer12$e = applyDecoratedInitializer(_class2$1d.prototype, "_rect", [serializable$6], function () {
        return new Rect$1(0, 0, 1, 1);
      }), _initializer13$d = applyDecoratedInitializer(_class2$1d.prototype, "_aperture", [serializable$6], function () {
        return Aperture.F16_0;
      }), _initializer14$a = applyDecoratedInitializer(_class2$1d.prototype, "_shutter", [serializable$6], function () {
        return Shutter.D125;
      }), _initializer15$7 = applyDecoratedInitializer(_class2$1d.prototype, "_iso", [serializable$6], function () {
        return ISO.ISO100;
      }), _initializer16$7 = applyDecoratedInitializer(_class2$1d.prototype, "_screenScale", [serializable$6], function () {
        return 1;
      }), _initializer17$6 = applyDecoratedInitializer(_class2$1d.prototype, "_visibility", [serializable$6], function () {
        return CAMERA_DEFAULT_MASK;
      }), _initializer18$6 = applyDecoratedInitializer(_class2$1d.prototype, "_targetTexture", [serializable$6], function () {
        return null;
      }), _initializer19$5 = applyDecoratedInitializer(_class2$1d.prototype, "_postProcess", [serializable$6], function () {
        return null;
      }), _initializer20$3 = applyDecoratedInitializer(_class2$1d.prototype, "_usePostProcess", [serializable$6], function () {
        return false;
      }), _initializer21$3 = applyDecoratedInitializer(_class2$1d.prototype, "_cameraType", [serializable$6], function () {
        return CameraType.DEFAULT;
      }), _initializer22$2 = applyDecoratedInitializer(_class2$1d.prototype, "_trackingType", [serializable$6], function () {
        return TrackingType.NO_TRACKING;
      }), _applyDecoratedDescriptor(_class2$1d.prototype, "visibility", [_dec2$1d], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "visibility"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "clearFlags", [_dec3$X], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "clearFlags"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "projection", [_dec4$L], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "projection"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "fovAxis", [_dec5$G], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "fovAxis"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "aperture", [_dec6$t], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "aperture"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "shutter", [_dec7$n], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "shutter"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "iso", [_dec8$j], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "iso"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "targetTexture", [_dec9$g], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "targetTexture"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "usePostProcess", [property$2], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "usePostProcess"), _class2$1d.prototype), _applyDecoratedDescriptor(_class2$1d.prototype, "postProcess", [_dec10$b], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "postProcess"), _class2$1d.prototype)), _class2$1d)) || _class$1i); exports({ Camera: Camera, CameraComponent: Camera });
      legacyCC.Camera = Camera;

      const localWinSize = new Size$1();
      const orientationMap = {
        [macro.ORIENTATION_AUTO]: Orientation.AUTO,
        [macro.ORIENTATION_LANDSCAPE]: Orientation.LANDSCAPE,
        [macro.ORIENTATION_PORTRAIT]: Orientation.PORTRAIT
      };
      class View extends Eventify(System) {
        constructor() {
          super();
          this._designResolutionSize = void 0;
          this._scaleX = void 0;
          this._scaleY = void 0;
          this._viewportRect = void 0;
          this._visibleRect = void 0;
          this._autoFullScreen = void 0;
          this._retinaEnabled = void 0;
          this._resizeCallback = void 0;
          this._resolutionPolicy = void 0;
          this._rpExactFit = void 0;
          this._rpShowAll = void 0;
          this._rpNoBorder = void 0;
          this._rpFixedHeight = void 0;
          this._rpFixedWidth = void 0;
          const _strategyer = ContainerStrategy;
          const _strategy = ContentStrategy;
          this._designResolutionSize = new Size$1(0, 0);
          this._scaleX = 1;
          this._scaleY = 1;
          this._viewportRect = new Rect$1(0, 0, 0, 0);
          this._visibleRect = new Rect$1(0, 0, 0, 0);
          this._autoFullScreen = false;
          this._retinaEnabled = false;
          this._resizeCallback = null;
          this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
          this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
          this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
          this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
          this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
          this._resolutionPolicy = this._rpShowAll;
        }
        init() {
          const windowSize = screen.windowSize;
          const w = windowSize.width;
          const h = windowSize.height;
          this._designResolutionSize.width = w;
          this._designResolutionSize.height = h;
          this._viewportRect.width = w;
          this._viewportRect.height = h;
          this._visibleRect.width = w;
          this._visibleRect.height = h;
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;
          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }
          {
            this.resizeWithBrowserSize(true);
            const designResolution = settings.querySettings(Settings.Category.SCREEN, 'designResolution');
            if (designResolution) {
              this.setDesignResolutionSize(Number(designResolution.width), Number(designResolution.height), designResolution.policy || ResolutionPolicy.FIXED_HEIGHT);
            }
          }
          screen.on('window-resize', this._updateAdaptResult, this);
          screen.on('fullscreen-change', this._updateAdaptResult, this);
        }
        resizeWithBrowserSize(enabled) {
          screenAdapter.handleResizeEvent = enabled;
        }
        setResizeCallback(callback) {
          if (typeof callback === 'function' || callback == null) {
            this._resizeCallback = callback;
          }
        }
        setOrientation(orientation) {
          screenAdapter.orientation = orientationMap[orientation];
        }
        adjustViewportMeta(enabled) {}
        enableRetina(enabled) {
          this._retinaEnabled = !!enabled;
        }
        isRetinaEnabled() {
          return this._retinaEnabled;
        }
        enableAutoFullScreen(enabled) {
          if (enabled === this._autoFullScreen) {
            return;
          }
          this._autoFullScreen = enabled;
          if (enabled) {
            screen.requestFullScreen().catch(e => {});
          }
        }
        isAutoFullScreenEnabled() {
          return this._autoFullScreen;
        }
        setCanvasSize(width, height) {
          screenAdapter.resolutionScale = 1;
          const dpr = screenAdapter.devicePixelRatio;
          const windowSize = new Size$1(width * dpr, height * dpr);
          screen.windowSize = windowSize;
        }
        getCanvasSize() {
          return screen.windowSize;
        }
        getFrameSize() {
          const dpr = screenAdapter.devicePixelRatio;
          const sizeInCssPixels = screen.windowSize;
          sizeInCssPixels.width /= dpr;
          sizeInCssPixels.height /= dpr;
          return sizeInCssPixels;
        }
        setFrameSize(width, height) {
          const dpr = screenAdapter.devicePixelRatio;
          screen.windowSize = new Size$1(width * dpr, height * dpr);
        }
        getVisibleSize() {
          return new Size$1(this._visibleRect.width, this._visibleRect.height);
        }
        getVisibleSizeInPixel() {
          return new Size$1(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        }
        getVisibleOrigin() {
          return new Vec2(this._visibleRect.x, this._visibleRect.y);
        }
        getVisibleOriginInPixel() {
          return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        }
        getResolutionPolicy() {
          return this._resolutionPolicy;
        }
        _updateResolutionPolicy(resolutionPolicy) {
          if (resolutionPolicy instanceof ResolutionPolicy) {
            this._resolutionPolicy = resolutionPolicy;
          } else {
            const _locPolicy = ResolutionPolicy;
            if (resolutionPolicy === _locPolicy.EXACT_FIT) {
              this._resolutionPolicy = this._rpExactFit;
            }
            if (resolutionPolicy === _locPolicy.SHOW_ALL) {
              this._resolutionPolicy = this._rpShowAll;
            }
            if (resolutionPolicy === _locPolicy.NO_BORDER) {
              this._resolutionPolicy = this._rpNoBorder;
            }
            if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
              this._resolutionPolicy = this._rpFixedHeight;
            }
            if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
              this._resolutionPolicy = this._rpFixedWidth;
            }
          }
        }
        setResolutionPolicy(resolutionPolicy) {
          this._updateResolutionPolicy(resolutionPolicy);
          const designedResolution = view.getDesignResolutionSize();
          view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
        }
        setDesignResolutionSize(width, height, resolutionPolicy) {
          if (!(width > 0 && height > 0)) {
            errorID(2200);
            return;
          }
          this._updateResolutionPolicy(resolutionPolicy);
          const policy = this._resolutionPolicy;
          if (policy) {
            policy.preApply(this);
          }
          this._designResolutionSize.width = width;
          this._designResolutionSize.height = height;
          const result = policy.apply(this, this._designResolutionSize);
          if (result.scale && result.scale.length === 2) {
            this._scaleX = result.scale[0];
            this._scaleY = result.scale[1];
          }
          if (result.viewport) {
            const vp = this._viewportRect;
            const vb = this._visibleRect;
            const rv = result.viewport;
            vp.x = rv.x;
            vp.y = rv.y;
            vp.width = rv.width;
            vp.height = rv.height;
            vb.x = 0;
            vb.y = 0;
            vb.width = rv.width / this._scaleX;
            vb.height = rv.height / this._scaleY;
          }
          policy.postApply(this);
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;
          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }
          this.emit('design-resolution-changed');
        }
        getDesignResolutionSize() {
          return new Size$1(this._designResolutionSize.width, this._designResolutionSize.height);
        }
        setRealPixelResolution(width, height, resolutionPolicy) {
          this.setDesignResolutionSize(width, height, resolutionPolicy);
        }
        getViewportRect() {
          return this._viewportRect;
        }
        getScaleX() {
          return this._scaleX;
        }
        getScaleY() {
          return this._scaleY;
        }
        getDevicePixelRatio() {
          return screenAdapter.devicePixelRatio;
        }
        convertToLocationInView(tx, ty, relatedPos, out = new Vec2()) {
          const x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
          const y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
          if (screenAdapter.isFrameRotated) {
            out.x = screen.windowSize.width - y;
            out.y = x;
          } else {
            out.x = x;
            out.y = y;
          }
          return out;
        }
        _convertToUISpace(point) {
          const viewport = this._viewportRect;
          point.x = (point.x - viewport.x) / this._scaleX;
          point.y = (point.y - viewport.y) / this._scaleY;
        }
        _updateAdaptResult(width, height, windowId) {
          var _this$_resizeCallback;
          legacyCC.director.root.resize(width, height, windowId === undefined || windowId === 0 ? 1 : windowId);
          const w = this._designResolutionSize.width;
          const h = this._designResolutionSize.height;
          if (width > 0 && height > 0) {
            this.setDesignResolutionSize(w, h, this._resolutionPolicy);
          } else {
            assert(false, '_updateAdaptResult Invalid size.');
          }
          this.emit('canvas-resize');
          (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
        }
      } exports('View', View);
      View.instance = void 0;
      class ContainerStrategy {
        constructor() {
          this.name = 'ContainerStrategy';
        }
        preApply(_view) {}
        apply(_view, designedResolution) {}
        postApply(_view) {}
        _setupCanvas() {
          const locCanvas = legacyCC.game.canvas;
          if (locCanvas) {
            const windowSize = screen.windowSize;
            if (locCanvas.width !== windowSize.width) {
              locCanvas.width = windowSize.width;
            }
            if (locCanvas.height !== windowSize.height) {
              locCanvas.height = windowSize.height;
            }
          }
        }
      }
      ContainerStrategy.EQUAL_TO_FRAME = void 0;
      ContainerStrategy.PROPORTION_TO_FRAME = void 0;
      class ContentStrategy {
        constructor() {
          this.name = 'ContentStrategy';
          this._result = void 0;
          this._result = {
            scale: [1, 1],
            viewport: null
          };
        }
        preApply(_view) {}
        apply(_view, designedResolution) {
          return {
            scale: [1, 1]
          };
        }
        postApply(_view) {}
        _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
          if (Math.abs(containerW - contentW) < 2) {
            contentW = containerW;
          }
          if (Math.abs(containerH - contentH) < 2) {
            contentH = containerH;
          }
          const viewport = new Rect$1(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
          this._result.scale = [scaleX, scaleY];
          this._result.viewport = viewport;
          return this._result;
        }
      }
      ContentStrategy.EXACT_FIT = void 0;
      ContentStrategy.SHOW_ALL = void 0;
      ContentStrategy.NO_BORDER = void 0;
      ContentStrategy.FIXED_HEIGHT = void 0;
      ContentStrategy.FIXED_WIDTH = void 0;
      (() => {
        class EqualToFrame extends ContainerStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'EqualToFrame';
          }
          apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = false;
            this._setupCanvas();
          }
        }
        class ProportionalToFrame extends ContainerStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ProportionalToFrame';
          }
          apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = true;
            this._setupCanvas();
          }
        }
        ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
        ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
        class ExactFit extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ExactFit';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const scaleX = containerW / designedResolution.width;
            const scaleY = containerH / designedResolution.height;
            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
          }
        }
        class ShowAll extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'ShowAll';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const designH = designedResolution.height;
            const scaleX = containerW / designW;
            const scaleY = containerH / designH;
            let scale = 0;
            let contentW;
            let contentH;
            if (scaleX < scaleY) {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            } else {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            }
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class NoBorder extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'NoBorder';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const designH = designedResolution.height;
            const scaleX = containerW / designW;
            const scaleY = containerH / designH;
            let scale;
            let contentW;
            let contentH;
            if (scaleX < scaleY) {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            } else {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            }
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class FixedHeight extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'FixedHeight';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designH = designedResolution.height;
            const scale = containerH / designH;
            const contentW = containerW;
            const contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        class FixedWidth extends ContentStrategy {
          constructor(...args) {
            super(...args);
            this.name = 'FixedWidth';
          }
          apply(_view, designedResolution) {
            const windowSize = screen.windowSize;
            const containerW = windowSize.width;
            const containerH = windowSize.height;
            const designW = designedResolution.width;
            const scale = containerW / designW;
            const contentW = containerW;
            const contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          }
        }
        ContentStrategy.EXACT_FIT = new ExactFit();
        ContentStrategy.SHOW_ALL = new ShowAll();
        ContentStrategy.NO_BORDER = new NoBorder();
        ContentStrategy.FIXED_HEIGHT = new FixedHeight();
        ContentStrategy.FIXED_WIDTH = new FixedWidth();
      })();
      class ResolutionPolicy {
        constructor(containerStg, contentStg) {
          this.name = 'ResolutionPolicy';
          this._containerStrategy = void 0;
          this._contentStrategy = void 0;
          this._containerStrategy = null;
          this._contentStrategy = null;
          this.setContainerStrategy(containerStg);
          this.setContentStrategy(contentStg);
        }
        get canvasSize() {
          return screen.windowSize;
        }
        preApply(_view) {
          this._contentStrategy.preApply(_view);
        }
        apply(_view, designedResolution) {
          this._containerStrategy.apply(_view, designedResolution);
          return this._contentStrategy.apply(_view, designedResolution);
        }
        postApply(_view) {
          this._contentStrategy.postApply(_view);
        }
        setContainerStrategy(containerStg) {
          if (containerStg instanceof ContainerStrategy) {
            this._containerStrategy = containerStg;
          }
        }
        setContentStrategy(contentStg) {
          if (contentStg instanceof ContentStrategy) {
            this._contentStrategy = contentStg;
          }
        }
      } exports('ResolutionPolicy', ResolutionPolicy);
      ResolutionPolicy.EXACT_FIT = 0;
      ResolutionPolicy.NO_BORDER = 1;
      ResolutionPolicy.SHOW_ALL = 2;
      ResolutionPolicy.FIXED_HEIGHT = 3;
      ResolutionPolicy.FIXED_WIDTH = 4;
      ResolutionPolicy.UNKNOWN = 5;
      ResolutionPolicy.ContainerStrategy = ContainerStrategy;
      ResolutionPolicy.ContentStrategy = ContentStrategy;
      legacyCC.ResolutionPolicy = ResolutionPolicy;
      const view = exports('view', View.instance = legacyCC.view = new View());
      director.registerSystem('view', view, 0);
      legacyCC.winSize = localWinSize;

      var _dec$1j, _dec2$1c, _dec3$W, _class$1h;
      let RenderRoot2D = exports('RenderRoot2D', (_dec$1j = ccclass$6('cc.RenderRoot2D'), _dec2$1c = executionOrder$1(100), _dec3$W = requireComponent(UITransform), _dec$1j(_class$1h = _dec2$1c(_class$1h = _dec3$W(_class$1h = disallowMultiple$1(_class$1h = class RenderRoot2D extends Component {
        onEnable() {
          legacyCC.director.root.batcher2D.addScreen(this);
        }
        onDisable() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        }
        onDestroy() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        }
      }) || _class$1h) || _class$1h) || _class$1h) || _class$1h));

      var _dec$1i, _dec2$1b, _dec3$V, _dec4$K, _class$1g, _class2$1c, _initializer$18, _initializer2$11;
      const _worldPos = new Vec3();
      const RenderMode$1 = Enum({
        OVERLAY: 0,
        INTERSPERSE: 1
      });
      let Canvas = (_dec$1i = ccclass$6('cc.Canvas'), _dec2$1b = executionOrder$1(100), _dec3$V = type$6(Camera), _dec4$K = type$6(Camera), _dec$1i(_class$1g = _dec2$1b(_class$1g = disallowMultiple$1(_class$1g = (_class2$1c = class Canvas extends RenderRoot2D {
        get renderMode() {
          return this._renderMode;
        }
        set renderMode(val) {
          this._renderMode = val;
          if (this._cameraComponent) {
            this._cameraComponent.priority = this._getViewPriority();
          }
        }
        get cameraComponent() {
          return this._cameraComponent;
        }
        set cameraComponent(value) {
          if (this._cameraComponent === value) {
            return;
          }
          this._cameraComponent = value;
          this._onResizeCamera();
        }
        get alignCanvasWithScreen() {
          return this._alignCanvasWithScreen;
        }
        set alignCanvasWithScreen(value) {
          this._alignCanvasWithScreen = value;
          this._onResizeCamera();
        }
        constructor() {
          super();
          this._cameraComponent = _initializer$18 && _initializer$18();
          this._alignCanvasWithScreen = _initializer2$11 && _initializer2$11();
          this._thisOnCameraResized = void 0;
          this.fitDesignResolution_EDITOR = void 0;
          this._pos = new Vec3();
          this._renderMode = RenderMode$1.OVERLAY;
          this._thisOnCameraResized = this._onResizeCamera.bind(this);
        }
        __preload() {
          const widget = this.getComponent('cc.Widget');
          if (widget) {
            widget.updateAlignment();
          }
          {
            if (this._cameraComponent) {
              this._cameraComponent._createCamera();
              this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
            }
          }
          this._onResizeCamera();
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        }
        onEnable() {
          super.onEnable();
          if (this._cameraComponent) {
            this._cameraComponent.node.on(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        }
        onDisable() {
          super.onDisable();
          if (this._cameraComponent) {
            this._cameraComponent.node.off(Camera.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        }
        onDestroy() {
          super.onDestroy();
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
        }
        _onResizeCamera() {
          if (this._cameraComponent && this._alignCanvasWithScreen) {
            if (this._cameraComponent.targetTexture) {
              this._cameraComponent.orthoHeight = visibleRect.height / 2;
            } else {
              const size = screen.windowSize;
              this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
            }
            this.node.getWorldPosition(_worldPos);
            this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
          }
        }
        _getViewPriority() {
          if (this._cameraComponent) {
            var _this$cameraComponent;
            let priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
            priority = this._renderMode === RenderMode$1.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
            return priority;
          }
          return 0;
        }
      }, (_applyDecoratedDescriptor(_class2$1c.prototype, "cameraComponent", [_dec3$V], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "cameraComponent"), _class2$1c.prototype), _initializer$18 = applyDecoratedInitializer(_class2$1c.prototype, "_cameraComponent", [_dec4$K], function () {
        return null;
      }), _initializer2$11 = applyDecoratedInitializer(_class2$1c.prototype, "_alignCanvasWithScreen", [serializable$6], function () {
        return true;
      })), _class2$1c)) || _class$1g) || _class$1g) || _class$1g); exports({ Canvas: Canvas, CanvasComponent: Canvas });
      legacyCC.Canvas = Canvas;

      var _dec$1h, _dec2$1a, _dec3$U, _class$1f;
      let UIComponent = exports('UIComponent', (_dec$1h = ccclass$6('cc.UIComponent'), _dec2$1a = requireComponent(UITransform), _dec3$U = executionOrder$1(110), _dec$1h(_class$1f = _dec2$1a(_class$1f = _dec3$U(_class$1f = disallowMultiple$1(_class$1f = class UIComponent extends Component {
        constructor(...args) {
          super(...args);
          this._lastParent = null;
          this.stencilStage = Stage.DISABLED;
        }
        __preload() {
          this.node._uiProps.uiComp = this;
        }
        onEnable() {}
        onDisable() {}
        onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
        }
        postUpdateAssembler(render) {}
        markForUpdateRenderData(enable = true) {}
        setNodeDirty() {}
        setTextureDirty() {}
      }) || _class$1f) || _class$1f) || _class$1f) || _class$1f));

      removeProperty(UIComponent.prototype, 'UIComponent', [{
        name: '_visibility'
      }, {
        name: 'setVisibility'
      }]);
      replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
        name: 'camera',
        newName: 'cameraComponent.camera',
        customGetter() {
          var _this$_cameraComponen;
          return (_this$_cameraComponen = this._cameraComponent) === null || _this$_cameraComponen === void 0 ? void 0 : _this$_cameraComponen.camera;
        }
      }, {
        name: 'clearFlag',
        newName: 'cameraComponent.clearFlags',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearFlags = val;
        }
      }, {
        name: 'color',
        newName: 'cameraComponent.clearColor',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearColor : Color$1.BLACK;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearColor = val;
        }
      }, {
        name: 'priority',
        newName: 'cameraComponent.priority',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.priority : 0;
        },
        customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.priority = val;
        }
      }, {
        name: 'targetTexture',
        newName: 'cameraComponent.targetTexture',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.targetTexture : null;
        },
        customSetter(value) {
          if (this._cameraComponent) this._cameraComponent.targetTexture = value;
        }
      }, {
        name: 'visibility',
        newName: 'cameraComponent.visibility',
        customGetter() {
          return this._cameraComponent ? this._cameraComponent.visibility : 0;
        }
      }]);
      markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
        name: 'priority',
        suggest: `Please use setSiblingIndex to change index of the current node in its parent's children array.`
      }]);
      legacyCC.UITransformComponent = UITransform;
      setClassAlias(UITransform, 'cc.UITransformComponent');
      setClassAlias(UIRenderer, 'cc.RenderComponent');
      legacyCC.CanvasComponent = Canvas;
      setClassAlias(Canvas, 'cc.CanvasComponent');
      legacyCC.internal.Renderable2D = UIRenderer;
      setClassAlias(UIRenderer, 'cc.Renderable2D');

      function rayAABB2(ray, min, max) {
        const o = ray.o;
        const d = ray.d;
        const ix = 1 / d.x;
        const iy = 1 / d.y;
        const iz = 1 / d.z;
        const t1 = (min.x - o.x) * ix;
        const t2 = (max.x - o.x) * ix;
        const t3 = (min.y - o.y) * iy;
        const t4 = (max.y - o.y) * iy;
        const t5 = (min.z - o.z) * iz;
        const t6 = (max.z - o.z) * iz;
        const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) {
          return 0;
        }
        return tmin > 0 ? tmin : tmax;
      }
      const raySubMesh = function () {
        const tri = Triangle.create();
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        let minDis = 0;
        const fillResult = (m, d, i0, i1, i2, r) => {
          if (m === ERaycastMode.CLOSEST) {
            if (minDis > d || minDis === 0) {
              minDis = d;
              if (r) {
                if (r.length === 0) {
                  r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                } else {
                  r[0].distance = d;
                  r[0].vertexIndex0 = i0 / 3;
                  r[0].vertexIndex1 = i1 / 3;
                  r[0].vertexIndex2 = i2 / 3;
                }
              }
            }
          } else {
            minDis = d;
            if (r) r.push({
              distance: d,
              vertexIndex0: i0 / 3,
              vertexIndex1: i1 / 3,
              vertexIndex2: i2 / 3
            });
          }
        };
        const narrowphase = (vb, ib, pm, ray, opt) => {
          if (pm === PrimitiveMode.TRIANGLE_LIST) {
            const cnt = ib.length;
            for (let j = 0; j < cnt; j += 3) {
              const i0 = ib[j] * 3;
              const i1 = ib[j + 1] * 3;
              const i2 = ib[j + 2] * 3;
              Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
            const cnt = ib.length - 2;
            let rev = 0;
            for (let j = 0; j < cnt; j += 1) {
              const i0 = ib[j - rev] * 3;
              const i1 = ib[j + rev + 1] * 3;
              const i2 = ib[j + 2] * 3;
              Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              rev = ~rev;
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
            const cnt = ib.length - 1;
            const i0 = ib[0] * 3;
            Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
            for (let j = 1; j < cnt; j += 1) {
              const i1 = ib[j] * 3;
              const i2 = ib[j + 1] * 3;
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          }
          return minDis;
        };
        return function (ray, submesh, options) {
          minDis = 0;
          if (submesh.geometricInfo.positions.length === 0) return minDis;
          const opt = options === undefined ? deOpt : options;
          const min = submesh.geometricInfo.boundingBox.min;
          const max = submesh.geometricInfo.boundingBox.max;
          if (rayAABB2(ray, min, max)) {
            const pm = submesh.primitiveMode;
            const {
              positions: vb,
              indices: ib
            } = submesh.geometricInfo;
            narrowphase(vb, ib, pm, ray, opt);
          }
          return minDis;
        };
      }();
      const rayMesh = function () {
        let minDis = 0;
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        return function (ray, mesh, options) {
          minDis = 0;
          const opt = options === undefined ? deOpt : options;
          const length = mesh.renderingSubMeshes.length;
          const min = mesh.struct.minPosition;
          const max = mesh.struct.maxPosition;
          if (min && max && !rayAABB2(ray, min, max)) return minDis;
          for (let i = 0; i < length; i++) {
            const sm = mesh.renderingSubMeshes[i];
            const dis = raySubMesh(ray, sm, opt);
            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);
                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }
          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }
            if (opt.subIndices) opt.subIndices.length = 1;
          }
          return minDis;
        };
      }();
      const rayModel = function () {
        let minDis = 0;
        const deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        const modelRay = new Ray();
        const m4 = new Mat4();
        return function (r, model, options) {
          minDis = 0;
          const opt = options === undefined ? deOpt : options;
          const wb = model.worldBounds;
          if (wb && !intersect.rayAABB(r, wb)) return minDis;
          Ray.copy(modelRay, r);
          if (model.node) {
            Mat4.invert(m4, model.node.getWorldMatrix(m4));
            Vec3.transformMat4(modelRay.o, r.o, m4);
            Vec3.transformMat4Normal(modelRay.d, r.d, m4);
          }
          const subModels = model.subModels;
          for (let i = 0; i < subModels.length; i++) {
            const subMesh = subModels[i].subMesh;
            const dis = raySubMesh(modelRay, subMesh, opt);
            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);
                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }
          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }
            if (opt.subIndices) opt.subIndices.length = 1;
          }
          return minDis;
        };
      }();
      intersect.rayModel = rayModel;
      intersect.raySubMesh = raySubMesh;
      intersect.rayMesh = rayMesh;

      var _dec$1g, _class$1e, _class2$1b, _initializer$17;
      getPhaseID('specular-pass');
      let ModelRenderer = (_dec$1g = ccclass$6('cc.ModelRenderer'), _dec$1g(_class$1e = (_class2$1b = class ModelRenderer extends Renderer {
        constructor(...args) {
          super(...args);
          this._visFlags = _initializer$17 && _initializer$17();
          this._models = [];
          this._priority = 0;
        }
        get visibility() {
          return this._visFlags;
        }
        set visibility(val) {
          this._visFlags = val;
          this._onVisibilityChange(val);
        }
        get priority() {
          return this._priority;
        }
        set priority(val) {
          if (val === this._priority) return;
          this._priority = val;
          this._updatePriority();
        }
        _collectModels() {
          return this._models;
        }
        onEnable() {
          this._updatePriority();
        }
        _attachToScene() {}
        _detachFromScene() {}
        _onVisibilityChange(val) {}
        _updatePriority() {
          if (this._models.length > 0) {
            for (let i = 0; i < this._models.length; i++) {
              this._models[i].priority = this._priority;
            }
          }
        }
      }, (_initializer$17 = applyDecoratedInitializer(_class2$1b.prototype, "_visFlags", [serializable$6], function () {
        return Layers.Enum.NONE;
      })), _class2$1b)) || _class$1e); exports({ ModelRenderer: ModelRenderer, RenderableComponent: ModelRenderer });

      var _dec$1f, _dec2$19, _class$1d, _class2$1a, _initializer$16;
      const {
        ccclass: ccclass$4,
        serializable: serializable$4,
        type: type$4,
        visible: visible$4
      } = _decorator;
      let PrefabLink = exports('PrefabLink', (_dec$1f = ccclass$4('cc.PrefabLink'), _dec2$19 = type$4(Prefab), _dec$1f(_class$1d = (_class2$1a = class PrefabLink extends Component {
        constructor(...args) {
          super(...args);
          this.prefab = _initializer$16 && _initializer$16();
        }
      }, (_initializer$16 = applyDecoratedInitializer(_class2$1a.prototype, "prefab", [_dec2$19, serializable$4], function () {
        return null;
      })), _class2$1a)) || _class$1d));

      replaceProperty(Camera, 'Camera', [{
        name: 'CameraClearFlag',
        newName: 'ClearFlag'
      }]);
      replaceProperty(Camera.prototype, 'Camera.prototype', [{
        name: 'color',
        newName: 'clearColor'
      }, {
        name: 'depth',
        newName: 'clearDepth'
      }, {
        name: 'stencil',
        newName: 'clearStencil'
      }]);
      markAsWarning(Renderer.prototype, 'Renderer.prototype', [{
        name: 'getMaterial',
        suggest: 'please use renderer.getSharedMaterial instead.'
      }]);
      legacyCC.CameraComponent = Camera;
      setClassAlias(Camera, 'cc.CameraComponent');
      legacyCC.RenderableComponent = ModelRenderer;
      setClassAlias(ModelRenderer, 'cc.RenderableComponent');

      var _dec$1e, _dec2$18, _dec3$T, _class$1c, _class2$19, _initializer$15, _initializer2$10, _initializer3$O, _initializer4$I, _initializer5$B, _initializer6$t;
      var SpriteMode;
      (function (SpriteMode) {
        SpriteMode[SpriteMode["SIMPLE"] = 0] = "SIMPLE";
        SpriteMode[SpriteMode["SLICED"] = 1] = "SLICED";
        SpriteMode[SpriteMode["TILED"] = 2] = "TILED";
      })(SpriteMode || (SpriteMode = {}));
      let SpriteRenderer = exports('SpriteRenderer', (_dec$1e = ccclass$6('cc.SpriteRenderer'), _dec2$18 = executionOrder$1(100), _dec3$T = type$6(SpriteFrame), _dec$1e(_class$1c = _dec2$18(_class$1c = (_class2$19 = class SpriteRenderer extends ModelRenderer {
        constructor(...args) {
          super(...args);
          this._spriteFrame = _initializer$15 && _initializer$15();
          this._mode = _initializer2$10 && _initializer2$10();
          this._color = _initializer3$O && _initializer3$O();
          this._flipX = _initializer4$I && _initializer4$I();
          this._flipY = _initializer5$B && _initializer5$B();
          this._size = _initializer6$t && _initializer6$t();
          this._model = null;
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          this._spriteFrame;
          this._spriteFrame = value;
          if (this._spriteFrame) {
            this._spriteFrame.ensureMeshData();
            const mesh = this._spriteFrame.mesh;
            mesh.initialize();
          }
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        }
        get model() {
          return this._model;
        }
        onLoad() {
          if (this._spriteFrame) {
            if (!this._spriteFrame.mesh) {
              this._spriteFrame.ensureMeshData();
            }
            this._spriteFrame.mesh.initialize();
          }
          this._updateModels();
        }
        onRestore() {
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        }
        onEnable() {
          super.onEnable();
          if (!this._model) {
            this._updateModels();
          }
          this._attachToScene();
        }
        onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
        }
        onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
          }
        }
        _updateModels() {
          if (!this._spriteFrame) {
            return;
          }
          const model = this._model;
          if (model) {
            model.destroy();
            model.initialize();
            model.node = model.transform = this.node;
          } else {
            this._createModel();
          }
          if (this._model) {
            const mesh = this._spriteFrame.mesh;
            this._model.createBoundingShape(mesh.struct.minPosition, mesh.struct.maxPosition);
            this._updateModelParams();
            this._onUpdateLocalDescriptorSet();
          }
        }
        _createModel() {
          const model = this._model = legacyCC.director.root.createModel(Model);
          model.visFlags = this.visibility;
          model.node = model.transform = this.node;
          this._models.length = 0;
          this._models.push(this._model);
        }
        _updateModelParams() {
          if (!this._spriteFrame || !this._model) {
            return;
          }
          this._spriteFrame.ensureMeshData();
          const mesh = this._spriteFrame.mesh;
          this.node.hasChangedFlags |= TransformBit.POSITION;
          this._model.transform.hasChangedFlags |= TransformBit.POSITION;
          const renderingMesh = mesh ? mesh.renderingSubMeshes : null;
          if (renderingMesh) {
            const meshCount = renderingMesh.length;
            for (let i = 0; i < meshCount; ++i) {
              let material = this.getRenderMaterial(i);
              if (material && !material.isValid) {
                material = null;
              }
              const subMeshData = renderingMesh[i];
              if (subMeshData) {
                this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
              }
            }
          }
          this._model.enabled = true;
        }
        _getBuiltinMaterial() {
          return builtinResMgr.get('missing-material');
        }
        _onMaterialModified(idx, material) {
          super._onMaterialModified(idx, material);
          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }
          this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        }
        _onRebuildPSO(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }
          this._model.setSubModelMaterial(idx, material);
          this._onUpdateLocalDescriptorSet();
        }
        _onUpdateLocalDescriptorSet() {
          if (!this._spriteFrame || !this._model || !this._model.inited) {
            return;
          }
          const texture = this._spriteFrame.getGFXTexture();
          const sampler = this._spriteFrame.getGFXSampler();
          const subModels = this._model.subModels;
          const binding = ModelLocalBindings.SAMPLER_SPRITE;
          for (let i = 0; i < subModels.length; i++) {
            const {
              descriptorSet
            } = subModels[i];
            descriptorSet.bindTexture(binding, texture);
            descriptorSet.bindSampler(binding, sampler);
            descriptorSet.update();
          }
        }
        _attachToScene() {
          if (!this.node.scene || !this._model) {
            return;
          }
          const renderScene = this._getRenderScene();
          if (this._model.scene !== null) {
            this._detachFromScene();
          }
          renderScene.addModel(this._model);
        }
        _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        }
      }, (_applyDecoratedDescriptor(_class2$19.prototype, "spriteFrame", [_dec3$T], Object.getOwnPropertyDescriptor(_class2$19.prototype, "spriteFrame"), _class2$19.prototype), _initializer$15 = applyDecoratedInitializer(_class2$19.prototype, "_spriteFrame", [serializable$6], function () {
        return null;
      }), _initializer2$10 = applyDecoratedInitializer(_class2$19.prototype, "_mode", [serializable$6], function () {
        return SpriteMode.SIMPLE;
      }), _initializer3$O = applyDecoratedInitializer(_class2$19.prototype, "_color", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer4$I = applyDecoratedInitializer(_class2$19.prototype, "_flipX", [serializable$6], function () {
        return false;
      }), _initializer5$B = applyDecoratedInitializer(_class2$19.prototype, "_flipY", [serializable$6], function () {
        return false;
      }), _initializer6$t = applyDecoratedInitializer(_class2$19.prototype, "_size", [serializable$6], function () {
        return new Vec2();
      })), _class2$19)) || _class$1c) || _class$1c));

      var _dec$1d, _dec2$17, _dec3$S, _dec4$J, _dec5$F, _dec6$s, _dec7$m, _dec8$i, _class$1b, _class2$18, _initializer$14, _initializer2$$, _initializer3$N, _initializer4$H, _initializer5$A, _initializer6$s, _initializer7$p, _initializer8$n, _initializer9$k, _initializer10$h, _initializer11$g, _initializer12$d, _initializer13$c, _initializer14$9, _class3$r;
      const _htmlTextParser = new HtmlTextParser();
      const RichTextChildName = 'RICHTEXT_CHILD';
      const RichTextChildImageName = 'RICHTEXT_Image_CHILD';
      const _tempSize = new Vec2();
      const _tempSizeLeft = new Vec2();
      const labelPool = new Pool$1(seg => {
        if (!legacyCC.isValid(seg.node)) {
          return false;
        } else {
          const outline = seg.node.getComponent(LabelOutline);
          if (outline) {
            outline.width = 0;
          }
        }
        return true;
      }, 20);
      const imagePool = new Pool$1(seg => {
        return legacyCC.isValid(seg.node);
      }, 10);
      function createSegment(type) {
        return {
          node: new Node$1(type),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: '',
          clickParam: '',
          clickHandler: '',
          type
        };
      }
      function getSegmentByPool(type, content) {
        let seg;
        if (type === RichTextChildName) {
          seg = labelPool._get();
        } else if (type === RichTextChildImageName) {
          seg = imagePool._get();
        }
        seg = seg || createSegment(type);
        let node = seg.node;
        if (!node) {
          node = new Node$1(type);
        }
        node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
        node.active = true;
        if (type === RichTextChildImageName) {
          seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
          seg.comp.spriteFrame = content;
          seg.comp.type = Sprite.Type.SLICED;
          seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
        } else {
          seg.comp = node.getComponent(Label) || node.addComponent(Label);
          seg.comp.string = content;
          seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
          seg.comp.verticalAlign = VerticalTextAlignment.TOP;
          seg.comp.underlineHeight = 2;
        }
        node.setPosition(0, 0, 0);
        const trans = node._uiProps.uiTransformComp;
        trans.setAnchorPoint(0.5, 0.5);
        seg.node = node;
        seg.lineCount = 0;
        seg.styleIndex = 0;
        seg.imageOffset = '';
        seg.clickParam = '';
        seg.clickHandler = '';
        return seg;
      }
      let RichText = (_dec$1d = ccclass$6('cc.RichText'), _dec2$17 = executionOrder$1(110), _dec3$S = type$6(HorizontalTextAlignment), _dec4$J = type$6(VerticalTextAlignment), _dec5$F = type$6(Color$1), _dec6$s = type$6(Font), _dec7$m = type$6(CacheMode), _dec8$i = type$6(SpriteAtlas), _dec$1d(_class$1b = _dec2$17(_class$1b = (_class2$18 = (_class3$r = class RichText extends Component {
        get string() {
          return this._string;
        }
        set string(value) {
          if (this._string === value) {
            return;
          }
          this._string = value;
          this._updateRichTextStatus();
        }
        get horizontalAlign() {
          return this._horizontalAlign;
        }
        set horizontalAlign(value) {
          if (this.horizontalAlign === value) {
            return;
          }
          this._horizontalAlign = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get verticalAlign() {
          return this._verticalAlign;
        }
        set verticalAlign(value) {
          if (this._verticalAlign === value) {
            return;
          }
          this._verticalAlign = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (this._fontSize === value) {
            return;
          }
          this._fontSize = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get fontColor() {
          return this._fontColor;
        }
        set fontColor(value) {
          if (this._fontColor === value) {
            return;
          }
          this._fontColor = value;
          this._updateTextDefaultColor();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          if (this._fontFamily === value) return;
          this._fontFamily = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get font() {
          return this._font;
        }
        set font(value) {
          if (this._font === value) {
            return;
          }
          this._font = value;
          this._layoutDirty = true;
          if (this._font) {
            this.useSystemFont = false;
            this._onTTFLoaded();
          } else {
            this.useSystemFont = true;
          }
          this._updateRichTextStatus();
        }
        get useSystemFont() {
          return this._isSystemFontUsed;
        }
        set useSystemFont(value) {
          if (this._isSystemFontUsed === value) {
            return;
          }
          this._isSystemFontUsed = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get cacheMode() {
          return this._cacheMode;
        }
        set cacheMode(value) {
          if (this._cacheMode === value) {
            return;
          }
          this._cacheMode = value;
          this._updateRichTextStatus();
        }
        get maxWidth() {
          return this._maxWidth;
        }
        set maxWidth(value) {
          if (this._maxWidth === value) {
            return;
          }
          this._maxWidth = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          if (this._lineHeight === value) {
            return;
          }
          this._lineHeight = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get imageAtlas() {
          return this._imageAtlas;
        }
        set imageAtlas(value) {
          if (this._imageAtlas === value) {
            return;
          }
          this._imageAtlas = value;
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
        get handleTouchEvent() {
          return this._handleTouchEvent;
        }
        set handleTouchEvent(value) {
          if (this._handleTouchEvent === value) {
            return;
          }
          this._handleTouchEvent = value;
          if (this.enabledInHierarchy) {
            if (this.handleTouchEvent) {
              this._addEventListeners();
            } else {
              this._removeEventListeners();
            }
          }
        }
        constructor() {
          super();
          this._lineHeight = _initializer$14 && _initializer$14();
          this._string = _initializer2$$ && _initializer2$$();
          this._horizontalAlign = _initializer3$N && _initializer3$N();
          this._verticalAlign = _initializer4$H && _initializer4$H();
          this._fontSize = _initializer5$A && _initializer5$A();
          this._fontColor = _initializer6$s && _initializer6$s();
          this._maxWidth = _initializer7$p && _initializer7$p();
          this._fontFamily = _initializer8$n && _initializer8$n();
          this._font = _initializer9$k && _initializer9$k();
          this._isSystemFontUsed = _initializer10$h && _initializer10$h();
          this._userDefinedFont = _initializer11$g && _initializer11$g();
          this._cacheMode = _initializer12$d && _initializer12$d();
          this._imageAtlas = _initializer13$c && _initializer13$c();
          this._handleTouchEvent = _initializer14$9 && _initializer14$9();
          this._textArray = [];
          this._segments = [];
          this._labelSegmentsCache = [];
          this._linesWidth = [];
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
          this._lineOffsetX = 0;
          this._updateRichTextStatus = void 0;
          this._labelChildrenNum = 0;
          this._updateRichTextStatus = this._updateRichText;
        }
        onLoad() {
          this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
        }
        onEnable() {
          if (this.handleTouchEvent) {
            this._addEventListeners();
          }
          this._updateRichText();
          this._activateChildren(true);
        }
        onDisable() {
          if (this.handleTouchEvent) {
            this._removeEventListeners();
          }
          this._activateChildren(false);
        }
        onRestore() {
          {
            return;
          }
        }
        onDestroy() {
          for (const seg of this._segments) {
            seg.node.removeFromParent();
            if (seg.type === RichTextChildName) {
              labelPool.put(seg);
            } else if (seg.type === RichTextChildImageName) {
              imagePool.put(seg);
            }
          }
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        }
        _addEventListeners() {
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        }
        _removeEventListeners() {
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        }
        _updateLabelSegmentTextAttributes() {
          this._segments.forEach(item => {
            this._applyTextAttribute(item);
          });
        }
        _createFontLabel(str) {
          return getSegmentByPool(RichTextChildName, str);
        }
        _createImage(spriteFrame) {
          return getSegmentByPool(RichTextChildImageName, spriteFrame);
        }
        _onTTFLoaded() {
          if (this._font instanceof TTFFont) {
            this._layoutDirty = true;
            this._updateRichText();
          } else {
            this._layoutDirty = true;
            this._updateRichText();
          }
        }
        splitLongStringApproximatelyIn2048(text, styleIndex) {
          const approxSize = text.length * this.fontSize;
          const partStringArr = [];
          if (approxSize <= 2048 * 0.8) {
            partStringArr.push(text);
            return partStringArr;
          }
          this._calculateSize(_tempSize, styleIndex, text);
          if (_tempSize.x < 2048) {
            partStringArr.push(text);
          } else {
            const multilineTexts = text.split('\n');
            for (let i = 0; i < multilineTexts.length; i++) {
              this._calculateSize(_tempSize, styleIndex, multilineTexts[i]);
              if (_tempSize.x < 2048) {
                partStringArr.push(multilineTexts[i]);
              } else {
                const thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);
                partStringArr.push(...thisPartSplitResultArr);
              }
            }
          }
          return partStringArr;
        }
        splitLongStringOver2048(text, styleIndex) {
          const partStringArr = [];
          const longStr = text;
          let curStart = 0;
          let curEnd = longStr.length / 2;
          let curString = longStr.substring(curStart, curEnd);
          let leftString = longStr.substring(curEnd);
          const curStringSize = this._calculateSize(_tempSize, styleIndex, curString);
          const leftStringSize = this._calculateSize(_tempSizeLeft, styleIndex, leftString);
          let maxWidth = this._maxWidth;
          if (this._maxWidth === 0) {
            maxWidth = 2047.9;
          }
          const lineCountForOnePart = 1;
          const sizeForOnePart = lineCountForOnePart * maxWidth;
          while (curStringSize.x > sizeForOnePart) {
            curEnd /= 2;
            if (curEnd < 1) {
              curEnd *= 2;
              break;
            }
            curString = curString.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            this._calculateSize(curStringSize, styleIndex, curString);
          }
          let leftTryTimes = 1000;
          let curWordStep = 1;
          while (leftTryTimes && curStart < text.length) {
            while (leftTryTimes && curStringSize.x < sizeForOnePart) {
              const nextPartExec = getEnglishWordPartAtFirst(leftString);
              if (nextPartExec && nextPartExec.length > 0) {
                curWordStep = nextPartExec[0].length;
              }
              curEnd += curWordStep;
              curString = longStr.substring(curStart, curEnd);
              leftString = longStr.substring(curEnd);
              this._calculateSize(curStringSize, styleIndex, curString);
              leftTryTimes--;
            }
            while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {
              curEnd -= curWordStep;
              curString = longStr.substring(curStart, curEnd);
              this._calculateSize(curStringSize, styleIndex, curString);
              curWordStep = 1;
              leftTryTimes--;
            }
            if (curString.length >= 2) {
              const lastWordExec = getEnglishWordPartAtLast(curString);
              if (lastWordExec && lastWordExec.length > 0 && curString !== lastWordExec[0]) {
                curEnd -= lastWordExec[0].length;
                curString = longStr.substring(curStart, curEnd);
              }
            }
            partStringArr.push(curString);
            const partStep = curString.length;
            curStart = curEnd;
            curEnd += partStep;
            curString = longStr.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            this._calculateSize(leftStringSize, styleIndex, leftString);
            this._calculateSize(curStringSize, styleIndex, curString);
            leftTryTimes--;
            if (leftStringSize.x < 2048 && curStringSize.x < sizeForOnePart) {
              partStringArr.push(curString);
              curStart = text.length;
              curEnd = text.length;
              curString = leftString;
              if (leftString !== '') {
                partStringArr.push(curString);
              }
              break;
            }
          }
          return partStringArr;
        }
        _measureText(styleIndex, string) {
          const func = s => {
            const width = this._calculateSize(_tempSize, styleIndex, s).x;
            return width;
          };
          if (string) {
            return func(string);
          } else {
            return func;
          }
        }
        _calculateSize(out, styleIndex, s) {
          let label;
          if (this._labelSegmentsCache.length === 0) {
            label = this._createFontLabel(s);
            this._labelSegmentsCache.push(label);
          } else {
            label = this._labelSegmentsCache[0];
            label.node.getComponent(Label).string = s;
          }
          label.styleIndex = styleIndex;
          this._applyTextAttribute(label);
          const size = label.node._uiProps.uiTransformComp.contentSize;
          Vec2.set(out, size.x, size.y);
          return out;
        }
        _onTouchEnded(event) {
          const components = this.node.getComponents(Component);
          for (const seg of this._segments) {
            const clickHandler = seg.clickHandler;
            const clickParam = seg.clickParam;
            if (clickHandler && this._containsTouchLocation(seg, event.touch.getUILocation())) {
              components.forEach(component => {
                const func = component[clickHandler];
                if (component.enabledInHierarchy && func) {
                  func.call(component, event, clickParam);
                }
              });
              event.propagationStopped = true;
            }
          }
        }
        _containsTouchLocation(label, point) {
          const comp = label.node.getComponent(UITransform);
          if (!comp) {
            return false;
          }
          const myRect = comp.getBoundingBoxToWorld();
          return myRect.contains(point);
        }
        _resetState() {
          const children = this.node.children;
          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              {
                assert(child.parent === this.node);
              }
              child.parent = null;
              const segment = createSegment(child.name);
              segment.node = child;
              if (child.name === RichTextChildName) {
                segment.comp = child.getComponent(Label);
                labelPool.put(segment);
              } else {
                segment.comp = child.getComponent(Sprite);
                imagePool.put(segment);
              }
              this._labelChildrenNum--;
            }
          }
          this._segments.length = 0;
          this._labelSegmentsCache.length = 0;
          this._linesWidth.length = 0;
          this._lineOffsetX = 0;
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
        }
        _activateChildren(active) {
          for (let i = this.node.children.length - 1; i >= 0; i--) {
            const child = this.node.children[i];
            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              child.active = active;
            }
          }
        }
        _addLabelSegment(stringToken, styleIndex) {
          let labelSegment;
          if (this._labelSegmentsCache.length === 0) {
            labelSegment = this._createFontLabel(stringToken);
          } else {
            labelSegment = this._labelSegmentsCache.pop();
            const label = labelSegment.node.getComponent(Label);
            if (label) {
              label.string = stringToken;
            }
          }
          const labelComp = labelSegment.comp;
          if (labelComp.verticalAlign !== this._verticalAlign) {
            labelComp.verticalAlign = this._verticalAlign;
          }
          labelSegment.styleIndex = styleIndex;
          labelSegment.lineCount = this._lineCount;
          labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);
          labelSegment.node.layer = this.node.layer;
          this.node.insertChild(labelSegment.node, this._labelChildrenNum++);
          this._applyTextAttribute(labelSegment);
          this._segments.push(labelSegment);
          return labelSegment;
        }
        _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
          let fragmentWidth = labelWidth;
          let labelSegment;
          if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
            let checkStartIndex = 0;
            while (this._lineOffsetX <= this._maxWidth) {
              const checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
              const checkString = labelString.substr(checkStartIndex, checkEndIndex);
              const checkStringWidth = this._measureText(styleIndex, checkString);
              if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                this._lineOffsetX += checkStringWidth;
                checkStartIndex += checkEndIndex;
              } else {
                if (checkStartIndex > 0) {
                  const remainingString = labelString.substr(0, checkStartIndex);
                  this._addLabelSegment(remainingString, styleIndex);
                  labelString = labelString.substr(checkStartIndex, labelString.length);
                  fragmentWidth = this._measureText(styleIndex, labelString);
                }
                this._updateLineInfo();
                break;
              }
            }
          }
          if (fragmentWidth > this._maxWidth) {
            const fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));
            for (let k = 0; k < fragments.length; ++k) {
              const splitString = fragments[k];
              labelSegment = this._addLabelSegment(splitString, styleIndex);
              const labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
              this._lineOffsetX += labelSize.width;
              if (fragments.length > 1 && k < fragments.length - 1) {
                this._updateLineInfo();
              }
            }
          } else {
            this._lineOffsetX += fragmentWidth;
            this._addLabelSegment(labelString, styleIndex);
          }
        }
        _isLastComponentCR(stringToken) {
          return stringToken.length - 1 === stringToken.lastIndexOf('\n');
        }
        _updateLineInfo() {
          this._linesWidth.push(this._lineOffsetX);
          this._lineOffsetX = 0;
          this._lineCount++;
        }
        _needsUpdateTextLayout(newTextArray) {
          if (this._layoutDirty || !this._textArray || !newTextArray) {
            return true;
          }
          if (this._textArray.length !== newTextArray.length) {
            return true;
          }
          for (let i = 0; i < this._textArray.length; i++) {
            const oldItem = this._textArray[i];
            const newItem = newTextArray[i];
            if (oldItem.text !== newItem.text) {
              return true;
            } else {
              const oldStyle = oldItem.style;
              const newStyle = newItem.style;
              if (oldStyle) {
                if (newStyle) {
                  if (!!newStyle.outline !== !!oldStyle.outline) {
                    return true;
                  }
                  if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                    return true;
                  }
                  if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                    return true;
                  }
                } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                  return true;
                }
              } else if (newStyle) {
                if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        _addRichTextImageElement(richTextElement) {
          if (!richTextElement.style) {
            return;
          }
          const style = richTextElement.style;
          const spriteFrameName = style.src;
          const spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
          if (!spriteFrame) {
            warnID(4400);
          } else {
            const segment = this._createImage(spriteFrame);
            segment.comp;
            switch (style.imageAlign) {
              case 'top':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);
                break;
              case 'center':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);
                break;
              default:
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);
                break;
            }
            if (style.imageOffset) {
              segment.imageOffset = style.imageOffset;
            }
            segment.node.layer = this.node.layer;
            this.node.insertChild(segment.node, this._labelChildrenNum++);
            this._segments.push(segment);
            const spriteRect = spriteFrame.rect.clone();
            let scaleFactor = 1;
            let spriteWidth = spriteRect.width;
            let spriteHeight = spriteRect.height;
            const expectWidth = style.imageWidth || 0;
            const expectHeight = style.imageHeight || 0;
            if (expectHeight > 0) {
              scaleFactor = expectHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            } else {
              scaleFactor = this._lineHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            }
            if (expectWidth > 0) {
              spriteWidth = expectWidth;
            }
            if (this._maxWidth > 0) {
              if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                this._updateLineInfo();
              }
              this._lineOffsetX += spriteWidth;
            } else {
              this._lineOffsetX += spriteWidth;
              if (this._lineOffsetX > this._labelWidth) {
                this._labelWidth = this._lineOffsetX;
              }
            }
            segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);
            segment.lineCount = this._lineCount;
            segment.clickHandler = '';
            segment.clickParam = '';
            const event = style.event;
            if (event) {
              segment.clickHandler = event.click;
              segment.clickParam = event.param;
            }
          }
        }
        _updateTextDefaultColor() {
          for (let i = 0; i < this._segments.length; ++i) {
            var _this$_textArray$segm, _this$_textArray$segm2;
            const segment = this._segments[i];
            const label = segment.node.getComponent(Label);
            if (!label) {
              continue;
            }
            if ((_this$_textArray$segm = this._textArray[segment.styleIndex]) !== null && _this$_textArray$segm !== void 0 && (_this$_textArray$segm2 = _this$_textArray$segm.style) !== null && _this$_textArray$segm2 !== void 0 && _this$_textArray$segm2.color) {
              continue;
            }
            label.color = this._fontColor;
          }
        }
        _updateRichText() {
          if (!this.enabledInHierarchy) {
            return;
          }
          const newTextArray = _htmlTextParser.parse(this._string);
          if (!this._needsUpdateTextLayout(newTextArray)) {
            this._textArray = newTextArray.slice();
            this._updateLabelSegmentTextAttributes();
            return;
          }
          this._textArray = newTextArray.slice();
          this._resetState();
          let lastEmptyLine = false;
          let label;
          for (let i = 0; i < this._textArray.length; ++i) {
            const richTextElement = this._textArray[i];
            let text = richTextElement.text;
            if (text === undefined) {
              continue;
            }
            if (text === '') {
              if (richTextElement.style && richTextElement.style.isNewLine) {
                this._updateLineInfo();
                continue;
              }
              if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                this._addRichTextImageElement(richTextElement);
                continue;
              }
            }
            const splitArr = this.splitLongStringApproximatelyIn2048(text, i);
            text = splitArr.join('\n');
            const multilineTexts = text.split('\n');
            for (let j = 0; j < multilineTexts.length; ++j) {
              const labelString = multilineTexts[j];
              if (labelString === '') {
                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                  continue;
                }
                this._updateLineInfo();
                lastEmptyLine = true;
                continue;
              }
              lastEmptyLine = false;
              if (this._maxWidth > 0) {
                const labelWidth = this._measureText(i, labelString);
                this._updateRichTextWithMaxWidth(labelString, labelWidth, i);
                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              } else {
                label = this._addLabelSegment(labelString, i);
                this._lineOffsetX += label.node._uiProps.uiTransformComp.width;
                if (this._lineOffsetX > this._labelWidth) {
                  this._labelWidth = this._lineOffsetX;
                }
                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              }
            }
          }
          if (!lastEmptyLine) {
            this._linesWidth.push(this._lineOffsetX);
          }
          if (this._maxWidth > 0) {
            this._labelWidth = this._maxWidth;
          }
          this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;
          this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);
          this._updateRichTextPosition();
          this._layoutDirty = false;
        }
        _getFirstWordLen(text, startIndex, textLen) {
          let character = getSymbolAt(text, startIndex);
          if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
            return 1;
          }
          let len = 1;
          for (let index = startIndex + 1; index < textLen; ++index) {
            character = getSymbolAt(text, index);
            if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }
            len++;
          }
          return len;
        }
        _updateRichTextPosition() {
          let nextTokenX = 0;
          let nextLineIndex = 1;
          const totalLineCount = this._lineCount;
          const trans = this.node._uiProps.uiTransformComp;
          const anchorX = trans.anchorX;
          const anchorY = trans.anchorY;
          for (let i = 0; i < this._segments.length; ++i) {
            const segment = this._segments[i];
            const lineCount = segment.lineCount;
            if (lineCount > nextLineIndex) {
              nextTokenX = 0;
              nextLineIndex = lineCount;
            }
            let lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);
            switch (this._horizontalAlign) {
              case HorizontalTextAlignment.LEFT:
                break;
              case HorizontalTextAlignment.CENTER:
                lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                break;
              case HorizontalTextAlignment.RIGHT:
                lineOffsetX -= this._linesWidth[lineCount - 1];
                break;
            }
            const pos = segment.node.position;
            segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);
            if (lineCount === nextLineIndex) {
              nextTokenX += segment.node._uiProps.uiTransformComp.width;
            }
            const sprite = segment.node.getComponent(Sprite);
            if (sprite) {
              const position = segment.node.position.clone();
              const lineHeightSet = this._lineHeight;
              const lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);
              switch (segment.node._uiProps.uiTransformComp.anchorY) {
                case 1:
                  position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                  break;
                case 0.5:
                  position.y += lineHeightReal / 2;
                  break;
                default:
                  position.y += (lineHeightReal - lineHeightSet) / 2;
                  break;
              }
              if (segment.imageOffset) {
                const offsets = segment.imageOffset.split(',');
                if (offsets.length === 1 && offsets[0]) {
                  const offsetY = parseFloat(offsets[0]);
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                } else if (offsets.length === 2) {
                  const offsetX = parseFloat(offsets[0]);
                  const offsetY = parseFloat(offsets[1]);
                  if (Number.isInteger(offsetX)) position.x += offsetX;
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                }
              }
              segment.node.position = position;
            }
            const outline = segment.node.getComponent(LabelOutline);
            if (outline) {
              const position = segment.node.position.clone();
              position.y -= outline.width;
              segment.node.position = position;
            }
          }
        }
        _convertLiteralColorValue(color) {
          const colorValue = color.toUpperCase();
          if (Color$1[colorValue]) {
            const colorUse = Color$1[colorValue];
            return colorUse;
          } else {
            const out = new Color$1();
            return out.fromHEX(color);
          }
        }
        _applyTextAttribute(labelSeg) {
          const label = labelSeg.node.getComponent(Label);
          if (!label) {
            return;
          }
          this._resetLabelState(label);
          const index = labelSeg.styleIndex;
          let textStyle;
          if (this._textArray[index]) {
            textStyle = this._textArray[index].style;
          }
          if (textStyle) {
            if (textStyle.color) {
              label.color = this._convertLiteralColorValue(textStyle.color);
            } else {
              label.color = this._fontColor;
            }
            label.isBold = !!textStyle.bold;
            label.isItalic = !!textStyle.italic;
            label.isUnderline = !!textStyle.underline;
            if (textStyle.outline) {
              let labelOutline = labelSeg.node.getComponent(LabelOutline);
              if (!labelOutline) {
                labelOutline = labelSeg.node.addComponent(LabelOutline);
              }
              labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
              labelOutline.width = textStyle.outline.width;
            }
            label.fontSize = textStyle.size || this._fontSize;
            labelSeg.clickHandler = '';
            labelSeg.clickParam = '';
            const event = textStyle.event;
            if (event) {
              labelSeg.clickHandler = event.click || '';
              labelSeg.clickParam = event.param || '';
            }
          }
          label.cacheMode = this._cacheMode;
          const isAsset = this._font instanceof Font;
          if (isAsset && !this._isSystemFontUsed) {
            label.font = this._font;
          } else {
            label.fontFamily = this._fontFamily;
          }
          label.useSystemFont = this._isSystemFontUsed;
          label.lineHeight = this._lineHeight;
          label.updateRenderData(true);
        }
        _applyLayer() {
          for (const seg of this._segments) {
            seg.node.layer = this.node.layer;
          }
        }
        _resetLabelState(label) {
          label.fontSize = this._fontSize;
          label.color = this._fontColor;
          label.isBold = false;
          label.isItalic = false;
          label.isUnderline = false;
        }
      }, _class3$r.HorizontalAlign = HorizontalTextAlignment, _class3$r.VerticalAlign = VerticalTextAlignment, _class3$r), (_applyDecoratedDescriptor(_class2$18.prototype, "horizontalAlign", [_dec3$S], Object.getOwnPropertyDescriptor(_class2$18.prototype, "horizontalAlign"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "verticalAlign", [_dec4$J], Object.getOwnPropertyDescriptor(_class2$18.prototype, "verticalAlign"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "fontColor", [_dec5$F], Object.getOwnPropertyDescriptor(_class2$18.prototype, "fontColor"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "font", [_dec6$s], Object.getOwnPropertyDescriptor(_class2$18.prototype, "font"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "cacheMode", [_dec7$m], Object.getOwnPropertyDescriptor(_class2$18.prototype, "cacheMode"), _class2$18.prototype), _applyDecoratedDescriptor(_class2$18.prototype, "imageAtlas", [_dec8$i], Object.getOwnPropertyDescriptor(_class2$18.prototype, "imageAtlas"), _class2$18.prototype), _initializer$14 = applyDecoratedInitializer(_class2$18.prototype, "_lineHeight", [serializable$6], function () {
        return 40;
      }), _initializer2$$ = applyDecoratedInitializer(_class2$18.prototype, "_string", [serializable$6], function () {
        return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
      }), _initializer3$N = applyDecoratedInitializer(_class2$18.prototype, "_horizontalAlign", [serializable$6], function () {
        return HorizontalTextAlignment.LEFT;
      }), _initializer4$H = applyDecoratedInitializer(_class2$18.prototype, "_verticalAlign", [serializable$6], function () {
        return VerticalTextAlignment.TOP;
      }), _initializer5$A = applyDecoratedInitializer(_class2$18.prototype, "_fontSize", [serializable$6], function () {
        return 40;
      }), _initializer6$s = applyDecoratedInitializer(_class2$18.prototype, "_fontColor", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer7$p = applyDecoratedInitializer(_class2$18.prototype, "_maxWidth", [serializable$6], function () {
        return 0;
      }), _initializer8$n = applyDecoratedInitializer(_class2$18.prototype, "_fontFamily", [serializable$6], function () {
        return 'Arial';
      }), _initializer9$k = applyDecoratedInitializer(_class2$18.prototype, "_font", [serializable$6], function () {
        return null;
      }), _initializer10$h = applyDecoratedInitializer(_class2$18.prototype, "_isSystemFontUsed", [serializable$6], function () {
        return true;
      }), _initializer11$g = applyDecoratedInitializer(_class2$18.prototype, "_userDefinedFont", [serializable$6], function () {
        return null;
      }), _initializer12$d = applyDecoratedInitializer(_class2$18.prototype, "_cacheMode", [serializable$6], function () {
        return CacheMode.NONE;
      }), _initializer13$c = applyDecoratedInitializer(_class2$18.prototype, "_imageAtlas", [serializable$6], function () {
        return null;
      }), _initializer14$9 = applyDecoratedInitializer(_class2$18.prototype, "_handleTouchEvent", [serializable$6], function () {
        return true;
      })), _class2$18)) || _class$1b) || _class$1b); exports({ RichText: RichText, RichTextComponent: RichText });
      legacyCC.RichText = RichText;

      var _dec$1c, _dec2$16, _class$1a;
      let UIMeshRenderer = (_dec$1c = ccclass$6('cc.UIMeshRenderer'), _dec2$16 = executionOrder$1(110), _dec$1c(_class$1a = _dec2$16(_class$1a = class UIMeshRenderer extends Component {
        constructor() {
          super();
          this._modelComponent = null;
          this._dirtyVersion = -1;
          this._internalId = -1;
          this.stencilStage = Stage.DISABLED;
          this._renderData = null;
          this._renderEntity = new RenderEntity(RenderEntityType.DYNAMIC);
          {
            this._UIModelNativeProxy = new NativeUIModelProxy();
          }
        }
        get modelComponent() {
          return this._modelComponent;
        }
        __preload() {
          this.node._uiProps.uiComp = this;
        }
        onEnable() {
          uiRendererManager.addRenderer(this);
          this.markForUpdateRenderData();
        }
        onDisable() {
          uiRendererManager.removeRenderer(this);
          this.renderEntity.enabled = this._canRender();
        }
        onLoad() {
          if (!this.node._uiProps.uiTransformComp) {
            this.node.addComponent('cc.UITransform');
          }
          this._modelComponent = this.getComponent('cc.ModelRenderer');
          if (!this._modelComponent) {
            warn(`node '${this.node && this.node.name}' doesn't have any renderable component`);
            return;
          }
          {
            this._UIModelNativeProxy.attachNode(this.node);
          }
          this.renderEntity.setNode(this.node);
        }
        onDestroy() {
          this.renderEntity.setNode(null);
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
          this._modelComponent = this.getComponent('cc.ModelRenderer');
          if (!this._modelComponent) {
            return;
          }
          this._modelComponent._sceneGetter = null;
        }
        _render(render) {
          if (this._modelComponent) {
            const models = this._modelComponent._collectModels();
            this._modelComponent._detachFromScene();
            for (let i = 0; i < models.length; i++) {
              if (models[i].enabled) {
                render.commitModel(this, models[i], this._modelComponent.material);
              }
            }
            return true;
          }
          return false;
        }
        fillBuffers(render) {
          if (this.enabled) {
            this._render(render);
          }
        }
        updateRenderer() {
          {
            this.renderEntity.enabled = this._canRender();
            if (this._modelComponent) {
              const models = this._modelComponent._collectModels();
              this._modelComponent._detachFromScene();
              this._UIModelNativeProxy.clearModels();
              this._renderEntity.clearDynamicRenderDrawInfos();
              for (let i = 0; i < models.length; i++) {
                if (models[i].enabled) {
                  this._uploadRenderData(i);
                  this._UIModelNativeProxy.updateModels(models[i]);
                }
              }
              this._UIModelNativeProxy.attachDrawInfo();
            }
          }
        }
        _uploadRenderData(index) {
          {
            const renderData = MeshRenderData.add();
            renderData.initRenderDrawInfo(this, RenderDrawInfoType.MODEL);
            this._renderData = renderData;
            this._renderData.material = this._modelComponent.getMaterialInstance(index);
          }
        }
        postUpdateAssembler(render) {}
        update() {
          {
            if (this._modelComponent) {
              this.markForUpdateRenderData();
            }
          }
          this._fitUIRenderQueue();
        }
        _fitUIRenderQueue() {
          if (!this._modelComponent) {
            return;
          }
          const matNum = this._modelComponent.sharedMaterials.length;
          for (let i = 0; i < matNum; i++) {
            const material = this._modelComponent.getMaterialInstance(i);
            if (material == null) {
              continue;
            }
            const passes = material.passes;
            const passNum = passes.length;
            for (let j = 0; j < passNum; j++) {
              const pass = passes[j];
              pass.setPriority(RenderPriority.MAX - 11);
              material.recompileShaders({
                CC_FORCE_FORWARD_SHADING: true
              }, j);
            }
          }
        }
        markForUpdateRenderData(enable = true) {
          uiRendererManager.markDirtyRenderer(this);
        }
        setNodeDirty() {}
        setTextureDirty() {}
        _canRender() {
          return this.enabled && this._modelComponent !== null;
        }
        get renderEntity() {
          {
            assert(Boolean(this._renderEntity), 'this._renderEntity should not be invalid');
          }
          return this._renderEntity;
        }
        get renderData() {
          return this._renderData;
        }
      }) || _class$1a) || _class$1a); exports({ UIMeshRenderer: UIMeshRenderer, UIModelComponent: UIMeshRenderer });
      legacyCC.UIMeshRenderer = UIMeshRenderer;

      const UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
      class DrawBatch2D {
        constructor() {
          this.model = null;
          this.texture = null;
          this.sampler = null;
          this.useLocalData = null;
          this.isStatic = false;
          this.textureHash = 0;
          this.samplerHash = 0;
          this._passes = [];
          this._shaders = [];
          this._visFlags = UI_VIS_FLAG;
          this._inputAssembler = null;
          this._descriptorSet = null;
        }
        get inputAssembler() {
          return this._inputAssembler;
        }
        set inputAssembler(ia) {
          this._inputAssembler = ia;
        }
        get descriptorSet() {
          return this._descriptorSet;
        }
        set descriptorSet(ds) {
          this._descriptorSet = ds;
        }
        get visFlags() {
          return this._visFlags;
        }
        set visFlags(vis) {
          this._visFlags = vis;
        }
        get passes() {
          return this._passes;
        }
        get shaders() {
          return this._shaders;
        }
        destroy(ui) {
          this._passes = [];
        }
        clear() {
          this._inputAssembler = null;
          this._descriptorSet = null;
          this.texture = null;
          this.sampler = null;
          this.textureHash = 0;
          this.samplerHash = 0;
          this.model = null;
          this.isStatic = false;
          this.useLocalData = null;
          this.visFlags = UI_VIS_FLAG;
        }
        fillPasses(mat, dss, dssHash, patches) {
          if (mat) {
            const passes = mat.passes;
            if (!passes) {
              return;
            }
            this._shaders.length = passes.length;
            for (let i = 0; i < passes.length; i++) {
              if (!this._passes[i]) {
                this._passes[i] = new Pass(legacyCC.director.root);
              }
              const mtlPass = passes[i];
              const passInUse = this._passes[i];
              mtlPass.update();
              if (!dss) {
                dss = mtlPass.depthStencilState;
                dssHash = 0;
              }
              passInUse._initPassFromTarget(mtlPass, dss, dssHash);
              this._shaders[i] = passInUse.getShaderVariant(patches);
            }
          }
        }
      }

      var _dec$1b, _dec2$15, _class$19, _class2$17;
      let UIStaticBatch = (_dec$1b = ccclass$6('cc.UIStaticBatch'), _dec2$15 = executionOrder$1(110), _dec$1b(_class$19 = _dec2$15(_class$19 = (_class2$17 = class UIStaticBatch extends UIRenderer {
        constructor(...args) {
          super(...args);
          this._init = false;
          this._bufferAccessor = null;
          this._dirty = true;
          this._uiDrawBatchList = [];
        }
        get color() {
          return this._color;
        }
        set color(value) {
          if (this._color === value) {
            return;
          }
          this._color.set(value);
        }
        get drawBatchList() {
          return this._uiDrawBatchList;
        }
        postUpdateAssembler(render) {}
        markAsDirty() {}
        _requireDrawBatch() {
          const batch = new DrawBatch2D();
          batch.isStatic = true;
          this._uiDrawBatchList.push(batch);
          return batch;
        }
        _clearData() {
          if (this._bufferAccessor) {
            this._bufferAccessor.reset();
            const ui = this._getBatcher();
            for (let i = 0; i < this._uiDrawBatchList.length; i++) {
              const element = this._uiDrawBatchList[i];
              element.destroy(ui);
            }
          }
          this._uiDrawBatchList.length = 0;
          this._init = false;
        }
        _getBatcher() {
          if (director.root && director.root.batcher2D) {
            return director.root.batcher2D;
          }
          warnID(9301);
          return null;
        }
      }, (_applyDecoratedDescriptor(_class2$17.prototype, "color", [override], Object.getOwnPropertyDescriptor(_class2$17.prototype, "color"), _class2$17.prototype)), _class2$17)) || _class$19) || _class$19); exports({ UIStaticBatch: UIStaticBatch, UIStaticBatchComponent: UIStaticBatch });

      var _dec$1a, _dec2$14, _dec3$R, _class$18;
      let LabelShadow = exports('LabelShadow', (_dec$1a = ccclass$6('cc.LabelShadow'), _dec2$14 = executionOrder$1(110), _dec3$R = requireComponent(Label), _dec$1a(_class$18 = _dec2$14(_class$18 = _dec3$R(_class$18 = class LabelShadow extends Component {
        get color() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          return label.shadowColor;
        }
        set color(value) {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.shadowColor = value;
        }
        get offset() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          return label.shadowOffset;
        }
        set offset(value) {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.shadowOffset = value;
        }
        get blur() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          return label.shadowBlur;
        }
        set blur(value) {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.shadowBlur = value;
        }
        onEnable() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.enableShadow = true;
        }
        onDisable() {
          const label = this.node.getComponent(Label);
          assertIsTrue(label);
          label.enableShadow = false;
        }
      }) || _class$18) || _class$18) || _class$18));

      var _dec$19, _dec2$13, _class$17, _class2$16, _initializer$13;
      let UIOpacity = (_dec$19 = ccclass$6('cc.UIOpacity'), _dec2$13 = executionOrder$1(110), _dec$19(_class$17 = _dec2$13(_class$17 = disallowMultiple$1(_class$17 = (_class2$16 = class UIOpacity extends Component {
        constructor(...args) {
          super(...args);
          this._setByParent = false;
          this._opacity = _initializer$13 && _initializer$13();
        }
        get opacity() {
          return this._opacity;
        }
        set opacity(value) {
          if (this._opacity === value) {
            return;
          }
          value = clampf(value, 0, 255);
          this._opacity = value;
          this.node._uiProps.localOpacity = value / 255;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
        setEntityLocalOpacityDirtyRecursively(dirty) {
          {
            UIOpacity.setEntityLocalOpacityDirtyRecursively(this.node, dirty, 1, false);
          }
        }
        static setEntityLocalOpacityDirtyRecursively(node, dirty, interruptParentOpacity, setByParent) {
          if (!node.isValid) {
            return;
          }
          const render = node._uiProps.uiComp;
          const uiOp = node.getComponent(UIOpacity);
          let interruptOpacity = interruptParentOpacity;
          if (render && render.color) {
            render.renderEntity.colorDirty = dirty;
            if (uiOp) {
              render.renderEntity.localOpacity = interruptOpacity * uiOp.opacity / 255;
              uiOp._setByParent = setByParent;
            } else {
              render.renderEntity.localOpacity = interruptOpacity;
            }
            render.node._uiProps.localOpacity = render.renderEntity.localOpacity;
            interruptOpacity = 1;
          } else if (uiOp) {
            interruptOpacity = interruptOpacity * uiOp.opacity / 255;
            uiOp._setByParent = setByParent;
          }
          for (let i = 0; i < node.children.length; i++) {
            UIOpacity.setEntityLocalOpacityDirtyRecursively(node.children[i], dirty || interruptOpacity < 1, interruptOpacity, true);
          }
        }
        onEnable() {
          if (this._setByParent) {
            return;
          }
          this.node._uiProps.localOpacity = this._opacity / 255;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
        onDisable() {
          if (this._setByParent) {
            return;
          }
          this.node._uiProps.localOpacity = 1;
          this.setEntityLocalOpacityDirtyRecursively(true);
        }
      }, (_initializer$13 = applyDecoratedInitializer(_class2$16.prototype, "_opacity", [serializable$6], function () {
        return 255;
      })), _class2$16)) || _class$17) || _class$17) || _class$17); exports({ UIOpacity: UIOpacity, UIOpacityComponent: UIOpacity });

      legacyCC.MaskComponent = Mask;
      setClassAlias(Mask, 'cc.MaskComponent');
      legacyCC.LabelComponent = Label;
      setClassAlias(Label, 'cc.LabelComponent');
      legacyCC.LabelOutlineComponent = LabelOutline;
      setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
      legacyCC.RichTextComponent = RichText;
      setClassAlias(RichText, 'cc.RichTextComponent');
      legacyCC.SpriteComponent = Sprite;
      setClassAlias(Sprite, 'cc.SpriteComponent');
      legacyCC.UIModelComponent = UIMeshRenderer;
      setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
      legacyCC.GraphicsComponent = Graphics;
      setClassAlias(Graphics, 'cc.GraphicsComponent');
      setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
      setClassAlias(UIOpacity, 'cc.UIOpacityComponent');
      replaceProperty(Mask.prototype, 'Mask', [{
        name: 'graphics',
        newName: 'subComp',
        target: Mask.prototype,
        targetName: 'Mask'
      }]);
      replaceProperty(MaskType, 'MaskType', [{
        name: 'RECT',
        newName: 'GRAPHICS_RECT',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'ELLIPSE',
        newName: 'GRAPHICS_ELLIPSE',
        target: MaskType,
        targetName: 'MaskType'
      }, {
        name: 'IMAGE_STENCIL',
        newName: 'SPRITE_STENCIL',
        target: MaskType,
        targetName: 'MaskType'
      }]);
      markAsWarning(LabelOutline.prototype, 'LabelOutline', [{
        name: 'width',
        suggest: 'Please use Label.outlineWidth instead.'
      }, {
        name: 'color',
        suggest: 'Please use Label.outlineColor instead.'
      }]);
      markAsWarning(LabelShadow.prototype, 'LabelShadow', [{
        name: 'color',
        suggest: 'Please use Label.shadowColor instead.'
      }, {
        name: 'offset',
        suggest: 'Please use Label.shadowOffset instead.'
      }, {
        name: 'blur',
        suggest: 'Please use Label.shadowBlur instead.'
      }]);

      class Aim {
        constructor(i, x, y) {
          this.i = void 0;
          this.x = void 0;
          this.y = void 0;
          this.prev = null;
          this.next = null;
          this.z = null;
          this.prevZ = null;
          this.nextZ = null;
          this.steiner = false;
          this.i = i;
          this.x = x;
          this.y = y;
        }
      }
      function linkedList(datas, start, end, dim, clockwise) {
        let i = 0;
        let last = null;
        if (clockwise === signedArea(datas, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        } else {
          for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end = null) {
        if (!start) {
          return start;
        }
        if (!end) {
          end = start;
        }
        let p = start;
        let again = false;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) {
              return null;
            }
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, size, pass = 0) {
        if (!ear) {
          return;
        }
        if (!pass && size) {
          indexCurve(ear, minX, minY, size);
        }
        let stop = ear;
        let prev = null;
        let next = null;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(ear, triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, size, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, size);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        const a = ear.prev;
        const b = ear;
        const c = ear.next;
        if (area(a, b, c) >= 0) {
          return false;
        }
        let p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, size) {
        const a = ear.prev;
        const b = ear;
        const c = ear.next;
        if (area(a, b, c) >= 0) {
          return false;
        }
        const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
        const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
        const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
        const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        const minZ = zOrder(minTX, minTY, minX, minY, size);
        const maxZ = zOrder(maxTX, maxTY, minX, minY, size);
        let p = ear.nextZ;
        while (p && p.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.nextZ;
        }
        p = ear.prevZ;
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }
          p = p.prevZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        let p = start;
        do {
          const a = p.prev;
          const b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return p;
      }
      function splitEarcut(start, triangles, dim, minX, minY, size) {
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              let c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, size);
              earcutLinked(c, triangles, dim, minX, minY, size);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(datas, holeIndices, outerNode, dim) {
        const queue = [];
        let i = 0;
        let len = 0;
        let start = 0;
        let end = 0;
        let list = null;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
          list = linkedList(datas, start, end, dim, false);
          if (!list) {
            continue;
          }
          if (list === list.next) {
            list.steiner = true;
          }
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        if (!outerNode) {
          return outerNode;
        }
        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
          const b = splitPolygon(outerNode, hole);
          filterPoints(b, b.next);
        }
      }
      function findHoleBridge(hole, outerNode) {
        let p = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m = null;
        do {
          if (hy <= p.y && hy >= p.next.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p.y) {
                  return p;
                }
                if (hy === p.next.y) {
                  return p.next;
                }
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m) {
          return null;
        }
        if (hx === qx) {
          return m.prev;
        }
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        let tan;
        p = m.next;
        while (p !== stop) {
          if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        }
        return m;
      }
      function indexCurve(start, minX, minY, size) {
        let p = start;
        do {
          if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, size);
          }
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        let i = 0;
        let p = null;
        let q = null;
        let e = null;
        let tail = null;
        let numMerges = 0;
        let pSize = 0;
        let qSize = 0;
        let inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q) {
                break;
              }
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize === 0) {
                e = q;
                q = q.nextZ;
                qSize--;
              } else if (qSize === 0 || !q) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else if (p.z <= q.z) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail) {
                tail.nextZ = e;
              } else {
                list = e;
              }
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, size) {
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }
      function getLeftmost(start) {
        let p = start;
        let leftmost = start;
        do {
          if (p.x < leftmost.x) {
            leftmost = p;
          }
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
          return true;
        }
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
      }
      function intersectsPolygon(a, b) {
        let p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
            return true;
          }
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        let p = a;
        let inside = false;
        const px = (a.x + b.x) / 2;
        const py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
            inside = !inside;
          }
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        const a2 = new Aim(a.i, a.x, a.y);
        const b2 = new Aim(b.i, b.x, b.y);
        const an = a.next;
        const bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        const p = new Aim(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
          p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
          p.nextZ.prevZ = p.prevZ;
        }
      }
      function signedArea(datas, start, end, dim) {
        let sum = 0;
        for (let i = start, j = end - dim; i < end; i += dim) {
          sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
          j = i;
        }
        return sum;
      }
      function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        const hasHoles = holeIndices ? holeIndices.length : 0;
        const outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
        let outerNode = linkedList(datas, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode) {
          return triangles;
        }
        let minX = 0;
        let minY = 0;
        let maxX = 0;
        let maxY = 0;
        let x = 0;
        let y = 0;
        let size = 0;
        if (hasHoles) {
          outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
        }
        if (datas.length > 80 * dim) {
          minX = maxX = datas[0];
          minY = maxY = datas[1];
          for (let i = dim; i < outerLen; i += dim) {
            x = datas[i];
            y = datas[i + 1];
            if (x < minX) {
              minX = x;
            }
            if (y < minY) {
              minY = y;
            }
            if (x > maxX) {
              maxX = x;
            }
            if (y > maxY) {
              maxY = y;
            }
          }
          size = Math.max(maxX - minX, maxY - minY);
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, size);
        return triangles;
      }

      const MAX_VERTEX = 65535;
      const MAX_INDICES = MAX_VERTEX * 2;
      const PI = Math.PI;
      const min = Math.min;
      const max = Math.max;
      const ceil = Math.ceil;
      const acos = Math.acos;
      const cos = Math.cos;
      const sin = Math.sin;
      const atan2 = Math.atan2;
      const attrBytes = 8;
      let _renderData = null;
      let _impl = null;
      const _curColor = new Color$1();
      const vec3_temps = [];
      for (let i = 0; i < 4; i++) {
        vec3_temps.push(new Vec3());
      }
      function curveDivs(r, arc, tol) {
        const da = acos(r / (r + tol)) * 2.0;
        return max(2, ceil(arc / da));
      }
      function clamp(v, minNum, maxNum) {
        if (v < minNum) {
          return minNum;
        } else if (v > maxNum) {
          return maxNum;
        }
        return v;
      }
      const graphicsAssembler = {
        useModel: true,
        updateRenderData(graphics) {
          {
            if (graphics.renderData) {
              graphics.renderData.material = graphics.getMaterialInstance(0);
            }
          }
        },
        fillBuffers(graphics, renderer) {},
        renderIA(graphics, renderer) {},
        getRenderData(graphics, vertexCount) {
          if (!_impl) {
            return null;
          }
          const renderDataList = _impl.getRenderDataList();
          let renderData = renderDataList[_impl.dataOffset];
          if (!renderData) {
            return null;
          }
          let meshBuffer = renderData;
          const maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;
          if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
            ++_impl.dataOffset;
            if (_impl.dataOffset < renderDataList.length) {
              renderData = renderDataList[_impl.dataOffset];
            } else {
              renderData = _impl.requestRenderData();
              renderDataList[_impl.dataOffset] = renderData;
            }
            meshBuffer = renderData;
          }
          if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
            meshBuffer.request(vertexCount, vertexCount * 3);
          }
          return renderData;
        },
        stroke(graphics) {
          Color$1.copy(_curColor, graphics.strokeColor);
          if (!graphics.impl) {
            return;
          }
          this._flattenPaths(graphics.impl);
          this._expandStroke(graphics);
          graphics.impl.updatePathOffset = true;
          this.end(graphics);
        },
        fill(graphics) {
          Color$1.copy(_curColor, graphics.fillColor);
          this._expandFill(graphics);
          if (graphics.impl) {
            graphics.impl.updatePathOffset = true;
          }
          this.end(graphics);
        },
        end(graphics) {
          graphics.markForUpdateRenderData();
        },
        _expandStroke(graphics) {
          const w = graphics.lineWidth * 0.5;
          const lineCap = graphics.lineCap;
          const lineJoin = graphics.lineJoin;
          const miterLimit = graphics.miterLimit;
          _impl = graphics.impl;
          if (!_impl) {
            return;
          }
          const nCap = curveDivs(w, PI, _impl.tessTol);
          this._calculateJoins(_impl, w, lineJoin, miterLimit);
          const paths = _impl.paths;
          let vertexCount = 0;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pointsLength = path.points.length;
            if (lineJoin === LineJoin.ROUND) {
              vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
            } else {
              vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
            }
            if (!path.closed) {
              if (lineCap === LineCap.ROUND) {
                vertexCount += (nCap * 2 + 2) * 2;
              } else {
                vertexCount += (3 + 3) * 2;
              }
            }
          }
          const meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);
          if (!meshBuffer) {
            return;
          }
          const vData = meshBuffer.vData;
          const iData = meshBuffer.iData;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const pointsLength = pts.length;
            const offset = meshBuffer.vertexStart;
            let p0;
            let p1;
            let start = 0;
            let end = 0;
            const loop = path.closed;
            if (loop) {
              p0 = pts[pointsLength - 1];
              p1 = pts[0];
              start = 0;
              end = pointsLength;
            } else {
              p0 = pts[0];
              p1 = pts[1];
              start = 1;
              end = pointsLength - 1;
            }
            p1 = p1 || p0;
            if (!loop) {
              const dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              const dx = dPos.x;
              const dy = dPos.y;
              if (lineCap === LineCap.BUTT) {
                this._buttCapStart(p0, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapStart(p0, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapStart(p0, dx, dy, w, nCap);
              }
            }
            for (let j = start; j < end; ++j) {
              if (lineJoin === LineJoin.ROUND) {
                this._roundJoin(p0, p1, w, w, nCap);
              } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                this._bevelJoin(p0, p1, w, w);
              } else {
                this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);
                this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
              }
              p0 = p1;
              p1 = pts[j + 1];
            }
            if (loop) {
              const vDataOffset = offset * attrBytes;
              this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);
              this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
            } else {
              const dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              const dx = dPos.x;
              const dy = dPos.y;
              if (lineCap === LineCap.BUTT) {
                this._buttCapEnd(p1, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapEnd(p1, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapEnd(p1, dx, dy, w, nCap);
              }
            }
            let indicesOffset = meshBuffer.indexStart;
            for (let begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
              iData[indicesOffset++] = begin - 2;
              iData[indicesOffset++] = begin - 1;
              iData[indicesOffset++] = begin;
            }
            meshBuffer.indexStart = indicesOffset;
          }
          _renderData = null;
          _impl = null;
        },
        _expandFill(graphics) {
          _impl = graphics.impl;
          if (!_impl) {
            return;
          }
          const paths = _impl.paths;
          let vertexCount = 0;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pointsLength = path.points.length;
            vertexCount += pointsLength;
          }
          const renderData = _renderData = this.getRenderData(graphics, vertexCount);
          if (!renderData) {
            return;
          }
          const meshBuffer = renderData;
          const vData = meshBuffer.vData;
          const iData = meshBuffer.iData;
          for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const pointsLength = pts.length;
            if (pointsLength === 0) {
              continue;
            }
            const vertexOffset = renderData.vertexStart;
            for (let j = 0; j < pointsLength; ++j) {
              this._vSet(pts[j].x, pts[j].y);
            }
            let indicesOffset = renderData.indexStart;
            if (path.complex) {
              const earcutData = [];
              for (let j = vertexOffset, end = renderData.vertexStart; j < end; j++) {
                let vDataOffset = j * attrBytes;
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
              }
              const newIndices = earcut(earcutData, null, 3);
              if (!newIndices || newIndices.length === 0) {
                continue;
              }
              for (let j = 0, nIndices = newIndices.length; j < nIndices; j++) {
                iData[indicesOffset++] = newIndices[j] + vertexOffset;
              }
            } else {
              const first = vertexOffset;
              for (let start = vertexOffset + 2, end = meshBuffer.vertexStart; start < end; start++) {
                iData[indicesOffset++] = first;
                iData[indicesOffset++] = start - 1;
                iData[indicesOffset++] = start;
              }
            }
            meshBuffer.indexStart = indicesOffset;
          }
          _renderData = null;
          _impl = null;
        },
        _calculateJoins(impl, w, lineJoin, miterLimit) {
          let iw = 0.0;
          if (w > 0.0) {
            iw = 1 / w;
          }
          const paths = impl.paths;
          for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            const ptsLength = pts.length;
            let p0 = pts[ptsLength - 1];
            let p1 = pts[0];
            path.bevel = 0;
            for (let j = 0; j < ptsLength; j++) {
              let dmr2 = 0;
              let cross = 0;
              let limit = 0;
              const dlx0 = p0.dy;
              const dly0 = -p0.dx;
              const dlx1 = p1.dy;
              const dly1 = -p1.dx;
              p1.dmx = (dlx0 + dlx1) * 0.5;
              p1.dmy = (dly0 + dly1) * 0.5;
              dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
              if (dmr2 > 0.000001) {
                let scale = 1 / dmr2;
                if (scale > 600) {
                  scale = 600;
                }
                p1.dmx *= scale;
                p1.dmy *= scale;
              }
              cross = p1.dx * p0.dy - p0.dx * p1.dy;
              if (cross > 0) {
                p1.flags |= PointFlags.PT_LEFT;
              }
              limit = max(11, min(p0.len, p1.len) * iw);
              if (dmr2 * limit * limit < 1) {
                p1.flags |= PointFlags.PT_INNERBEVEL;
              }
              if (p1.flags & PointFlags.PT_CORNER) {
                if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                  p1.flags |= PointFlags.PT_BEVEL;
                }
              }
              if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                path.bevel++;
              }
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _flattenPaths(impl) {
          const paths = impl.paths;
          for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
            const path = paths[i];
            const pts = path.points;
            let p0 = pts[pts.length - 1];
            let p1 = pts[0];
            if (pts.length > 2 && p0.equals(p1)) {
              path.closed = true;
              pts.pop();
              p0 = pts[pts.length - 1];
            }
            for (let j = 0, size = pts.length; j < size; j++) {
              const dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              p0.len = dPos.length();
              if (dPos.x || dPos.y) {
                dPos.normalize();
              }
              p0.dx = dPos.x;
              p0.dy = dPos.y;
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _chooseBevel(bevel, p0, p1, w) {
          const x = p1.x;
          const y = p1.y;
          let x0 = 0;
          let y0 = 0;
          let x1 = 0;
          let y1 = 0;
          if (bevel !== 0) {
            x0 = x + p0.dy * w;
            y0 = y - p0.dx * w;
            x1 = x + p1.dy * w;
            y1 = y - p1.dx * w;
          } else {
            x0 = x1 = x + p1.dmx * w;
            y0 = y1 = y + p1.dmy * w;
          }
          return [x0, y0, x1, y1];
        },
        _buttCapStart(p, dx, dy, w, d) {
          const px = p.x - dx * d;
          const py = p.y - dy * d;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _buttCapEnd(p, dx, dy, w, d) {
          const px = p.x + dx * d;
          const py = p.y + dy * d;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapStart(p, dx, dy, w, nCap) {
          const px = p.x;
          const py = p.y;
          const dlx = dy;
          const dly = -dx;
          for (let i = 0; i < nCap; i++) {
            const a = i / (nCap - 1) * PI;
            const ax = cos(a) * w;
            const ay = sin(a) * w;
            this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);
            this._vSet(px, py, 0);
          }
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapEnd(p, dx, dy, w, nCap) {
          const px = p.x;
          const py = p.y;
          const dlx = dy;
          const dly = -dx;
          this._vSet(px + dlx * w, py + dly * w, 1);
          this._vSet(px - dlx * w, py - dly * w, -1);
          for (let i = 0; i < nCap; i++) {
            const a = i / (nCap - 1) * PI;
            const ax = cos(a) * w;
            const ay = sin(a) * w;
            this._vSet(px, py, 0);
            this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
          }
        },
        _roundJoin(p0, p1, lw, rw, nCap) {
          const dlx0 = p0.dy;
          const dly0 = -p0.dx;
          const dlx1 = p1.dy;
          const dly1 = -p1.dx;
          const p1x = p1.x;
          const p1y = p1.y;
          if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            const lx0 = out[0];
            const ly0 = out[1];
            const lx1 = out[2];
            const ly1 = out[3];
            const a0 = atan2(-dly0, -dlx0);
            let a1 = atan2(-dly1, -dlx1);
            if (a1 > a0) {
              a1 -= PI * 2;
            }
            this._vSet(lx0, ly0, 1);
            this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);
            const n = clamp(ceil((a0 - a1) / PI) * nCap, 2, nCap);
            for (let i = 0; i < n; i++) {
              const u = i / (n - 1);
              const a = a0 + u * (a1 - a0);
              const rx = p1x + cos(a) * rw;
              const ry = p1y + sin(a) * rw;
              this._vSet(p1x, p1y, 0);
              this._vSet(rx, ry, -1);
            }
            this._vSet(lx1, ly1, 1);
            this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
          } else {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            const rx0 = out[0];
            const ry0 = out[1];
            const rx1 = out[2];
            const ry1 = out[3];
            const a0 = atan2(dly0, dlx0);
            let a1 = atan2(dly1, dlx1);
            if (a1 < a0) {
              a1 += PI * 2;
            }
            this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);
            this._vSet(rx0, ry0, -1);
            const n = clamp(ceil((a1 - a0) / PI) * nCap, 2, nCap);
            for (let i = 0; i < n; i++) {
              const u = i / (n - 1);
              const a = a0 + u * (a1 - a0);
              const lx = p1x + cos(a) * lw;
              const ly = p1y + sin(a) * lw;
              this._vSet(lx, ly, 1);
              this._vSet(p1x, p1y, 0);
            }
            this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);
            this._vSet(rx1, ry1, -1);
          }
        },
        _bevelJoin(p0, p1, lw, rw) {
          let rx0 = 0;
          let ry0 = 0;
          let rx1 = 0;
          let ry1 = 0;
          let lx0 = 0;
          let ly0 = 0;
          let lx1 = 0;
          let ly1 = 0;
          const dlx0 = p0.dy;
          const dly0 = -p0.dx;
          const dlx1 = p1.dy;
          const dly1 = -p1.dx;
          if (p1.flags & PointFlags.PT_LEFT) {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            lx0 = out[0];
            ly0 = out[1];
            lx1 = out[2];
            ly1 = out[3];
            this._vSet(lx0, ly0, 1);
            this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);
            this._vSet(lx1, ly1, 1);
            this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
          } else {
            const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            rx0 = out[0];
            ry0 = out[1];
            rx1 = out[2];
            ry1 = out[3];
            this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);
            this._vSet(rx0, ry0, -1);
            this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);
            this._vSet(rx1, ry1, -1);
          }
        },
        _vSet(x, y, distance = 0) {
          if (!_renderData) {
            return;
          }
          const meshBuffer = _renderData;
          let dataOffset = meshBuffer.vertexStart * attrBytes;
          const vData = meshBuffer.vData;
          vData[dataOffset++] = x;
          vData[dataOffset++] = y;
          vData[dataOffset++] = 0;
          Color$1.toArray(vData, _curColor, dataOffset);
          dataOffset += 4;
          vData[dataOffset++] = distance;
          meshBuffer.vertexStart++;
        }
      };

      const graphicsAssemblerManager = exports('graphicsAssembler', {
        getAssembler(sprite) {
          return graphicsAssembler;
        }
      });
      Graphics.Assembler = graphicsAssemblerManager;

      const Alignment = ['left', 'center', 'right'];
      const MAX_SIZE = 2048;
      const _BASELINE_OFFSET = getBaselineOffset();
      const _invisibleAlpha = (1 / 255).toFixed(3);
      const MAX_CALCULATION_NUM = 3;
      class LetterInfo {
        constructor() {
          this.char = '';
          this.valid = true;
          this.x = 0;
          this.y = 0;
          this.line = 0;
          this.hash = '';
        }
      }
      class TextProcessing {
        constructor() {
          this._context = null;
          this._canvas = null;
          this._canvasData = null;
          this._lettersInfo = [];
          this._tmpRect = new Rect$1();
          this._maxFontSize = 100;
          this._fontScale = 1;
          this._canvasData = CanvasPool.getInstance().get();
          this._canvas = this._canvasData.canvas;
          this._context = this._canvasData.context;
        }
        destroy() {
          CanvasPool.getInstance().put(this._canvasData);
          this._lettersInfo.length = 0;
        }
        processingString(isBmFont, style, layout, outputLayoutData, inputString, out) {
          if (!isBmFont) {
            let loopTime = 0;
            this._fontScale = this._getStyleFontScale(style.fontSize, style.fontScale);
            this._updatePaddingRect(style, outputLayoutData);
            this._calculateLabelFont(style, layout, outputLayoutData, inputString);
            while ((outputLayoutData.canvasSize.width > MAX_SIZE || outputLayoutData.canvasSize.height > MAX_SIZE) && loopTime <= MAX_CALCULATION_NUM) {
              loopTime++;
              if (loopTime > MAX_CALCULATION_NUM) {
                this._fontScale = 1;
              } else {
                const maxValue = Math.max(outputLayoutData.canvasSize.width, outputLayoutData.canvasSize.height);
                const canvasScaleToMaxSizeRatio = MAX_SIZE / maxValue;
                this._fontScale *= canvasScaleToMaxSizeRatio;
                this._fontScale = Math.max(1, this._fontScale);
              }
              this._updatePaddingRect(style, outputLayoutData);
              this._calculateLabelFont(style, layout, outputLayoutData, inputString);
            }
          } else {
            if (!style.fntConfig) {
              this._fontScale = this._getStyleFontScale(style.originFontSize, style.fontScale);
            } else {
              this._fontScale = 1;
            }
            shareLabelInfo.fontScale = this._fontScale;
            this._setupBMFontOverflowMetrics(layout, outputLayoutData);
            this._updateFontScale(style);
            this._computeHorizontalKerningForText(style, layout, inputString);
            this._alignText(style, layout, outputLayoutData, inputString);
          }
          if (out) {
            out = outputLayoutData.parsedString;
          }
        }
        generateRenderInfo(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          if (!isBmFont) {
            this._updateLabelDimensions(style, layout, outputLayoutData);
            this._updateTexture(style, layout, outputLayoutData, outputRenderData);
            this.generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback);
          } else {
            this._computeAlignmentOffset(style, layout, outputLayoutData);
            this.generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback);
          }
        }
        setCanvasUsed(canvas, content) {
          this._canvas = canvas;
          this._context = content;
        }
        _getStyleFontScale(fontSize, fontScale) {
          let scale = fontScale;
          if (scale * fontSize > this._maxFontSize && fontSize < this._maxFontSize) {
            scale = this._maxFontSize / fontSize;
          }
          if (scale < 1) {
            scale = 1;
          }
          return scale;
        }
        _calculateLabelFont(style, layout, outputLayoutData, inputString) {
          if (!this._context) {
            return;
          }
          style.actualFontSize = style.fontSize * this._fontScale;
          {
            style.actualFontSize = Math.floor(style.actualFontSize);
            this._fontScale = style.actualFontSize / style.fontSize;
          }
          const paragraphedStrings = inputString.split('\n');
          const _splitStrings = outputLayoutData.parsedString = paragraphedStrings;
          const _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = style.fontDesc = _fontDesc;
          switch (layout.overFlow) {
            case Overflow$1.NONE:
              {
                let canvasSizeX = 0;
                let canvasSizeY = 0;
                for (let i = 0; i < paragraphedStrings.length; ++i) {
                  const paraLength = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
                  canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }
                canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
                const rawWidth = canvasSizeX;
                const rawHeight = canvasSizeY;
                outputLayoutData.canvasSize.width = rawWidth + outputLayoutData.canvasPadding.width * this._fontScale;
                outputLayoutData.canvasSize.height = rawHeight + outputLayoutData.canvasPadding.height * this._fontScale;
                outputLayoutData.nodeContentSize.width = (rawWidth + outputLayoutData.contentSizeExtend.width * this._fontScale) / this._fontScale;
                outputLayoutData.nodeContentSize.height = (rawHeight + outputLayoutData.contentSizeExtend.height * this._fontScale) / this._fontScale;
                break;
              }
            case Overflow$1.SHRINK:
              {
                this._calculateShrinkFont(paragraphedStrings, style, layout, outputLayoutData);
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = outputLayoutData.nodeContentSize.height * this._fontScale;
                break;
              }
            case Overflow$1.CLAMP:
              {
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = outputLayoutData.nodeContentSize.height * this._fontScale;
                break;
              }
            case Overflow$1.RESIZE_HEIGHT:
              {
                this._calculateWrapText(paragraphedStrings, style, layout, outputLayoutData);
                const rawHeight = (outputLayoutData.parsedString.length + BASELINE_RATIO) * this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
                outputLayoutData.canvasSize.width = outputLayoutData.nodeContentSize.width * this._fontScale;
                outputLayoutData.canvasSize.height = rawHeight + outputLayoutData.canvasPadding.height * this._fontScale;
                outputLayoutData.nodeContentSize.height = (rawHeight + outputLayoutData.contentSizeExtend.height * this._fontScale) / this._fontScale;
                break;
              }
          }
        }
        _getFontDesc(fontSize, fontFamily, isBold, isItalic) {
          let fontDesc = `${fontSize.toString()}px `;
          fontDesc += fontFamily;
          if (isBold) {
            fontDesc = `bold ${fontDesc}`;
          }
          if (isItalic) {
            fontDesc = `italic ${fontDesc}`;
          }
          return fontDesc;
        }
        _getLineHeight(lineHeight, fontSize, drawFontsize) {
          let nodeSpacingY = lineHeight;
          if (nodeSpacingY === 0) {
            nodeSpacingY = fontSize;
          } else {
            nodeSpacingY = nodeSpacingY * fontSize / drawFontsize;
          }
          return nodeSpacingY;
        }
        _calculateShrinkFont(paragraphedStrings, style, layout, outputLayoutData) {
          if (!this._context) return;
          let _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = _fontDesc;
          const paragraphLength = this._calculateParagraphLength(paragraphedStrings, this._context, _fontDesc);
          let i = 0;
          let totalHeight = 0;
          let maxLength = 0;
          let _fontSize = style.actualFontSize;
          if (layout.wrapping) {
            const canvasWidthNoMargin = outputLayoutData.nodeContentSize.width * this._fontScale;
            const canvasHeightNoMargin = outputLayoutData.nodeContentSize.height * this._fontScale;
            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              return;
            }
            totalHeight = canvasHeightNoMargin + 1;
            const actualFontSize = style.actualFontSize + 1;
            let textFragment = [];
            let left = 0;
            let right = actualFontSize | 0;
            let mid = 0;
            while (left < right) {
              mid = left + right + 1 >> 1;
              if (mid <= 0) {
                logID(4003);
                break;
              }
              _fontSize = mid;
              _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
              this._context.font = _fontDesc;
              const lineHeight = this._getLineHeight(layout.lineHeight, _fontSize, style.fontSize);
              totalHeight = 0;
              for (i = 0; i < paragraphedStrings.length; ++i) {
                const allWidth = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
                textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._context, _fontDesc));
                totalHeight += textFragment.length * lineHeight;
              }
              if (totalHeight > canvasHeightNoMargin) {
                right = mid - 1;
              } else {
                left = mid;
              }
            }
            if (left === 0) {
              logID(4003);
            } else {
              _fontSize = left;
              _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
              this._context.font = _fontDesc;
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight(layout.lineHeight, _fontSize, style.fontSize);
            for (i = 0; i < paragraphedStrings.length; ++i) {
              if (maxLength < paragraphLength[i]) {
                maxLength = paragraphLength[i];
              }
            }
            const scaleX = (outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width) * this._fontScale / maxLength;
            const scaleY = outputLayoutData.canvasSize.height * this._fontScale / totalHeight;
            _fontSize = style.actualFontSize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc(_fontSize, style.fontFamily, style.isBold, style.isItalic);
            this._context.font = _fontDesc;
          }
          style.actualFontSize = _fontSize;
          style.fontDesc = _fontDesc;
        }
        _calculateWrapText(paragraphedStrings, style, layout, outputLayoutData) {
          if (!layout.wrapping || !this._context) return;
          let _splitStrings = [];
          const canvasWidthNoMargin = outputLayoutData.nodeContentSize.width * this._fontScale;
          const _fontDesc = this._getFontDesc(style.actualFontSize, style.fontFamily, style.isBold, style.isItalic);
          this._context.font = _fontDesc;
          for (let i = 0; i < paragraphedStrings.length; ++i) {
            const allWidth = safeMeasureText(this._context, paragraphedStrings[i], _fontDesc);
            const textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._context, _fontDesc));
            _splitStrings = _splitStrings.concat(textFragment);
          }
          outputLayoutData.parsedString = _splitStrings;
          style.fontDesc = _fontDesc;
        }
        _measureText(ctx, fontDesc) {
          return str => safeMeasureText(ctx, str, fontDesc);
        }
        _calculateParagraphLength(paragraphedStrings, ctx, fontDesc) {
          const paragraphLength = [];
          for (const para of paragraphedStrings) {
            const width = safeMeasureText(ctx, para, fontDesc);
            paragraphLength.push(width);
          }
          return paragraphLength;
        }
        _updatePaddingRect(style, outputLayoutData) {
          let top = 0;
          let bottom = 0;
          let left = 0;
          let right = 0;
          let outlineWidth = 0;
          outputLayoutData.contentSizeExtend.width = outputLayoutData.contentSizeExtend.height = 0;
          if (style.isOutlined) {
            outlineWidth = style.outlineWidth;
            top = bottom = left = right = outlineWidth;
            outputLayoutData.contentSizeExtend.width = outputLayoutData.contentSizeExtend.height = outlineWidth * 2;
          }
          if (style.hasShadow) {
            const shadowWidth = style.shadowBlur + outlineWidth;
            const offsetX = style.shadowOffsetX;
            const offsetY = style.shadowOffsetY;
            left = Math.max(left, -offsetX + shadowWidth);
            right = Math.max(right, offsetX + shadowWidth);
            top = Math.max(top, offsetY + shadowWidth);
            bottom = Math.max(bottom, -offsetY + shadowWidth);
          }
          if (style.isItalic) {
            const offset = style.fontSize * Math.tan(12 * 0.0174532925);
            right += offset;
            outputLayoutData.contentSizeExtend.width += offset;
          }
          outputLayoutData.canvasPadding.x = left;
          outputLayoutData.canvasPadding.y = top;
          outputLayoutData.canvasPadding.width = left + right;
          outputLayoutData.canvasPadding.height = top + bottom;
        }
        _updateLabelDimensions(style, layout, outputLayoutData) {
          outputLayoutData.canvasSize.width = Math.min(outputLayoutData.canvasSize.width, MAX_SIZE);
          outputLayoutData.canvasSize.height = Math.min(outputLayoutData.canvasSize.height, MAX_SIZE);
          this._canvas.width = outputLayoutData.canvasSize.width;
          this._canvas.height = outputLayoutData.canvasSize.height;
          this._context.font = style.fontDesc;
          this._context.textAlign = Alignment[layout.horizontalAlign];
          this._context.textBaseline = 'alphabetic';
        }
        _calculateFillTextStartPosition(style, layout, outputLayoutData) {
          let labelX = 0;
          if (layout.horizontalAlign === HorizontalTextAlignment.RIGHT) {
            labelX = outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width;
          } else if (layout.horizontalAlign === HorizontalTextAlignment.CENTER) {
            labelX = (outputLayoutData.canvasSize.width - outputLayoutData.canvasPadding.width) / 2;
          }
          const lineHeight = this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
          const drawStartY = lineHeight * (outputLayoutData.parsedString.length - 1);
          let firstLinelabelY = style.actualFontSize * (1 - BASELINE_RATIO / 2);
          if (layout.verticalAlign !== VerticalTextAlignment.TOP) {
            let blank = drawStartY + outputLayoutData.canvasPadding.height + style.actualFontSize - outputLayoutData.canvasSize.height;
            if (layout.verticalAlign === VerticalTextAlignment.BOTTOM) {
              blank += BASELINE_RATIO / 2 * style.actualFontSize;
              firstLinelabelY -= blank;
            } else {
              firstLinelabelY -= blank / 2;
            }
          }
          firstLinelabelY += _BASELINE_OFFSET * style.actualFontSize;
          outputLayoutData.startPosition.set(labelX + outputLayoutData.canvasPadding.x, firstLinelabelY + outputLayoutData.canvasPadding.y);
        }
        _updateTexture(style, layout, outputLayoutData, outputRenderData) {
          if (!this._context || !this._canvas) {
            return;
          }
          this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
          this._context.font = style.fontDesc;
          this._calculateFillTextStartPosition(style, layout, outputLayoutData);
          const lineHeight = this._getLineHeight(layout.lineHeight, style.actualFontSize, style.fontSize);
          this._context.lineJoin = 'round';
          if (style.isOutlined) {
            this._context.fillStyle = `rgba(${style.outlineColor.r}, ${style.outlineColor.g}, ${style.outlineColor.b}, ${_invisibleAlpha})`;
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
          } else {
            this._context.fillStyle = `rgba(${style.color.r}, ${style.color.g}, ${style.color.b}, ${_invisibleAlpha})`;
            this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
          }
          this._context.fillStyle = `rgb(${style.color.r}, ${style.color.g}, ${style.color.b})`;
          const tempPos = new Vec2(outputLayoutData.startPosition.x, outputLayoutData.startPosition.y);
          const drawTextPosX = tempPos.x;
          let drawTextPosY = 0;
          this._drawTextEffect(tempPos, lineHeight, style, layout, outputLayoutData);
          for (let i = 0; i < outputLayoutData.parsedString.length; ++i) {
            drawTextPosY = tempPos.y + i * lineHeight;
            if (style.hasShadow) {
              this._setupShadow(style);
              this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
            }
            if (style.isOutlined) {
              this._setupOutline(style);
              this._context.strokeText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
            }
            if (!style.hasShadow || style.isOutlined) {
              this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
            }
          }
          if (style.hasShadow) {
            this._context.shadowColor = 'transparent';
          }
          this._uploadTexture(outputRenderData);
        }
        _uploadTexture(outputRenderData) {
          if (outputRenderData.texture && this._canvas) {
            let tex;
            if (outputRenderData.texture instanceof SpriteFrame) {
              tex = outputRenderData.texture.texture;
            } else {
              tex = outputRenderData.texture;
            }
            const uploadAgain = this._canvas.width !== 0 && this._canvas.height !== 0;
            if (uploadAgain) {
              tex.reset({
                width: this._canvas.width,
                height: this._canvas.height,
                mipmapLevel: 1
              });
              tex.uploadData(this._canvas);
              tex.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
              if (outputRenderData.texture instanceof SpriteFrame) {
                outputRenderData.texture.rect = new Rect$1(0, 0, this._canvas.width, this._canvas.height);
                outputRenderData.texture._calculateUV();
              }
              if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                {
                  legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getGFXTexture(), tex.getGFXSampler());
                }
              }
            }
          }
        }
        _drawTextEffect(startPosition, lineHeight, style, layout, outputLayoutData) {
          if (!style.hasShadow && !style.isOutlined && !style.isUnderline) return;
          const isMultiple = outputLayoutData.parsedString.length > 1 && style.hasShadow;
          const measureText = this._measureText(this._context, style.fontDesc);
          let drawTextPosX = 0;
          let drawTextPosY = 0;
          for (let i = 0; i < outputLayoutData.parsedString.length; ++i) {
            drawTextPosX = startPosition.x;
            drawTextPosY = startPosition.y + i * lineHeight;
            if (isMultiple) {
              if (style.hasShadow) {
                this._setupShadow(style);
                this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
              }
              if (style.isOutlined) {
                this._setupOutline(style);
                this._context.strokeText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
              }
              if (!style.hasShadow || style.isOutlined) {
                this._context.fillText(outputLayoutData.parsedString[i], drawTextPosX, drawTextPosY);
              }
            }
            if (style.isUnderline) {
              const _drawUnderlineWidth = measureText(outputLayoutData.parsedString[i]);
              const _drawUnderlinePos = new Vec2();
              if (layout.horizontalAlign === HorizontalTextAlignment.RIGHT) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
              } else if (layout.horizontalAlign === HorizontalTextAlignment.CENTER) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
              } else {
                _drawUnderlinePos.x = startPosition.x;
              }
              _drawUnderlinePos.y = drawTextPosY + style.actualFontSize / 8;
              this._context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, style.underlineHeight * this._fontScale);
            }
          }
          if (isMultiple) {
            this._context.shadowColor = 'transparent';
          }
        }
        _setupOutline(style) {
          this._context.shadowBlur = 0;
          this._context.shadowOffsetX = 0;
          this._context.shadowOffsetY = 0;
          this._context.strokeStyle = `rgba(${style.outlineColor.r}, ${style.outlineColor.g}, ${style.outlineColor.b}, ${style.outlineColor.a / 255})`;
          this._context.lineWidth = style.outlineWidth * 2 * this._fontScale;
        }
        _setupShadow(style) {
          const fontScale = this._fontScale;
          this._context.shadowColor = `rgba(${style.shadowColor.r}, ${style.shadowColor.g}, ${style.shadowColor.b}, ${style.shadowColor.a / 255})`;
          this._context.shadowBlur = style.shadowBlur * fontScale;
          this._context.shadowOffsetX = style.shadowOffsetX * fontScale;
          this._context.shadowOffsetY = -style.shadowOffsetY * fontScale;
        }
        generateVertexData(isBmFont, style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          if (!isBmFont) {
            this.updateQuatCount(outputRenderData);
            callback(style, outputLayoutData, outputRenderData);
          } else {
            this._updateQuads(style, layout, outputLayoutData, outputRenderData, inputString, callback);
          }
        }
        updateQuatCount(outputRenderData) {
          const data = outputRenderData.vertexBuffer;
          const count = outputRenderData.quadCount;
          if (data.length !== count) {
            for (let i = data.length; i < count; i++) {
              data.push({
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color$1.WHITE.clone()
              });
            }
            data.length = count;
          }
        }
        _setupBMFontOverflowMetrics(layout, outputLayoutData) {
          let newWidth = outputLayoutData.nodeContentSize.width;
          let newHeight = outputLayoutData.nodeContentSize.height;
          if (layout.overFlow === Overflow$1.RESIZE_HEIGHT) {
            newHeight = 0;
          }
          if (layout.overFlow === Overflow$1.NONE) {
            newWidth = 0;
            newHeight = 0;
          }
          layout.textWidthTemp = newWidth;
          layout.textHeightTemp = newHeight;
          layout.textDimensions.width = newWidth;
          layout.textDimensions.height = newHeight;
          layout.maxLineWidth = newWidth;
        }
        _updateFontScale(style) {
          style.bmfontScale = style.actualFontSize / (style.originFontSize * this._fontScale);
        }
        _computeHorizontalKerningForText(style, layout, inputString) {
          const string = inputString;
          const stringLen = string.length;
          if (!style.fntConfig) return;
          const kerningDict = style.fntConfig.kerningDict;
          const horizontalKerning = layout.horizontalKerning;
          if (!kerningDict || kerningDict.length === 0) {
            return;
          }
          let prev = -1;
          for (let i = 0; i < stringLen; ++i) {
            const key = string.charCodeAt(i);
            const kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;
            if (i < stringLen - 1) {
              horizontalKerning[i] = kerningAmount;
            } else {
              horizontalKerning[i] = 0;
            }
            prev = key;
          }
        }
        _alignText(style, layout, outputLayoutData, inputString) {
          this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
          if (layout.overFlow === Overflow$1.SHRINK) {
            if (style.fontSize > 0 && this._isVerticalClamp(style, layout, outputLayoutData, inputString, this)) {
              this._shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, this._isVerticalClamp);
            }
            if (style.fontSize > 0 && this._isHorizontalNeedShrink(layout, outputLayoutData)) {
              this._shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, this._isHorizontalClamp);
            }
          }
          this._parsedString(outputLayoutData, inputString);
        }
        _parsedString(outputLayoutData, inputString) {
          let _splitStrings = [];
          let textFragment = '';
          const length = getSymbolLength(inputString);
          for (let i = 0, line = 0, l = length; i < l; ++i) {
            const letterInfo = this._lettersInfo[i];
            if (!letterInfo.valid) {
              continue;
            }
            if (line === letterInfo.line) {
              textFragment += letterInfo.char;
            } else {
              _splitStrings = _splitStrings.concat(textFragment);
              line = letterInfo.line;
              textFragment = '';
            }
          }
          _splitStrings = _splitStrings.concat(textFragment);
          outputLayoutData.parsedString = _splitStrings;
        }
        _multilineTextWrap(style, layout, outputLayoutData, inputString, nextTokenFunc) {
          layout.linesWidth.length = 0;
          const _string = inputString;
          const textLen = _string.length;
          let lineIndex = 0;
          let nextTokenX = 0;
          let nextTokenY = 0;
          let longestLine = 0;
          let letterRight = 0;
          let highestY = 0;
          let lowestY = 0;
          let letterDef = null;
          const _lineSpacing = 0;
          for (let index = 0; index < textLen;) {
            let character = getSymbolAt(_string, index);
            if (character === '\n') {
              layout.linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= layout.lineHeight * this._getFontScale(style, layout) + _lineSpacing;
              this._recordPlaceholderInfo(index, character);
              index++;
              continue;
            }
            const tokenLen = nextTokenFunc(style, layout, _string, index, textLen);
            let tokenHighestY = highestY;
            let tokenLowestY = lowestY;
            let tokenRight = letterRight;
            let nextLetterX = nextTokenX;
            let newLine = false;
            const letterPosition = new Vec2();
            for (let tmp = 0; tmp < tokenLen; ++tmp) {
              const letterIndex = index + tmp;
              character = getSymbolAt(_string, letterIndex);
              if (character === '\r') {
                this._recordPlaceholderInfo(letterIndex, character);
                continue;
              }
              letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
              if (!letterDef) {
                this._recordPlaceholderInfo(letterIndex, character);
                if (style.fntConfig != null) {
                  log(`Can't find letter definition in texture atlas ${style.fntConfig.atlasName} for letter:${character}`);
                } else {
                  log(`Can't find letter definition in font family ${style.fontFamily} for letter:${character}`);
                }
                continue;
              }
              const letterX = nextLetterX + letterDef.offsetX * style.bmfontScale - shareLabelInfo.margin;
              if (layout.wrapping && layout.maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * style.bmfontScale > layout.maxLineWidth && !isUnicodeSpace(character)) {
                layout.linesWidth.push(letterRight);
                letterRight = 0;
                lineIndex++;
                nextTokenX = 0;
                nextTokenY -= layout.lineHeight * this._getFontScale(style, layout) + _lineSpacing;
                newLine = true;
                break;
              } else {
                letterPosition.x = letterX;
              }
              letterPosition.y = nextTokenY - letterDef.offsetY * style.bmfontScale;
              this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
              if (letterIndex + 1 < layout.horizontalKerning.length && letterIndex < textLen - 1) {
                nextLetterX += layout.horizontalKerning[letterIndex + 1] * style.bmfontScale;
              }
              nextLetterX += letterDef.xAdvance * style.bmfontScale + layout.spacingX;
              tokenRight = letterPosition.x + letterDef.w * style.bmfontScale;
              if (tokenHighestY < letterPosition.y) {
                tokenHighestY = letterPosition.y;
              }
              if (tokenLowestY > letterPosition.y - letterDef.h * style.bmfontScale) {
                tokenLowestY = letterPosition.y - letterDef.h * style.bmfontScale;
              }
            }
            if (newLine) {
              continue;
            }
            nextTokenX = nextLetterX;
            letterRight = tokenRight;
            if (highestY < tokenHighestY) {
              highestY = tokenHighestY;
            }
            if (lowestY > tokenLowestY) {
              lowestY = tokenLowestY;
            }
            if (longestLine < letterRight) {
              longestLine = letterRight;
            }
            index += tokenLen;
          }
          layout.linesWidth.push(letterRight);
          layout.numberOfLines = lineIndex + 1;
          layout.textDesiredHeight = layout.numberOfLines * layout.lineHeight * this._getFontScale(style, layout);
          if (layout.numberOfLines > 1) {
            layout.textDesiredHeight += (layout.numberOfLines - 1) * _lineSpacing;
          }
          outputLayoutData.nodeContentSize.width = layout.textWidthTemp;
          outputLayoutData.nodeContentSize.height = layout.textHeightTemp;
          if (layout.textWidthTemp <= 0) {
            outputLayoutData.nodeContentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
          }
          if (layout.textHeightTemp <= 0) {
            outputLayoutData.nodeContentSize.height = parseFloat(layout.textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
          }
          layout.tailoredTopY = outputLayoutData.nodeContentSize.height;
          layout.tailoredBottomY = 0;
          if (highestY > 0) {
            layout.tailoredTopY = outputLayoutData.nodeContentSize.height + highestY;
          }
          if (lowestY < -layout.textDesiredHeight) {
            layout.tailoredBottomY = layout.textDesiredHeight + lowestY;
          }
          return true;
        }
        _recordPlaceholderInfo(letterIndex, char) {
          if (letterIndex >= this._lettersInfo.length) {
            const tmpInfo = new LetterInfo();
            this._lettersInfo.push(tmpInfo);
          }
          this._lettersInfo[letterIndex].char = char;
          this._lettersInfo[letterIndex].hash = `${getSymbolCodeAt(char, 0)}${shareLabelInfo.hash}`;
          this._lettersInfo[letterIndex].valid = false;
        }
        _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
          if (letterIndex >= this._lettersInfo.length) {
            const tmpInfo = new LetterInfo();
            this._lettersInfo.push(tmpInfo);
          }
          const char = getSymbolCodeAt(character, 0);
          const key = `${char}${shareLabelInfo.hash}`;
          this._lettersInfo[letterIndex].line = lineIndex;
          this._lettersInfo[letterIndex].char = character;
          this._lettersInfo[letterIndex].hash = key;
          this._lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
          this._lettersInfo[letterIndex].x = letterPosition.x;
          this._lettersInfo[letterIndex].y = letterPosition.y;
        }
        _getFirstWordLen(style, layout, text, startIndex, textLen) {
          let character = getSymbolAt(text, startIndex);
          if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
            return 1;
          }
          let len = 1;
          let letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
          if (!letterDef) {
            return len;
          }
          let nextLetterX = letterDef.xAdvance * style.bmfontScale + layout.spacingX;
          let letterX = 0;
          for (let index = startIndex + 1; index < textLen; ++index) {
            character = getSymbolAt(text, index);
            letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
            if (!letterDef) {
              break;
            }
            letterX = nextLetterX + letterDef.offsetX * style.bmfontScale;
            if (letterX + letterDef.w * style.bmfontScale > layout.maxLineWidth && !isUnicodeSpace(character) && layout.maxLineWidth > 0) {
              return len;
            }
            nextLetterX += letterDef.xAdvance * style.bmfontScale + layout.spacingX;
            if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }
            len++;
          }
          return len;
        }
        _computeAlignmentOffset(style, layout, outputLayoutData) {
          layout.linesOffsetX.length = 0;
          layout.letterOffsetY = 0;
          switch (layout.horizontalAlign) {
            case HorizontalTextAlignment.LEFT:
              for (let i = 0; i < layout.numberOfLines; ++i) {
                layout.linesOffsetX.push(0);
              }
              break;
            case HorizontalTextAlignment.CENTER:
              for (let i = 0, l = layout.linesWidth.length; i < l; i++) {
                layout.linesOffsetX.push((outputLayoutData.nodeContentSize.width - layout.linesWidth[i]) / 2);
              }
              break;
            case HorizontalTextAlignment.RIGHT:
              for (let i = 0, l = layout.linesWidth.length; i < l; i++) {
                layout.linesOffsetX.push(outputLayoutData.nodeContentSize.width - layout.linesWidth[i]);
              }
              break;
          }
          layout.letterOffsetY = outputLayoutData.nodeContentSize.height;
          if (layout.verticalAlign !== VerticalTextAlignment.TOP) {
            const blank = outputLayoutData.nodeContentSize.height - layout.textDesiredHeight + layout.lineHeight * this._getFontScale(style, layout) - style.originFontSize * this._fontScale * style.bmfontScale;
            if (layout.verticalAlign === VerticalTextAlignment.BOTTOM) {
              layout.letterOffsetY -= blank;
            } else {
              layout.letterOffsetY -= blank / 2;
            }
          }
        }
        _getFontScale(style, layout) {
          return layout.overFlow === Overflow$1.SHRINK ? style.bmfontScale : 1;
        }
        _isVerticalClamp(style, layout, outputLayoutData, inputString, process) {
          if (layout.textDesiredHeight > outputLayoutData.nodeContentSize.height) {
            return true;
          } else {
            return false;
          }
        }
        _isHorizontalClamp(style, layout, outputLayoutData, inputString, process) {
          let letterClamp = false;
          const _string = inputString;
          const _length = getSymbolLength(_string);
          for (let ctr = 0, l = _length; ctr < l; ++ctr) {
            const letterInfo = process._lettersInfo[ctr];
            if (letterInfo.valid) {
              const letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo.char, shareLabelInfo);
              if (!letterDef) {
                continue;
              }
              const px = letterInfo.x + letterDef.w * style.bmfontScale;
              const lineIndex = letterInfo.line;
              if (layout.textWidthTemp > 0) {
                if (!layout.wrapping) {
                  if (px > outputLayoutData.nodeContentSize.width) {
                    letterClamp = true;
                    break;
                  }
                } else {
                  const wordWidth = layout.linesWidth[lineIndex];
                  if (wordWidth > outputLayoutData.nodeContentSize.width && (px > outputLayoutData.nodeContentSize.width || px < 0)) {
                    letterClamp = true;
                    break;
                  }
                }
              }
            }
          }
          return letterClamp;
        }
        _isHorizontalNeedShrink(layout, outputLayoutData) {
          let wordWidth = 0;
          for (let ctr = 0, l = layout.linesWidth.length; ctr < l; ++ctr) {
            wordWidth = layout.linesWidth[ctr];
            if (wordWidth > outputLayoutData.nodeContentSize.width) return true;
          }
          return false;
        }
        _shrinkLabelToContentSize(style, layout, outputLayoutData, inputString, lambda) {
          const fontSize = style.actualFontSize;
          let left = 0;
          let right = fontSize | 0;
          let mid = 0;
          while (left < right) {
            mid = left + right + 1 >> 1;
            const newFontSize = mid;
            if (newFontSize <= 0) {
              break;
            }
            style.bmfontScale = newFontSize / (style.originFontSize * this._fontScale);
            this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
            this._computeAlignmentOffset(style, layout, outputLayoutData);
            if (lambda(style, layout, outputLayoutData, inputString, this)) {
              right = mid - 1;
            } else {
              left = mid;
            }
          }
          if (left >= 0) {
            this._scaleFontSizeDown(style, layout, outputLayoutData, inputString, left);
          }
        }
        _scaleFontSizeDown(style, layout, outputLayoutData, inputString, fontSize) {
          let shouldUpdateContent = true;
          if (!fontSize) {
            fontSize = 0.1;
            shouldUpdateContent = false;
          }
          style.actualFontSize = fontSize;
          if (shouldUpdateContent) {
            this._updateFontScale(style);
            this._multilineTextWrap(style, layout, outputLayoutData, inputString, this._getFirstWordLen);
          }
        }
        _updateQuads(style, layout, outputLayoutData, outputRenderData, inputString, callback) {
          const texture = style.spriteFrame ? style.spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
          const appX = outputRenderData.uiTransAnchorX * outputLayoutData.nodeContentSize.width;
          const appY = outputRenderData.uiTransAnchorY * outputLayoutData.nodeContentSize.height;
          const ret = true;
          const _length = getSymbolLength(inputString);
          for (let ctr = 0, l = _length; ctr < l; ++ctr) {
            const letterInfo = this._lettersInfo[ctr];
            if (!letterInfo.valid) {
              continue;
            }
            const letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);
            if (!letterDef) {
              warn('Can\'t find letter in this bitmap-font');
              continue;
            }
            this._tmpRect.height = letterDef.h;
            this._tmpRect.width = letterDef.w;
            this._tmpRect.x = letterDef.u;
            this._tmpRect.y = letterDef.v;
            let py = letterInfo.y + layout.letterOffsetY;
            if (layout.textHeightTemp > 0) {
              if (py > layout.tailoredTopY) {
                const clipTop = py - layout.tailoredTopY;
                this._tmpRect.y += clipTop;
                this._tmpRect.height -= clipTop;
                py -= clipTop;
              }
              if (py - this._tmpRect.height * style.bmfontScale < layout.tailoredBottomY && layout.overFlow === Overflow$1.CLAMP) {
                this._tmpRect.height = py < layout.tailoredBottomY ? 0 : (py - layout.tailoredBottomY) / style.bmfontScale;
              }
            }
            const lineIndex = letterInfo.line;
            const px = letterInfo.x + letterDef.w / 2 * style.bmfontScale + layout.linesOffsetX[lineIndex];
            if (layout.textWidthTemp > 0) {
              if (this._isHorizontalClamped(layout, outputLayoutData, px, lineIndex)) {
                if (layout.overFlow === Overflow$1.CLAMP) {
                  this._tmpRect.width = 0;
                }
              }
            }
            if (this._tmpRect.height > 0 && this._tmpRect.width > 0) {
              const isRotated = this._determineRect(style);
              const letterPositionX = letterInfo.x + layout.linesOffsetX[letterInfo.line];
              const offset = outputRenderData.quadCount;
              outputRenderData.quadCount += 4;
              this.updateQuatCount(outputRenderData);
              callback(style, outputLayoutData, outputRenderData, offset, texture, this._tmpRect, isRotated, letterPositionX - appX, py - appY);
            }
          }
          return ret;
        }
        _isHorizontalClamped(layout, outputLayoutData, px, lineIndex) {
          const wordWidth = layout.linesWidth[lineIndex];
          const letterOverClamp = px > outputLayoutData.nodeContentSize.width || px < 0;
          if (!layout.wrapping) {
            return letterOverClamp;
          } else {
            return wordWidth > outputLayoutData.nodeContentSize.width && letterOverClamp;
          }
        }
        _determineRect(style) {
          const _spriteFrame = style.spriteFrame;
          if (!_spriteFrame) return false;
          const isRotated = _spriteFrame.isRotated();
          const originalSize = _spriteFrame.getOriginalSize();
          const rect = _spriteFrame.getRect();
          const offset = _spriteFrame.getOffset();
          const trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
          const trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
          if (!isRotated) {
            this._tmpRect.x += rect.x - trimmedLeft;
            this._tmpRect.y += rect.y + trimmedTop;
          } else {
            const originalX = this._tmpRect.x;
            this._tmpRect.x = rect.x + rect.height - this._tmpRect.y - this._tmpRect.height - trimmedTop;
            this._tmpRect.y = originalX + rect.y - trimmedLeft;
            if (this._tmpRect.y < 0) {
              this._tmpRect.height += trimmedTop;
            }
          }
          return isRotated;
        }
      }
      TextProcessing.instance = void 0;
      TextProcessing.instance = new TextProcessing();

      const _defaultLetterAtlas = new LetterAtlas(64, 64);
      const _defaultFontAtlas = new FontAtlas(null);
      let _comp = null;
      let _uiTrans = null;
      let _fntConfig = null;
      let _spriteFrame = null;
      let QUAD_INDICES$5;
      const bmfontUtils = {
        updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans) {
          style.fontSize = comp.fontSize;
          style.actualFontSize = comp.fontSize;
          style.originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
          layout.horizontalAlign = comp.horizontalAlign;
          layout.verticalAlign = comp.verticalAlign;
          layout.spacingX = comp.spacingX;
          const overflow = comp.overflow;
          layout.overFlow = overflow;
          layout.lineHeight = comp.lineHeight;
          outputLayoutData.nodeContentSize.width = trans.width;
          outputLayoutData.nodeContentSize.height = trans.height;
          if (overflow === Overflow$1.NONE) {
            layout.wrapping = false;
            outputLayoutData.nodeContentSize.width += shareLabelInfo.margin * 2;
            outputLayoutData.nodeContentSize.height += shareLabelInfo.margin * 2;
          } else if (overflow === Overflow$1.RESIZE_HEIGHT) {
            layout.wrapping = true;
            outputLayoutData.nodeContentSize.height += shareLabelInfo.margin * 2;
          } else {
            layout.wrapping = comp.enableWrapText;
          }
          outputRenderData.uiTransAnchorX = trans.anchorX;
          outputRenderData.uiTransAnchorY = trans.anchorY;
          shareLabelInfo.lineHeight = comp.lineHeight;
          shareLabelInfo.fontSize = comp.fontSize;
          style.spriteFrame = _spriteFrame;
          style.fntConfig = _fntConfig;
          style.fontFamily = shareLabelInfo.fontFamily;
          style.color.set(comp.color);
        },
        updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }
          if (_comp === comp) {
            return;
          }
          if (comp.renderData.vertDirty) {
            _comp = comp;
            _uiTrans = _comp.node._uiProps.uiTransformComp;
            const renderData = comp.renderData;
            const processing = TextProcessing.instance;
            const style = comp.textStyle;
            const layout = comp.textLayout;
            const outputLayoutData = comp.textLayoutData;
            const outputRenderData = comp.textRenderData;
            style.fontScale = view.getScaleX();
            this._updateFontFamily(comp);
            this.updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, _uiTrans);
            this._updateLabelInfo(comp);
            style.fontDesc = shareLabelInfo.fontDesc;
            processing.processingString(true, style, layout, outputLayoutData, comp.string);
            outputRenderData.quadCount = 0;
            processing.generateRenderInfo(true, style, layout, outputLayoutData, outputRenderData, comp.string, this.generateVertexData);
            let isResized = false;
            if (renderData.dataLength !== outputRenderData.quadCount) {
              this.resetRenderData(comp);
              renderData.dataLength = outputRenderData.quadCount;
              renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
              isResized = true;
            }
            const datalist = renderData.data;
            for (let i = 0, l = outputRenderData.quadCount; i < l; i++) {
              datalist[i] = outputRenderData.vertexBuffer[i];
            }
            const indexCount = renderData.indexCount;
            this.createQuadIndices(indexCount);
            renderData.chunk.setIndexBuffer(QUAD_INDICES$5);
            _comp.actualFontSize = style.actualFontSize;
            _uiTrans.setContentSize(outputLayoutData.nodeContentSize);
            this.updateUVs(comp);
            if (_comp.renderEntity.colorDirty || isResized) {
              this.updateColor(comp);
              _comp.node._uiProps.colorDirty = false;
            }
            renderData.vertDirty = false;
            _comp = null;
            this._resetProperties();
          }
          if (comp.spriteFrame) {
            const renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateUVs(label) {
          const renderData = label.renderData;
          const vData = renderData.chunk.vb;
          const vertexCount = renderData.vertexCount;
          const dataList = renderData.data;
          let vertexOffset = 3;
          for (let i = 0; i < vertexCount; i++) {
            const vert = dataList[i];
            vData[vertexOffset] = vert.u;
            vData[vertexOffset + 1] = vert.v;
            vertexOffset += 9;
          }
        },
        updateColor(label) {
          {
            const renderData = label.renderData;
            const vertexCount = renderData.vertexCount;
            if (vertexCount === 0) return;
            const vData = renderData.chunk.vb;
            const stride = renderData.floatStride;
            let colorOffset = 5;
            const color = label.color;
            const colorR = color.r / 255;
            const colorG = color.g / 255;
            const colorB = color.b / 255;
            const colorA = color.a / 255;
            for (let i = 0; i < vertexCount; i++) {
              vData[colorOffset] = colorR;
              vData[colorOffset + 1] = colorG;
              vData[colorOffset + 2] = colorB;
              vData[colorOffset + 3] = colorA;
              colorOffset += stride;
            }
          }
        },
        resetRenderData(comp) {
          const renderData = comp.renderData;
          renderData.dataLength = 0;
          renderData.resize(0, 0);
        },
        generateVertexData(style, outputLayoutData, outputRenderData, offset, spriteFrame, rect, rotated, x, y) {
          const dataOffset = offset;
          const scale = style.bmfontScale;
          const dataList = outputRenderData.vertexBuffer;
          const texW = spriteFrame.width;
          const texH = spriteFrame.height;
          const rectWidth = rect.width;
          const rectHeight = rect.height;
          let l = 0;
          let b = 0;
          let t = 0;
          let r = 0;
          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }
          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        },
        _updateFontFamily(comp) {
          const fontAsset = comp.font;
          _spriteFrame = fontAsset.spriteFrame;
          _fntConfig = fontAsset.fntConfig;
          shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;
          if (!shareLabelInfo.fontAtlas) {
            if (comp.cacheMode === CacheMode.CHAR) {
              shareLabelInfo.fontAtlas = _defaultLetterAtlas;
            } else {
              shareLabelInfo.fontAtlas = _defaultFontAtlas;
            }
          }
          dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
        },
        _updateLabelInfo(comp) {
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _resetProperties() {
          _fntConfig = null;
          _spriteFrame = null;
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            console.error('illegal index count!');
            return;
          }
          const quadCount = indexCount / 6;
          QUAD_INDICES$5 = null;
          QUAD_INDICES$5 = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < quadCount; i++) {
            QUAD_INDICES$5[offset++] = 0 + i * 4;
            QUAD_INDICES$5[offset++] = 1 + i * 4;
            QUAD_INDICES$5[offset++] = 2 + i * 4;
            QUAD_INDICES$5[offset++] = 1 + i * 4;
            QUAD_INDICES$5[offset++] = 3 + i * 4;
            QUAD_INDICES$5[offset++] = 2 + i * 4;
          }
        }
      };

      const tempColor$2 = new Color$1(255, 255, 255, 255);
      const bmfont = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.resize(0, 0);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          const node = comp.node;
          tempColor$2.set(comp.color);
          tempColor$2.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$2);
        },
        appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
          const renderData = comp.renderData;
          if (!renderData) {
            return;
          }
          const dataOffset = renderData.dataLength;
          renderData.dataLength += 4;
          renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
          const dataList = renderData.data;
          const texW = spriteFrame.width;
          const texH = spriteFrame.height;
          const rectWidth = rect.width;
          const rectHeight = rect.height;
          let l = 0;
          let b = 0;
          let t = 0;
          let r = 0;
          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }
          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        }
      };
      addon(bmfont, bmfontUtils);

      const _atlasWidth = 1024;
      const _atlasHeight = 1024;
      let _shareAtlas = null;
      const letterFont = mixin(bmfontUtils, {
        getAssemblerData() {
          if (!_shareAtlas) {
            _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
          }
          return _shareAtlas.getTexture();
        },
        _updateFontFamily(comp) {
          shareLabelInfo.fontAtlas = _shareAtlas;
          shareLabelInfo.fontFamily = this._getFontFamily(comp);
          const isOutlined = comp.enableOutline && comp.outlineWidth > 0;
          if (isOutlined) {
            shareLabelInfo.isOutlined = true;
            shareLabelInfo.margin = comp.outlineWidth;
            shareLabelInfo.out = comp.outlineColor.clone();
            shareLabelInfo.out.a = comp.outlineColor.a * comp.color.a / 255.0;
          } else {
            shareLabelInfo.isOutlined = false;
            shareLabelInfo.margin = 0;
          }
        },
        _getFontFamily(comp) {
          let fontFamily = 'Arial';
          if (!comp.useSystemFont) {
            if (comp.font) {
              fontFamily = comp.font._nativeAsset || 'Arial';
            }
          } else {
            fontFamily = comp.fontFamily || 'Arial';
          }
          return fontFamily;
        },
        _updateLabelInfo(comp) {
          shareLabelInfo.fontDesc = this._getFontDesc();
          shareLabelInfo.color = comp.color;
          shareLabelInfo.hash = computeHash(shareLabelInfo);
        },
        _getFontDesc() {
          let fontDesc = `${shareLabelInfo.fontSize.toString()}px `;
          fontDesc += shareLabelInfo.fontFamily;
          return fontDesc;
        }
      });

      const tempColor$1 = new Color$1(255, 255, 255, 255);
      const letter = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.resize(0, 0);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          if (!comp.renderData) {
            return;
          }
          const node = comp.node;
          tempColor$1.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$1);
        },
        updateColor(label) {
          {
            const renderData = label.renderData;
            const vertexCount = renderData.vertexCount;
            if (vertexCount === 0) return;
            const vData = renderData.chunk.vb;
            const stride = renderData.floatStride;
            let colorOffset = 5;
            for (let i = 0; i < vertexCount; i++) {
              vData[colorOffset] = 1;
              vData[colorOffset + 1] = 1;
              vData[colorOffset + 2] = 1;
              vData[colorOffset + 3] = 1;
              colorOffset += stride;
            }
          }
        }
      };
      addon(letter, letterFont);

      const Overflow = Label.Overflow;
      const ttfUtils = {
        updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans) {
          style.isSystemFontUsed = comp.useSystemFont;
          style.fontSize = comp.fontSize;
          outputLayoutData.nodeContentSize.width = outputLayoutData.canvasSize.width = trans.width;
          outputLayoutData.nodeContentSize.height = outputLayoutData.canvasSize.height = trans.height;
          layout.lineHeight = comp.lineHeight;
          layout.overFlow = comp.overflow;
          if (comp.overflow === Overflow.NONE) {
            layout.wrapping = false;
          } else if (comp.overflow === Overflow.RESIZE_HEIGHT) {
            layout.wrapping = true;
          } else {
            layout.wrapping = comp.enableWrapText;
          }
          style.isBold = comp.isBold;
          style.isItalic = comp.isItalic;
          style.isUnderline = comp.isUnderline;
          style.underlineHeight = comp.underlineHeight;
          const isOutlined = comp.enableOutline && comp.outlineWidth > 0;
          if (isOutlined) {
            style.isOutlined = true;
            style.outlineColor.set(comp.outlineColor);
            style.outlineWidth = comp.outlineWidth;
          } else {
            style.isOutlined = false;
          }
          const isShadow = comp.enableShadow && (comp.shadowBlur > 0 || !approx(comp.shadowOffset.x, 0) || !approx(comp.shadowOffset.y, 0));
          if (isShadow) {
            style.hasShadow = true;
            style.shadowColor.set(comp.shadowColor);
            style.shadowBlur = comp.shadowBlur;
            style.shadowOffsetX = comp.shadowOffset.x;
            style.shadowOffsetY = comp.shadowOffset.y;
          } else {
            style.hasShadow = false;
          }
          style.color.set(comp.color);
          outputRenderData.texture = comp.spriteFrame;
          outputRenderData.uiTransAnchorX = trans.anchorX;
          outputRenderData.uiTransAnchorY = trans.anchorY;
          layout.horizontalAlign = comp.horizontalAlign;
          layout.verticalAlign = comp.verticalAlign;
        },
        getAssemblerData() {
          const sharedLabelData = Label._canvasPool.get();
          sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1;
          return sharedLabelData;
        },
        resetAssemblerData(assemblerData) {
          if (assemblerData) {
            Label._canvasPool.put(assemblerData);
          }
        },
        updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }
          if (comp.renderData.vertDirty) {
            const trans = comp.node._uiProps.uiTransformComp;
            const processing = TextProcessing.instance;
            const style = comp.textStyle;
            const layout = comp.textLayout;
            const outputLayoutData = comp.textLayoutData;
            const outputRenderData = comp.textRenderData;
            style.fontScale = view.getScaleX();
            this.updateProcessingData(style, layout, outputLayoutData, outputRenderData, comp, trans);
            processing.setCanvasUsed(comp.assemblerData.canvas, comp.assemblerData.context);
            style.fontFamily = this._updateFontFamily(comp);
            this._resetDynamicAtlas(comp);
            processing.processingString(false, style, layout, outputLayoutData, comp.string);
            processing.generateRenderInfo(false, style, layout, outputLayoutData, outputRenderData, comp.string, this.generateVertexData);
            const renderData = comp.renderData;
            renderData.textureDirty = true;
            this._calDynamicAtlas(comp, outputLayoutData);
            comp.actualFontSize = style.actualFontSize;
            trans.setContentSize(outputLayoutData.nodeContentSize);
            const datalist = renderData.data;
            datalist[0] = outputRenderData.vertexBuffer[0];
            datalist[1] = outputRenderData.vertexBuffer[1];
            datalist[2] = outputRenderData.vertexBuffer[2];
            datalist[3] = outputRenderData.vertexBuffer[3];
            this.updateUVs(comp);
            comp.renderData.vertDirty = false;
            comp.contentWidth = outputLayoutData.nodeContentSize.width;
          }
          if (comp.spriteFrame) {
            const renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        generateVertexData(style, outputLayoutData, outputRenderData) {
          const data = outputRenderData.vertexBuffer;
          const width = outputLayoutData.nodeContentSize.width;
          const height = outputLayoutData.nodeContentSize.height;
          const appX = outputRenderData.uiTransAnchorX * width;
          const appY = outputRenderData.uiTransAnchorY * height;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = -appY;
          data[2].x = -appX;
          data[2].y = height - appY;
          data[3].x = width - appX;
          data[3].y = height - appY;
        },
        updateVertexData(comp) {},
        updateUVs(comp) {},
        _updateFontFamily(comp) {
          let _fontFamily = '';
          if (!comp.useSystemFont) {
            if (comp.font) {
              _fontFamily = comp.font._nativeAsset || 'Arial';
            } else {
              _fontFamily = 'Arial';
            }
          } else {
            _fontFamily = comp.fontFamily || 'Arial';
          }
          return _fontFamily;
        },
        _calDynamicAtlas(comp, outputLayoutData) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP || outputLayoutData.canvasSize.width <= 0 || outputLayoutData.canvasSize.height <= 0) return;
          const frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(comp, frame);
        },
        _resetDynamicAtlas(comp) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
          const frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.deleteAtlasSpriteFrame(frame);
          frame._resetDynamicAtlasFrame();
        }
      };

      const WHITE = Color$1.WHITE.clone();
      const QUAD_INDICES$4 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const ttf = {
        createData(comp) {
          const renderData = comp.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          comp.textRenderData.quadCount = 4;
          const vData = renderData.chunk.vb;
          vData[3] = vData[21] = vData[22] = vData[31] = 0;
          vData[4] = vData[12] = vData[13] = vData[30] = 1;
          let offset = 5;
          for (let i = 0; i < 4; i++) {
            Color$1.toArray(vData, WHITE, offset);
            offset += 9;
          }
          renderData.chunk.setIndexBuffer(QUAD_INDICES$4);
          return renderData;
        },
        fillBuffers(comp, renderer) {
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          const dataList = renderData.data;
          const node = comp.node;
          const vData = chunk.vb;
          const m = node.worldMatrix;
          const stride = renderData.floatStride;
          let offset = 0;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const curData = dataList[i];
            const x = curData.x;
            const y = curData.y;
            let rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData(comp) {
          const renderData = comp.renderData;
          if (!renderData) {
            return;
          }
          const uiTrans = comp.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          const data = renderData.data;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = -appY;
          data[2].x = -appX;
          data[2].y = height - appY;
          data[3].x = width - appX;
          data[3].y = height - appY;
        },
        updateUVs(comp) {
          const renderData = comp.renderData;
          if (!renderData || !comp.ttfSpriteFrame) {
            return;
          }
          const vData = renderData.chunk.vb;
          const uv = comp.ttfSpriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor(comp) {}
      };
      addon(ttf, ttfUtils);

      const labelAssembler = exports('labelAssembler', {
        getAssembler(comp) {
          let assembler = ttf;
          if (comp.font instanceof BitmapFont) {
            assembler = bmfont;
          } else if (comp.cacheMode === Label.CacheMode.CHAR) {
            assembler = letter;
          }
          return assembler;
        }
      });
      Label.Assembler = labelAssembler;

      const FillType$1 = Sprite.FillType;
      const m$3 = new Mat4();
      const QUAD_INDICES$3 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const barFilled = {
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            const vertDirty = renderData.vertDirty;
            if (!vertDirty) {
              return;
            }
            let fillStart = sprite.fillStart;
            let fillRange = sprite.fillRange;
            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }
            fillRange = fillStart + fillRange;
            fillStart = fillStart > 1.0 ? 1.0 : fillStart;
            fillStart = fillStart < 0.0 ? 0.0 : fillStart;
            fillRange = fillRange > 1.0 ? 1.0 : fillRange;
            fillRange = fillRange < 0.0 ? 0.0 : fillRange;
            fillRange -= fillStart;
            fillRange = fillRange < 0 ? 0 : fillRange;
            let fillEnd = fillStart + fillRange;
            fillEnd = fillEnd > 1 ? 1 : fillEnd;
            this.updateUVs(sprite, fillStart, fillEnd);
            this.updateVertexData(sprite, fillStart, fillEnd);
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateUVs(sprite, fillStart, fillEnd) {
          const spriteFrame = sprite.spriteFrame;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const atlasWidth = spriteFrame.width;
          const atlasHeight = spriteFrame.height;
          const textureRect = spriteFrame.rect;
          let ul = 0;
          let vb = 0;
          let ur = 0;
          let vt = 0;
          let quadUV0 = 0;
          let quadUV1 = 0;
          let quadUV2 = 0;
          let quadUV3 = 0;
          let quadUV4 = 0;
          let quadUV5 = 0;
          let quadUV6 = 0;
          let quadUV7 = 0;
          if (spriteFrame.isRotated()) {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.width) / atlasHeight;
            ur = (textureRect.x + textureRect.height) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV2 = ul;
            quadUV4 = quadUV6 = ur;
            quadUV3 = quadUV7 = vb;
            quadUV1 = quadUV5 = vt;
          } else {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.height) / atlasHeight;
            ur = (textureRect.x + textureRect.width) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV4 = ul;
            quadUV2 = quadUV6 = ur;
            quadUV1 = quadUV3 = vb;
            quadUV5 = quadUV7 = vt;
          }
          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              vData[3] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
              vData[12] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
              vData[13] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
              vData[21] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
              vData[22] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
              vData[30] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
              vData[31] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
              break;
            case FillType$1.VERTICAL:
              vData[3] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
              vData[12] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
              vData[13] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
              vData[21] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
              vData[22] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
              vData[30] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
              vData[31] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
              break;
            default:
              errorID(2626);
              break;
          }
        },
        updateVertexData(sprite, fillStart, fillEnd) {
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          let l = -appX;
          let b = -appY;
          let r = width - appX;
          let t = height - appY;
          let progressStart = 0;
          let progressEnd = 0;
          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              progressStart = l + (r - l) * fillStart;
              progressEnd = l + (r - l) * fillEnd;
              l = progressStart;
              r = progressEnd;
              break;
            case FillType$1.VERTICAL:
              progressStart = b + (t - b) * fillStart;
              progressEnd = b + (t - b) * fillEnd;
              b = progressStart;
              t = progressEnd;
              break;
            default:
              errorID(2626);
              break;
          }
          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
        },
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.chunk.setIndexBuffer(QUAD_INDICES$3);
          const dataList = renderData.data;
          for (const data of dataList) {
            data.z = 0;
          }
          return renderData;
        },
        updateWorldVertexData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$3);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = sprite.renderData.data;
          const vData = chunk.vb;
          let offset = 0;
          for (let i = 0; i < 4; i++) {
            const local = dataList[i];
            const x = local.x;
            const y = local.y;
            let rhw = m$3.m03 * x + m$3.m07 * y + m$3.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset] = (m$3.m00 * x + m$3.m04 * y + m$3.m12) * rhw;
            vData[offset + 1] = (m$3.m01 * x + m$3.m05 * y + m$3.m13) * rhw;
            vData[offset + 2] = (m$3.m02 * x + m$3.m06 * y + m$3.m14) * rhw;
          }
        },
        fillBuffers(sprite, renderer) {
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < 4; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      const PI_2 = Math.PI * 2;
      const EPSILON$1 = 1e-6;
      const m$2 = new Mat4();
      const _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _vertices = new Array(4);
      const _uvs$2 = new Array(8);
      const _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      const _center = new Vec2();
      const _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      let QUAD_INDICES$2 = null;
      function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        let sinAngle = Math.sin(angle);
        sinAngle = Math.abs(sinAngle) > EPSILON$1 ? sinAngle : 0;
        let cosAngle = Math.cos(angle);
        cosAngle = Math.abs(cosAngle) > EPSILON$1 ? cosAngle : 0;
        let tanAngle = 0;
        let cotAngle = 0;
        if (cosAngle !== 0) {
          tanAngle = sinAngle / cosAngle;
          if ((left - center.x) * cosAngle > 0) {
            const yLeft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yLeft;
          }
          if ((right - center.x) * cosAngle > 0) {
            const yRight = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yRight;
          }
        }
        if (sinAngle !== 0) {
          cotAngle = cosAngle / sinAngle;
          if ((top - center.y) * sinAngle > 0) {
            const xTop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xTop;
            intersectPoints[3].y = top;
          }
          if ((bottom - center.y) * sinAngle > 0) {
            const xBottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xBottom;
            intersectPoints[1].y = bottom;
          }
        }
      }
      function _calculateVertices(sprite) {
        const uiTrans = sprite.node._uiProps.uiTransformComp;
        const width = uiTrans.width;
        const height = uiTrans.height;
        const appX = uiTrans.anchorX * width;
        const appY = uiTrans.anchorY * height;
        const l = -appX;
        const b = -appY;
        const r = width - appX;
        const t = height - appY;
        const vertices = _vertices;
        vertices[0] = l;
        vertices[1] = b;
        vertices[2] = r;
        vertices[3] = t;
        const fillCenter = sprite.fillCenter;
        const cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
        const cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
        _vertPos[0].x = _vertPos[3].x = l;
        _vertPos[1].x = _vertPos[2].x = r;
        _vertPos[0].y = _vertPos[1].y = b;
        _vertPos[2].y = _vertPos[3].y = t;
        for (const num of _triangles) {
          Vec2.set(num, 0, 0);
        }
        if (cx !== vertices[0]) {
          Vec2.set(_triangles[0], 3, 0);
        }
        if (cx !== vertices[2]) {
          Vec2.set(_triangles[2], 1, 2);
        }
        if (cy !== vertices[1]) {
          Vec2.set(_triangles[1], 0, 1);
        }
        if (cy !== vertices[3]) {
          Vec2.set(_triangles[3], 2, 3);
        }
      }
      function _calculateUVs(spriteFrame) {
        const atlasWidth = spriteFrame.width;
        const atlasHeight = spriteFrame.height;
        const textureRect = spriteFrame.getRect();
        let u0 = 0;
        let u1 = 0;
        let v0 = 0;
        let v1 = 0;
        const uvs = _uvs$2;
        if (spriteFrame.isRotated()) {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.height) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.width) / atlasHeight;
          uvs[0] = uvs[2] = u0;
          uvs[4] = uvs[6] = u1;
          uvs[3] = uvs[7] = v1;
          uvs[1] = uvs[5] = v0;
        } else {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.width) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.height) / atlasHeight;
          uvs[0] = uvs[4] = u0;
          uvs[2] = uvs[6] = u1;
          uvs[1] = uvs[3] = v1;
          uvs[5] = uvs[7] = v0;
        }
      }
      function _getVertAngle(start, end) {
        const placementX = end.x - start.x;
        const placementY = end.y - start.y;
        if (placementX === 0 && placementY === 0) {
          return 0;
        } else if (placementX === 0) {
          if (placementY > 0) {
            return Math.PI * 0.5;
          } else {
            return Math.PI * 1.5;
          }
        } else {
          let angle = Math.atan(placementY / placementX);
          if (placementX < 0) {
            angle += Math.PI;
          }
          return angle;
        }
      }
      function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
        const vertices = _vertices;
        const v0x = vertices[0];
        const v0y = vertices[1];
        const v1x = vertices[2];
        const v1y = vertices[3];
        dataList[offset].x = vert0.x;
        dataList[offset].y = vert0.y;
        dataList[offset + 1].x = vert1.x;
        dataList[offset + 1].y = vert1.y;
        dataList[offset + 2].x = vert2.x;
        dataList[offset + 2].y = vert2.y;
        let progressX = 0;
        let progressY = 0;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset + 1);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        _generateUV(progressX, progressY, dataList, offset + 2);
      }
      function _generateUV(progressX, progressY, data, offset) {
        const uvs = _uvs$2;
        const px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        const px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        const py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        const py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        const uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY;
        uv.v = py1 + (py2 - py1) * progressY;
      }
      const radialFilled = {
        useModel: false,
        createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            if (!renderData.vertDirty) {
              return;
            }
            const dataList = renderData.data;
            let fillStart = sprite.fillStart;
            let fillRange = sprite.fillRange;
            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }
            while (fillStart >= 1.0) {
              fillStart -= 1.0;
            }
            while (fillStart < 0.0) {
              fillStart += 1.0;
            }
            fillStart *= PI_2;
            fillRange *= PI_2;
            const fillEnd = fillStart + fillRange;
            _calculateVertices(sprite);
            _calculateUVs(frame);
            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);
            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
            let offset = 0;
            for (let triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
              const triangle = _triangles[triangleIndex];
              if (!triangle) {
                continue;
              }
              if (fillRange >= PI_2) {
                renderData.dataLength = offset + 3;
                _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                offset += 3;
                continue;
              }
              let startAngle = _getVertAngle(_center, _vertPos[triangle.x]);
              let endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
              if (endAngle < startAngle) {
                endAngle += PI_2;
              }
              startAngle -= PI_2;
              endAngle -= PI_2;
              for (let testIndex = 0; testIndex < 3; ++testIndex) {
                if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                  renderData.dataLength = offset + 3;
                  if (endAngle >= fillEnd) {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                  } else {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                  }
                  offset += 3;
                } else if (endAngle > fillStart) {
                  if (endAngle <= fillEnd) {
                    renderData.dataLength = offset + 3;
                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);
                    offset += 3;
                  } else {
                    renderData.dataLength = offset + 3;
                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);
                    offset += 3;
                  }
                }
                startAngle += PI_2;
                endAngle += PI_2;
              }
            }
            if (offset === 0) {
              renderData.dataLength = 0;
            }
            renderData.resize(offset, offset);
            {
              const indexCount = renderData.indexCount;
              this.createQuadIndices(indexCount);
              renderData.chunk.setIndexBuffer(QUAD_INDICES$2);
              this.updateWorldUVData(sprite);
              sprite.renderEntity.colorDirty = true;
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        createQuadIndices(indexCount) {
          QUAD_INDICES$2 = null;
          QUAD_INDICES$2 = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < indexCount; i++) {
            QUAD_INDICES$2[offset++] = i;
          }
        },
        fillBuffers(comp, renderer) {
          const node = comp.node;
          const renderData = comp.renderData;
          const chunk = renderData.chunk;
          if (comp._flagChangedVersion !== node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(comp, chunk);
            renderData.vertDirty = false;
            comp._flagChangedVersion = node.flagChangedVersion;
          }
          this.updateColorLate(comp);
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          const indexOffset = meshBuffer.indexOffset;
          for (let i = 0; i < renderData.indexCount; i++) {
            ib[indexOffset + i] = vid + i;
          }
          meshBuffer.indexOffset += renderData.indexCount;
          meshBuffer.setDirty();
        },
        updateWorldUVData(sprite, chunk) {
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = renderData.chunk.vb;
          for (let i = 0; i < dataList.length; i++) {
            const offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$2);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = sprite.renderData.data;
          const vData = chunk.vb;
          const vertexCount = renderData.vertexCount;
          let vertexOffset = 0;
          for (let i = 0; i < vertexCount; i++) {
            const vert = dataList[i];
            const x = vert.x;
            const y = vert.y;
            let rhw = m$2.m03 * x + m$2.m07 * y + m$2.m15;
            rhw = rhw ? 1 / rhw : 1;
            vData[vertexOffset + 0] = (m$2.m00 * x + m$2.m04 * y + m$2.m12) * rhw;
            vData[vertexOffset + 1] = (m$2.m01 * x + m$2.m05 * y + m$2.m13) * rhw;
            vData[vertexOffset + 2] = (m$2.m02 * x + m$2.m06 * y + m$2.m14) * rhw;
            vData[vertexOffset + 3] = vert.u;
            vData[vertexOffset + 4] = vert.v;
            vertexOffset += stride;
          }
        },
        updateUVs(sprite) {
          const renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        updateColorLate(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const vertexCount = renderData.vertexCount;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor(sprite) {}
      };

      const QUAD_INDICES$1 = Uint16Array.from([0, 1, 2, 1, 3, 2]);
      const simple = {
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          renderData.chunk.setIndexBuffer(QUAD_INDICES$1);
          return renderData;
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            if (renderData.vertDirty) {
              this.updateVertexData(sprite);
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateWorldVerts(sprite, chunk) {
          const renderData = sprite.renderData;
          const vData = chunk.vb;
          const dataList = renderData.data;
          const node = sprite.node;
          const m = node.worldMatrix;
          const stride = renderData.floatStride;
          let offset = 0;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const curData = dataList[i];
            const x = curData.x;
            const y = curData.y;
            let rhw = m.m03 * x + m.m07 * y + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            offset = i * stride;
            vData[offset + 0] = (m.m00 * x + m.m04 * y + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m14) * rhw;
          }
        },
        fillBuffers(sprite, renderer) {
          if (sprite === null) {
            return;
          }
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVerts(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          const vidOrigin = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          const vid = vidOrigin;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          ib[indexOffset++] = vid + 2;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData(sprite) {
          const renderData = sprite.renderData;
          if (!renderData) {
            return;
          }
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const dataList = renderData.data;
          const cw = uiTrans.width;
          const ch = uiTrans.height;
          const appX = uiTrans.anchorX * cw;
          const appY = uiTrans.anchorY * ch;
          let l = 0;
          let b = 0;
          let r = 0;
          let t = 0;
          if (sprite.trim) {
            l = -appX;
            b = -appY;
            r = cw - appX;
            t = ch - appY;
          } else {
            const frame = sprite.spriteFrame;
            const originSize = frame.originalSize;
            const ow = originSize.width;
            const oh = originSize.height;
            const scaleX = cw / ow;
            const scaleY = ch / oh;
            const trimmedBorder = frame.trimmedBorder;
            l = trimmedBorder.x * scaleX - appX;
            b = trimmedBorder.z * scaleY - appY;
            r = cw + trimmedBorder.y * scaleX - appX;
            t = ch + trimmedBorder.w * scaleY - appY;
          }
          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
          renderData.vertDirty = true;
        },
        updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const uv = sprite.spriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = color.a / 255;
          for (let i = 0; i < 4; i++, colorOffset += renderData.floatStride) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
          }
        }
      };

      const m$1 = new Mat4();
      const tempRenderData$1 = [];
      for (let i = 0; i < 4; i++) {
        tempRenderData$1.push({
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: new Color$1()
        });
      }
      const sliced = {
        createData(sprite) {
          const renderData = sprite.requestRenderData();
          renderData.dataLength = 16;
          renderData.resize(16, 54);
          this.QUAD_INDICES = new Uint16Array(54);
          this.createQuadIndices(4, 4);
          renderData.chunk.setIndexBuffer(this.QUAD_INDICES);
          return renderData;
        },
        createQuadIndices(vertexRow, vertexCol) {
          let offset = 0;
          for (let curRow = 0; curRow < vertexRow - 1; curRow++) {
            for (let curCol = 0; curCol < vertexCol - 1; curCol++) {
              const vid = curRow * vertexCol + curCol;
              this.QUAD_INDICES[offset++] = vid;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
              this.QUAD_INDICES[offset++] = vid + 1;
              this.QUAD_INDICES[offset++] = vid + 1 + vertexCol;
              this.QUAD_INDICES[offset++] = vid + vertexCol;
            }
          }
        },
        updateRenderData(sprite) {
          const frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          const renderData = sprite.renderData;
          if (renderData && frame) {
            const vertDirty = renderData.vertDirty;
            if (vertDirty) {
              this.updateVertexData(sprite);
            }
            renderData.updateRenderData(sprite, frame);
          }
        },
        updateVertexData(sprite) {
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const width = uiTrans.width;
          const height = uiTrans.height;
          const appX = uiTrans.anchorX * width;
          const appY = uiTrans.anchorY * height;
          const frame = sprite.spriteFrame;
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          let sizableWidth = width - leftWidth - rightWidth;
          let sizableHeight = height - topHeight - bottomHeight;
          let xScale = width / (leftWidth + rightWidth);
          let yScale = height / (topHeight + bottomHeight);
          xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
          yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
          sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
          sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
          tempRenderData$1[0].x = -appX;
          tempRenderData$1[0].y = -appY;
          tempRenderData$1[1].x = leftWidth * xScale - appX;
          tempRenderData$1[1].y = bottomHeight * yScale - appY;
          tempRenderData$1[2].x = tempRenderData$1[1].x + sizableWidth;
          tempRenderData$1[2].y = tempRenderData$1[1].y + sizableHeight;
          tempRenderData$1[3].x = width - appX;
          tempRenderData$1[3].y = height - appY;
          for (let curRow = 0; curRow < 4; curRow++) {
            for (let curCol = 0; curCol < 4; curCol++) {
              const curIndex = curRow * 4 + curCol;
              if (curIndex < renderData.dataLength && curRow < tempRenderData$1.length && curCol < tempRenderData$1.length) {
                dataList[curIndex].x = tempRenderData$1[curCol].x;
                dataList[curIndex].y = tempRenderData$1[curRow].y;
              }
            }
          }
        },
        fillBuffers(sprite, renderer) {
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (sprite._flagChangedVersion !== sprite.node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = sprite.node.flagChangedVersion;
          }
          chunk.bufferId;
          const vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          for (let r = 0; r < 3; ++r) {
            for (let c = 0; c < 3; ++c) {
              const start = vid + r * 4 + c;
              ib[indexOffset++] = start;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 4;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 5;
              ib[indexOffset++] = start + 4;
            }
          }
          meshBuffer.indexOffset = indexOffset;
        },
        updateWorldVertexData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m$1);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = chunk.vb;
          let offset = 0;
          for (let row = 0; row < 4; ++row) {
            const rowD = dataList[row * 4];
            for (let col = 0; col < 4; ++col) {
              const colD = dataList[col];
              const x = colD.x;
              const y = rowD.y;
              let rhw = m$1.m03 * x + m$1.m07 * y + m$1.m15;
              rhw = rhw ? 1 / rhw : 1;
              offset = (row * 4 + col) * stride;
              vData[offset + 0] = (m$1.m00 * x + m$1.m04 * y + m$1.m12) * rhw;
              vData[offset + 1] = (m$1.m01 * x + m$1.m05 * y + m$1.m13) * rhw;
              vData[offset + 2] = (m$1.m02 * x + m$1.m06 * y + m$1.m14) * rhw;
            }
          }
        },
        updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const uv = sprite.spriteFrame.uvSliced;
          let uvOffset = 3;
          for (let i = 0; i < 16; i++) {
            vData[uvOffset] = uv[i].u;
            vData[uvOffset + 1] = uv[i].v;
            uvOffset += stride;
          }
        },
        updateColor(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < 16; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      const m = new Mat4();
      let origin;
      let leftInner;
      let rightInner;
      let rightOuter;
      let bottomInner;
      let topInner;
      let topOuter;
      let tempRenderDataLength = 0;
      const tempRenderData = [];
      let QUAD_INDICES = null;
      function has9SlicedOffsetVertexCount(spriteFrame) {
        if (spriteFrame) {
          if (spriteFrame.insetTop > 0 || spriteFrame.insetBottom > 0 || spriteFrame.insetLeft > 0 || spriteFrame.insetRight > 0) {
            return 2;
          }
        }
        return 0;
      }
      const tiled = {
        createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData(sprite) {
          const renderData = sprite.renderData;
          const frame = sprite.spriteFrame;
          if (!frame || !renderData) {
            return;
          }
          if (!renderData.vertDirty) {
            return;
          }
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const contentWidth = Math.abs(uiTrans.width);
          const contentHeight = Math.abs(uiTrans.height);
          const rect = frame.getRect();
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          const centerHeight = rect.height - topHeight - bottomHeight;
          let sizableWidth = contentWidth - leftWidth - rightWidth;
          let sizableHeight = contentHeight - topHeight - bottomHeight;
          sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
          sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
          const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          const offsetVertexCount = has9SlicedOffsetVertexCount(frame);
          const row = Math.ceil(vRepeat + offsetVertexCount);
          const col = Math.ceil(hRepeat + offsetVertexCount);
          renderData.dataLength = row * 2 * (col * 2);
          this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);
          if (renderData.vertexCount !== row * col * 4) {
            sprite.renderEntity.colorDirty = true;
          }
          renderData.resize(row * col * 4, row * col * 6);
          {
            const indexCount = renderData.indexCount;
            this.createQuadIndices(indexCount);
            renderData.chunk.setIndexBuffer(QUAD_INDICES);
            this.updateWorldUVData(sprite);
          }
          renderData.updateRenderData(sprite, frame);
        },
        createQuadIndices(indexCount) {
          if (indexCount % 6 !== 0) {
            error('illegal index count!');
            return;
          }
          const quadCount = indexCount / 6;
          QUAD_INDICES = null;
          QUAD_INDICES = new Uint16Array(indexCount);
          let offset = 0;
          for (let i = 0; i < quadCount; i++) {
            QUAD_INDICES[offset++] = 0 + i * 4;
            QUAD_INDICES[offset++] = 1 + i * 4;
            QUAD_INDICES[offset++] = 2 + i * 4;
            QUAD_INDICES[offset++] = 1 + i * 4;
            QUAD_INDICES[offset++] = 3 + i * 4;
            QUAD_INDICES[offset++] = 2 + i * 4;
          }
        },
        updateUVs(sprite) {
          const renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        fillBuffers(sprite, renderer) {
          const node = sprite.node;
          const renderData = sprite.renderData;
          const chunk = renderData.chunk;
          if (chunk === null) {
            return;
          }
          if (sprite._flagChangedVersion !== node.flagChangedVersion || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(sprite, chunk);
            renderData.vertDirty = false;
            sprite._flagChangedVersion = node.flagChangedVersion;
          }
          this.updateColorLate(sprite);
          chunk.bufferId;
          let vid = chunk.vertexOffset;
          const meshBuffer = chunk.meshBuffer;
          const ib = chunk.meshBuffer.iData;
          let indexOffset = meshBuffer.indexOffset;
          for (let i = 0; i < renderData.indexCount; i += 6) {
            ib[indexOffset++] = vid;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 2;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 3;
            ib[indexOffset++] = vid + 2;
            vid += 4;
            meshBuffer.indexOffset += 6;
          }
          meshBuffer.setDirty();
        },
        updateWorldUVData(sprite) {
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = renderData.chunk.vb;
          for (let i = 0; i < dataList.length; i++) {
            const offset = i * stride;
            vData[offset + 3] = dataList[i].u;
            vData[offset + 4] = dataList[i].v;
          }
        },
        updateWorldVertexAndUVData(sprite, chunk) {
          const node = sprite.node;
          node.getWorldMatrix(m);
          const renderData = sprite.renderData;
          const stride = renderData.floatStride;
          const dataList = renderData.data;
          const vData = chunk.vb;
          const length = dataList.length;
          for (let i = 0; i < length; i++) {
            const x = dataList[i].x;
            const y = dataList[i].y;
            const z = dataList[i].z;
            let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
            rhw = rhw ? 1 / rhw : 1;
            const offset = i * stride;
            vData[offset] = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
            vData[offset + 1] = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
            vData[offset + 2] = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
          }
          this.updateWorldUVData(sprite);
        },
        updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
          const uiTrans = sprite.node._uiProps.uiTransformComp;
          const renderData = sprite.renderData;
          const dataList = renderData.data;
          const frame = sprite.spriteFrame;
          const rect = frame.rect;
          const contentWidth = Math.abs(uiTrans.width);
          const contentHeight = Math.abs(uiTrans.height);
          const appx = uiTrans.anchorX * contentWidth;
          const appy = uiTrans.anchorY * contentHeight;
          const leftWidth = frame.insetLeft;
          const rightWidth = frame.insetRight;
          const centerWidth = rect.width - leftWidth - rightWidth;
          const topHeight = frame.insetTop;
          const bottomHeight = frame.insetBottom;
          const centerHeight = rect.height - topHeight - bottomHeight;
          const xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
          const yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
          let offsetWidth = 0;
          let offsetHeight = 0;
          if (centerWidth > 0) {
            offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
          } else {
            offsetWidth = sizableWidth;
          }
          if (centerHeight > 0) {
            offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
          } else {
            offsetHeight = sizableHeight;
          }
          tempRenderData.length = 0;
          tempRenderDataLength = Math.max(row + 1, col + 1);
          for (let i = 0; i < tempRenderDataLength; i++) {
            tempRenderData.push({
              x: 0,
              y: 0,
              z: 0,
              u: 0,
              v: 0,
              color: new Color$1()
            });
          }
          const offsetVertexCount = has9SlicedOffsetVertexCount(frame);
          if (offsetVertexCount === 0) {
            for (let i = 0; i < tempRenderDataLength; i++) {
              if (i >= col) {
                tempRenderData[i].x = contentWidth - appx;
              } else {
                tempRenderData[i].x = -appx + i * centerWidth;
              }
              if (i >= row) {
                tempRenderData[i].y = contentHeight - appy;
              } else {
                tempRenderData[i].y = -appy + i * centerHeight;
              }
            }
          } else {
            for (let i = 0; i < tempRenderDataLength; i++) {
              if (i === 0) {
                tempRenderData[i].x = -appx;
              } else if (i === 1) {
                tempRenderData[i].x = -appx + leftWidth * xScale;
              } else if (i > 1 && i < col - 1) {
                if (centerWidth > 0) {
                  tempRenderData[i].x = -appx + leftWidth * xScale + centerWidth * (i - 1);
                } else {
                  tempRenderData[i].x = leftWidth + sizableWidth - appx;
                }
              } else if (i === col - 1) {
                tempRenderData[i].x = -appx + leftWidth * xScale + offsetWidth + centerWidth * (i - 2);
              } else if (i >= col) {
                tempRenderData[i].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
              }
              if (i === 0) {
                tempRenderData[i].y = -appy;
              } else if (i === 1) {
                tempRenderData[i].y = -appy + bottomHeight * yScale;
              } else if (i > 1 && i < row - 1) {
                if (centerHeight > 0) {
                  tempRenderData[i].y = -appy + bottomHeight * yScale + centerHeight * (i - 1);
                } else {
                  tempRenderData[i].y = bottomHeight + sizableHeight - appy;
                }
              } else if (i === row - 1) {
                tempRenderData[i].y = -appy + bottomHeight * yScale + offsetHeight + centerHeight * (i - 2);
              } else if (i >= row) {
                tempRenderData[i].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
              }
            }
          }
          let x = 0;
          let x1 = 0;
          let y = 0;
          let y1 = 0;
          for (let yIndex = 0; yIndex < row; ++yIndex) {
            y = tempRenderData[yIndex].y;
            y1 = tempRenderData[yIndex + 1].y;
            for (let xIndex = 0; xIndex < col; ++xIndex) {
              x = tempRenderData[xIndex].x;
              x1 = tempRenderData[xIndex + 1].x;
              const curIndex = 4 * (yIndex * col + xIndex);
              dataList[curIndex].x = x;
              dataList[curIndex].y = y;
              dataList[curIndex + 1].x = x1;
              dataList[curIndex + 1].y = y;
              dataList[curIndex + 2].x = x;
              dataList[curIndex + 2].y = y1;
              dataList[curIndex + 3].x = x1;
              dataList[curIndex + 3].y = y1;
            }
          }
          const rotated = frame.rotated;
          frame.uv;
          const uvSliced = frame.uvSliced;
          origin = uvSliced[0];
          leftInner = uvSliced[1];
          rightInner = uvSliced[2];
          rightOuter = uvSliced[3];
          bottomInner = uvSliced[4];
          topInner = uvSliced[8];
          topOuter = uvSliced[12];
          let coefU = 0;
          let coefV = 0;
          const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          const tempXVerts = [];
          const tempYVerts = [];
          for (let yIndexUV = 0; yIndexUV < row; ++yIndexUV) {
            if (sizableHeight > centerHeight) {
              const curYRectCount = offsetVertexCount > 0 ? yIndexUV : yIndexUV + 1;
              if (sizableHeight >= curYRectCount * centerHeight) {
                coefV = 1;
              } else {
                coefV = vRepeat % 1;
              }
            } else {
              coefV = vRepeat;
            }
            for (let xIndexUV = 0; xIndexUV < col; ++xIndexUV) {
              if (sizableWidth > centerWidth) {
                const curXRectCount = offsetVertexCount > 0 ? xIndexUV : xIndexUV + 1;
                if (sizableWidth >= curXRectCount * centerWidth) {
                  coefU = 1;
                } else {
                  coefU = hRepeat % 1;
                }
              } else {
                coefU = hRepeat;
              }
              if (rotated) {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = bottomInner.u;
                  tempXVerts[1] = bottomInner.u;
                  tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  tempYVerts[0] = leftInner.v;
                  tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                  tempYVerts[2] = leftInner.v;
                } else {
                  if (yIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = origin.u;
                    tempXVerts[2] = bottomInner.u;
                  } else if (yIndexUV < row - 1) {
                    tempXVerts[0] = bottomInner.u;
                    tempXVerts[1] = bottomInner.u;
                    tempXVerts[2] = bottomInner.u + (topInner.u - bottomInner.u) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempXVerts[0] = topInner.u;
                    tempXVerts[1] = topInner.u;
                    tempXVerts[2] = topOuter.u;
                  }
                  if (xIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = leftInner.v;
                    tempYVerts[2] = origin.v;
                  } else if (xIndexUV < col - 1) {
                    tempYVerts[0] = leftInner.v;
                    tempYVerts[1] = leftInner.v + (rightInner.v - leftInner.v) * coefU;
                    tempYVerts[2] = leftInner.v;
                  } else if (xIndexUV === col - 1) {
                    tempYVerts[0] = rightInner.v;
                    tempYVerts[1] = rightOuter.v;
                    tempYVerts[2] = rightInner.v;
                  }
                }
                tempXVerts[3] = tempXVerts[2];
                tempYVerts[3] = tempYVerts[1];
              } else {
                if (offsetVertexCount === 0) {
                  tempXVerts[0] = leftInner.u;
                  tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                  tempXVerts[2] = leftInner.u;
                  tempYVerts[0] = bottomInner.v;
                  tempYVerts[1] = bottomInner.v;
                  tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                } else {
                  if (xIndexUV === 0) {
                    tempXVerts[0] = origin.u;
                    tempXVerts[1] = leftInner.u;
                    tempXVerts[2] = origin.u;
                  } else if (xIndexUV < col - 1) {
                    tempXVerts[0] = leftInner.u;
                    tempXVerts[1] = leftInner.u + (rightInner.u - leftInner.u) * coefU;
                    tempXVerts[2] = leftInner.u;
                  } else if (xIndexUV === col - 1) {
                    tempXVerts[0] = rightInner.u;
                    tempXVerts[1] = rightOuter.u;
                    tempXVerts[2] = rightInner.u;
                  }
                  if (yIndexUV === 0) {
                    tempYVerts[0] = origin.v;
                    tempYVerts[1] = origin.v;
                    tempYVerts[2] = bottomInner.v;
                  } else if (yIndexUV < row - 1) {
                    tempYVerts[0] = bottomInner.v;
                    tempYVerts[1] = bottomInner.v;
                    tempYVerts[2] = bottomInner.v + (topInner.v - bottomInner.v) * coefV;
                  } else if (yIndexUV === row - 1) {
                    tempYVerts[0] = topInner.v;
                    tempYVerts[1] = topInner.v;
                    tempYVerts[2] = topOuter.v;
                  }
                }
                tempXVerts[3] = tempXVerts[1];
                tempYVerts[3] = tempYVerts[2];
              }
              const curIndex = 4 * (yIndexUV * col + xIndexUV);
              dataList[curIndex].u = tempXVerts[0];
              dataList[curIndex].v = tempYVerts[0];
              dataList[curIndex + 1].u = tempXVerts[1];
              dataList[curIndex + 1].v = tempYVerts[1];
              dataList[curIndex + 2].u = tempXVerts[2];
              dataList[curIndex + 2].v = tempYVerts[2];
              dataList[curIndex + 3].u = tempXVerts[3];
              dataList[curIndex + 3].v = tempYVerts[3];
            }
          }
        },
        updateColorLate(sprite) {
          const renderData = sprite.renderData;
          const vData = renderData.chunk.vb;
          const stride = renderData.floatStride;
          const vertexCount = renderData.vertexCount;
          let colorOffset = 5;
          const color = sprite.color;
          const colorR = color.r / 255;
          const colorG = color.g / 255;
          const colorB = color.b / 255;
          const colorA = sprite.node._uiProps.opacity;
          for (let i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor(sprite) {}
      };

      const SpriteType = Sprite.Type;
      const FillType = Sprite.FillType;
      const spriteAssembler = exports('spriteAssembler', {
        getAssembler(spriteComp) {
          let util = simple;
          const comp = spriteComp;
          switch (comp.type) {
            case SpriteType.SLICED:
              util = sliced;
              break;
            case SpriteType.TILED:
              util = tiled;
              break;
            case SpriteType.FILLED:
              if (comp.fillType === FillType.RADIAL) {
                util = radialFilled;
              } else {
                util = barFilled;
              }
              break;
          }
          return util;
        }
      });
      Sprite.Assembler = spriteAssembler;

      const mouseEvents = [Input.EventType.MOUSE_DOWN, Input.EventType.MOUSE_MOVE, Input.EventType.MOUSE_UP, Input.EventType.MOUSE_WHEEL];
      const touchEvents = [Input.EventType.TOUCH_START, Input.EventType.TOUCH_MOVE, Input.EventType.TOUCH_END, Input.EventType.TOUCH_CANCEL];
      class PointerEventDispatcher {
        constructor() {
          this.priority = EventDispatcherPriority.UI;
          this._isListDirty = false;
          this._inDispatchCount = 0;
          this._pointerEventProcessorList = [];
          this._processorListToAdd = [];
          this._processorListToRemove = [];
          input._registerEventDispatcher(this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.MARK_LIST_DIRTY, this._markListDirty, this);
        }
        dispatchEvent(event) {
          const eventType = event.type;
          if (touchEvents.includes(eventType)) {
            return this.dispatchEventTouch(event);
          } else if (mouseEvents.includes(eventType)) {
            return this.dispatchEventMouse(event);
          }
          return true;
        }
        addPointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            if (!this._pointerEventProcessorList.includes(pointerEventProcessor)) {
              this._pointerEventProcessorList.push(pointerEventProcessor);
              this._isListDirty = true;
            }
          } else if (!this._processorListToAdd.includes(pointerEventProcessor)) {
            this._processorListToAdd.push(pointerEventProcessor);
          }
          remove(this._processorListToRemove, pointerEventProcessor);
        }
        removePointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            remove(this._pointerEventProcessorList, pointerEventProcessor);
            this._isListDirty = true;
          } else if (!this._processorListToRemove.includes(pointerEventProcessor)) {
            this._processorListToRemove.push(pointerEventProcessor);
          }
          remove(this._processorListToAdd, pointerEventProcessor);
        }
        dispatchEventMouse(eventMouse) {
          this._inDispatchCount++;
          this._sortPointerEventProcessorList();
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          let dispatchToNextEventDispatcher = true;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
              dispatchToNextEventDispatcher = false;
              if (!eventMouse.preventSwallow) {
                break;
              } else {
                eventMouse.preventSwallow = false;
              }
            }
          }
          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }
          return dispatchToNextEventDispatcher;
        }
        dispatchEventTouch(eventTouch) {
          this._inDispatchCount++;
          this._sortPointerEventProcessorList();
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          const touch = eventTouch.touch;
          let dispatchToNextEventDispatcher = true;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
              if (eventTouch.type === InputEventType.TOUCH_START) {
                if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                  if (pointerEventProcessor.isEnabled) {
                    pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                  } else {
                    const cancelEvent = new EventTouch([eventTouch.touch], true, InputEventType.TOUCH_CANCEL);
                    cancelEvent.touch = eventTouch.touch;
                    pointerEventProcessor.dispatchEvent(cancelEvent);
                    pointerEventProcessor.claimedTouchIdList.length = 0;
                  }
                  dispatchToNextEventDispatcher = false;
                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                const index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());
                if (index !== -1) {
                  pointerEventProcessor._handleEventTouch(eventTouch);
                  if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                    removeAt(pointerEventProcessor.claimedTouchIdList, index);
                  }
                  dispatchToNextEventDispatcher = false;
                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              }
            }
          }
          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }
          return dispatchToNextEventDispatcher;
        }
        _updatePointerEventProcessorList() {
          const listToAdd = this._processorListToAdd;
          const addLength = listToAdd.length;
          for (let i = 0; i < addLength; ++i) {
            this.addPointerEventProcessor(listToAdd[i]);
          }
          listToAdd.length = 0;
          const listToRemove = this._processorListToRemove;
          const removeLength = listToRemove.length;
          for (let i = 0; i < removeLength; ++i) {
            this.removePointerEventProcessor(listToRemove[i]);
          }
          listToRemove.length = 0;
        }
        _sortPointerEventProcessorList() {
          if (!this._isListDirty) {
            return;
          }
          const pointerEventProcessorList = this._pointerEventProcessorList;
          const length = pointerEventProcessorList.length;
          for (let i = 0; i < length; ++i) {
            const pointerEventProcessor = pointerEventProcessorList[i];
            const node = pointerEventProcessor.node;
            if (node._uiProps) {
              const trans = node._uiProps.uiTransformComp;
              pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
            }
          }
          pointerEventProcessorList.sort(this._sortByPriority);
          this._isListDirty = false;
        }
        _sortByPriority(p1, p2) {
          const node1 = p1.node;
          const node2 = p2.node;
          if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
            return -1;
          } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
            return 1;
          }
          if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
            return p2.cachedCameraPriority - p1.cachedCameraPriority;
          }
          let n1 = node1;
          let n2 = node2;
          let ex = false;
          while (((_parent = n1.parent) === null || _parent === void 0 ? void 0 : _parent.uuid) !== ((_parent2 = n2.parent) === null || _parent2 === void 0 ? void 0 : _parent2.uuid)) {
            var _parent, _parent2, _n, _n$parent, _n2, _n2$parent;
            n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
            n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent = _n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
          }
          if (n1.uuid === n2.uuid) {
            if (n1.uuid === node2.uuid) {
              return -1;
            }
            if (n1.uuid === node1.uuid) {
              return 1;
            }
          }
          const priority1 = n1 ? n1.getSiblingIndex() : 0;
          const priority2 = n2 ? n2.getSiblingIndex() : 0;
          return ex ? priority1 - priority2 : priority2 - priority1;
        }
        _markListDirty() {
          this._isListDirty = true;
        }
      }
      new PointerEventDispatcher();

      const _dsInfo = new DescriptorSetInfo(null);
      const m4_1$1 = new Mat4();
      class Batcher2D {
        get nativeObj() {
          return this._nativeObj;
        }
        get currBufferAccessor() {
          if (this._staticVBBuffer) return this._staticVBBuffer;
          this._staticVBBuffer = this.switchBufferAccessor();
          return this._staticVBBuffer;
        }
        get batches() {
          return this._batches;
        }
        set currStaticRoot(value) {
          this._currStaticRoot = value;
        }
        set currIsStatic(value) {
          this._currIsStatic = value;
        }
        constructor(_root) {
          this.device = void 0;
          this._screens = [];
          this._staticVBBuffer = null;
          this._bufferAccessors = new Map();
          this._drawBatchPool = void 0;
          this._batches = void 0;
          this._currBID = -1;
          this._indexStart = 0;
          this._emptyMaterial = new Material();
          this._currRenderData = null;
          this._currMaterial = this._emptyMaterial;
          this._currTexture = null;
          this._currSampler = null;
          this._currStaticRoot = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
          this._currDepthStencilStateStage = null;
          this._currIsStatic = false;
          this._currHash = 0;
          this._currIsMiddleware = false;
          this._middlewareEnableBatch = false;
          this._middlewareBuffer = null;
          this._middlewareIndexStart = 0;
          this._middlewareIndexCount = 0;
          this._pOpacity = 1;
          this._opacityDirty = 0;
          this._descriptorSetCache = new DescriptorSetCache();
          this._meshDataArray = [];
          this._maskClearModel = null;
          this._maskClearMtl = null;
          this._maskModelMesh = null;
          this._root = _root;
          this.device = _root.device;
          this._batches = new CachedArray(64);
          this._drawBatchPool = new Pool(() => new DrawBatch2D(), 128, obj => obj.destroy(this));
        }
        initialize() {
          return true;
        }
        destroy() {
          for (let i = 0; i < this._batches.length; i++) {
            if (this._batches.array[i]) {
              this._batches.array[i].destroy(this);
            }
          }
          this._batches.destroy();
          for (const accessor of this._bufferAccessors.values()) {
            accessor.destroy();
          }
          this._bufferAccessors.clear();
          if (this._drawBatchPool) {
            this._drawBatchPool.destroy();
          }
          this._descriptorSetCache.destroy();
          StencilManager.sharedManager.destroy();
          if (this._maskClearModel && this._maskModelMesh) {
            legacyCC.director.root.destroyModel(this._maskClearModel);
            this._maskModelMesh.destroy();
          }
          if (this._maskClearMtl) {
            this._maskClearMtl.destroy();
          }
        }
        syncRootNodesToNative() {
          {
            const rootNodes = [];
            for (const screen of this._screens) {
              rootNodes.push(screen.node);
            }
            this._nativeObj.syncRootNodesToNative(rootNodes);
          }
        }
        addScreen(comp) {
          this._screens.push(comp);
          this._screens.sort(this._screenSort);
          {
            this.syncRootNodesToNative();
          }
        }
        removeScreen(comp) {
          const idx = this._screens.indexOf(comp);
          if (idx === -1) {
            return;
          }
          this._screens.splice(idx, 1);
          {
            this.syncRootNodesToNative();
          }
        }
        sortScreens() {
          this._screens.sort(this._screenSort);
          {
            this.syncRootNodesToNative();
          }
        }
        getFirstRenderCamera(node) {
          if (node.scene && node.scene.renderScene) {
            const cameras = node.scene.renderScene.cameras;
            for (let i = 0; i < cameras.length; i++) {
              const camera = cameras[i];
              if (camera.visibility & node.layer) {
                return camera;
              }
            }
          }
          return null;
        }
        update() {
          {
            return;
          }
        }
        uploadBuffers() {
          {
            this._nativeObj.uploadBuffers();
          }
        }
        reset() {
          {
            this._nativeObj.reset();
          }
        }
        switchBufferAccessor(attributes = vfmtPosUvColor) {
          const strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);
          if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== strideBytes) {
            let accessor = this._bufferAccessors.get(strideBytes);
            if (!accessor) {
              accessor = new StaticVBAccessor(this.device, attributes);
              this._bufferAccessors.set(strideBytes, accessor);
            }
            this._staticVBBuffer = accessor;
            this._currBID = -1;
          }
          return this._staticVBBuffer;
        }
        registerBufferAccessor(key, accessor) {
          this._bufferAccessors.set(key, accessor);
        }
        updateBuffer(attributes, bid) {
          const accessor = this.switchBufferAccessor(attributes);
          if (this._currBID !== bid) {
            this._currBID = bid;
            this._indexStart = accessor.getMeshBuffer(bid).indexOffset;
          }
        }
        commitComp(comp, renderData, frame, assembler, transform) {
          let dataHash = 0;
          let mat;
          let bufferID = -1;
          if (renderData && renderData.chunk) {
            if (!renderData.isValid()) return;
            dataHash = renderData.dataHash;
            mat = renderData.material;
            bufferID = renderData.chunk.bufferId;
          }
          if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
            this._insertMaskBatch(comp);
          } else {
            comp.stencilStage = StencilManager.sharedManager.stage;
          }
          const depthStencilStateStage = comp.stencilStage;
          if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
            this.autoMergeBatches(this._currComponent);
            if (renderData && !renderData._isMeshBuffer) {
              this.updateBuffer(renderData.vertexFormat, bufferID);
            }
            this._currRenderData = renderData;
            this._currHash = renderData ? renderData.dataHash : 0;
            this._currComponent = comp;
            this._currTransform = transform;
            this._currMaterial = comp.getRenderMaterial(0);
            this._currDepthStencilStateStage = depthStencilStateStage;
            this._currLayer = comp.node.layer;
            if (frame) {
              {
                assert(frame.isValid, 'frame should not be invalid, it may have been released');
              }
              this._currTexture = frame.getGFXTexture();
              this._currSampler = frame.getGFXSampler();
              this._currTextureHash = frame.getHash();
              this._currSamplerHash = this._currSampler.hash;
            } else {
              this._currTexture = null;
              this._currSampler = null;
              this._currTextureHash = 0;
              this._currSamplerHash = 0;
            }
          }
          assembler.fillBuffers(comp, this);
        }
        commitIA(renderComp, ia, tex, mat, transform) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }
          let depthStencil;
          let dssHash = 0;
          if (renderComp) {
            renderComp.stencilStage = StencilManager.sharedManager.stage;
            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }
            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = transform || null;
          if (tex) {
            curDrawBatch.texture = tex.getGFXTexture();
            curDrawBatch.sampler = tex.getGFXSampler();
            curDrawBatch.textureHash = tex.getHash();
            curDrawBatch.samplerHash = curDrawBatch.sampler.hash;
          }
          curDrawBatch.fillPasses(mat || null, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
        }
        commitMiddleware(comp, meshBuffer, indexOffset, indexCount, tex, mat, enableBatch) {
          const texture = tex.getGFXTexture();
          if (enableBatch && this._middlewareEnableBatch && this._middlewareBuffer === meshBuffer && this._currTexture === texture && this._currMaterial.hash === mat.hash && this._middlewareIndexStart + this._middlewareIndexCount === indexOffset && this._currLayer === comp.node.layer) {
            this._middlewareIndexCount += indexCount;
          } else {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
            this._currComponent = comp;
            this._currTexture = texture;
            this._currSampler = tex.getGFXSampler();
            this._currTextureHash = tex.getHash();
            this._currLayer = comp.node.layer;
            this._currSamplerHash = this._currSampler.hash;
            this._currHash = 0;
            this._currTransform = enableBatch ? null : comp.node;
            this._middlewareEnableBatch = enableBatch;
            this._middlewareBuffer = meshBuffer;
            this._currMaterial = mat;
            this._middlewareIndexStart = indexOffset;
            this._middlewareIndexCount = indexCount;
          }
          this._currIsMiddleware = true;
        }
        commitModel(comp, model, mat) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }
          let depthStencil;
          let dssHash = 0;
          if (mat) {
            if (comp.stencilStage === Stage.ENTER_LEVEL || comp.stencilStage === Stage.ENTER_LEVEL_INVERTED) {
              this._insertMaskBatch(comp);
            } else {
              comp.stencilStage = StencilManager.sharedManager.stage;
            }
            depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
            dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
          }
          const stamp = legacyCC.director.getTotalFrames();
          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }
          for (let i = 0; i < model.subModels.length; i++) {
            const curDrawBatch = this._drawBatchPool.alloc();
            const subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;
            if (!depthStencil) {
              depthStencil = null;
            }
            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;
            this._batches.push(curDrawBatch);
          }
        }
        setupStaticBatch(staticComp, bufferAccessor) {
          this.finishMergeBatches();
          this._staticVBBuffer = bufferAccessor;
          this.currStaticRoot = staticComp;
        }
        endStaticBatch() {
          this.finishMergeBatches();
          this.currStaticRoot = null;
          this._staticVBBuffer = null;
          this.switchBufferAccessor();
        }
        commitStaticBatch(comp) {
          this._batches.concat(comp.drawBatchList);
          this.finishMergeBatches();
        }
        autoMergeBatches(renderComp) {
          if (this._currIsMiddleware) {
            this.mergeBatchesForMiddleware(renderComp);
            return;
          }
          const mat = this._currMaterial;
          if (!mat) {
            return;
          }
          let ia;
          const rd = this._currRenderData;
          const accessor = this._staticVBBuffer;
          if (rd && rd._isMeshBuffer) {
            ia = rd.requestIA(this.device);
            if (this._meshDataArray.indexOf(rd) === -1) {
              this._meshDataArray.push(rd);
            }
          } else if (accessor) {
            const bid = this._currBID;
            const buf = accessor.getMeshBuffer(bid);
            if (!buf) {
              return;
            }
            const indexCount = buf.indexOffset - this._indexStart;
            if (indexCount <= 0) return;
            assertIsTrue(this._indexStart < buf.indexOffset);
            buf.setDirty();
            ia = buf.requireFreeIA(this.device);
            ia.firstIndex = this._indexStart;
            ia.indexCount = indexCount;
            this._indexStart = buf.indexOffset;
          }
          this._currBID = -1;
          if (!ia || !this._currTexture) {
            return;
          }
          let depthStencil;
          let dssHash = 0;
          if (renderComp) {
            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }
            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = this._currLayer;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(mat, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
        }
        mergeBatchesForMiddleware(renderComp) {
          let depthStencil;
          let dssHash = 0;
          renderComp.stencilStage = StencilManager.sharedManager.stage;
          if (renderComp.customMaterial !== null) {
            depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, this._currMaterial);
          } else {
            depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
          }
          dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          const ia = this._middlewareBuffer.requireFreeIA(this.device);
          ia.firstIndex = this._middlewareIndexStart;
          ia.indexCount = this._middlewareIndexCount;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(this._currMaterial || null, depthStencil, dssHash, null);
          this._batches.push(curDrawBatch);
          this._currIsMiddleware = false;
          this._middlewareBuffer = null;
        }
        forceMergeBatches(material, frame, renderComp) {
          this._currMaterial = material;
          if (frame) {
            this._currTexture = frame.getGFXTexture();
            this._currSampler = frame.getGFXSampler();
            this._currTextureHash = frame.getHash();
            this._currSamplerHash = this._currSampler.hash;
          } else {
            this._currTexture = this._currSampler = null;
            this._currTextureHash = this._currSamplerHash = 0;
          }
          this._currLayer = renderComp.node.layer;
          this.autoMergeBatches(renderComp);
        }
        resetRenderStates() {
          this._currMaterial = this._emptyMaterial;
          this._currRenderData = null;
          this._currTexture = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
        }
        finishMergeBatches() {
          this.autoMergeBatches();
          this.resetRenderStates();
        }
        flushMaterial(mat) {
          this._currMaterial = mat;
        }
        walk(node, level = 0) {
          if (!node.activeInHierarchy) {
            return;
          }
          const children = node.children;
          const uiProps = node._uiProps;
          const render = uiProps.uiComp;
          const parentOpacity = this._pOpacity;
          let opacity = parentOpacity;
          const selfOpacity = render && render.color ? render.color.a / 255 : 1;
          this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
          uiProps.setOpacity(opacity);
          if (!approx(opacity, 0, EPSILON$2)) {
            if (uiProps.colorDirty) {
              this._opacityDirty++;
            }
            if (render && render.enabledInHierarchy) {
              render.fillBuffers(this);
            }
            if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
              updateOpacity(render.renderData, opacity);
              const buffer = render.renderData.getMeshBuffer();
              if (buffer) {
                buffer.setDirty();
              }
            }
            if (children.length > 0 && !node._static) {
              for (let i = 0; i < children.length; ++i) {
                const child = children[i];
                this.walk(child, level);
              }
            }
            if (uiProps.colorDirty) {
              this._opacityDirty--;
              uiProps.colorDirty = false;
            }
          }
          this._pOpacity = parentOpacity;
          if (render && render.enabledInHierarchy) {
            render.postUpdateAssembler(this);
            if ((render.stencilStage === Stage.ENTER_LEVEL || render.stencilStage === Stage.ENTER_LEVEL_INVERTED) && StencilManager.sharedManager.getMaskStackSize() > 0) {
              this.autoMergeBatches(this._currComponent);
              this.resetRenderStates();
              StencilManager.sharedManager.exitMask();
            }
          }
          level += 1;
        }
        _screenSort(a, b) {
          return a.node.getSiblingIndex() - b.node.getSiblingIndex();
        }
        _releaseDescriptorSetCache(textureHash, sampler = null) {
          {
            this._nativeObj.releaseDescriptorSetCache(textureHash, sampler);
          }
        }
        _createClearModel() {
          if (!this._maskClearModel) {
            this._maskClearMtl = builtinResMgr.get('default-clear-stencil');
            this._maskClearModel = legacyCC.director.root.createModel(Model);
            const stride = getAttributeStride(vfmt);
            const gfxDevice = deviceManager.gfxDevice;
            const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
            const vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            vertexBuffer.update(vb);
            const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
            const ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
            indexBuffer.update(ib);
            this._maskModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            this._maskModelMesh.subMeshIdx = 0;
            this._maskClearModel.initSubModel(0, this._maskModelMesh, this._maskClearMtl);
          }
        }
        _insertMaskBatch(comp) {
          this.autoMergeBatches(this._currComponent);
          this.resetRenderStates();
          this._createClearModel();
          this._maskClearModel.node = this._maskClearModel.transform = comp.node;
          const _stencilManager = StencilManager.sharedManager;
          _stencilManager.pushMask(1);
          const stage = _stencilManager.clear(comp);
          let depthStencil;
          let dssHash = 0;
          const mat = this._maskClearMtl;
          if (mat) {
            depthStencil = _stencilManager.getStencilStage(stage, mat);
            dssHash = _stencilManager.getStencilHash(stage);
          }
          const model = this._maskClearModel;
          const stamp = legacyCC.director.getTotalFrames();
          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }
          for (let i = 0; i < model.subModels.length; i++) {
            const curDrawBatch = this._drawBatchPool.alloc();
            const subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;
            if (!depthStencil) {
              depthStencil = null;
            }
            curDrawBatch.fillPasses(mat, depthStencil, dssHash, subModel.patches);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;
            this._batches.push(curDrawBatch);
          }
          _stencilManager.enableMask();
        }
        syncMeshBuffersToNative(accId, buffers) {
          {
            const nativeBuffers = buffers.map(buf => buf.nativeObj);
            this._nativeObj.syncMeshBuffersToNative(accId, nativeBuffers);
          }
        }
      } exports('UI', Batcher2D);
      class LocalDescriptorSet {
        get descriptorSet() {
          return this._descriptorSet;
        }
        constructor() {
          this._descriptorSet = null;
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
          this._localBuffer = null;
          this._transformUpdate = true;
          const device = deviceManager.gfxDevice;
          this._localData = new Float32Array(UBOLocal.COUNT);
          this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
        }
        initialize(batch) {
          const device = deviceManager.gfxDevice;
          this._transform = batch.useLocalData;
          this._textureHash = batch.textureHash;
          this._samplerHash = batch.samplerHash;
          _dsInfo.layout = batch.passes[0].localSetLayout;
          this._descriptorSet = device.createDescriptorSet(_dsInfo);
          this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);
          const binding = ModelLocalBindings.SAMPLER_SPRITE;
          this._descriptorSet.bindTexture(binding, batch.texture);
          this._descriptorSet.bindSampler(binding, batch.sampler);
          this._descriptorSet.update();
          this._transformUpdate = true;
        }
        updateTransform(transform) {
          if (transform === this._transform) return;
          this._transform = transform;
          this._transformUpdate = true;
          this.uploadLocalData();
        }
        equals(transform, textureHash, samplerHash) {
          return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
        }
        reset() {
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
        }
        destroy() {
          if (this._localBuffer) {
            this._localBuffer.destroy();
            this._localBuffer = null;
          }
          if (this._descriptorSet) {
            this._descriptorSet.destroy();
            this._descriptorSet = null;
          }
          this._localData = null;
        }
        isValid() {
          return this._transform && this._transform.isValid;
        }
        uploadLocalData() {
          const node = this._transform;
          if (node.hasChangedFlags || node.isTransformDirty()) {
            node.updateWorldTransform();
            this._transformUpdate = true;
          }
          if (this._transformUpdate) {
            const worldMatrix = node.worldMatrix;
            Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
            Mat4.invert(m4_1$1, worldMatrix);
            Mat4.transpose(m4_1$1, m4_1$1);
            Mat4.toArray(this._localData, m4_1$1, UBOLocal.MAT_WORLD_IT_OFFSET);
            this._localBuffer.update(this._localData);
            this._transformUpdate = false;
          }
        }
      }
      class DescriptorSetCache {
        constructor() {
          this._descriptorSetCache = new Map();
          this._dsCacheHashByTexture = new Map();
          this._localDescriptorSetCache = [];
          this._localCachePool = void 0;
          this._localCachePool = new Pool(() => new LocalDescriptorSet(), 16, obj => obj.destroy());
        }
        getDescriptorSet(batch) {
          legacyCC.director.root;
          let hash;
          if (batch.useLocalData) {
            const caches = this._localDescriptorSetCache;
            for (let i = 0, len = caches.length; i < len; i++) {
              const cache = caches[i];
              if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                return cache.descriptorSet;
              }
            }
            const localDs = this._localCachePool.alloc();
            localDs.initialize(batch);
            this._localDescriptorSetCache.push(localDs);
            return localDs.descriptorSet;
          } else {
            hash = batch.textureHash ^ batch.samplerHash;
            if (this._descriptorSetCache.has(hash)) {
              return this._descriptorSetCache.get(hash);
            } else {
              _dsInfo.layout = batch.passes[0].localSetLayout;
              const descriptorSet = deviceManager.gfxDevice.createDescriptorSet(_dsInfo);
              const binding = ModelLocalBindings.SAMPLER_SPRITE;
              descriptorSet.bindTexture(binding, batch.texture);
              descriptorSet.bindSampler(binding, batch.sampler);
              descriptorSet.update();
              this._descriptorSetCache.set(hash, descriptorSet);
              this._dsCacheHashByTexture.set(batch.textureHash, hash);
              return descriptorSet;
            }
          }
        }
        update() {
          const caches = this._localDescriptorSetCache;
          const length = caches.length;
          if (length === 0) {
            return;
          }
          const uselessArray = [];
          for (let i = 0; i < length; i++) {
            const value = caches[i];
            if (value.isValid()) {
              value.uploadLocalData();
            } else {
              value.reset();
              const pos = caches.indexOf(value);
              uselessArray.push(pos);
            }
          }
          for (let i = uselessArray.length - 1; i >= 0; i--) {
            const index = uselessArray[i];
            const localDs = caches[index];
            caches.splice(index, 1);
            this._localCachePool.free(localDs);
          }
        }
        reset() {
          const caches = this._localDescriptorSetCache;
          const length = caches.length;
          for (let i = 0; i < length; i++) {
            const value = caches[i];
            this._localCachePool.free(value);
          }
          this._localDescriptorSetCache.length = 0;
        }
        releaseDescriptorSetCache(textureHash) {
          const key = this._dsCacheHashByTexture.get(textureHash);
          if (key && this._descriptorSetCache.has(key)) {
            this._descriptorSetCache.get(key).destroy();
            this._descriptorSetCache.delete(key);
            this._dsCacheHashByTexture.delete(textureHash);
          }
        }
        destroy() {
          for (const value of this._descriptorSetCache.values()) {
            value.destroy();
          }
          this._descriptorSetCache.clear();
          this._dsCacheHashByTexture.clear();
          this._localDescriptorSetCache.length = 0;
          this._localCachePool.destroy();
        }
      }
      legacyCC.internal.Batcher2D = Batcher2D;

      class UIDrawBatch extends DrawBatch2D {} exports('UIDrawBatch', UIDrawBatch);
      markAsWarning(MeshBuffer.prototype, 'MeshBuffer', ['byteStart', 'vertexStart', 'indicesStart', 'request'].map(item => ({
        name: item,
        suggest: `please use meshBuffer.accessor.${item} instead`
      })));
      replaceProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'indicesOffset',
        newName: 'indexOffset'
      }]);
      removeProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'vertexBuffers'
      }, {
        name: 'indexBuffer'
      }]);
      replaceProperty(Batcher2D.prototype, 'Batcher2D', [{
        name: 'currBufferBatch',
        newName: 'currBufferAccessor'
      }, {
        name: 'acquireBufferBatch',
        newName: 'switchBufferAccessor'
      }]);
      removeProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'formatByte'
      }, {
        name: 'byteStart'
      }, {
        name: 'byteCount'
      }]);
      replaceProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'indicesStart',
        newName: 'indexStart'
      }]);
      class QuadRenderData extends MeshRenderData {
        constructor(vertexFormat) {
          super(vertexFormat);
          warnID(9006);
        }
      } exports('QuadRenderData', QuadRenderData);

      legacyCC.UI = {
        MeshBuffer,
        spriteAssembler,
        graphicsAssembler: graphicsAssemblerManager,
        labelAssembler,
        RenderData,
        MeshRenderData
      };

      const SortingLayer = {
        default: 0
      };
      game.on(Game.EVENT_POST_SUBSYSTEM_INIT, () => {
        SortingLayers.init();
      });
      class SortingLayers {
        static getSortingPriority(layer = 0, order = 0) {
          return (layer + (1 << 15) << 16 | order + (1 << 15)) >>> 0;
        }
        static getLayerIndex(layer = 0) {
          let index = 0;
          if (this.indexMap.has(layer)) {
            index = this.indexMap.get(layer);
          } else {
            errorID(2105);
          }
          return index;
        }
        static getLayerIndexByName(name) {
          const id = this.getLayerByName(name);
          return this.getLayerIndex(id);
        }
        static getLayerName(layer = 0) {
          let name = '';
          if (this.nameMap.has(layer)) {
            name = this.nameMap.get(layer);
          } else {
            errorID(2105);
          }
          return name;
        }
        static getLayerByName(name) {
          const count = this.nameMap.size;
          const keyIterator = this.nameMap.keys();
          let key = 0;
          for (let i = 0; i < count; i++) {
            key = keyIterator.next().value;
            if (this.nameMap.get(key) === name) return key;
          }
          errorID(2106);
          return 0;
        }
        static isLayerValid(id) {
          if (this.indexMap.has(id)) {
            return true;
          } else {
            errorID(2105);
            return false;
          }
        }
        static getBuiltinLayers() {
          return [{
            id: 0,
            name: 'default',
            value: 0
          }];
        }
        static init() {
          let sortingLayers = settings.querySettings(Settings.Category.ENGINE, 'sortingLayers');
          if (!sortingLayers || sortingLayers.length === 0) {
            sortingLayers = this.getBuiltinLayers();
          }
          SortingLayers.resetState();
          for (let i = 0; i < sortingLayers.length; i++) {
            const layer = sortingLayers[i];
            SortingLayers.setLayer(layer.id, layer.name, layer.value);
            SortingLayers.Enum[layer.name] = layer.id;
          }
          Enum.update(SortingLayers.Enum);
          Enum.sortList(SortingLayers.Enum, (a, b) => SortingLayers.getLayerIndex(a.value) - SortingLayers.getLayerIndex(b.value));
        }
        static setLayer(layer, layerName, layerIndex) {
          this.nameMap.set(layer, layerName);
          this.indexMap.set(layer, layerIndex);
        }
        static resetState() {
          const oldItem = Object.keys(SortingLayers.Enum);
          for (let i = 0; i < oldItem.length; i++) {
            delete SortingLayers.Enum[SortingLayers.Enum[oldItem[i]]];
            delete SortingLayers.Enum[oldItem[i]];
          }
          SortingLayers.indexMap.clear();
          SortingLayers.nameMap.clear();
        }
      } exports('SortingLayers', SortingLayers);
      SortingLayers.nameMap = new Map();
      SortingLayers.indexMap = new Map();
      SortingLayers.Enum = Enum(SortingLayer);

      var _dec$18, _dec2$12, _class$16, _class2$15, _initializer$12, _initializer2$_;
      const MAX_INT16 = (1 << 15) - 1;
      const MIN_INT16 = -1 << 15;
      let Sorting = exports('Sorting', (_dec$18 = ccclass$6('cc.Sorting'), _dec2$12 = type$6(SortingLayers.Enum), _dec$18(_class$16 = disallowMultiple$1(_class$16 = (_class2$15 = class Sorting extends Component {
        constructor(...args) {
          super(...args);
          this._sortingLayer = _initializer$12 && _initializer$12();
          this._sortingOrder = _initializer2$_ && _initializer2$_();
          this._modelRenderer = null;
        }
        get sortingLayer() {
          return this._sortingLayer;
        }
        set sortingLayer(val) {
          if (val === this._sortingLayer || !SortingLayers.isLayerValid(val)) return;
          this._sortingLayer = val;
          this._updateSortingPriority();
        }
        get sortingOrder() {
          return this._sortingOrder;
        }
        set sortingOrder(val) {
          if (val === this._sortingOrder) return;
          this._sortingOrder = clamp$1(val, MIN_INT16, MAX_INT16);
          this._updateSortingPriority();
        }
        __preload() {
          this._modelRenderer = this.getComponent('cc.ModelRenderer');
          if (!this._modelRenderer) {
            warnID(16301, this.node.name);
          }
          this._updateSortingPriority();
        }
        _updateSortingPriority() {
          const sortingLayerValue = SortingLayers.getLayerIndex(this._sortingLayer);
          const sortingPriority = SortingLayers.getSortingPriority(sortingLayerValue, this._sortingOrder);
          if (this._modelRenderer && this._modelRenderer.isValid) {
            this._modelRenderer.priority = sortingPriority;
          }
        }
      }, (_applyDecoratedDescriptor(_class2$15.prototype, "sortingLayer", [_dec2$12], Object.getOwnPropertyDescriptor(_class2$15.prototype, "sortingLayer"), _class2$15.prototype), _initializer$12 = applyDecoratedInitializer(_class2$15.prototype, "_sortingLayer", [serializable$6], function () {
        return SortingLayers.Enum.default;
      }), _initializer2$_ = applyDecoratedInitializer(_class2$15.prototype, "_sortingOrder", [serializable$6], function () {
        return 0;
      })), _class2$15)) || _class$16) || _class$16));

      const Mesh = exports('Mesh', jsb.Mesh);
      const IStructProto = jsb.Mesh.IStruct.prototype;
      Object.defineProperty(IStructProto, 'minPosition', {
        configurable: true,
        enumerable: true,
        get() {
          const r = this.getMinPosition();
          if (r) {
            if (!this._minPositionCache) {
              this._minPositionCache = new Vec3(r.x, r.y, r.z);
            } else {
              this._minPositionCache.set(r.x, r.y, r.z);
            }
          } else {
            this._minPositionCache = undefined;
          }
          return this._minPositionCache;
        },
        set(v) {
          this.setMinPosition(v);
        }
      });
      Object.defineProperty(IStructProto, 'maxPosition', {
        configurable: true,
        enumerable: true,
        get() {
          const r = this.getMaxPosition();
          if (r) {
            if (!this._maxPositionCache) {
              this._maxPositionCache = new Vec3(r.x, r.y, r.z);
            } else {
              this._maxPositionCache.set(r.x, r.y, r.z);
            }
          } else {
            this._maxPositionCache = undefined;
          }
          return this._maxPositionCache;
        },
        set(v) {
          this.setMaxPosition(v);
        }
      });
      const meshAssetProto = jsb.Mesh.prototype;
      meshAssetProto.createNode = null;
      const originOnLoaded = meshAssetProto.onLoaded;
      meshAssetProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._struct = {
          vertexBundles: [],
          primitives: []
        };
        this._minPosition = undefined;
        this._maxPosition = undefined;
      };
      Object.defineProperty(meshAssetProto, 'struct', {
        configurable: true,
        enumerable: true,
        get() {
          return this.getStruct();
        }
      });
      Object.defineProperty(meshAssetProto, 'minPosition', {
        configurable: true,
        enumerable: true,
        get() {
          const r = this.getMinPosition();
          if (r) {
            if (!this._minPosition) {
              this._minPosition = new Vec3(r.x, r.y, r.z);
            } else {
              this._minPosition.set(r.x, r.y, r.z);
            }
          } else {
            this._minPosition = undefined;
          }
          return this._minPosition;
        }
      });
      Object.defineProperty(meshAssetProto, 'maxPosition', {
        configurable: true,
        enumerable: true,
        get() {
          const r = this.getMaxPosition();
          if (r) {
            if (!this._maxPosition) {
              this._maxPosition = new Vec3(r.x, r.y, r.z);
            } else {
              this._maxPosition.set(r.x, r.y, r.z);
            }
          } else {
            this._maxPosition = undefined;
          }
          return this._maxPosition;
        }
      });
      meshAssetProto.onLoaded = function () {
        const meshStruct = this._struct;
        if (meshStruct) {
          if (meshStruct.vertexBundles.length !== 0 || meshStruct.primitives.length !== 0) {
            this.setStruct(this._struct);
          }
        }
        this._struct = null;
        originOnLoaded.apply(this);
      };
      legacyCC.Mesh = jsb.Mesh;
      patch_cc_Mesh({
        Mesh
      });

      const MorphModel = jsb.MorphModel;
      legacyCC.MorphModel = jsb.MorphModel;

      let ReflectionProbeType; exports('ReflectionProbeType', ReflectionProbeType);
      (function (ReflectionProbeType) {
        ReflectionProbeType[ReflectionProbeType["NONE"] = 0] = "NONE";
        ReflectionProbeType[ReflectionProbeType["BAKED_CUBEMAP"] = 1] = "BAKED_CUBEMAP";
        ReflectionProbeType[ReflectionProbeType["PLANAR_REFLECTION"] = 2] = "PLANAR_REFLECTION";
        ReflectionProbeType[ReflectionProbeType["BLEND_PROBES"] = 3] = "BLEND_PROBES";
        ReflectionProbeType[ReflectionProbeType["BLEND_PROBES_AND_SKYBOX"] = 4] = "BLEND_PROBES_AND_SKYBOX";
      })(ReflectionProbeType || (exports('ReflectionProbeType', ReflectionProbeType = {})));

      var _dec$17, _dec2$11, _dec3$Q, _dec4$I, _dec5$E, _dec6$r, _dec7$l, _class$15, _class2$14, _initializer$11, _initializer2$Z, _initializer3$M, _initializer4$G, _initializer5$z, _initializer6$r, _initializer7$o, _initializer8$m, _initializer9$j, _initializer10$g, _class3$q, _dec8$h, _dec9$f, _dec10$a, _dec11$7, _dec12$7, _dec13$6, _dec14$5, _dec15$4, _class4$5, _class5$7, _initializer11$f, _initializer12$c, _initializer13$b, _initializer14$8, _initializer15$6, _initializer16$6, _initializer17$5, _initializer18$5, _initializer19$4, _initializer20$2, _initializer21$2, _class6$1;
      const {
        ccclass: ccclass$3,
        help: help$2,
        executeInEditMode: executeInEditMode$2,
        executionOrder,
        menu: menu$2,
        visible: visible$3,
        type: type$3,
        formerlySerializedAs: formerlySerializedAs$2,
        serializable: serializable$3,
        editable: editable$2,
        disallowAnimation
      } = _decorator;
      let _phaseID = getPhaseID('specular-pass');
      function getSkinPassIndex(subModel) {
        const passes = subModel.passes;
        const r = legacyCC.rendering;
        if (isEnableEffect()) _phaseID = r.getPhaseID(r.getPassID('specular-pass'), 'default');
        for (let k = 0; k < passes.length; k++) {
          if ((!r || !r.enableEffectImport) && passes[k].phase === _phaseID || isEnableEffect() && passes[k].phaseID === _phaseID) {
            return k;
          }
        }
        return -1;
      }
      const ModelShadowCastingMode = Enum({
        OFF: 0,
        ON: 1
      });
      const ModelShadowReceivingMode = Enum({
        OFF: 0,
        ON: 1
      });
      let ModelBakeSettings = (_dec$17 = ccclass$3('cc.ModelBakeSettings'), _dec2$11 = formerlySerializedAs$2('_recieveShadow'), _dec3$Q = type$3(CCInteger), _dec4$I = type$3(CCBoolean), _dec5$E = type$3(CCBoolean), _dec6$r = type$3(Enum(ReflectionProbeType)), _dec7$l = type$3(CCBoolean), _dec$17(_class$15 = (_class2$14 = (_class3$q = class ModelBakeSettings extends EventTarget {
        constructor(...args) {
          super(...args);
          this.texture = _initializer$11 && _initializer$11();
          this.uvParam = _initializer2$Z && _initializer2$Z();
          this._bakeable = _initializer3$M && _initializer3$M();
          this._castShadow = _initializer4$G && _initializer4$G();
          this._receiveShadow = _initializer5$z && _initializer5$z();
          this._lightmapSize = _initializer6$r && _initializer6$r();
          this._useLightProbe = _initializer7$o && _initializer7$o();
          this._bakeToLightProbe = _initializer8$m && _initializer8$m();
          this._reflectionProbeType = _initializer9$j && _initializer9$j();
          this._bakeToReflectionProbe = _initializer10$g && _initializer10$g();
          this.probeCubemap = null;
          this.probeBlendCubemap = null;
          this.probePlanarmap = null;
        }
        get bakeable() {
          return this._bakeable;
        }
        set bakeable(val) {
          this._bakeable = val;
        }
        get castShadow() {
          return this._castShadow;
        }
        set castShadow(val) {
          this._castShadow = val;
        }
        get receiveShadow() {
          return this._receiveShadow;
        }
        set receiveShadow(val) {
          this._receiveShadow = val;
        }
        get lightmapSize() {
          return this._lightmapSize;
        }
        set lightmapSize(val) {
          this._lightmapSize = val;
        }
        get useLightProbe() {
          return this._useLightProbe;
        }
        set useLightProbe(val) {
          this._useLightProbe = val;
          this.emit(ModelBakeSettings.USE_LIGHT_PROBE_CHANGED);
        }
        get bakeToLightProbe() {
          return this._bakeToLightProbe;
        }
        set bakeToLightProbe(val) {
          this._bakeToLightProbe = val;
        }
        get reflectionProbe() {
          return this._reflectionProbeType;
        }
        set reflectionProbe(val) {
          this._reflectionProbeType = val;
          this.emit(ModelBakeSettings.REFLECTION_PROBE_CHANGED);
        }
        get bakeToReflectionProbe() {
          return this._bakeToReflectionProbe;
        }
        set bakeToReflectionProbe(val) {
          this._bakeToReflectionProbe = val;
          this.emit(ModelBakeSettings.BAKE_TO_REFLECTION_PROBE_CHANGED);
        }
      }, _class3$q.USE_LIGHT_PROBE_CHANGED = 'use_light_probe_changed', _class3$q.REFLECTION_PROBE_CHANGED = 'reflection_probe_changed', _class3$q.BAKE_TO_REFLECTION_PROBE_CHANGED = 'bake_to_reflection_probe_changed', _class3$q), (_initializer$11 = applyDecoratedInitializer(_class2$14.prototype, "texture", [serializable$3], function () {
        return null;
      }), _initializer2$Z = applyDecoratedInitializer(_class2$14.prototype, "uvParam", [serializable$3], function () {
        return new Vec4();
      }), _initializer3$M = applyDecoratedInitializer(_class2$14.prototype, "_bakeable", [serializable$3], function () {
        return false;
      }), _initializer4$G = applyDecoratedInitializer(_class2$14.prototype, "_castShadow", [serializable$3], function () {
        return false;
      }), _initializer5$z = applyDecoratedInitializer(_class2$14.prototype, "_receiveShadow", [_dec2$11], function () {
        return false;
      }), _initializer6$r = applyDecoratedInitializer(_class2$14.prototype, "_lightmapSize", [serializable$3], function () {
        return 64;
      }), _initializer7$o = applyDecoratedInitializer(_class2$14.prototype, "_useLightProbe", [serializable$3], function () {
        return false;
      }), _initializer8$m = applyDecoratedInitializer(_class2$14.prototype, "_bakeToLightProbe", [serializable$3], function () {
        return true;
      }), _initializer9$j = applyDecoratedInitializer(_class2$14.prototype, "_reflectionProbeType", [serializable$3], function () {
        return ReflectionProbeType.NONE;
      }), _initializer10$g = applyDecoratedInitializer(_class2$14.prototype, "_bakeToReflectionProbe", [serializable$3], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$14.prototype, "lightmapSize", [_dec3$Q], Object.getOwnPropertyDescriptor(_class2$14.prototype, "lightmapSize"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "useLightProbe", [_dec4$I], Object.getOwnPropertyDescriptor(_class2$14.prototype, "useLightProbe"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "bakeToLightProbe", [_dec5$E], Object.getOwnPropertyDescriptor(_class2$14.prototype, "bakeToLightProbe"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "reflectionProbe", [_dec6$r], Object.getOwnPropertyDescriptor(_class2$14.prototype, "reflectionProbe"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "bakeToReflectionProbe", [_dec7$l], Object.getOwnPropertyDescriptor(_class2$14.prototype, "bakeToReflectionProbe"), _class2$14.prototype)), _class2$14)) || _class$15);
      let MeshRenderer = (_dec8$h = ccclass$3('cc.MeshRenderer'), _dec9$f = executionOrder(100), _dec10$a = type$3(CCFloat), _dec11$7 = type$3(CCFloat), _dec12$7 = type$3(ModelShadowCastingMode), _dec13$6 = type$3(ModelShadowReceivingMode), _dec14$5 = type$3(Mesh), _dec15$4 = type$3(CCBoolean), _dec8$h(_class4$5 = _dec9$f(_class4$5 = (_class5$7 = (_class6$1 = class MeshRenderer extends ModelRenderer {
        get shadowBias() {
          return this._shadowBias;
        }
        set shadowBias(val) {
          this._shadowBias = val;
          this._updateShadowBias();
          this._onUpdateLocalShadowBiasAndProbeId();
        }
        get shadowNormalBias() {
          return this._shadowNormalBias;
        }
        set shadowNormalBias(val) {
          this._shadowNormalBias = val;
          this._updateShadowNormalBias();
          this._onUpdateLocalShadowBiasAndProbeId();
        }
        get shadowCastingMode() {
          return this._shadowCastingMode;
        }
        set shadowCastingMode(val) {
          this._shadowCastingMode = val;
          this._updateCastShadow();
        }
        get shadowCastingModeForInspector() {
          return this.shadowCastingMode === ModelShadowCastingMode.ON;
        }
        set shadowCastingModeForInspector(val) {
          this.shadowCastingMode = val === true ? ModelShadowCastingMode.ON : ModelShadowCastingMode.OFF;
        }
        onUpdateReceiveDirLight(visibility, forceClose = false) {
          if (!this._model) {
            return;
          }
          if (forceClose) {
            this._model.receiveDirLight = false;
            return;
          }
          if (this.node && (visibility & this.node.layer) === this.node.layer || visibility & this._model.visFlags) {
            this._model.receiveDirLight = true;
          } else {
            this._model.receiveDirLight = false;
          }
        }
        get receiveShadow() {
          return this._shadowReceivingMode;
        }
        set receiveShadow(val) {
          this._shadowReceivingMode = val;
          this._updateReceiveShadow();
        }
        get receiveShadowForInspector() {
          return this._shadowReceivingMode === ModelShadowReceivingMode.ON;
        }
        set receiveShadowForInspector(val) {
          this._shadowReceivingMode = val === true ? ModelShadowReceivingMode.ON : ModelShadowReceivingMode.OFF;
          this._updateReceiveShadow();
        }
        get mesh() {
          return this._mesh;
        }
        set mesh(val) {
          const old = this._mesh;
          const mesh = this._mesh = val;
          mesh === null || mesh === void 0 ? void 0 : mesh.initialize();
          this._initSubMeshShapesWeights();
          this._watchMorphInMesh();
          this._onMeshChanged(old);
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
          this._updateCastShadow();
          this._updateReceiveShadow();
          this._updateUseLightProbe();
          this._updateUseReflectionProbe();
          this._updateReceiveDirLight();
        }
        get model() {
          return this._model;
        }
        get enableMorph() {
          return this._enableMorph;
        }
        set enableMorph(value) {
          this._enableMorph = value;
        }
        get isGlobalStandardSkinObject() {
          return this._enabledGlobalStandardSkinObject;
        }
        set isGlobalStandardSkinObject(val) {
          legacyCC.director.root.pipeline.pipelineSceneData.standardSkinMeshRenderer = val ? this : null;
          this._enabledGlobalStandardSkinObject = val;
        }
        clearGlobalStandardSkinObjectFlag() {
          this._enabledGlobalStandardSkinObject = false;
        }
        constructor() {
          super();
          this.bakeSettings = _initializer11$f && _initializer11$f();
          this._mesh = _initializer12$c && _initializer12$c();
          this._shadowCastingMode = _initializer13$b && _initializer13$b();
          this._shadowReceivingMode = _initializer14$8 && _initializer14$8();
          this._shadowBias = _initializer15$6 && _initializer15$6();
          this._shadowNormalBias = _initializer16$6 && _initializer16$6();
          this._reflectionProbeId = _initializer17$5 && _initializer17$5();
          this._reflectionProbeBlendId = _initializer18$5 && _initializer18$5();
          this._reflectionProbeBlendWeight = _initializer19$4 && _initializer19$4();
          this._enabledGlobalStandardSkinObject = _initializer20$2 && _initializer20$2();
          this._reflectionProbeDataMap = null;
          this._subMeshShapesWeights = [];
          this._modelType = void 0;
          this._model = null;
          this._morphInstance = null;
          this._enableMorph = _initializer21$2 && _initializer21$2();
          this._modelType = Model;
          const highQualityMode = settings.querySettings(Settings.Category.RENDERING, 'highQualityMode');
          if (highQualityMode) {
            this._shadowCastingMode = ModelShadowCastingMode.ON;
            this.bakeSettings.castShadow = true;
            this.bakeSettings.receiveShadow = true;
          }
        }
        onLoad() {
          if (this._mesh) {
            this._mesh.initialize();
          }
          if (!this._validateShapeWeights()) {
            this._initSubMeshShapesWeights();
          }
          this._watchMorphInMesh();
          this._updateModels();
          this._updateCastShadow();
          this._updateReceiveShadow();
          this._updateShadowBias();
          this._updateShadowNormalBias();
          this._updateUseLightProbe();
          this._updateBakeToReflectionProbe();
          this._updateUseReflectionProbe();
          this._updateReceiveDirLight();
          this._updateStandardSkin();
        }
        onRestore() {
          this._updateModels();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
          this._updateCastShadow();
          this._updateReceiveShadow();
          this._updateShadowBias();
          this._updateShadowNormalBias();
          this._updateUseLightProbe();
          this._updateBakeToReflectionProbe();
          this._updateUseReflectionProbe();
          this._updateReceiveDirLight();
          this._updateStandardSkin();
        }
        onEnable() {
          super.onEnable();
          this.node.on(NodeEventType.MOBILITY_CHANGED, this.onMobilityChanged, this);
          this.node.on(NodeEventType.LIGHT_PROBE_BAKING_CHANGED, this.onLightProbeBakingChanged, this);
          this.bakeSettings.on(ModelBakeSettings.USE_LIGHT_PROBE_CHANGED, this.onUseLightProbeChanged, this);
          this.bakeSettings.on(ModelBakeSettings.REFLECTION_PROBE_CHANGED, this.onReflectionProbeChanged, this);
          this.bakeSettings.on(ModelBakeSettings.BAKE_TO_REFLECTION_PROBE_CHANGED, this.onBakeToReflectionProbeChanged, this);
          if (!this._model) {
            this._updateModels();
          }
          this._model.onGlobalPipelineStateChanged();
          this._updateCastShadow();
          this._updateReceiveShadow();
          this._updateShadowBias();
          this._updateShadowNormalBias();
          this._updateBakeToReflectionProbe();
          this._updateUseReflectionProbe();
          this._onUpdateLocalShadowBiasAndProbeId();
          this._updateUseLightProbe();
          this._updateReceiveDirLight();
          this._onUpdateReflectionProbeDataMap();
          this._onUpdateLocalReflectionProbeData();
          this._updateStandardSkin();
          this._attachToScene();
        }
        onDisable() {
          if (this._model) {
            this._detachFromScene();
          }
          this.node.off(NodeEventType.MOBILITY_CHANGED, this.onMobilityChanged, this);
          this.node.off(NodeEventType.LIGHT_PROBE_BAKING_CHANGED, this.onLightProbeBakingChanged, this);
          this.bakeSettings.off(ModelBakeSettings.USE_LIGHT_PROBE_CHANGED, this.onUseLightProbeChanged, this);
          this.bakeSettings.off(ModelBakeSettings.REFLECTION_PROBE_CHANGED, this.onReflectionProbeChanged, this);
          this.bakeSettings.off(ModelBakeSettings.BAKE_TO_REFLECTION_PROBE_CHANGED, this.onBakeToReflectionProbeChanged, this);
        }
        onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
          }
          if (this._morphInstance) {
            this._morphInstance.destroy();
          }
        }
        onGeometryChanged() {
          if (this._model && this._mesh) {
            const meshStruct = this._mesh.struct;
            this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);
            this._model.updateWorldBound();
            this._model.onGeometryChanged();
          }
        }
        getWeight(subMeshIndex, shapeIndex) {
          const {
            _subMeshShapesWeights: subMeshShapesWeights
          } = this;
          assertIsTrue(subMeshIndex < subMeshShapesWeights.length);
          const shapeWeights = this._subMeshShapesWeights[subMeshIndex];
          assertIsTrue(shapeIndex < shapeWeights.length);
          return shapeWeights[shapeIndex];
        }
        setWeights(weights, subMeshIndex) {
          const {
            _subMeshShapesWeights: subMeshShapesWeights
          } = this;
          if (subMeshIndex >= subMeshShapesWeights.length) {
            return;
          }
          const shapeWeights = subMeshShapesWeights[subMeshIndex];
          if (shapeWeights.length !== weights.length) {
            return;
          }
          subMeshShapesWeights[subMeshIndex] = weights.slice(0);
          this._uploadSubMeshShapesWeights(subMeshIndex);
        }
        setWeight(weight, subMeshIndex, shapeIndex) {
          const {
            _subMeshShapesWeights: subMeshShapesWeights
          } = this;
          if (subMeshIndex >= subMeshShapesWeights.length) {
            return;
          }
          const shapeWeights = subMeshShapesWeights[subMeshIndex];
          if (shapeIndex >= shapeWeights.length) {
            return;
          }
          shapeWeights[shapeIndex] = weight;
          this._uploadSubMeshShapesWeights(subMeshIndex);
        }
        setInstancedAttribute(name, value) {
          if (!this.model) {
            return;
          }
          {
            this.model._setInstancedAttribute(name, value);
          }
        }
        _updateLightmap(lightmap, uOff, vOff, scale, lum) {
          this.bakeSettings.texture = lightmap;
          this.bakeSettings.uvParam.x = uOff;
          this.bakeSettings.uvParam.y = vOff;
          this.bakeSettings.uvParam.z = scale;
          this.bakeSettings.uvParam.w = lum;
          this._onUpdateLightingmap();
          this._updateReceiveDirLight();
        }
        updateProbeCubemap(cubeMap) {
          if (this.bakeSettings.probeCubemap && this.bakeSettings.probeCubemap === cubeMap) {
            return;
          }
          this.bakeSettings.probeCubemap = cubeMap;
          if (this.model !== null) {
            this.model.updateReflectionProbeCubemap(this.bakeSettings.probeCubemap);
          }
        }
        updateProbeBlendCubemap(cubeMap) {
          if (this.bakeSettings.probeBlendCubemap && this.bakeSettings.probeBlendCubemap === cubeMap) {
            return;
          }
          this.bakeSettings.probeBlendCubemap = cubeMap;
          if (this.model !== null) {
            this.model.updateReflectionProbeBlendCubemap(this.bakeSettings.probeBlendCubemap);
          }
        }
        updateProbePlanarMap(planarMap) {
          if (this.bakeSettings.probePlanarmap === planarMap) {
            return;
          }
          this.bakeSettings.probePlanarmap = planarMap;
          if (this.model !== null) {
            this.model.updateReflectionProbePlanarMap(this.bakeSettings.probePlanarmap);
          }
        }
        updateReflectionProbeDataMap(dataMap) {
          this._reflectionProbeDataMap = dataMap;
          if (this.model !== null) {
            this.model.updateReflectionProbeDataMap(dataMap);
          }
        }
        updateReflectionProbeId(probeId) {
          this._reflectionProbeId = probeId;
          if (this.model) {
            this.model.reflectionProbeId = probeId;
          }
          this._onUpdateLocalShadowBiasAndProbeId();
        }
        updateReflectionProbeBlendId(blendProbeId) {
          this._reflectionProbeBlendId = blendProbeId;
          if (this.model) {
            this.model.reflectionProbeBlendId = blendProbeId;
          }
          this._onUpdateLocalShadowBiasAndProbeId();
        }
        updateReflectionProbeBlendWeight(weight) {
          this._reflectionProbeBlendWeight = weight;
          if (this.model) {
            this.model.reflectionProbeBlendWeight = weight;
          }
          this._onUpdateLocalReflectionProbeData();
        }
        _updateReflectionProbeTexture() {
          if (!this.model) return;
          const bakeSettings = this.bakeSettings;
          const reflectionProbe = bakeSettings.reflectionProbe;
          const probeBlendCubemap = bakeSettings.probeBlendCubemap;
          const probePlanarMap = bakeSettings.probePlanarmap;
          const probeCubeMap = bakeSettings.probeCubemap;
          if (reflectionProbe === ReflectionProbeType.BAKED_CUBEMAP) {
            this.model.updateReflectionProbeCubemap(probeCubeMap);
            this.model.updateReflectionProbePlanarMap(null);
            this.model.updateReflectionProbeBlendCubemap(null);
          } else if (reflectionProbe === ReflectionProbeType.BLEND_PROBES || reflectionProbe === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
            this.model.updateReflectionProbeCubemap(probeCubeMap);
            this.model.updateReflectionProbeBlendCubemap(probeBlendCubemap);
            this.model.updateReflectionProbePlanarMap(null);
          } else if (reflectionProbe === ReflectionProbeType.PLANAR_REFLECTION) {
            this.model.updateReflectionProbePlanarMap(probePlanarMap);
            this.model.updateReflectionProbeCubemap(null);
            this.model.updateReflectionProbeBlendCubemap(null);
          } else {
            this.model.updateReflectionProbeCubemap(null);
            this.model.updateReflectionProbePlanarMap(null);
            this.model.updateReflectionProbeBlendCubemap(null);
          }
        }
        _updateModels() {
          if (!this.enabledInHierarchy) {
            return;
          }
          const model = this._model;
          if (model) {
            model.destroy();
            model.initialize();
            model.node = model.transform = this.node;
          } else {
            this._createModel();
          }
          if (this._model) {
            if (this._mesh) {
              const meshStruct = this._mesh.struct;
              this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);
              this._model.updateWorldBound();
            }
            this._model.initLightingmap(this.bakeSettings.texture, this.bakeSettings.uvParam);
            this._updateUseLightProbe();
            this._updateUseReflectionProbeType();
            this._updateModelParams();
            this._onUpdateLightingmap();
            this._onUpdateLocalShadowBiasAndProbeId();
            this._updateUseReflectionProbe();
            this._updateReceiveDirLight();
            this._onUpdateReflectionProbeDataMap();
            this._onUpdateLocalReflectionProbeData();
          }
        }
        _updateReceiveDirLight() {
          if (!this._model) {
            return;
          }
          const scene = this.node.scene;
          if (!scene || !scene.renderScene) {
            return;
          }
          const mainLight = scene.renderScene.mainLight;
          if (!mainLight) {
            return;
          }
          const visibility = mainLight.visibility;
          if (!mainLight.node) {
            return;
          }
          if (mainLight.node.mobility === MobilityMode.Static) {
            let forceClose = false;
            if (this.bakeSettings.texture && !this.node.scene.globals.disableLightmap) {
              forceClose = true;
            }
            if (this.node.scene.globals.lightProbeInfo.data && this.node.scene.globals.lightProbeInfo.data.hasCoefficients() && this._model.useLightProbe) {
              forceClose = true;
            }
            this.onUpdateReceiveDirLight(visibility, forceClose);
          } else {
            this.onUpdateReceiveDirLight(visibility);
          }
        }
        _createModel() {
          const preferMorphOverPlain = !!this._morphInstance;
          const modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
          const model = this._model = legacyCC.director.root.createModel(modelType);
          model.visFlags = this.visibility;
          model.node = model.transform = this.node;
          this._models.length = 0;
          this._models.push(this._model);
          if (this._morphInstance && model instanceof MorphModel) {
            model.setMorphRendering(this._morphInstance);
          }
        }
        _attachToScene() {
          if (!this.node.scene || !this._model) {
            return;
          }
          const renderScene = this._getRenderScene();
          if (this._model.scene !== null) {
            this._detachFromScene();
          }
          renderScene.addModel(this._model);
        }
        _detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        }
        _updateModelParams() {
          if (!this._mesh || !this._model) {
            return;
          }
          this.node.hasChangedFlags |= TransformBit.POSITION;
          this._model.transform.hasChangedFlags |= TransformBit.POSITION;
          this._model.isDynamicBatching = this._isBatchingEnabled();
          const meshCount = this._mesh ? this._mesh.renderingSubMeshes.length : 0;
          const renderingMesh = this._mesh.renderingSubMeshes;
          if (renderingMesh) {
            for (let i = 0; i < meshCount; ++i) {
              let material = this.getRenderMaterial(i);
              if (material && !material.isValid) {
                material = null;
              }
              const subMeshData = renderingMesh[i];
              if (subMeshData) {
                this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
              }
            }
          }
          this._model.enabled = true;
        }
        _onUpdateLightingmap() {
          if (this.model !== null) {
            this.model.updateLightingmap(this.bakeSettings.texture, this.bakeSettings.uvParam);
          }
          this.setInstancedAttribute('a_lightingMapUVParam', [this.bakeSettings.uvParam.x, this.bakeSettings.uvParam.y, this.bakeSettings.uvParam.z, this.bakeSettings.uvParam.w]);
        }
        _onUpdateLocalShadowBiasAndProbeId() {
          if (this.model !== null) {
            this.model.updateLocalShadowBias();
            this.model.updateReflectionProbeId();
          }
          this.setInstancedAttribute('a_localShadowBiasAndProbeId', [this._shadowBias, this._shadowNormalBias, this._reflectionProbeId, this._reflectionProbeBlendId]);
        }
        _onUpdateLocalReflectionProbeData() {
          if (this.bakeSettings.reflectionProbe === ReflectionProbeType.BAKED_CUBEMAP || this.bakeSettings.reflectionProbe === ReflectionProbeType.BLEND_PROBES || this.bakeSettings.reflectionProbe === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
            if (this.model !== null) {
              this.model.updateReflectionProbeId();
            }
            this.setInstancedAttribute('a_reflectionProbeData', [this._reflectionProbeBlendWeight, 0.0, 0.0, 0.0]);
          }
        }
        _onUpdateReflectionProbeDataMap() {
          if (this.model !== null) {
            this.model.updateReflectionProbeDataMap(this._reflectionProbeDataMap);
          }
        }
        _onMaterialModified(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }
          this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
          this._updateStandardSkin();
        }
        _onRebuildPSO(idx, material) {
          if (!this._model || !this._model.inited) {
            return;
          }
          this._model.isDynamicBatching = this._isBatchingEnabled();
          this._model.setSubModelMaterial(idx, material);
          this._onUpdateLightingmap();
          this._onUpdateLocalShadowBiasAndProbeId();
          this._updateReflectionProbeTexture();
          this._onUpdateReflectionProbeDataMap();
          this._onUpdateLocalReflectionProbeData();
        }
        _onMeshChanged(old) {}
        _clearMaterials() {
          if (!this._model) {
            return;
          }
          const subModels = this._model.subModels;
          for (let i = 0; i < subModels.length; ++i) {
            this._onMaterialModified(i, null);
          }
        }
        _getBuiltinMaterial() {
          return builtinResMgr.get('missing-material');
        }
        _onVisibilityChange(val) {
          if (!this._model) {
            return;
          }
          this._model.visFlags = val;
        }
        _updateShadowBias() {
          if (!this._model) {
            return;
          }
          this._model.shadowBias = this._shadowBias;
        }
        _updateShadowNormalBias() {
          if (!this._model) {
            return;
          }
          this._model.shadowNormalBias = this._shadowNormalBias;
        }
        _updateCastShadow() {
          if (!this._model) {
            return;
          }
          if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
            this._model.castShadow = false;
          } else {
            assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, `ShadowCastingMode ${this._shadowCastingMode} is not supported.`);
            this._model.castShadow = true;
          }
        }
        _updateReceiveShadow() {
          if (!this._model) {
            return;
          }
          if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
            this._model.receiveShadow = false;
          } else {
            this._model.receiveShadow = true;
          }
        }
        onMobilityChanged() {
          this._updateUseLightProbe();
          this._updateReceiveDirLight();
        }
        onLightProbeBakingChanged() {
          this._updateReceiveDirLight();
        }
        onUseLightProbeChanged() {
          this._updateUseLightProbe();
        }
        onReflectionProbeChanged() {
          this._updateUseReflectionProbe();
          this._onUpdateLocalShadowBiasAndProbeId();
          if (this.bakeSettings.reflectionProbe === ReflectionProbeType.BAKED_CUBEMAP || this.bakeSettings.reflectionProbe === ReflectionProbeType.BLEND_PROBES || this.bakeSettings.reflectionProbe === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
            legacyCC.internal.reflectionProbeManager.selectReflectionProbe(this._model);
            if (!legacyCC.internal.reflectionProbeManager.getUsedReflectionProbe(this._model, false)) {
              warnID(16302);
            }
          } else if (this.bakeSettings.reflectionProbe === ReflectionProbeType.PLANAR_REFLECTION) {
            legacyCC.internal.reflectionProbeManager.selectPlanarReflectionProbe(this._model);
            if (!legacyCC.internal.reflectionProbeManager.getUsedReflectionProbe(this._model, true)) {
              warnID(16302);
            }
          }
        }
        onBakeToReflectionProbeChanged() {
          this._updateBakeToReflectionProbe();
        }
        _updateUseLightProbe() {
          if (!this._model) {
            return;
          }
          const node = this.node;
          if (this._mesh && node && node.mobility === MobilityMode.Movable && this.bakeSettings.useLightProbe) {
            this._model.useLightProbe = true;
          } else {
            this._model.useLightProbe = false;
          }
        }
        _isBatchingEnabled() {
          for (let i = 0; i < this._materials.length; ++i) {
            const mat = this._materials[i];
            if (!mat) {
              continue;
            }
            for (let p = 0; p < mat.passes.length; ++p) {
              const pass = mat.passes[p];
              if (pass.batchingScheme) {
                return true;
              }
            }
          }
          return false;
        }
        _updateUseReflectionProbe() {
          if (!this._model) return;
          this._model.reflectionProbeType = this.bakeSettings.reflectionProbe;
          this._updateReflectionProbeTexture();
        }
        _updateUseReflectionProbeType() {
          if (!this._model) return;
          this._model.reflectionProbeType = this.bakeSettings.reflectionProbe;
        }
        _updateBakeToReflectionProbe() {
          if (!this._model) {
            return;
          }
          this._model.bakeToReflectionProbe = this.bakeSettings.bakeToReflectionProbe;
        }
        _watchMorphInMesh() {
          if (this._morphInstance) {
            this._morphInstance.destroy();
            this._morphInstance = null;
          }
          if (!this._enableMorph) {
            return;
          }
          if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
            return;
          }
          this._morphInstance = this._mesh.morphRendering.createInstance();
          const nSubMeshes = this._mesh.struct.primitives.length;
          for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
            this._uploadSubMeshShapesWeights(iSubMesh);
          }
          if (this._model && this._model instanceof MorphModel) {
            this._model.setMorphRendering(this._morphInstance);
          }
        }
        _initSubMeshShapesWeights() {
          const {
            _mesh: mesh
          } = this;
          this._subMeshShapesWeights.length = 0;
          if (!mesh) {
            return;
          }
          const morph = mesh.struct.morph;
          if (!morph) {
            return;
          }
          const commonWeights = morph.weights;
          this._subMeshShapesWeights = morph.subMeshMorphs.map(subMeshMorph => {
            if (!subMeshMorph) {
              return [];
            } else if (subMeshMorph.weights) {
              return subMeshMorph.weights.slice(0);
            } else if (commonWeights) {
              assertIsTrue(commonWeights.length === subMeshMorph.targets.length);
              return commonWeights.slice(0);
            } else {
              return new Array(subMeshMorph.targets.length).fill(0.0);
            }
          });
        }
        _validateShapeWeights() {
          const {
            _mesh: mesh,
            _subMeshShapesWeights: subMeshShapesWeights
          } = this;
          if (!mesh || !mesh.struct.morph) {
            return subMeshShapesWeights.length === 0;
          }
          const {
            morph
          } = mesh.struct;
          if (morph.subMeshMorphs.length !== subMeshShapesWeights.length) {
            return false;
          }
          return subMeshShapesWeights.every(({
            length: shapeCount
          }, subMeshIndex) => {
            var _morph$subMeshMorphs$, _morph$subMeshMorphs$2;
            return ((_morph$subMeshMorphs$ = (_morph$subMeshMorphs$2 = morph.subMeshMorphs[subMeshIndex]) === null || _morph$subMeshMorphs$2 === void 0 ? void 0 : _morph$subMeshMorphs$2.targets.length) !== null && _morph$subMeshMorphs$ !== void 0 ? _morph$subMeshMorphs$ : 0) === shapeCount;
          });
        }
        _uploadSubMeshShapesWeights(subMeshIndex) {
          var _this$_morphInstance;
          (_this$_morphInstance = this._morphInstance) === null || _this$_morphInstance === void 0 ? void 0 : _this$_morphInstance.setWeights(subMeshIndex, this._subMeshShapesWeights[subMeshIndex]);
        }
        _updateStandardSkin() {
          const pipelineSceneData = legacyCC.director.root.pipeline.pipelineSceneData;
          if (this._enabledGlobalStandardSkinObject) {
            pipelineSceneData.standardSkinMeshRenderer = this;
            pipelineSceneData.standardSkinModel = this.model;
          }
          if (!pipelineSceneData.skinMaterialModel && this._model) {
            const subModels = this._model.subModels;
            for (let j = 0; j < subModels.length; j++) {
              const subModel = subModels[j];
              const skinPassIdx = getSkinPassIndex(subModel);
              if (skinPassIdx < 0) {
                continue;
              }
              pipelineSceneData.skinMaterialModel = this._model;
              return;
            }
          }
        }
      }, _class6$1.ShadowCastingMode = ModelShadowCastingMode, _class6$1.ShadowReceivingMode = ModelShadowReceivingMode, _class6$1), (_initializer11$f = applyDecoratedInitializer(_class5$7.prototype, "bakeSettings", [serializable$3], function () {
        return new ModelBakeSettings(this);
      }), _initializer12$c = applyDecoratedInitializer(_class5$7.prototype, "_mesh", [serializable$3], function () {
        return null;
      }), _initializer13$b = applyDecoratedInitializer(_class5$7.prototype, "_shadowCastingMode", [serializable$3], function () {
        return ModelShadowCastingMode.OFF;
      }), _initializer14$8 = applyDecoratedInitializer(_class5$7.prototype, "_shadowReceivingMode", [serializable$3], function () {
        return ModelShadowReceivingMode.ON;
      }), _initializer15$6 = applyDecoratedInitializer(_class5$7.prototype, "_shadowBias", [serializable$3], function () {
        return 0;
      }), _initializer16$6 = applyDecoratedInitializer(_class5$7.prototype, "_shadowNormalBias", [serializable$3], function () {
        return 0;
      }), _initializer17$5 = applyDecoratedInitializer(_class5$7.prototype, "_reflectionProbeId", [serializable$3], function () {
        return -1;
      }), _initializer18$5 = applyDecoratedInitializer(_class5$7.prototype, "_reflectionProbeBlendId", [serializable$3], function () {
        return -1;
      }), _initializer19$4 = applyDecoratedInitializer(_class5$7.prototype, "_reflectionProbeBlendWeight", [serializable$3], function () {
        return 0;
      }), _initializer20$2 = applyDecoratedInitializer(_class5$7.prototype, "_enabledGlobalStandardSkinObject", [serializable$3], function () {
        return false;
      }), _applyDecoratedDescriptor(_class5$7.prototype, "shadowBias", [_dec10$a], Object.getOwnPropertyDescriptor(_class5$7.prototype, "shadowBias"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "shadowNormalBias", [_dec11$7], Object.getOwnPropertyDescriptor(_class5$7.prototype, "shadowNormalBias"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "shadowCastingMode", [_dec12$7], Object.getOwnPropertyDescriptor(_class5$7.prototype, "shadowCastingMode"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "receiveShadow", [_dec13$6], Object.getOwnPropertyDescriptor(_class5$7.prototype, "receiveShadow"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "mesh", [_dec14$5], Object.getOwnPropertyDescriptor(_class5$7.prototype, "mesh"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "isGlobalStandardSkinObject", [_dec15$4], Object.getOwnPropertyDescriptor(_class5$7.prototype, "isGlobalStandardSkinObject"), _class5$7.prototype), _initializer21$2 = applyDecoratedInitializer(_class5$7.prototype, "_enableMorph", [serializable$3], function () {
        return true;
      })), _class5$7)) || _class4$5) || _class4$5); exports({ MeshRenderer: MeshRenderer, ModelComponent: MeshRenderer });

      function checkMaterialisSame(comp1, comp2) {
        const matNum = comp1.sharedMaterials.length;
        if (matNum !== comp2.sharedMaterials.length) {
          return false;
        }
        for (let i = 0; i < matNum; i++) {
          if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
            return false;
          }
        }
        return true;
      }
      class BatchingUtility {
        static batchStaticModel(staticModelRoot, batchedRoot) {
          const models = staticModelRoot.getComponentsInChildren(MeshRenderer);
          if (models.length < 2) {
            console.error('the number of static models to batch is less than 2,it needn\'t batch.');
            return false;
          }
          for (let i = 1; i < models.length; i++) {
            if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
              console.error(`the meshes of ${models[0].node.name} and ${models[i].node.name} can't be merged`);
              return false;
            }
            if (!checkMaterialisSame(models[0], models[i])) {
              console.error(`the materials of ${models[0].node.name} and ${models[i].node.name} can't be merged`);
              return false;
            }
          }
          const batchedMesh = new Mesh();
          const worldMat = new Mat4();
          const rootWorldMatInv = new Mat4();
          staticModelRoot.getWorldMatrix(rootWorldMatInv);
          Mat4.invert(rootWorldMatInv, rootWorldMatInv);
          for (let i = 0; i < models.length; i++) {
            const comp = models[i];
            comp.node.getWorldMatrix(worldMat);
            Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
            batchedMesh.merge(models[i].mesh, worldMat);
            comp.enabled = false;
          }
          const batchedModel = batchedRoot.addComponent(MeshRenderer);
          batchedModel.mesh = batchedMesh;
          batchedModel.sharedMaterials = models[0].sharedMaterials;
          return true;
        }
        static unbatchStaticModel(staticModelRoot, batchedRoot) {
          const models = staticModelRoot.getComponentsInChildren(MeshRenderer);
          for (let i = 0; i < models.length; i++) {
            const comp = models[i];
            comp.enabled = true;
          }
          const batchedModel = batchedRoot.getComponent(MeshRenderer);
          if (batchedModel) {
            if (batchedModel.mesh) {
              batchedModel.mesh.destroyRenderingMesh();
            }
            batchedModel.destroy();
          }
          return true;
        }
      } exports('BatchingUtility', BatchingUtility);

      replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
        name: 'renderingMesh',
        newName: 'renderingSubMeshes'
      }]);
      removeProperty(Mesh.prototype, 'Mesh.prototype', [{
        name: 'hasFlatBuffers'
      }, {
        name: 'destroyFlatBuffers'
      }]);

      const Skeleton = exports('Skeleton', jsb.Skeleton);
      legacyCC.Skeleton = Skeleton;
      const skeletonProto = Skeleton.prototype;
      Object.defineProperty(skeletonProto, 'bindposes', {
        enumerable: true,
        configurable: true,
        get() {
          return this._bindposes;
        },
        set(v) {
          this._bindposes = v;
          this._setBindposes(v);
        }
      });
      skeletonProto._ctor = function () {
        jsb.Asset.prototype._ctor.apply(this, arguments);
        this._bindposes = [];
      };
      skeletonProto.destroy = function () {
        var _cclegacy$director$ro, _cclegacy$director$ro2;
        (_cclegacy$director$ro = legacyCC.director.root) === null || _cclegacy$director$ro === void 0 ? void 0 : (_cclegacy$director$ro2 = _cclegacy$director$ro.dataPoolManager) === null || _cclegacy$director$ro2 === void 0 ? void 0 : _cclegacy$director$ro2.releaseSkeleton(this);
        return Asset.prototype.destroy.call(this);
      };
      const oldSkeletonProtoOnLoaded = skeletonProto.onLoaded;
      skeletonProto.onLoaded = function () {
        this._setBindposes(this._bindposes);
        oldSkeletonProtoOnLoaded.call(this);
      };
      patch_cc_Skeleton({
        Skeleton,
        CCString,
        Mat4
      });

      removeProperty(MeshRenderer.prototype, 'MeshRenderer.prototype', [{
        name: 'enableDynamicBatching'
      }, {
        name: 'recieveShadows'
      }]);
      legacyCC.ModelComponent = MeshRenderer;
      setClassAlias(MeshRenderer, 'cc.ModelComponent');

      var _dec$16, _class$14, _class2$13, _initializer$10, _initializer2$Y, _initializer3$L, _dec2$10, _dec3$P, _dec4$H, _class4$4, _class5$6, _initializer4$F, _initializer5$y, _initializer6$q, _initializer7$n, _initializer8$l, _class6;
      const _color_tmp = new Vec3();
      const PhotometricTerm = Enum({
        LUMINOUS_FLUX: 0,
        LUMINANCE: 1
      });
      let StaticLightSettings = (_dec$16 = ccclass$6('cc.StaticLightSettings'), _dec$16(_class$14 = (_class2$13 = class StaticLightSettings {
        constructor() {
          this._baked = _initializer$10 && _initializer$10();
          this._editorOnly = _initializer2$Y && _initializer2$Y();
          this._castShadow = _initializer3$L && _initializer3$L();
        }
        get editorOnly() {
          return this._editorOnly;
        }
        set editorOnly(val) {
          this._editorOnly = val;
        }
        get baked() {
          return this._baked;
        }
        set baked(val) {
          this._baked = val;
        }
        get castShadow() {
          return this._castShadow;
        }
        set castShadow(val) {
          this._castShadow = val;
        }
      }, (_initializer$10 = applyDecoratedInitializer(_class2$13.prototype, "_baked", [serializable$6], function () {
        return false;
      }), _initializer2$Y = applyDecoratedInitializer(_class2$13.prototype, "_editorOnly", [serializable$6], function () {
        return false;
      }), _initializer3$L = applyDecoratedInitializer(_class2$13.prototype, "_castShadow", [serializable$6], function () {
        return false;
      })), _class2$13)) || _class$14);
      let Light = (_dec2$10 = ccclass$6('cc.Light'), _dec3$P = type$6(StaticLightSettings), _dec4$H = type$6(Layers.BitMask), _dec2$10(_class4$4 = (_class5$6 = (_class6 = class Light extends Component {
        get color() {
          return this._color;
        }
        set color(val) {
          this._color = val;
          if (this._light) {
            _color_tmp.x = val.r / 255.0;
            _color_tmp.y = val.g / 255.0;
            _color_tmp.z = val.b / 255.0;
            this._light.color = _color_tmp;
          }
        }
        get useColorTemperature() {
          return this._useColorTemperature;
        }
        set useColorTemperature(enable) {
          this._useColorTemperature = enable;
          if (this._light) {
            this._light.useColorTemperature = enable;
          }
        }
        get colorTemperature() {
          return this._colorTemperature;
        }
        set colorTemperature(val) {
          this._colorTemperature = val;
          if (this._light) {
            this._light.colorTemperature = val;
          }
        }
        get staticSettings() {
          return this._staticSettings;
        }
        set staticSettings(val) {
          this._staticSettings = val;
        }
        get type() {
          return this._type;
        }
        get baked() {
          return this.staticSettings.baked;
        }
        set baked(val) {
          this.staticSettings.baked = val;
          if (this._light !== null) {
            this._light.baked = val;
          }
        }
        set visibility(vis) {
          this._visibility = vis;
          if (this._light) {
            this._light.visibility = vis;
          }
          this._onUpdateReceiveDirLight();
        }
        get visibility() {
          return this._visibility;
        }
        constructor() {
          super();
          this._color = _initializer4$F && _initializer4$F();
          this._useColorTemperature = _initializer5$y && _initializer5$y();
          this._colorTemperature = _initializer6$q && _initializer6$q();
          this._staticSettings = _initializer7$n && _initializer7$n();
          this._visibility = _initializer8$l && _initializer8$l();
          this._type = LightType$1.UNKNOWN;
          this._lightType = void 0;
          this._light = null;
          this._lightType = Light$1;
        }
        onLoad() {
          this._createLight();
        }
        onEnable() {
          this._attachToScene();
        }
        onDisable() {
          this._detachFromScene();
        }
        onDestroy() {
          this._destroyLight();
        }
        _createLight() {
          if (!this._light) {
            this._light = legacyCC.director.root.createLight(this._lightType);
          }
          this.color = this._color;
          this.useColorTemperature = this._useColorTemperature;
          this.colorTemperature = this._colorTemperature;
          this._light.node = this.node;
          this._light.baked = this.baked;
          this._light.visibility = this.visibility;
        }
        _destroyLight() {
          if (this._light) {
            legacyCC.director.root.recycleLight(this._light);
            this._light = null;
          }
        }
        _attachToScene() {
          this._detachFromScene();
          if (this._light && !this._light.scene && this.node.scene) {
            const renderScene = this._getRenderScene();
            switch (this._type) {
              case LightType$1.DIRECTIONAL:
                renderScene.addDirectionalLight(this._light);
                renderScene.setMainLight(this._light);
                break;
              case LightType$1.SPHERE:
                renderScene.addSphereLight(this._light);
                break;
              case LightType$1.SPOT:
                renderScene.addSpotLight(this._light);
                break;
              case LightType$1.POINT:
                renderScene.addPointLight(this._light);
                break;
              case LightType$1.RANGED_DIRECTIONAL:
                renderScene.addRangedDirLight(this._light);
                break;
            }
          }
        }
        _detachFromScene() {
          if (this._light && this._light.scene) {
            const renderScene = this._light.scene;
            switch (this._type) {
              case LightType$1.DIRECTIONAL:
                renderScene.removeDirectionalLight(this._light);
                renderScene.unsetMainLight(this._light);
                break;
              case LightType$1.SPHERE:
                renderScene.removeSphereLight(this._light);
                break;
              case LightType$1.SPOT:
                renderScene.removeSpotLight(this._light);
                break;
              case LightType$1.POINT:
                renderScene.removePointLight(this._light);
                break;
              case LightType$1.RANGED_DIRECTIONAL:
                renderScene.removeRangedDirLight(this._light);
                break;
            }
          }
        }
        _onUpdateReceiveDirLight() {}
      }, _class6.Type = LightType$1, _class6.PhotometricTerm = PhotometricTerm, _class6), (_initializer4$F = applyDecoratedInitializer(_class5$6.prototype, "_color", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer5$y = applyDecoratedInitializer(_class5$6.prototype, "_useColorTemperature", [serializable$6], function () {
        return false;
      }), _initializer6$q = applyDecoratedInitializer(_class5$6.prototype, "_colorTemperature", [serializable$6], function () {
        return 6550;
      }), _initializer7$n = applyDecoratedInitializer(_class5$6.prototype, "_staticSettings", [serializable$6], function () {
        return new StaticLightSettings();
      }), _initializer8$l = applyDecoratedInitializer(_class5$6.prototype, "_visibility", [serializable$6], function () {
        return CAMERA_DEFAULT_MASK;
      }), _applyDecoratedDescriptor(_class5$6.prototype, "staticSettings", [_dec3$P], Object.getOwnPropertyDescriptor(_class5$6.prototype, "staticSettings"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "visibility", [_dec4$H], Object.getOwnPropertyDescriptor(_class5$6.prototype, "visibility"), _class5$6.prototype)), _class5$6)) || _class4$4); exports({ Light: Light, LightComponent: Light });

      var _dec$15, _dec2$$, _dec3$O, _dec4$G, _dec5$D, _dec6$q, _dec7$k, _dec8$g, _dec9$e, _dec10$9, _dec11$6, _dec12$6, _dec13$5, _dec14$4, _dec15$3, _dec16$3, _dec17$3, _dec18$3, _dec19$3, _dec20$3, _dec21$3, _dec22$3, _dec23$3, _dec24$3, _dec25$3, _dec26$3, _dec27$3, _dec28$3, _dec29$3, _dec30$2, _dec31$2, _dec32$2, _dec33$2, _dec34$2, _dec35$2, _dec36$2, _dec37$2, _dec38$2, _dec39$2, _class$13, _class2$12, _initializer$$, _initializer2$X, _initializer3$K, _initializer4$E, _initializer5$x, _initializer6$p, _initializer7$m, _initializer8$k, _initializer9$i, _initializer10$f, _initializer11$e, _initializer12$b, _initializer13$a, _initializer14$7, _initializer15$5, _initializer16$5, _initializer17$4, _initializer18$4, _initializer19$3;
      const {
        ccclass: ccclass$2,
        menu: menu$1,
        executeInEditMode: executeInEditMode$1,
        property: property$1,
        serializable: serializable$2,
        formerlySerializedAs: formerlySerializedAs$1,
        tooltip: tooltip$1,
        help: help$1,
        visible: visible$2,
        type: type$2,
        editable: editable$1,
        slide: slide$2,
        range: range$2
      } = _decorator;
      let DirectionalLight = (_dec$15 = ccclass$2('cc.DirectionalLight'), _dec2$$ = formerlySerializedAs$1('_illuminance'), _dec3$O = type$2(CCInteger), _dec4$G = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 1
        }
      }), _dec5$D = type$2(CCBoolean), _dec6$q = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 5
        }
      }), _dec7$k = type$2(PCFType), _dec8$g = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 6
        }
      }), _dec9$e = type$2(CCFloat), _dec10$9 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 7
        }
      }), _dec11$6 = type$2(CCFloat), _dec12$6 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 8
        }
      }), _dec13$5 = type$2(CCFloat), _dec14$4 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 9
        }
      }), _dec15$3 = type$2(CCFloat), _dec16$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 22
        }
      }), _dec17$3 = type$2(CCFloat), _dec18$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 10
        }
      }), _dec19$3 = type$2(CSMLevel$1), _dec20$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 11
        }
      }), _dec21$3 = type$2(CCBoolean), _dec22$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 12
        }
      }), _dec23$3 = type$2(CCFloat), _dec24$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 13
        }
      }), _dec25$3 = type$2(CSMOptimizationMode), _dec26$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 14
        }
      }), _dec27$3 = type$2(CCBoolean), _dec28$3 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 15
        }
      }), _dec29$3 = type$2(CCFloat), _dec30$2 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 16
        }
      }), _dec31$2 = type$2(CCFloat), _dec32$2 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 17
        }
      }), _dec33$2 = type$2(CCFloat), _dec34$2 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 19
        }
      }), _dec35$2 = type$2(CCBoolean), _dec36$2 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 20
        }
      }), _dec37$2 = type$2(CCBoolean), _dec38$2 = property$1({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 21
        }
      }), _dec39$2 = type$2(CCFloat), _dec$15(_class$13 = (_class2$12 = class DirectionalLight extends Light {
        get illuminance() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._illuminanceHDR;
          } else {
            return this._illuminanceLDR;
          }
        }
        set illuminance(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            this._illuminanceHDR = val;
            this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
          } else {
            this._illuminanceLDR = val;
            this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
          }
        }
        get shadowEnabled() {
          return this._shadowEnabled;
        }
        set shadowEnabled(val) {
          this._shadowEnabled = val;
          if (this._light) {
            this._light.shadowEnabled = this._shadowEnabled;
          }
        }
        get shadowPcf() {
          return this._shadowPcf;
        }
        set shadowPcf(val) {
          this._shadowPcf = val;
          if (this._light) {
            this._light.shadowPcf = this._shadowPcf;
          }
        }
        get shadowBias() {
          return this._shadowBias;
        }
        set shadowBias(val) {
          this._shadowBias = val;
          if (this._light) {
            this._light.shadowBias = this._shadowBias;
          }
        }
        get shadowNormalBias() {
          return this._shadowNormalBias;
        }
        set shadowNormalBias(val) {
          this._shadowNormalBias = val;
          if (this._light) {
            this._light.shadowNormalBias = this._shadowNormalBias;
          }
        }
        get shadowSaturation() {
          return this._shadowSaturation;
        }
        set shadowSaturation(val) {
          this._shadowSaturation = clamp$1(val, 0.0, 1.0);
          if (this._light) {
            this._light.shadowSaturation = this._shadowSaturation;
          }
        }
        get shadowDistance() {
          return this._shadowDistance;
        }
        set shadowDistance(val) {
          this._shadowDistance = Math.min(val, Shadows$1.MAX_FAR);
          if (this._shadowDistance / 0.1 < 10.0) {
            warnID(15003, this._shadowDistance);
          }
          if (this._light) {
            this._light.shadowDistance = this._shadowDistance;
            this._light.csmNeedUpdate = true;
          }
        }
        get shadowInvisibleOcclusionRange() {
          return this._shadowInvisibleOcclusionRange;
        }
        set shadowInvisibleOcclusionRange(val) {
          this._shadowInvisibleOcclusionRange = Math.min(val, Shadows$1.MAX_FAR);
          if (this._light) {
            this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
          }
        }
        get csmLevel() {
          return this._csmLevel;
        }
        set csmLevel(val) {
          this._csmLevel = val;
          if (this._light) {
            this._light.csmLevel = this._csmLevel;
            this._light.csmNeedUpdate = true;
          }
        }
        get enableCSM() {
          return this._csmLevel > CSMLevel$1.LEVEL_1;
        }
        set enableCSM(val) {
          this._csmLevel = val ? CSMLevel$1.LEVEL_4 : CSMLevel$1.LEVEL_1;
          if (this._light) {
            this._light.csmLevel = this._csmLevel;
            this._light.csmNeedUpdate = true;
          }
        }
        get csmLayerLambda() {
          return this._csmLayerLambda;
        }
        set csmLayerLambda(val) {
          this._csmLayerLambda = val;
          if (this._light) {
            this._light.csmLayerLambda = this._csmLayerLambda;
            this._light.csmNeedUpdate = true;
          }
        }
        get csmOptimizationMode() {
          return this._csmOptimizationMode;
        }
        set csmOptimizationMode(val) {
          this._csmOptimizationMode = val;
          if (this._light) {
            this._light.csmOptimizationMode = this._csmOptimizationMode;
          }
        }
        get shadowFixedArea() {
          return this._shadowFixedArea;
        }
        set shadowFixedArea(val) {
          this._shadowFixedArea = val;
          if (this._light) {
            this._light.shadowFixedArea = this._shadowFixedArea;
          }
        }
        get shadowNear() {
          return this._shadowNear;
        }
        set shadowNear(val) {
          this._shadowNear = val;
          if (this._light) {
            this._light.shadowNear = this._shadowNear;
          }
        }
        get shadowFar() {
          return this._shadowFar;
        }
        set shadowFar(val) {
          this._shadowFar = Math.min(val, Shadows$1.MAX_FAR);
          if (this._light) {
            this._light.shadowFar = this._shadowFar;
          }
        }
        get shadowOrthoSize() {
          return this._shadowOrthoSize;
        }
        set shadowOrthoSize(val) {
          this._shadowOrthoSize = val;
          if (this._light) {
            this._light.shadowOrthoSize = this._shadowOrthoSize;
          }
        }
        get csmAdvancedOptions() {
          return this._csmAdvancedOptions;
        }
        set csmAdvancedOptions(val) {
          this._csmAdvancedOptions = val;
        }
        get csmLayersTransition() {
          return this._csmLayersTransition;
        }
        set csmLayersTransition(val) {
          this._csmLayersTransition = val;
          if (this._light) {
            this._light.csmLayersTransition = val;
          }
        }
        get csmTransitionRange() {
          return this._csmTransitionRange;
        }
        set csmTransitionRange(val) {
          this._csmTransitionRange = val;
          if (this._light) {
            this._light.csmTransitionRange = val;
          }
        }
        constructor() {
          super();
          this._illuminanceHDR = _initializer$$ && _initializer$$();
          this._illuminanceLDR = _initializer2$X && _initializer2$X();
          this._shadowEnabled = _initializer3$K && _initializer3$K();
          this._shadowPcf = _initializer4$E && _initializer4$E();
          this._shadowBias = _initializer5$x && _initializer5$x();
          this._shadowNormalBias = _initializer6$p && _initializer6$p();
          this._shadowSaturation = _initializer7$m && _initializer7$m();
          this._shadowDistance = _initializer8$k && _initializer8$k();
          this._shadowInvisibleOcclusionRange = _initializer9$i && _initializer9$i();
          this._csmLevel = _initializer10$f && _initializer10$f();
          this._csmLayerLambda = _initializer11$e && _initializer11$e();
          this._csmOptimizationMode = _initializer12$b && _initializer12$b();
          this._csmAdvancedOptions = _initializer13$a && _initializer13$a();
          this._csmLayersTransition = _initializer14$7 && _initializer14$7();
          this._csmTransitionRange = _initializer15$5 && _initializer15$5();
          this._shadowFixedArea = _initializer16$5 && _initializer16$5();
          this._shadowNear = _initializer17$4 && _initializer17$4();
          this._shadowFar = _initializer18$4 && _initializer18$4();
          this._shadowOrthoSize = _initializer19$3 && _initializer19$3();
          this._lightType = DirectionalLight$1;
          const highQualityMode = settings.querySettings(Settings.Category.RENDERING, 'highQualityMode');
          if (highQualityMode) {
            this._shadowPcf = PCFType.SOFT_2X;
            this._shadowDistance = 50;
            this.enableCSM = true;
            this.staticSettings.castShadow = true;
          }
        }
        _createLight() {
          super._createLight();
          this._type = LightType$1.DIRECTIONAL;
          if (this._light) {
            const dirLight = this._light;
            dirLight.illuminanceHDR = this._illuminanceHDR;
            dirLight.illuminanceLDR = this._illuminanceLDR;
            dirLight.shadowEnabled = this._shadowEnabled;
            dirLight.shadowPcf = this._shadowPcf;
            dirLight.shadowBias = this._shadowBias;
            dirLight.shadowNormalBias = this._shadowNormalBias;
            dirLight.shadowSaturation = this._shadowSaturation;
            dirLight.shadowDistance = this._shadowDistance;
            dirLight.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
            dirLight.shadowFixedArea = this._shadowFixedArea;
            dirLight.shadowNear = this._shadowNear;
            dirLight.shadowFar = this._shadowFar;
            dirLight.shadowOrthoSize = this._shadowOrthoSize;
            dirLight.csmLevel = this._csmLevel;
            dirLight.csmLayerLambda = this._csmLayerLambda;
            dirLight.csmOptimizationMode = this._csmOptimizationMode;
            dirLight.csmLayersTransition = this._csmLayersTransition;
            dirLight.csmTransitionRange = this._csmTransitionRange;
          }
        }
        _onUpdateReceiveDirLight() {
          if (!this._light) {
            return;
          }
          super._onUpdateReceiveDirLight();
          const scene = this.node.scene;
          if (!scene || !scene.renderScene) {
            return;
          }
          if (scene.renderScene.mainLight !== this._light) {
            return;
          }
          const models = scene.renderScene.models;
          for (let i = 0; i < models.length; i++) {
            const model = models[i];
            if (!model.node) continue;
            const meshRender = model.node.getComponent(MeshRenderer);
            if (!meshRender) continue;
            meshRender.onUpdateReceiveDirLight(this._visibility);
          }
        }
      }, (_initializer$$ = applyDecoratedInitializer(_class2$12.prototype, "_illuminanceHDR", [property$1, _dec2$$], function () {
        return 65000;
      }), _initializer2$X = applyDecoratedInitializer(_class2$12.prototype, "_illuminanceLDR", [serializable$2], function () {
        return 65000 * Camera$1.standardExposureValue;
      }), _initializer3$K = applyDecoratedInitializer(_class2$12.prototype, "_shadowEnabled", [serializable$2], function () {
        return false;
      }), _initializer4$E = applyDecoratedInitializer(_class2$12.prototype, "_shadowPcf", [serializable$2], function () {
        return PCFType.HARD;
      }), _initializer5$x = applyDecoratedInitializer(_class2$12.prototype, "_shadowBias", [serializable$2], function () {
        return 0.00001;
      }), _initializer6$p = applyDecoratedInitializer(_class2$12.prototype, "_shadowNormalBias", [serializable$2], function () {
        return 0.0;
      }), _initializer7$m = applyDecoratedInitializer(_class2$12.prototype, "_shadowSaturation", [serializable$2], function () {
        return 1.0;
      }), _initializer8$k = applyDecoratedInitializer(_class2$12.prototype, "_shadowDistance", [serializable$2], function () {
        return 50;
      }), _initializer9$i = applyDecoratedInitializer(_class2$12.prototype, "_shadowInvisibleOcclusionRange", [serializable$2], function () {
        return 200;
      }), _initializer10$f = applyDecoratedInitializer(_class2$12.prototype, "_csmLevel", [serializable$2], function () {
        return CSMLevel$1.LEVEL_4;
      }), _initializer11$e = applyDecoratedInitializer(_class2$12.prototype, "_csmLayerLambda", [serializable$2], function () {
        return 0.75;
      }), _initializer12$b = applyDecoratedInitializer(_class2$12.prototype, "_csmOptimizationMode", [serializable$2], function () {
        return CSMOptimizationMode.RemoveDuplicates;
      }), _initializer13$a = applyDecoratedInitializer(_class2$12.prototype, "_csmAdvancedOptions", [serializable$2], function () {
        return false;
      }), _initializer14$7 = applyDecoratedInitializer(_class2$12.prototype, "_csmLayersTransition", [serializable$2], function () {
        return false;
      }), _initializer15$5 = applyDecoratedInitializer(_class2$12.prototype, "_csmTransitionRange", [serializable$2], function () {
        return 0.05;
      }), _initializer16$5 = applyDecoratedInitializer(_class2$12.prototype, "_shadowFixedArea", [serializable$2], function () {
        return false;
      }), _initializer17$4 = applyDecoratedInitializer(_class2$12.prototype, "_shadowNear", [serializable$2], function () {
        return 0.1;
      }), _initializer18$4 = applyDecoratedInitializer(_class2$12.prototype, "_shadowFar", [serializable$2], function () {
        return 10.0;
      }), _initializer19$3 = applyDecoratedInitializer(_class2$12.prototype, "_shadowOrthoSize", [serializable$2], function () {
        return 5;
      }), _applyDecoratedDescriptor(_class2$12.prototype, "illuminance", [_dec3$O], Object.getOwnPropertyDescriptor(_class2$12.prototype, "illuminance"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowEnabled", [_dec4$G, _dec5$D], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowEnabled"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowPcf", [_dec6$q, _dec7$k], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowPcf"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowBias", [_dec8$g, _dec9$e], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowBias"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowNormalBias", [_dec10$9, _dec11$6], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowNormalBias"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowSaturation", [_dec12$6, _dec13$5], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowSaturation"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowDistance", [_dec14$4, _dec15$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowDistance"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowInvisibleOcclusionRange", [_dec16$3, _dec17$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowInvisibleOcclusionRange"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmLevel", [_dec18$3, _dec19$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmLevel"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "enableCSM", [_dec20$3, _dec21$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "enableCSM"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmLayerLambda", [_dec22$3, _dec23$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmLayerLambda"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmOptimizationMode", [_dec24$3, _dec25$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmOptimizationMode"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowFixedArea", [_dec26$3, _dec27$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowFixedArea"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowNear", [_dec28$3, _dec29$3], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowNear"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowFar", [_dec30$2, _dec31$2], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowFar"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "shadowOrthoSize", [_dec32$2, _dec33$2], Object.getOwnPropertyDescriptor(_class2$12.prototype, "shadowOrthoSize"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmAdvancedOptions", [_dec34$2, _dec35$2], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmAdvancedOptions"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmLayersTransition", [_dec36$2, _dec37$2], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmLayersTransition"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "csmTransitionRange", [_dec38$2, _dec39$2], Object.getOwnPropertyDescriptor(_class2$12.prototype, "csmTransitionRange"), _class2$12.prototype)), _class2$12)) || _class$13); exports({ DirectionalLight: DirectionalLight, DirectionalLightComponent: DirectionalLight });

      var _dec$14, _dec2$_, _dec3$N, _dec4$F, _dec5$C, _dec6$p, _dec7$j, _class$12, _class2$11, _initializer$_, _initializer2$W, _initializer3$J, _initializer4$D, _initializer5$w;
      let SphereLight = (_dec$14 = ccclass$6('cc.SphereLight'), _dec2$_ = formerlySerializedAs$3('_luminance'), _dec3$N = type$6(CCInteger), _dec4$F = type$6(CCInteger), _dec5$C = type$6(PhotometricTerm), _dec6$p = type$6(CCFloat), _dec7$j = type$6(CCFloat), _dec$14(_class$12 = (_class2$11 = class SphereLight extends Light {
        get luminousFlux() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR * nt2lm(this._size);
          } else {
            return this._luminanceLDR;
          }
        }
        set luminousFlux(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          let result = 0;
          if (isHDR) {
            this._luminanceHDR = val / nt2lm(this._size);
            result = this._luminanceHDR;
          } else {
            this._luminanceLDR = val;
            result = this._luminanceLDR;
          }
          this._light && (this._light.luminance = result);
        }
        get luminance() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR;
          } else {
            return this._luminanceLDR;
          }
        }
        set luminance(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            this._luminanceHDR = val;
            this._light && (this._light.luminanceHDR = this._luminanceHDR);
          } else {
            this._luminanceLDR = val;
            this._light && (this._light.luminanceLDR = this._luminanceLDR);
          }
        }
        get term() {
          return this._term;
        }
        set term(val) {
          this._term = val;
        }
        get size() {
          return this._size;
        }
        set size(val) {
          this._size = val;
          if (this._light) {
            this._light.size = val;
          }
        }
        get range() {
          return this._range;
        }
        set range(val) {
          this._range = val;
          if (this._light) {
            this._light.range = val;
          }
        }
        constructor() {
          super();
          this._size = _initializer$_ && _initializer$_();
          this._luminanceHDR = _initializer2$W && _initializer2$W();
          this._luminanceLDR = _initializer3$J && _initializer3$J();
          this._term = _initializer4$D && _initializer4$D();
          this._range = _initializer5$w && _initializer5$w();
          this._lightType = SphereLight$1;
        }
        _createLight() {
          super._createLight();
          this._type = LightType$1.SPHERE;
          this.size = this._size;
          this.range = this._range;
          if (this._light) {
            this._light.luminanceHDR = this._luminanceHDR;
            this._light.luminanceLDR = this._luminanceLDR;
          }
        }
      }, (_initializer$_ = applyDecoratedInitializer(_class2$11.prototype, "_size", [serializable$6], function () {
        return 0.15;
      }), _initializer2$W = applyDecoratedInitializer(_class2$11.prototype, "_luminanceHDR", [serializable$6, _dec2$_], function () {
        return 1700 / nt2lm(0.15);
      }), _initializer3$J = applyDecoratedInitializer(_class2$11.prototype, "_luminanceLDR", [serializable$6], function () {
        return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
      }), _initializer4$D = applyDecoratedInitializer(_class2$11.prototype, "_term", [serializable$6], function () {
        return PhotometricTerm.LUMINOUS_FLUX;
      }), _initializer5$w = applyDecoratedInitializer(_class2$11.prototype, "_range", [serializable$6], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$11.prototype, "luminousFlux", [_dec3$N], Object.getOwnPropertyDescriptor(_class2$11.prototype, "luminousFlux"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "luminance", [_dec4$F], Object.getOwnPropertyDescriptor(_class2$11.prototype, "luminance"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "term", [_dec5$C], Object.getOwnPropertyDescriptor(_class2$11.prototype, "term"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "size", [_dec6$p], Object.getOwnPropertyDescriptor(_class2$11.prototype, "size"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "range", [_dec7$j], Object.getOwnPropertyDescriptor(_class2$11.prototype, "range"), _class2$11.prototype)), _class2$11)) || _class$12); exports({ SphereLight: SphereLight, SphereLightComponent: SphereLight });

      var _dec$13, _dec2$Z, _dec3$M, _dec4$E, _dec5$B, _dec6$o, _dec7$i, _dec8$f, _dec9$d, _dec10$8, _dec11$5, _dec12$5, _class$11, _class2$10, _initializer$Z, _initializer2$V, _initializer3$I, _initializer4$C, _initializer5$v, _initializer6$o, _initializer7$l, _initializer8$j, _initializer9$h, _initializer10$e, _initializer11$d;
      const {
        ccclass: ccclass$1,
        range: range$1,
        slide: slide$1,
        type: type$1,
        editable,
        displayOrder: displayOrder$1,
        help,
        executeInEditMode,
        menu,
        tooltip,
        serializable: serializable$1,
        formerlySerializedAs,
        visible: visible$1,
        property
      } = _decorator;
      let SpotLight = (_dec$13 = ccclass$1('cc.SpotLight'), _dec2$Z = formerlySerializedAs('_luminance'), _dec3$M = type$1(PhotometricTerm), _dec4$E = type$1(CCFloat), _dec5$B = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 1
        }
      }), _dec6$o = type$1(CCBoolean), _dec7$i = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 2
        }
      }), _dec8$f = type$1(PCFType), _dec9$d = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 3
        }
      }), _dec10$8 = type$1(CCFloat), _dec11$5 = property({
        group: {
          name: 'DynamicShadowSettings',
          displayOrder: 4
        }
      }), _dec12$5 = type$1(CCFloat), _dec$13(_class$11 = (_class2$10 = class SpotLight extends Light {
        get luminousFlux() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR * nt2lm(this._size);
          } else {
            return this._luminanceLDR;
          }
        }
        set luminousFlux(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          let result = 0;
          if (isHDR) {
            this._luminanceHDR = val / nt2lm(this._size);
            result = this._luminanceHDR;
          } else {
            this._luminanceLDR = val;
            result = this._luminanceLDR;
          }
          this._light && (this._light.luminance = result);
        }
        get luminance() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR;
          } else {
            return this._luminanceLDR;
          }
        }
        set luminance(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            this._luminanceHDR = val;
            this._light && (this._light.luminanceHDR = this._luminanceHDR);
          } else {
            this._luminanceLDR = val;
            this._light && (this._light.luminanceLDR = this._luminanceLDR);
          }
        }
        get term() {
          return this._term;
        }
        set term(val) {
          this._term = val;
        }
        get size() {
          return this._size;
        }
        set size(val) {
          this._size = val;
          if (this._light) {
            this._light.size = val;
          }
        }
        get range() {
          return this._range;
        }
        set range(val) {
          this._range = val;
          if (this._light) {
            this._light.range = val;
          }
        }
        get spotAngle() {
          return this._spotAngle;
        }
        set spotAngle(val) {
          this._spotAngle = val;
          if (this._light) {
            this._light.spotAngle = toRadian(val);
          }
        }
        get angleAttenuationStrength() {
          return this._angleAttenuationStrength;
        }
        set angleAttenuationStrength(val) {
          this._angleAttenuationStrength = val;
          if (this._light) {
            this._light.angleAttenuationStrength = val;
          }
        }
        get shadowEnabled() {
          return this._shadowEnabled;
        }
        set shadowEnabled(val) {
          this._shadowEnabled = val;
          if (this._light) {
            this._light.shadowEnabled = val;
          }
        }
        get shadowPcf() {
          return this._shadowPcf;
        }
        set shadowPcf(val) {
          this._shadowPcf = val;
          if (this._light) {
            this._light.shadowPcf = val;
          }
        }
        get shadowBias() {
          return this._shadowBias;
        }
        set shadowBias(val) {
          this._shadowBias = val;
          if (this._light) {
            this._light.shadowBias = val;
          }
        }
        get shadowNormalBias() {
          return this._shadowNormalBias;
        }
        set shadowNormalBias(val) {
          this._shadowNormalBias = val;
          if (this._light) {
            this._light.shadowNormalBias = val;
          }
        }
        constructor() {
          super();
          this._size = _initializer$Z && _initializer$Z();
          this._luminanceHDR = _initializer2$V && _initializer2$V();
          this._luminanceLDR = _initializer3$I && _initializer3$I();
          this._term = _initializer4$C && _initializer4$C();
          this._range = _initializer5$v && _initializer5$v();
          this._spotAngle = _initializer6$o && _initializer6$o();
          this._angleAttenuationStrength = _initializer7$l && _initializer7$l();
          this._shadowEnabled = _initializer8$j && _initializer8$j();
          this._shadowPcf = _initializer9$h && _initializer9$h();
          this._shadowBias = _initializer10$e && _initializer10$e();
          this._shadowNormalBias = _initializer11$d && _initializer11$d();
          this._lightType = SpotLight$1;
        }
        _createLight() {
          super._createLight();
          this._type = LightType$1.SPOT;
          this.size = this._size;
          this.range = this._range;
          this.spotAngle = this._spotAngle;
          this.angleAttenuationStrength = this._angleAttenuationStrength;
          if (this._light) {
            const spotLight = this._light;
            spotLight.luminanceHDR = this._luminanceHDR;
            spotLight.luminanceLDR = this._luminanceLDR;
            spotLight.shadowEnabled = this._shadowEnabled;
            spotLight.shadowPcf = this._shadowPcf;
            spotLight.shadowBias = this._shadowBias;
            spotLight.shadowNormalBias = this._shadowNormalBias;
          }
        }
      }, (_initializer$Z = applyDecoratedInitializer(_class2$10.prototype, "_size", [serializable$1], function () {
        return 0.15;
      }), _initializer2$V = applyDecoratedInitializer(_class2$10.prototype, "_luminanceHDR", [serializable$1, _dec2$Z], function () {
        return 1700 / nt2lm(0.15);
      }), _initializer3$I = applyDecoratedInitializer(_class2$10.prototype, "_luminanceLDR", [serializable$1], function () {
        return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
      }), _initializer4$C = applyDecoratedInitializer(_class2$10.prototype, "_term", [serializable$1], function () {
        return PhotometricTerm.LUMINOUS_FLUX;
      }), _initializer5$v = applyDecoratedInitializer(_class2$10.prototype, "_range", [serializable$1], function () {
        return 1;
      }), _initializer6$o = applyDecoratedInitializer(_class2$10.prototype, "_spotAngle", [serializable$1], function () {
        return 60;
      }), _initializer7$l = applyDecoratedInitializer(_class2$10.prototype, "_angleAttenuationStrength", [serializable$1], function () {
        return 0;
      }), _initializer8$j = applyDecoratedInitializer(_class2$10.prototype, "_shadowEnabled", [serializable$1], function () {
        return false;
      }), _initializer9$h = applyDecoratedInitializer(_class2$10.prototype, "_shadowPcf", [serializable$1], function () {
        return PCFType.HARD;
      }), _initializer10$e = applyDecoratedInitializer(_class2$10.prototype, "_shadowBias", [serializable$1], function () {
        return 0.00001;
      }), _initializer11$d = applyDecoratedInitializer(_class2$10.prototype, "_shadowNormalBias", [serializable$1], function () {
        return 0.0;
      }), _applyDecoratedDescriptor(_class2$10.prototype, "term", [_dec3$M], Object.getOwnPropertyDescriptor(_class2$10.prototype, "term"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "size", [_dec4$E], Object.getOwnPropertyDescriptor(_class2$10.prototype, "size"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "shadowEnabled", [_dec5$B, _dec6$o], Object.getOwnPropertyDescriptor(_class2$10.prototype, "shadowEnabled"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "shadowPcf", [_dec7$i, _dec8$f], Object.getOwnPropertyDescriptor(_class2$10.prototype, "shadowPcf"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "shadowBias", [_dec9$d, _dec10$8], Object.getOwnPropertyDescriptor(_class2$10.prototype, "shadowBias"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "shadowNormalBias", [_dec11$5, _dec12$5], Object.getOwnPropertyDescriptor(_class2$10.prototype, "shadowNormalBias"), _class2$10.prototype)), _class2$10)) || _class$11); exports({ SpotLight: SpotLight, SpotLightComponent: SpotLight });

      var _dec$12, _dec2$Y, _dec3$L, _dec4$D, _dec5$A, _dec6$n, _class$10, _class2$$, _initializer$Y, _initializer2$U, _initializer3$H, _initializer4$B;
      let PointLight = exports('PointLight', (_dec$12 = ccclass$6('cc.PointLight'), _dec2$Y = formerlySerializedAs$3('_luminance'), _dec3$L = type$6(CCInteger), _dec4$D = type$6(CCInteger), _dec5$A = type$6(PhotometricTerm), _dec6$n = type$6(CCFloat), _dec$12(_class$10 = (_class2$$ = class PointLight extends Light {
        get luminousFlux() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR * nt2lm(1.0);
          } else {
            return this._luminanceLDR;
          }
        }
        set luminousFlux(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          let result = 0;
          if (isHDR) {
            this._luminanceHDR = val / nt2lm(1.0);
            result = this._luminanceHDR;
          } else {
            this._luminanceLDR = val;
            result = this._luminanceLDR;
          }
          this._light && (this._light.luminance = result);
        }
        get luminance() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._luminanceHDR;
          } else {
            return this._luminanceLDR;
          }
        }
        set luminance(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            this._luminanceHDR = val;
            this._light && (this._light.luminanceHDR = this._luminanceHDR);
          } else {
            this._luminanceLDR = val;
            this._light && (this._light.luminanceLDR = this._luminanceLDR);
          }
        }
        get term() {
          return this._term;
        }
        set term(val) {
          this._term = val;
        }
        get range() {
          return this._range;
        }
        set range(val) {
          this._range = val;
          if (this._light) {
            this._light.range = val;
          }
        }
        constructor() {
          super();
          this._luminanceHDR = _initializer$Y && _initializer$Y();
          this._luminanceLDR = _initializer2$U && _initializer2$U();
          this._term = _initializer3$H && _initializer3$H();
          this._range = _initializer4$B && _initializer4$B();
          this._lightType = PointLight$1;
        }
        _createLight() {
          super._createLight();
          this._type = LightType$1.POINT;
          this.range = this._range;
          if (this._light) {
            this._light.luminanceHDR = this._luminanceHDR;
            this._light.luminanceLDR = this._luminanceLDR;
          }
        }
      }, (_initializer$Y = applyDecoratedInitializer(_class2$$.prototype, "_luminanceHDR", [serializable$6, _dec2$Y], function () {
        return 1700 / nt2lm(0.15);
      }), _initializer2$U = applyDecoratedInitializer(_class2$$.prototype, "_luminanceLDR", [serializable$6], function () {
        return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
      }), _initializer3$H = applyDecoratedInitializer(_class2$$.prototype, "_term", [serializable$6], function () {
        return PhotometricTerm.LUMINOUS_FLUX;
      }), _initializer4$B = applyDecoratedInitializer(_class2$$.prototype, "_range", [serializable$6], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$$.prototype, "luminousFlux", [_dec3$L], Object.getOwnPropertyDescriptor(_class2$$.prototype, "luminousFlux"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "luminance", [_dec4$D], Object.getOwnPropertyDescriptor(_class2$$.prototype, "luminance"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "term", [_dec5$A], Object.getOwnPropertyDescriptor(_class2$$.prototype, "term"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "range", [_dec6$n], Object.getOwnPropertyDescriptor(_class2$$.prototype, "range"), _class2$$.prototype)), _class2$$)) || _class$10));

      var _dec$11, _dec2$X, _dec3$K, _class$$, _class2$_, _initializer$X, _initializer2$T;
      let RangedDirectionalLight = exports('RangedDirectionalLight', (_dec$11 = ccclass$6('cc.RangedDirectionalLight'), _dec2$X = formerlySerializedAs$3('_illuminance'), _dec3$K = type$6(CCInteger), _dec$11(_class$$ = (_class2$_ = class RangedDirectionalLight extends Light {
        get illuminance() {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            return this._illuminanceHDR;
          } else {
            return this._illuminanceLDR;
          }
        }
        set illuminance(val) {
          const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
          if (isHDR) {
            this._illuminanceHDR = val;
            this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
          } else {
            this._illuminanceLDR = val;
            this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
          }
        }
        constructor() {
          super();
          this._illuminanceHDR = _initializer$X && _initializer$X();
          this._illuminanceLDR = _initializer2$T && _initializer2$T();
          this._lightType = RangedDirectionalLight$1;
        }
        _createLight() {
          super._createLight();
          this._type = LightType$1.RANGED_DIRECTIONAL;
          if (this._light) {
            this._light.illuminanceHDR = this._illuminanceHDR;
            this._light.illuminanceLDR = this._illuminanceLDR;
          }
        }
      }, (_initializer$X = applyDecoratedInitializer(_class2$_.prototype, "_illuminanceHDR", [property$2, _dec2$X], function () {
        return 65000;
      }), _initializer2$T = applyDecoratedInitializer(_class2$_.prototype, "_illuminanceLDR", [serializable$6], function () {
        return 65000 * Camera$1.standardExposureValue;
      }), _applyDecoratedDescriptor(_class2$_.prototype, "illuminance", [_dec3$K], Object.getOwnPropertyDescriptor(_class2$_.prototype, "illuminance"), _class2$_.prototype)), _class2$_)) || _class$$));

      legacyCC.LightComponent = Light;
      setClassAlias(Light, 'cc.LightComponent');
      legacyCC.DirectionalLightComponent = DirectionalLight;
      setClassAlias(DirectionalLight, 'cc.DirectionalLightComponent');
      legacyCC.SphereLightComponent = SphereLight;
      setClassAlias(SphereLight, 'cc.SphereLightComponent');
      legacyCC.SpotLightComponent = SpotLight;
      setClassAlias(SpotLight, 'cc.SpotLightComponent');
      replaceProperty(SpotLight.prototype, 'SpotLight.prototype', [{
        name: 'luminousPower',
        newName: 'luminousFlux',
        customGetter() {
          return this.luminousFlux;
        },
        customSetter(value) {
          this.luminousFlux = value;
        }
      }]);
      replaceProperty(SphereLight.prototype, 'SphereLight.prototype', [{
        name: 'luminousPower',
        newName: 'luminousFlux',
        customGetter() {
          return this.luminousFlux;
        },
        customSetter(value) {
          this.luminousFlux = value;
        }
      }]);
      replaceProperty(Light.PhotometricTerm, 'Light.PhotometricTerm', [{
        name: 'LUMINOUS_POWER',
        newName: 'LUMINOUS_FLUX'
      }]);

      const SkinningModel = jsb.SkinningModel;
      legacyCC.SkinningModel = jsb.SkinningModel;

      const BakedSkinningModel = jsb.BakedSkinningModel;
      legacyCC.BakedSkinningModel = jsb.BakedSkinningModel;
      jsb.MorphModel;
      const bakedSkinningModelProto = BakedSkinningModel.prototype;
      bakedSkinningModelProto._ctor = function () {
        jsb.Model.prototype._ctor.call(this);
        this.uploadedAnim = undefined;
        this._dataPoolManager = legacyCC.director.root.dataPoolManager;
        const jointTextureInfo = new Float32Array(4);
        const animInfo = this._dataPoolManager.jointAnimationInfo.getData();
        this._jointsMedium = {
          buffer: null,
          jointTextureInfo,
          animInfo,
          texture: null,
          boundsInfo: null
        };
        this._skeleton = null;
        this._mesh = null;
      };
      const oldDestroy = bakedSkinningModelProto.destroy;
      bakedSkinningModelProto.destroy = function () {
        this.uploadedAnim = undefined;
        this._jointsMedium.boundsInfo = null;
        this._applyJointTexture();
        oldDestroy.call(this);
      };
      const oldBindSkeleton = bakedSkinningModelProto.bindSkeleton;
      bakedSkinningModelProto.bindSkeleton = function (skeleton = null, skinningRoot = null, mesh = null) {
        this._skeleton = skeleton;
        this._mesh = mesh;
        if (!skeleton || !skinningRoot || !mesh) {
          return;
        }
        this.transform = skinningRoot;
        const resMgr = this._dataPoolManager;
        this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);
        const animInfo = this._jointsMedium.animInfo;
        this.syncAnimInfoForJS(animInfo.buffer, animInfo.data, animInfo.dirtyForJSB);
        oldBindSkeleton.apply(this, arguments);
      };
      bakedSkinningModelProto.uploadAnimation = function (anim) {
        var _texture;
        if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
          return;
        }
        this.uploadedAnim = anim;
        this.setUploadedAnimForJS(!!anim);
        const resMgr = this._dataPoolManager;
        let texture = null;
        let modelBounds = null;
        if (anim) {
          texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
          this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);
          modelBounds = null;
        } else {
          texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
          this._jointsMedium.boundsInfo = null;
          modelBounds = texture && texture.bounds.get(this._mesh.hash)[0];
        }
        this._applyJointTexture(texture);
        const {
          jointTextureInfo
        } = this._jointsMedium;
        const tex = (_texture = texture) === null || _texture === void 0 ? void 0 : _texture.handle.texture;
        this.syncDataForJS(this._jointsMedium.boundsInfo, modelBounds, jointTextureInfo[0], jointTextureInfo[1], jointTextureInfo[2], jointTextureInfo[3], tex, this._jointsMedium.animInfo.data);
      };
      bakedSkinningModelProto._applyJointTexture = function (texture = null) {
        const oldTex = this._jointsMedium.texture;
        if (oldTex && oldTex !== texture) {
          this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
        }
        this._jointsMedium.texture = texture;
        if (!texture) {
          return;
        }
        const {
          jointTextureInfo
        } = this._jointsMedium;
        jointTextureInfo[0] = texture.handle.texture.width;
        jointTextureInfo[1] = this._skeleton.joints.length;
        jointTextureInfo[2] = texture.pixelOffset + 0.1;
        jointTextureInfo[3] = 1 / jointTextureInfo[0];
      };

      var _dec$10, _dec2$W, _dec3$J, _dec4$C, _dec5$z, _dec6$m, _class$_, _class2$Z, _initializer$W, _initializer2$S;
      let SkinnedMeshRenderer = (_dec$10 = ccclass$6('cc.SkinnedMeshRenderer'), _dec2$W = executionOrder$1(100), _dec3$J = type$6(Skeleton), _dec4$C = type$6(Node$1), _dec5$z = type$6(Skeleton), _dec6$m = type$6(Node$1), _dec$10(_class$_ = _dec2$W(_class$_ = (_class2$Z = class SkinnedMeshRenderer extends MeshRenderer {
        get skeleton() {
          return this._skeleton;
        }
        set skeleton(val) {
          if (val === this._skeleton) {
            return;
          }
          this._skeleton = val;
          this._update();
        }
        get skinningRoot() {
          return this._skinningRoot;
        }
        set skinningRoot(value) {
          if (value === this._skinningRoot) {
            return;
          }
          this._skinningRoot = value;
          this._tryBindAnimation();
          this._update();
        }
        get model() {
          return this._model;
        }
        constructor() {
          super();
          this._skeleton = _initializer$W && _initializer$W();
          this._skinningRoot = _initializer2$S && _initializer2$S();
          this._clip = null;
          this.associatedAnimation = null;
          this._modelType = BakedSkinningModel;
        }
        onLoad() {
          super.onLoad();
          this._tryBindAnimation();
        }
        onDestroy() {
          if (this.associatedAnimation) {
            this.associatedAnimation.notifySkinnedMeshRemoved(this);
            assertIsTrue(this.associatedAnimation === null);
          }
          super.onDestroy();
        }
        uploadAnimation(clip) {
          this._clip = clip;
          if (this.model && this.model.uploadAnimation) {
            this.model.uploadAnimation(clip);
          }
        }
        setUseBakedAnimation(val = true, force = false) {
          const modelType = val ? BakedSkinningModel : SkinningModel;
          if (!force && this._modelType === modelType) {
            return;
          }
          this._modelType = modelType;
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
            this._models.length = 0;
            this._updateModels();
            this._updateCastShadow();
            this._updateReceiveShadow();
            this._updateUseLightProbe();
            if (this.enabledInHierarchy) {
              this._attachToScene();
            }
          }
        }
        setSharedMaterial(material, index) {
          super.setSharedMaterial(material, index);
          if (this._modelType === SkinningModel) {
            this.getMaterialInstance(index);
          }
        }
        _updateModelParams() {
          this._update();
          super._updateModelParams();
        }
        _tryBindAnimation() {
          const {
            _skinningRoot: skinningRoot
          } = this;
          if (!skinningRoot) {
            return;
          }
          let skinningRootIsParent = false;
          for (let current = this.node; current; current = current.parent) {
            if (current === skinningRoot) {
              skinningRootIsParent = true;
              break;
            }
          }
          if (!skinningRootIsParent) {
            return;
          }
          const animation = skinningRoot.getComponent('cc.SkeletalAnimation');
          if (animation && animation.enabledInHierarchy) {
            animation.notifySkinnedMeshAdded(this);
          } else {
            this.setUseBakedAnimation(false);
          }
        }
        _update() {
          if (this.model) {
            this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);
            if (this.model.uploadAnimation) {
              this.model.uploadAnimation(this._clip);
            }
          }
        }
      }, (_initializer$W = applyDecoratedInitializer(_class2$Z.prototype, "_skeleton", [_dec3$J], function () {
        return null;
      }), _initializer2$S = applyDecoratedInitializer(_class2$Z.prototype, "_skinningRoot", [_dec4$C], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$Z.prototype, "skeleton", [_dec5$z], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "skeleton"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "skinningRoot", [_dec6$m], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "skinningRoot"), _class2$Z.prototype)), _class2$Z)) || _class$_) || _class$_); exports({ SkinnedMeshRenderer: SkinnedMeshRenderer, SkinningModelComponent: SkinnedMeshRenderer });

      const m4_1 = new Mat4();
      function getWorldTransformUntilRoot(target, root, outMatrix) {
        Mat4.identity(outMatrix);
        while (target !== root) {
          Mat4.fromRTS(m4_1, target.rotation, target.position, target.scale);
          Mat4.multiply(outMatrix, m4_1, outMatrix);
          target = target.parent;
        }
        return outMatrix;
      }

      var _dec$$, _dec2$V, _dec3$I, _dec4$B, _dec5$y, _class$Z, _class2$Y, _initializer$V, _initializer2$R, _initializer3$G, _initializer4$A, _initializer5$u, _initializer6$n, _dec6$l, _dec7$h, _dec8$e, _dec9$c, _class4$3, _class5$5, _initializer7$k, _initializer8$i, _initializer9$g;
      const repeat$1 = n => n - Math.floor(n);
      const batch_id = new Attribute(AttributeName.ATTR_BATCH_ID, Format.R32F);
      const batch_uv = new Attribute(AttributeName.ATTR_BATCH_UV, Format.RG32F);
      const batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
      let SkinnedMeshUnit = (_dec$$ = ccclass$6('cc.SkinnedMeshUnit'), _dec2$V = type$6(Mesh), _dec3$I = type$6(Skeleton), _dec4$B = type$6(Material), _dec5$y = type$6(SkinnedMeshRenderer), _dec$$(_class$Z = (_class2$Y = class SkinnedMeshUnit {
        constructor() {
          this.mesh = _initializer$V && _initializer$V();
          this.skeleton = _initializer2$R && _initializer2$R();
          this.material = _initializer3$G && _initializer3$G();
          this._localTransform = _initializer4$A && _initializer4$A();
          this._offset = _initializer5$u && _initializer5$u();
          this._size = _initializer6$n && _initializer6$n();
        }
        set offset(offset) {
          Vec2.copy(this._offset, offset);
        }
        get offset() {
          return this._offset;
        }
        set size(size) {
          Vec2.copy(this._size, size);
        }
        get size() {
          return this._size;
        }
        set copyFrom(comp) {
          if (!comp) {
            return;
          }
          this.mesh = comp.mesh;
          this.skeleton = comp.skeleton;
          this.material = comp.getSharedMaterial(0);
          if (comp.skinningRoot) {
            getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
          }
        }
        get copyFrom() {
          return null;
        }
      }, (_initializer$V = applyDecoratedInitializer(_class2$Y.prototype, "mesh", [_dec2$V], function () {
        return null;
      }), _initializer2$R = applyDecoratedInitializer(_class2$Y.prototype, "skeleton", [_dec3$I], function () {
        return null;
      }), _initializer3$G = applyDecoratedInitializer(_class2$Y.prototype, "material", [_dec4$B], function () {
        return null;
      }), _initializer4$A = applyDecoratedInitializer(_class2$Y.prototype, "_localTransform", [serializable$6], function () {
        return new Mat4();
      }), _initializer5$u = applyDecoratedInitializer(_class2$Y.prototype, "_offset", [serializable$6], function () {
        return new Vec2(0, 0);
      }), _initializer6$n = applyDecoratedInitializer(_class2$Y.prototype, "_size", [serializable$6], function () {
        return new Vec2(1, 1);
      }), _applyDecoratedDescriptor(_class2$Y.prototype, "copyFrom", [_dec5$y], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "copyFrom"), _class2$Y.prototype)), _class2$Y)) || _class$Z); exports({ SkinnedMeshUnit: SkinnedMeshUnit, SkinningModelUnit: SkinnedMeshUnit });
      const m4_local = new Mat4();
      new Mat4();
      const v3_1$3 = new Vec3();
      let SkinnedMeshBatchRenderer = (_dec6$l = ccclass$6('cc.SkinnedMeshBatchRenderer'), _dec7$h = executionOrder$1(100), _dec8$e = type$6([CCString]), _dec9$c = type$6([SkinnedMeshUnit]), _dec6$l(_class4$3 = _dec7$h(_class4$3 = (_class5$5 = class SkinnedMeshBatchRenderer extends SkinnedMeshRenderer {
        constructor(...args) {
          super(...args);
          this.atlasSize = _initializer7$k && _initializer7$k();
          this.batchableTextureNames = _initializer8$i && _initializer8$i();
          this.units = _initializer9$g && _initializer9$g();
          this._textures = {};
          this._batchMaterial = null;
        }
        get mesh() {
          return super.mesh;
        }
        set mesh(val) {
          super.mesh = val;
        }
        get skeleton() {
          return super.skeleton;
        }
        set skeleton(val) {
          super.skeleton = val;
        }
        onLoad() {
          super.onLoad();
          this.cook();
        }
        onDestroy() {
          for (const tex in this._textures) {
            this._textures[tex].destroy();
          }
          this._textures = {};
          if (this._mesh) {
            this._mesh.destroy();
            this._mesh = null;
          }
          super.onDestroy();
        }
        _onMaterialModified(idx, material) {
          this.cookMaterials();
          super._onMaterialModified(idx, this.getMaterialInstance(idx));
        }
        cook() {
          this.cookMaterials();
          this.cookSkeletons();
          this.cookMeshes();
        }
        cookMaterials() {
          if (!this._batchMaterial) {
            this._batchMaterial = this.getSharedMaterial(0);
          }
          const mat = this.getMaterialInstance(0);
          if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
            console.warn('incomplete batch material!');
            return;
          }
          mat.copy(this._batchMaterial);
          this.resizeAtlases();
          const tech = mat.effectAsset.techniques[mat.technique];
          for (let i = 0; i < tech.passes.length; i++) {
            const pass = tech.passes[i];
            if (!pass.properties) {
              continue;
            }
            for (const prop in pass.properties) {
              if (pass.properties[prop].type >= Type$1.SAMPLER1D) {
                let tex = null;
                if (this.batchableTextureNames.find(n => n === prop)) {
                  tex = this._textures[prop];
                  if (!tex) {
                    tex = this.createTexture(prop);
                  }
                  this.cookTextures(tex, prop, i);
                } else {
                  this.units.some(u => tex = u.material && u.material.getProperty(prop, i));
                }
                if (tex) {
                  mat.setProperty(prop, tex, i);
                }
              } else {
                const value = [];
                for (let u = 0; u < this.units.length; u++) {
                  const unit = this.units[u];
                  if (!unit.material) {
                    continue;
                  }
                  value.push(unit.material.getProperty(prop.slice(0, -3), i));
                }
                mat.setProperty(prop, value, i);
              }
            }
          }
        }
        cookSkeletons() {
          if (!this._skinningRoot) {
            console.warn('no skinning root specified!');
            return;
          }
          const joints = [];
          const bindposes = [];
          for (let u = 0; u < this.units.length; u++) {
            const unit = this.units[u];
            if (!unit || !unit.skeleton) {
              continue;
            }
            const partial = unit.skeleton;
            Mat4.invert(m4_local, unit._localTransform);
            for (let i = 0; i < partial.joints.length; i++) {
              const path = partial.joints[i];
              const idx = joints.findIndex(p => p === path);
              if (idx >= 0) {
                continue;
              }
              joints.push(path);
              bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
            }
          }
          const idxMap = Array.from(Array(joints.length).keys()).sort((a, b) => {
            if (joints[a] > joints[b]) {
              return 1;
            }
            if (joints[a] < joints[b]) {
              return -1;
            }
            return 0;
          });
          const skeleton = new Skeleton();
          skeleton.joints = joints.map((_, idx, arr) => arr[idxMap[idx]]);
          skeleton.bindposes = bindposes.map((_, idx, arr) => arr[idxMap[idx]]);
          if (this._skeleton) {
            this._skeleton.destroy();
          }
          this.skeleton = skeleton;
        }
        cookMeshes() {
          let isValid = false;
          for (let u = 0; u < this.units.length; u++) {
            const unit = this.units[u];
            if (unit.mesh) {
              isValid = true;
              break;
            }
          }
          if (!isValid || !this._skinningRoot) {
            return;
          }
          if (this._mesh) {
            this._mesh.destroyRenderingMesh();
          } else {
            this._mesh = new Mesh();
          }
          let posOffset = 0;
          let posFormat = Format.UNKNOWN;
          let normalOffset = 0;
          let normalFormat = Format.UNKNOWN;
          let tangentOffset = 0;
          let tangentFormat = Format.UNKNOWN;
          let uvOffset = 0;
          let uvFormat = Format.UNKNOWN;
          let jointOffset = 0;
          let jointFormat = Format.UNKNOWN;
          const jointIndexMap = new Array(this.units.length);
          const unitLen = this.units.length;
          for (let i = 0; i < unitLen; i++) {
            const unit = this.units[i];
            if (!unit || !unit.skeleton) {
              continue;
            }
            jointIndexMap[i] = unit.skeleton.joints.map(j => this._skeleton.joints.findIndex(ref => j === ref));
          }
          for (let i = 0; i < unitLen; i++) {
            const unit = this.units[i];
            if (!unit || !unit.mesh || !unit.mesh.data) {
              continue;
            }
            const newMesh = this._createUnitMesh(i, unit.mesh);
            const dataView = new DataView(newMesh.data.buffer);
            Mat4.invert(m4_local, unit._localTransform);
            Mat4.transpose(m4_local, m4_local);
            const {
              offset
            } = unit;
            const {
              size
            } = unit;
            for (let b = 0; b < newMesh.struct.vertexBundles.length; b++) {
              const bundle = newMesh.struct.vertexBundles[b];
              posOffset = bundle.view.offset;
              posFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_POSITION) {
                  posFormat = attr.format;
                  break;
                }
                posOffset += FormatInfos[attr.format].size;
              }
              if (posFormat) {
                const pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);
                for (let j = 0; j < pos.length; j += 3) {
                  Vec3.fromArray(v3_1$3, pos, j);
                  Vec3.transformMat4(v3_1$3, v3_1$3, unit._localTransform);
                  Vec3.toArray(pos, v3_1$3, j);
                }
                writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
              }
              normalOffset = bundle.view.offset;
              normalFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_NORMAL) {
                  normalFormat = attr.format;
                  break;
                }
                normalOffset += FormatInfos[attr.format].size;
              }
              if (normalFormat) {
                const normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);
                for (let j = 0; j < normal.length; j += 3) {
                  Vec3.fromArray(v3_1$3, normal, j);
                  Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                  Vec3.toArray(normal, v3_1$3, j);
                }
                writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
              }
              tangentOffset = bundle.view.offset;
              tangentFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_TANGENT) {
                  tangentFormat = attr.format;
                  break;
                }
                tangentOffset += FormatInfos[attr.format].size;
              }
              if (tangentFormat) {
                const tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);
                for (let j = 0; j < tangent.length; j += 3) {
                  Vec3.fromArray(v3_1$3, tangent, j);
                  Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                  Vec3.toArray(tangent, v3_1$3, j);
                }
                writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
              }
              uvOffset = bundle.view.offset;
              uvFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_BATCH_UV) {
                  uvFormat = attr.format;
                  break;
                }
                uvOffset += FormatInfos[attr.format].size;
              }
              if (uvFormat) {
                mapBuffer(dataView, (cur, idx) => {
                  cur = repeat$1(cur);
                  const comp = idx === 0 ? 'x' : 'y';
                  return cur * size[comp] + offset[comp];
                }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
              }
              const idxMap = jointIndexMap[i];
              if (!idxMap) {
                continue;
              }
              jointOffset = bundle.view.offset;
              jointFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_JOINTS) {
                  jointFormat = attr.format;
                  break;
                }
                jointOffset += FormatInfos[attr.format].size;
              }
              if (jointFormat) {
                mapBuffer(dataView, cur => idxMap[cur], jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
              }
            }
            this._mesh.merge(newMesh);
          }
          this._onMeshChanged(this._mesh);
          this._updateModels();
        }
        cookTextures(target, prop, passIdx) {
          const texImages = [];
          const texImageRegions = [];
          const texBuffers = [];
          const texBufferRegions = [];
          for (let u = 0; u < this.units.length; u++) {
            const unit = this.units[u];
            if (!unit.material) {
              continue;
            }
            const partial = unit.material.getProperty(prop, passIdx);
            if (partial && partial.image && partial.image.data) {
              const region = new BufferTextureCopy();
              region.texOffset.x = unit.offset.x * this.atlasSize;
              region.texOffset.y = unit.offset.y * this.atlasSize;
              region.texExtent.width = unit.size.x * this.atlasSize;
              region.texExtent.height = unit.size.y * this.atlasSize;
              const {
                data
              } = partial.image;
              if (!ArrayBuffer.isView(data)) {
                texImages.push(data);
                texImageRegions.push(region);
              } else {
                texBuffers.push(data);
                texBufferRegions.push(region);
              }
            }
          }
          const gfxTex = target.getGFXTexture();
          const {
            device
          } = legacyCC.director.root;
          if (texBuffers.length > 0) {
            device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
          }
          if (texImages.length > 0) {
            device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
          }
        }
        createTexture(prop) {
          const tex = new Texture2D$1();
          tex.setFilters(Filter.LINEAR, Filter.LINEAR);
          tex.setMipFilter(Filter.NEAREST);
          tex.reset({
            width: this.atlasSize,
            height: this.atlasSize,
            format: PixelFormat.RGBA8888
          });
          this._textures[prop] = tex;
          return tex;
        }
        resizeAtlases() {
          for (const prop in this._textures) {
            const tex = this._textures[prop];
            tex.reset({
              width: this.atlasSize,
              height: this.atlasSize,
              format: PixelFormat.RGBA8888
            });
          }
        }
        _createUnitMesh(unitIdx, mesh) {
          const newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
          const modifiedBundles = {};
          for (let p = 0; p < mesh.struct.primitives.length; p++) {
            const primitive = mesh.struct.primitives[p];
            let uvOffset = 0;
            let uvFormat = Format.UNKNOWN;
            let bundleIdx = 0;
            for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
              const bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
              uvOffset = bundle.view.offset;
              uvFormat = Format.UNKNOWN;
              for (let a = 0; a < bundle.attributes.length; a++) {
                const attr = bundle.attributes[a];
                if (attr.name === AttributeName.ATTR_TEX_COORD) {
                  uvFormat = attr.format;
                  break;
                }
                uvOffset += FormatInfos[attr.format].size;
              }
              if (uvFormat) {
                break;
              }
            }
            if (modifiedBundles[bundleIdx] !== undefined) {
              continue;
            }
            modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
            const newBundle = newMeshStruct.vertexBundles[bundleIdx];
            newBundle.attributes.push(batch_id);
            newBundle.attributes.push(batch_uv);
            newBundle.view.offset = 0;
            newBundle.view.length += newBundle.view.count * batch_extras_size;
            newBundle.view.stride += batch_extras_size;
          }
          let totalLength = 0;
          for (let b = 0; b < newMeshStruct.vertexBundles.length; b++) {
            totalLength += newMeshStruct.vertexBundles[b].view.length;
          }
          for (let p = 0; p < newMeshStruct.primitives.length; p++) {
            const pm = newMeshStruct.primitives[p];
            if (pm.indexView) {
              pm.indexView.offset = totalLength;
              totalLength += pm.indexView.length;
            }
          }
          const newMeshData = new Uint8Array(totalLength);
          const oldMeshData = mesh.data;
          const newDataView = new DataView(newMeshData.buffer);
          const oldDataView = new DataView(oldMeshData.buffer);
          const {
            isLittleEndian
          } = legacyCC.sys;
          for (const b in modifiedBundles) {
            const newBundle = newMeshStruct.vertexBundles[b];
            const oldBundle = mesh.struct.vertexBundles[b];
            const [uvFormat, uvOffset] = modifiedBundles[b];
            const uvs = readBuffer(oldDataView, uvFormat, uvOffset, oldBundle.view.length, oldBundle.view.stride);
            const oldView = oldBundle.view;
            const newView = newBundle.view;
            const oldStride = oldView.stride;
            const newStride = newView.stride;
            let oldOffset = oldView.offset;
            let newOffset = newView.offset;
            for (let j = 0; j < newView.count; j++) {
              const srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
              newMeshData.set(srcVertex, newOffset);
              newDataView.setFloat32(newOffset + oldStride, unitIdx);
              newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
              newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
              newOffset += newStride;
              oldOffset += oldStride;
            }
          }
          for (let k = 0; k < newMeshStruct.primitives.length; k++) {
            const oldPrimitive = mesh.struct.primitives[k];
            const newPrimitive = newMeshStruct.primitives[k];
            if (oldPrimitive.indexView && newPrimitive.indexView) {
              const oldStride = oldPrimitive.indexView.stride;
              const newStride = newPrimitive.indexView.stride;
              let oldOffset = oldPrimitive.indexView.offset;
              let newOffset = newPrimitive.indexView.offset;
              for (let j = 0; j < newPrimitive.indexView.count; j++) {
                const srcIndices = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                newMeshData.set(srcIndices, newOffset);
                newOffset += newStride;
                oldOffset += oldStride;
              }
            }
          }
          const newMesh = new Mesh();
          newMesh.reset({
            struct: newMeshStruct,
            data: newMeshData
          });
          return newMesh;
        }
      }, (_initializer7$k = applyDecoratedInitializer(_class5$5.prototype, "atlasSize", [serializable$6], function () {
        return 1024;
      }), _initializer8$i = applyDecoratedInitializer(_class5$5.prototype, "batchableTextureNames", [_dec8$e, serializable$6], function () {
        return [];
      }), _initializer9$g = applyDecoratedInitializer(_class5$5.prototype, "units", [_dec9$c, serializable$6], function () {
        return [];
      }), _applyDecoratedDescriptor(_class5$5.prototype, "mesh", [override], Object.getOwnPropertyDescriptor(_class5$5.prototype, "mesh"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "skeleton", [override], Object.getOwnPropertyDescriptor(_class5$5.prototype, "skeleton"), _class5$5.prototype)), _class5$5)) || _class4$3) || _class4$3); exports({ SkinnedMeshBatchRenderer: SkinnedMeshBatchRenderer, BatchedSkinningModelComponent: SkinnedMeshBatchRenderer });

      legacyCC.SkinningModelComponent = SkinnedMeshRenderer;
      setClassAlias(SkinnedMeshRenderer, 'cc.SkinningModelComponent');
      legacyCC.SkinningModelUnit = SkinnedMeshUnit;
      setClassAlias(SkinnedMeshUnit, 'cc.SkinningModelUnit');
      legacyCC.BatchedSkinningModelComponent = SkinnedMeshBatchRenderer;
      setClassAlias(SkinnedMeshBatchRenderer, 'cc.BatchedSkinningModelComponent');

      var _dec$_, _dec2$U, _dec3$H, _dec4$A, _dec5$x, _class$Y, _class2$X, _initializer$U, _initializer2$Q, _dec6$k, _dec7$g, _dec8$d, _class4$2, _class5$4, _initializer3$F, _initializer4$z, _initializer5$t;
      const DEFAULT_SCREEN_OCCUPATION = [0.25, 0.125, 0.01];
      let LOD = exports('LOD', (_dec$_ = ccclass$6('cc.LOD'), _dec2$U = type$6([MeshRenderer]), _dec3$H = type$6(CCFloat), _dec4$A = type$6([MeshRenderer]), _dec5$x = type$6([CCInteger]), _dec$_(_class$Y = (_class2$X = class LOD {
        constructor() {
          this._screenUsagePercentage = _initializer$U && _initializer$U();
          this._renderers = _initializer2$Q && _initializer2$Q();
          this._LODData = new LODData();
          this._modelAddedCallback = void 0;
          this._LODData.screenUsagePercentage = this._screenUsagePercentage;
          this._modelAddedCallback = null;
        }
        get screenUsagePercentage() {
          return this._screenUsagePercentage;
        }
        set screenUsagePercentage(val) {
          this._screenUsagePercentage = val;
          this._LODData.screenUsagePercentage = val;
        }
        get renderers() {
          return this._renderers;
        }
        set renderers(meshList) {
          if (meshList === this._renderers) return;
          let modelAdded = false;
          this._renderers.length = 0;
          this._LODData.clearModels();
          for (let i = 0; i < meshList.length; i++) {
            var _meshList$i;
            this._renderers[i] = meshList[i];
            const model = (_meshList$i = meshList[i]) === null || _meshList$i === void 0 ? void 0 : _meshList$i.model;
            if (model) {
              modelAdded = true;
              this._LODData.addModel(model);
            }
          }
          if (this._modelAddedCallback && modelAdded) {
            this._modelAddedCallback();
          }
        }
        get triangleCount() {
          const tris = [];
          this._renderers.forEach(meshRenderer => {
            let count = 0;
            if (meshRenderer && meshRenderer.mesh) {
              const primitives = meshRenderer.mesh.struct.primitives;
              primitives === null || primitives === void 0 ? void 0 : primitives.forEach(subMesh => {
                if (subMesh && subMesh.indexView) {
                  count += subMesh.indexView.count;
                }
              });
            }
            tris.push(count / 3);
          });
          return tris;
        }
        get rendererCount() {
          return this._renderers.length;
        }
        get lodData() {
          return this._LODData;
        }
        set modelAddedCallback(callback) {
          this._modelAddedCallback = callback;
        }
        insertRenderer(index, renderer) {
          if (index < 0 || index > this._renderers.length) {
            index = this._renderers.length;
          }
          this._renderers.splice(index, 0, renderer);
          let modelAdded = false;
          if (renderer.model) {
            modelAdded = true;
            this._LODData.addModel(renderer.model);
          }
          if (this._modelAddedCallback && modelAdded) {
            this._modelAddedCallback();
          }
          return renderer;
        }
        deleteRenderer(index) {
          var _renders$;
          const renders = this._renderers.splice(index, 1);
          const model = renders.length > 0 ? (_renders$ = renders[0]) === null || _renders$ === void 0 ? void 0 : _renders$.model : null;
          if (model) {
            this._LODData.eraseModel(model);
          }
          return renders[0];
        }
        getRenderer(index) {
          return this._renderers[index] || null;
        }
        setRenderer(index, renderer) {
          if (index < 0 || index >= this.rendererCount) {
            console.error('setRenderer to LOD error, index out of range');
            return;
          }
          this.deleteRenderer(index);
          this.insertRenderer(index, renderer);
        }
      }, (_initializer$U = applyDecoratedInitializer(_class2$X.prototype, "_screenUsagePercentage", [serializable$6], function () {
        return 1.0;
      }), _initializer2$Q = applyDecoratedInitializer(_class2$X.prototype, "_renderers", [_dec2$U, serializable$6], function () {
        return [];
      }), _applyDecoratedDescriptor(_class2$X.prototype, "screenUsagePercentage", [_dec3$H], Object.getOwnPropertyDescriptor(_class2$X.prototype, "screenUsagePercentage"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "renderers", [_dec4$A], Object.getOwnPropertyDescriptor(_class2$X.prototype, "renderers"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "triangleCount", [_dec5$x], Object.getOwnPropertyDescriptor(_class2$X.prototype, "triangleCount"), _class2$X.prototype)), _class2$X)) || _class$Y));
      let LODGroup = exports('LODGroup', (_dec6$k = ccclass$6('cc.LODGroup'), _dec7$g = type$6(CCFloat), _dec8$d = type$6([LOD]), _dec6$k(_class4$2 = (_class5$4 = class LODGroup extends Component {
        constructor() {
          super();
          this._localBoundaryCenter = _initializer3$F && _initializer3$F();
          this._objectSize = _initializer4$z && _initializer4$z();
          this._LODs = _initializer5$t && _initializer5$t();
          this._lodGroup = new LODGroup$1();
          this._eventRegistered = false;
          this._forceUsedLevels = [];
        }
        set localBoundaryCenter(val) {
          this._localBoundaryCenter.set(val);
          this._lodGroup.localBoundaryCenter = val;
        }
        get localBoundaryCenter() {
          return this._localBoundaryCenter.clone();
        }
        get lodCount() {
          return this._LODs.length;
        }
        set objectSize(val) {
          this._objectSize = val;
          this._lodGroup.objectSize = val;
        }
        get objectSize() {
          return this._objectSize;
        }
        get LODs() {
          return this._LODs;
        }
        set LODs(valArray) {
          if (valArray === this._LODs) {
            this._updateDataToScene();
            return;
          }
          this._LODs.length = 0;
          this.lodGroup.clearLODs();
          valArray.forEach((lod, index) => {
            this.lodGroup.insertLOD(index, lod.lodData);
            this._LODs[index] = lod;
            lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
          });
          this._updateDataToScene();
        }
        get lodGroup() {
          return this._lodGroup;
        }
        onLodModelAddedCallback() {
          if (this.objectSize === 0) {
            this.recalculateBounds();
          }
        }
        insertLOD(index, screenUsagePercentage, lod) {
          if (index < 0 || index > this.lodCount) {
            index = this.lodCount;
          }
          if (!lod) {
            lod = new LOD();
          }
          lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
          if (!screenUsagePercentage) {
            const preLod = this.getLOD(index - 1);
            const nextLod = this.getLOD(index);
            if (preLod && nextLod) {
              screenUsagePercentage = (preLod.screenUsagePercentage + nextLod.screenUsagePercentage) / 2;
            } else if (preLod && !nextLod) {
              screenUsagePercentage = preLod.screenUsagePercentage / 2;
              if (screenUsagePercentage > 0.01) {
                screenUsagePercentage = 0.01;
              }
            } else if (nextLod && !preLod) {
              screenUsagePercentage = nextLod.screenUsagePercentage;
              const curNextLOD = this.getLOD(index + 1);
              nextLod.screenUsagePercentage = (screenUsagePercentage + (curNextLOD ? curNextLOD.screenUsagePercentage : 0)) / 2;
            } else {
              screenUsagePercentage = DEFAULT_SCREEN_OCCUPATION[0];
            }
          }
          lod.screenUsagePercentage = screenUsagePercentage;
          this._LODs.splice(index, 0, lod);
          this._lodGroup.insertLOD(index, lod.lodData);
          this._updateDataToScene();
          if (this.node) {
            this._emitChangeNode(this.node);
          }
          return lod;
        }
        eraseLOD(index) {
          if (index < 0 || index >= this.lodCount) {
            console.warn('eraseLOD error, index out of range');
            return null;
          }
          const lod = this._LODs[index];
          if (!lod) {
            console.warn('eraseLOD error, LOD not exist at specified index.');
            return null;
          }
          this._LODs.splice(index, 1);
          this._lodGroup.eraseLOD(index);
          this._updateDataToScene();
          this._emitChangeNode(this.node);
          return lod;
        }
        getLOD(index) {
          if (index < 0 || index >= this.lodCount) {
            console.warn('getLOD error, index out of range');
            return null;
          }
          return this._LODs[index];
        }
        setLOD(index, lod) {
          if (index < 0 || index >= this.lodCount) {
            console.warn('setLOD error, index out of range');
            return;
          }
          this._LODs[index] = lod;
          lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
          this.lodGroup.updateLOD(index, lod.lodData);
          this._updateDataToScene();
        }
        recalculateBounds() {
          function getTransformedBoundary(c, e, transform) {
            let minPos;
            let maxPos;
            const pts = new Array(new Vec3(c.x - e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y - e.y, c.z + e.z), new Vec3(c.x - e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y - e.y, c.z + e.z));
            minPos = pts[0].transformMat4(transform);
            maxPos = minPos.clone();
            for (let i = 1; i < 8; ++i) {
              const pt = pts[i].transformMat4(transform);
              minPos = Vec3.min(minPos, minPos, pt);
              maxPos = Vec3.max(maxPos, maxPos, pt);
            }
            return [minPos, maxPos];
          }
          const minPos = new Vec3();
          const maxPos = new Vec3();
          let boundsMin = null;
          let boundsMax = new Vec3();
          for (let i = 0; i < this.lodCount; ++i) {
            const lod = this.getLOD(i);
            if (lod) {
              for (let j = 0; j < lod.rendererCount; ++j) {
                var _renderer$model, _renderer$model2;
                const renderer = lod.getRenderer(j);
                if (!renderer) {
                  continue;
                }
                (_renderer$model = renderer.model) === null || _renderer$model === void 0 ? void 0 : _renderer$model.updateWorldBound();
                let worldBounds = (_renderer$model2 = renderer.model) === null || _renderer$model2 === void 0 ? void 0 : _renderer$model2.worldBounds;
                if (worldBounds) {
                  {
                    const center = worldBounds.center;
                    const halfExtents = worldBounds.halfExtents;
                    worldBounds = AABB.create(center.x, center.y, center.z, halfExtents.x, halfExtents.y, halfExtents.z);
                  }
                  worldBounds.getBoundary(minPos, maxPos);
                  if (boundsMin) {
                    Vec3.min(boundsMin, boundsMin, minPos);
                    Vec3.max(boundsMax, boundsMax, maxPos);
                  } else {
                    boundsMin = minPos.clone();
                    boundsMax = maxPos.clone();
                  }
                }
              }
            }
          }
          if (boundsMin) {
            const boundsMin2 = boundsMin;
            const c = new Vec3((boundsMax.x + boundsMin2.x) * 0.5, (boundsMax.y + boundsMin2.y) * 0.5, (boundsMax.z + boundsMin2.z) * 0.5);
            const e = new Vec3((boundsMax.x - boundsMin2.x) * 0.5, (boundsMax.y - boundsMin2.y) * 0.5, (boundsMax.z - boundsMin2.z) * 0.5);
            const [minPos, maxPos] = getTransformedBoundary(c, e, this.node.worldMatrix.clone().invert());
            c.set((maxPos.x + minPos.x) * 0.5, (maxPos.y + minPos.y) * 0.5, (maxPos.z + minPos.z) * 0.5);
            e.set((maxPos.x - minPos.x) * 0.5, (maxPos.y - minPos.y) * 0.5, (maxPos.z - minPos.z) * 0.5);
            this.localBoundaryCenter = c;
            this.objectSize = Math.max(e.x, e.y, e.z) * 2.0;
          } else {
            this.localBoundaryCenter = new Vec3(0, 0, 0);
            this.objectSize = 0;
          }
          this._emitChangeNode(this.node);
        }
        resetObjectSize() {
          if (this.objectSize === 1.0) return;
          if (this.objectSize === 0) {
            this.objectSize = 1.0;
          }
          const scale = 1.0 / this.objectSize;
          this.objectSize = 1.0;
          for (let i = 0; i < this.lodCount; ++i) {
            const lod = this.getLOD(i);
            if (lod) {
              lod.screenUsagePercentage *= scale;
            }
          }
          this._emitChangeNode(this.node);
        }
        forceLOD(lodLevel) {
          this._forceUsedLevels = lodLevel < 0 ? [] : [lodLevel];
          this.lodGroup.lockLODLevels(this._forceUsedLevels);
        }
        forceLODs(lodIndexArray) {
        }
        onLoad() {
          this._lodGroup.node = this.node;
          this._lodGroup.objectSize = this._objectSize;
          this._lodGroup.localBoundaryCenter = this._localBoundaryCenter;
          if (!this._eventRegistered) {
            this.node.on(NodeEventType.COMPONENT_REMOVED, this._onRemove, this);
            this._eventRegistered = true;
          }
          this._constructLOD();
        }
        _onRemove(comp) {
          if (comp === this) {
            this.onDisable();
          }
        }
        _constructLOD() {
          if (this.lodCount < 1) {
            const size = DEFAULT_SCREEN_OCCUPATION.length;
            for (let i = 0; i < size; i++) {
              this.insertLOD(i, DEFAULT_SCREEN_OCCUPATION[i]);
            }
          }
        }
        onRestore() {
          this._constructLOD();
          if (this.enabledInHierarchy) {
            this._attachToScene();
          }
        }
        onEnable() {
          this._attachToScene();
          if (this.objectSize === 0) {
            this.recalculateBounds();
          }
          this.lodGroup.lockLODLevels(this._forceUsedLevels);
          if (this.lodCount > 0 && this._lodGroup.lodCount < 1) {
            this._LODs.forEach((lod, index) => {
              lod.lodData.screenUsagePercentage = lod.screenUsagePercentage;
              const renderers = lod.renderers;
              if (renderers !== null && renderers.length > 0) {
                for (let i = 0; i < renderers.length; i++) {
                  const lodInstance = lod.lodData;
                  const renderer = renderers[i];
                  if (lodInstance && renderer && renderer.model) {
                    lodInstance.addModel(renderer.model);
                  }
                }
              }
              this._lodGroup.insertLOD(index, lod.lodData);
            });
          }
        }
        onDisable() {
          this._detachFromScene();
          this.lodGroup.lockLODLevels([]);
        }
        _attachToScene() {
          if (this.node && this.node.scene) {
            const renderScene = this._getRenderScene();
            if (this._lodGroup.scene) {
              this._detachFromScene();
            }
            renderScene.addLODGroup(this._lodGroup);
          }
        }
        _detachFromScene() {
          if (this._lodGroup.scene) {
            this._lodGroup.scene.removeLODGroup(this._lodGroup);
          }
        }
        _emitChangeNode(node) {
        }
        _updateDataToScene() {
          this._detachFromScene();
          this._attachToScene();
        }
      }, (_initializer3$F = applyDecoratedInitializer(_class5$4.prototype, "_localBoundaryCenter", [serializable$6], function () {
        return new Vec3(0, 0, 0);
      }), _initializer4$z = applyDecoratedInitializer(_class5$4.prototype, "_objectSize", [serializable$6], function () {
        return 0;
      }), _initializer5$t = applyDecoratedInitializer(_class5$4.prototype, "_LODs", [serializable$6], function () {
        return [];
      }), _applyDecoratedDescriptor(_class5$4.prototype, "objectSize", [_dec7$g], Object.getOwnPropertyDescriptor(_class5$4.prototype, "objectSize"), _class5$4.prototype), _applyDecoratedDescriptor(_class5$4.prototype, "LODs", [_dec8$d], Object.getOwnPropertyDescriptor(_class5$4.prototype, "LODs"), _class5$4.prototype)), _class5$4)) || _class4$2));

      const REFLECTION_PROBE_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.UI_3D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER, Layers.Enum.IGNORE_RAYCAST]);
      class ReflectionProbeManager {
        constructor() {
          this._probes = [];
          this._useCubeModels = new Map();
          this._usePlanarModels = new Map();
          this._updateForRuntime = true;
          this._dataTexture = null;
          this._registeredEvent = false;
        }
        set updateForRuntime(val) {
          this._updateForRuntime = val;
        }
        get updateForRuntime() {
          return this._updateForRuntime;
        }
        registerEvent() {
          if (!this._registeredEvent) {
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.onUpdateProbes, this);
            this._registeredEvent = true;
          }
        }
        onUpdateProbes() {
          if (this._probes.length === 0) return;
          const scene = legacyCC.director.getScene();
          if (!scene || !scene.renderScene) {
            return;
          }
          const models = scene.renderScene.models;
          for (let i = 0; i < models.length; i++) {
            const model = models[i];
            if (!model.node) continue;
            if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK) {
              if (model.reflectionProbeType === ReflectionProbeType.BAKED_CUBEMAP || this._isUsedBlending(model)) {
                this.selectReflectionProbe(model);
              } else if (model.reflectionProbeType === ReflectionProbeType.PLANAR_REFLECTION) {
                this.selectPlanarReflectionProbe(model);
              }
            }
          }
        }
        filterModelsForPlanarReflection() {
          if (this._probes.length === 0) return;
          const scene = legacyCC.director.getScene();
          if (!scene || !scene.renderScene) {
            return;
          }
          const models = scene.renderScene.models;
          for (let i = 0; i < models.length; i++) {
            const model = models[i];
            if (!model.node) continue;
            if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK && model.reflectionProbeType === ReflectionProbeType.PLANAR_REFLECTION) {
              this.selectPlanarReflectionProbe(model);
            }
          }
        }
        clearPlanarReflectionMap(probe) {
          for (const entry of this._usePlanarModels.entries()) {
            if (entry[1] === probe) {
              this._updatePlanarMapOfModel(entry[0], null, null);
            }
          }
        }
        register(probe) {
          const index = this._probes.indexOf(probe);
          if (index === -1) {
            this._probes.push(probe);
            this.updateProbeData();
          }
        }
        unregister(probe) {
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i] === probe) {
              const del = this._probes.splice(i, 1);
              if (del[0]) {
                this._removeDependentModels(del[0]);
              }
              break;
            }
          }
          this.updateProbeData();
        }
        exists(probeId) {
          if (this._probes.length === 0) return false;
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].getProbeId() === probeId) {
              return true;
            }
          }
          return false;
        }
        getNewReflectionProbeId() {
          let probeId = 0;
          while (true) {
            if (this.exists(probeId)) {
              probeId++;
            } else {
              return probeId;
            }
          }
        }
        getProbes() {
          return this._probes;
        }
        getProbeById(probeId) {
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].getProbeId() === probeId) {
              return this._probes[i];
            }
          }
          return null;
        }
        clearAll() {
          this._probes = [];
        }
        getProbeByCamera(camera) {
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].camera === camera) {
              return this._probes[i];
            }
          }
          return null;
        }
        updateBakedCubemap(probe) {
          const models = this._getModelsByProbe(probe);
          if (!probe.cubemap) return;
          for (let i = 0; i < models.length; i++) {
            const model = models[i];
            this._updateCubemapOfModel(model, probe);
          }
          probe.needRefresh = false;
          if (models.length === 0) {
            for (const entry of this._useCubeModels.entries()) {
              if (entry[0].reflectionProbeBlendId === probe.getProbeId()) {
                this._updateBlendCubemap(entry[0], probe);
              }
            }
          }
        }
        updatePlanarMap(probe, texture) {
          if (!probe.node || !probe.node.scene) return;
          const models = this._getModelsByProbe(probe);
          for (let i = 0; i < models.length; i++) {
            this._updatePlanarMapOfModel(models[i], texture, probe);
          }
          if (probe.previewPlane) {
            const meshRender = probe.previewPlane.getComponent(MeshRenderer);
            if (meshRender) {
              meshRender.updateProbePlanarMap(texture);
            }
          }
        }
        selectPlanarReflectionProbe(model) {
          if (!model.node || !model.worldBounds || model.reflectionProbeType !== ReflectionProbeType.PLANAR_REFLECTION) return;
          for (let i = 0; i < this._probes.length; i++) {
            const probe = this._probes[i];
            if (probe.probeType !== ProbeType.PLANAR) continue;
            if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK) {
              model.updateWorldBound();
              if (intersect.aabbWithAABB(model.worldBounds, probe.boundingBox)) {
                this._usePlanarModels.set(model, probe);
              } else if (this._usePlanarModels.has(model)) {
                const old = this._usePlanarModels.get(model);
                if (old === probe) {
                  this._usePlanarModels.delete(model);
                  this._updatePlanarMapOfModel(model, null, null);
                }
              }
            }
          }
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].probeType === ProbeType.PLANAR) {
              if (!this._probes[i].realtimePlanarTexture) {
                this.updatePlanarMap(this._probes[i], null);
              } else {
                this.updatePlanarMap(this._probes[i], this._probes[i].realtimePlanarTexture.getGFXTexture());
              }
            }
          }
        }
        selectReflectionProbe(model) {
          if (model.node && model.worldBounds && model.node.layer & REFLECTION_PROBE_DEFAULT_MASK) {
            model.updateWorldBound();
            const nearest = this._getNearestProbe(model);
            if (!nearest) {
              this._updateCubemapOfModel(model, null);
              this._useCubeModels.delete(model);
            } else if (this._useCubeModels.has(model)) {
              const old = this._useCubeModels.get(model);
              if (old !== nearest) {
                this._useCubeModels.set(model, nearest);
              }
              nearest.needRefresh = true;
            } else {
              this._useCubeModels.set(model, nearest);
              nearest.needRefresh = true;
            }
          }
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].needRefresh && this._probes[i].probeType === ProbeType.CUBE || this._isUsedBlending(model)) {
              this.updateBakedCubemap(this._probes[i]);
            }
          }
        }
        updatePreviewSphere(probe) {
          if (!probe || !probe.previewSphere) return;
          const meshRender = probe.previewSphere.getComponent(MeshRenderer);
          if (meshRender) {
            meshRender.updateProbeCubemap(probe.cubemap);
            meshRender.updateReflectionProbeId(probe.getProbeId());
          }
        }
        updatePreviewPlane(probe) {
          if (!probe || !probe.previewPlane) return;
          const meshRender = probe.previewPlane.getComponent(MeshRenderer);
          if (meshRender) {
            if (probe.realtimePlanarTexture) {
              this.updatePlanarMap(probe, probe.realtimePlanarTexture.getGFXTexture());
            }
          }
        }
        updateProbeData() {
          if (this._probes.length === 0) return;
          const maxId = this.getMaxProbeId();
          const height = maxId + 1;
          const dataWidth = 3;
          if (this._dataTexture) {
            this._dataTexture.destroy();
          }
          const buffer = new Float32Array(4 * dataWidth * height);
          let bufferOffset = 0;
          for (let i = 0; i <= maxId; i++) {
            const probe = this.getProbeById(i);
            if (!probe) {
              bufferOffset += 4 * dataWidth;
              continue;
            }
            if (probe.probeType === ProbeType.CUBE) {
              buffer[bufferOffset] = probe.node.worldPosition.x;
              buffer[bufferOffset + 1] = probe.node.worldPosition.y;
              buffer[bufferOffset + 2] = probe.node.worldPosition.z;
              buffer[bufferOffset + 3] = 0.0;
              buffer[bufferOffset + 4] = probe.size.x;
              buffer[bufferOffset + 5] = probe.size.y;
              buffer[bufferOffset + 6] = probe.size.z;
              buffer[bufferOffset + 7] = 0.0;
              const mipAndUseRGBE = probe.isRGBE() ? 1000 : 0;
              buffer[bufferOffset + 8] = probe.cubemap ? probe.cubemap.mipmapLevel + mipAndUseRGBE : 1.0 + mipAndUseRGBE;
            } else {
              buffer[bufferOffset] = probe.node.up.x;
              buffer[bufferOffset + 1] = probe.node.up.y;
              buffer[bufferOffset + 2] = probe.node.up.z;
              buffer[bufferOffset + 3] = 1.0;
              buffer[bufferOffset + 4] = 1.0;
              buffer[bufferOffset + 5] = 1.0;
              buffer[bufferOffset + 6] = 0.0;
              buffer[bufferOffset + 7] = 0.0;
              buffer[bufferOffset + 8] = 1.0;
            }
            bufferOffset += 4 * dataWidth;
          }
          const updateView = new Uint8Array(buffer.buffer);
          const image = new ImageAsset$1({
            _data: updateView,
            _compressed: false,
            width: dataWidth * 4,
            height,
            format: PixelFormat.RGBA8888
          });
          this._dataTexture = new Texture2D$1();
          this._dataTexture.setFilters(Texture2D$1.Filter.NONE, Texture2D$1.Filter.NONE);
          this._dataTexture.setMipFilter(Texture2D$1.Filter.NONE);
          this._dataTexture.setWrapMode(Texture2D$1.WrapMode.CLAMP_TO_EDGE, Texture2D$1.WrapMode.CLAMP_TO_EDGE, Texture2D$1.WrapMode.CLAMP_TO_EDGE);
          this._dataTexture.image = image;
          this._dataTexture.uploadData(updateView);
          for (let i = 0; i < this._probes.length; i++) {
            const probe = this._probes[i];
            const models = this._getModelsByProbe(probe);
            for (let j = 0; j < models.length; j++) {
              const meshRender = models[j].node.getComponent(MeshRenderer);
              if (meshRender) {
                meshRender.updateReflectionProbeDataMap(this._dataTexture);
              }
            }
          }
        }
        getMaxProbeId() {
          if (this._probes.length === 0) {
            return -1;
          }
          if (this._probes.length === 1) {
            return this._probes[0].getProbeId();
          }
          this._probes.sort((a, b) => a.getProbeId() - b.getProbeId());
          return this._probes[this._probes.length - 1].getProbeId();
        }
        getUsedReflectionProbe(model, planarReflection) {
          if (planarReflection) {
            if (this._usePlanarModels.has(model)) {
              return this._usePlanarModels.get(model);
            }
          } else if (this._useCubeModels.has(model)) {
            return this._useCubeModels.get(model);
          }
          return null;
        }
        setReflectionProbe(model, probe, blendProbe = null) {
          if (!probe) return;
          this._useCubeModels.set(model, probe);
          this._updateCubemapOfModel(model, probe);
          if (blendProbe) {
            this._updateBlendProbeInfo(model, probe, blendProbe);
          }
        }
        updateProbeOfModels() {
          if (this._probes.length === 0) return;
          const scene = legacyCC.director.getScene();
          if (!scene || !scene.renderScene) {
            return;
          }
          const models = scene.renderScene.models;
          for (let i = 0; i < models.length; i++) {
            const model = models[i];
            if (!model.node) continue;
            if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK) {
              if (model.reflectionProbeType === ReflectionProbeType.BAKED_CUBEMAP || model.reflectionProbeType === ReflectionProbeType.PLANAR_REFLECTION || this._isUsedBlending(model)) {
                model.updateReflectionProbeId();
              }
            }
          }
        }
        _getNearestProbe(model) {
          if (!model.node || !model.worldBounds || this._probes.length === 0) return null;
          let nearestProbe = null;
          let minDistance = Infinity;
          for (const probe of this._probes) {
            if (probe.probeType !== ProbeType.CUBE || !probe.validate() || !intersect.aabbWithAABB(model.worldBounds, probe.boundingBox)) {
              continue;
            }
            const distance = Vec3.distance(model.node.worldPosition, probe.node.worldPosition);
            if (distance < minDistance) {
              minDistance = distance;
              nearestProbe = probe;
            }
          }
          return nearestProbe;
        }
        _getBlendProbe(model) {
          if (!model || !model.node || !model.worldBounds || this._probes.length < 2) {
            return null;
          }
          const temp = [];
          for (let i = 0; i < this._probes.length; i++) {
            if (this._probes[i].probeType !== ProbeType.CUBE || !this._probes[i].validate() || !intersect.aabbWithAABB(model.worldBounds, this._probes[i].boundingBox)) {
              continue;
            }
            temp.push(this._probes[i]);
          }
          temp.sort((a, b) => {
            const aDistance = Vec3.distance(model.node.worldPosition, a.node.worldPosition);
            const bDistance = Vec3.distance(model.node.worldPosition, b.node.worldPosition);
            return aDistance - bDistance;
          });
          return temp.length > 1 ? temp[1] : null;
        }
        _getModelsByProbe(probe) {
          const models = [];
          let useModels = this._useCubeModels;
          if (probe.probeType === ProbeType.PLANAR) {
            useModels = this._usePlanarModels;
          }
          for (const entry of useModels.entries()) {
            if (entry[1] === probe) {
              models.push(entry[0]);
            }
          }
          return models;
        }
        _removeDependentModels(probe) {
          for (const key of this._useCubeModels.keys()) {
            const p = this._useCubeModels.get(key);
            if (p !== undefined && p === probe) {
              this._useCubeModels.delete(key);
              this.selectReflectionProbe(key);
            }
          }
          for (const key of this._usePlanarModels.keys()) {
            const p = this._usePlanarModels.get(key);
            if (p !== undefined && p === probe) {
              this._usePlanarModels.delete(key);
              this.selectPlanarReflectionProbe(key);
            }
          }
        }
        _updateCubemapOfModel(model, probe) {
          const node = model.node;
          if (!node) {
            return;
          }
          const meshRender = node.getComponent(MeshRenderer);
          if (!meshRender) {
            return;
          }
          meshRender.updateProbeCubemap(probe ? probe.cubemap : null);
          meshRender.updateReflectionProbeId(probe && probe.cubemap ? probe.getProbeId() : -1);
          if (probe) {
            meshRender.updateReflectionProbeDataMap(this._dataTexture);
            if (this._isUsedBlending(model)) {
              const blendProbe = this._getBlendProbe(model);
              this._updateBlendProbeInfo(model, probe, blendProbe);
            }
          }
        }
        _updatePlanarMapOfModel(model, texture, probe) {
          const meshRender = model.node.getComponent(MeshRenderer);
          if (meshRender) {
            meshRender.updateProbePlanarMap(texture);
            if (probe) {
              meshRender.updateReflectionProbeId(probe.getProbeId());
              meshRender.updateReflectionProbeDataMap(this._dataTexture);
            } else {
              meshRender.updateReflectionProbeId(-1);
            }
          }
        }
        _isUsedBlending(model) {
          if (model.reflectionProbeType === ReflectionProbeType.BLEND_PROBES || model.reflectionProbeType === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
            return true;
          }
          return false;
        }
        _updateBlendProbeInfo(model, probe, blendProbe) {
          const node = model.node;
          if (!node) {
            return;
          }
          const meshRender = node.getComponent(MeshRenderer);
          if (!meshRender) {
            return;
          }
          if (blendProbe) {
            meshRender.updateReflectionProbeBlendId(blendProbe.getProbeId());
            meshRender.updateProbeBlendCubemap(blendProbe.cubemap);
            meshRender.updateReflectionProbeBlendWeight(this._calculateBlendWeight(model, probe, blendProbe));
          } else {
            meshRender.updateReflectionProbeBlendId(-1);
            if (model.reflectionProbeType === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
              meshRender.updateReflectionProbeBlendWeight(this._calculateBlendWeight(model, probe, blendProbe));
            }
          }
        }
        _updateBlendCubemap(model, probe) {
          const node = model.node;
          if (!node) {
            return;
          }
          if (!this._isUsedBlending(model)) {
            return;
          }
          const meshRender = node.getComponent(MeshRenderer);
          if (meshRender) {
            meshRender.updateProbeBlendCubemap(probe.cubemap);
          }
        }
        _calculateBlendWeight(model, probe, blendProbe) {
          if (blendProbe) {
            const d1 = Vec3.distance(model.node.worldPosition, probe.node.worldPosition);
            const d2 = Vec3.distance(model.node.worldPosition, blendProbe.node.worldPosition);
            return 1.0 - d2 / (d1 + d2);
          }
          if (model.reflectionProbeType === ReflectionProbeType.BLEND_PROBES) {
            return 0.0;
          } else if (model.reflectionProbeType === ReflectionProbeType.BLEND_PROBES_AND_SKYBOX) {
            return this._calculateBlendOfSkybox(model.worldBounds, probe.boundingBox);
          }
          return 0.0;
        }
        _calculateBlendOfSkybox(aabb1, aabb2) {
          if (!aabb1) return 1.0;
          const aMin = new Vec3();
          const aMax = new Vec3();
          const bMin = new Vec3();
          const bMax = new Vec3();
          Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
          Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
          Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
          Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
          const inside = aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
          if (inside) {
            const fullSize = new Vec3();
            Vec3.multiplyScalar(fullSize, aabb1.halfExtents, 2.0);
            const boundaryXAdd = aMin.x + fullSize.x <= bMax.x && aMax.x + fullSize.x >= bMin.x;
            const boundaryXSub = aMin.x - fullSize.x <= bMax.x && aMax.x - fullSize.x >= bMin.x;
            const boundaryYAdd = aMin.y + fullSize.y <= bMax.y && aMax.y + fullSize.y >= bMin.y;
            const boundaryYSub = aMin.y - fullSize.y <= bMax.y && aMax.y - fullSize.y >= bMin.y;
            const boundaryZAdd = aMin.z + fullSize.z <= bMax.z && aMax.z + fullSize.z >= bMin.z;
            const boundaryZSub = aMin.z - fullSize.z <= bMax.z && aMax.z - fullSize.z >= bMin.z;
            const weights = [];
            if (!boundaryXAdd) {
              const offset = aMax.x - bMax.x;
              weights.push(offset / fullSize.x);
            }
            if (!boundaryXSub) {
              const offset = Math.abs(aMin.x - bMin.x);
              weights.push(offset / fullSize.x);
            }
            if (!boundaryYAdd) {
              const offset = aMax.y - bMax.y;
              weights.push(offset / fullSize.y);
            }
            if (!boundaryYSub) {
              const offset = Math.abs(aMin.y - bMin.y);
              weights.push(offset / fullSize.y);
            }
            if (!boundaryZAdd) {
              const offset = aMax.z - bMax.z;
              weights.push(offset / fullSize.z);
            }
            if (!boundaryZSub) {
              const offset = Math.abs(aMin.z - bMin.z);
              weights.push(offset / fullSize.z);
            }
            if (weights.length > 0) {
              weights.sort((a, b) => b - a);
              return weights[0];
            } else {
              return 0.0;
            }
          }
          return 1.0;
        }
      } exports('ReflectionProbeManager', ReflectionProbeManager);
      ReflectionProbeManager.probeManager = void 0;
      ReflectionProbeManager.probeManager = new ReflectionProbeManager();
      legacyCC.internal.reflectionProbeManager = ReflectionProbeManager.probeManager;

      function wireframe(indices) {
        const offsets = [[0, 1], [1, 2], [2, 0]];
        const lines = [];
        const lineIDs = {};
        for (let i = 0; i < indices.length; i += 3) {
          for (let k = 0; k < 3; ++k) {
            const i1 = indices[i + offsets[k][0]];
            const i2 = indices[i + offsets[k][1]];
            const id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            if (lineIDs[id] === undefined) {
              lineIDs[id] = 0;
              lines.push(i1, i2);
            }
          }
        }
        return lines;
      }
      function invWinding(indices) {
        const newIB = [];
        for (let i = 0; i < indices.length; i += 3) {
          newIB.push(indices[i], indices[i + 2], indices[i + 1]);
        }
        return newIB;
      }
      function toWavefrontOBJ(primitive, scale = 1) {
        if (!primitive.indices || !primitive.uvs || !primitive.normals || primitive.primitiveMode !== undefined && primitive.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
          return '';
        }
        const v = primitive.positions;
        const t = primitive.uvs;
        const n = primitive.normals;
        const IB = primitive.indices;
        const V = i => `${IB[i] + 1}/${IB[i] + 1}/${IB[i] + 1}`;
        let content = '';
        for (let i = 0; i < v.length; i += 3) {
          content += `v ${v[i] * scale} ${v[i + 1] * scale} ${v[i + 2] * scale}\n`;
        }
        for (let i = 0; i < t.length; i += 2) {
          content += `vt ${t[i]} ${t[i + 1]}\n`;
        }
        for (let i = 0; i < n.length; i += 3) {
          content += `vn ${n[i]} ${n[i + 1]} ${n[i + 2]}\n`;
        }
        for (let i = 0; i < IB.length; i += 3) {
          content += `f ${V(i)} ${V(i + 1)} ${V(i + 2)}\n`;
        }
        return content;
      }
      function normals(positions, nms, length = 1) {
        const verts = new Array(2 * positions.length);
        for (let i = 0; i < positions.length / 3; ++i) {
          const i3 = 3 * i;
          const i6 = 6 * i;
          verts[i6 + 0] = positions[i3 + 0];
          verts[i6 + 1] = positions[i3 + 1];
          verts[i6 + 2] = positions[i3 + 2];
          verts[i6 + 3] = positions[i3 + 0] + nms[i3 + 0] * length;
          verts[i6 + 4] = positions[i3 + 1] + nms[i3 + 1] * length;
          verts[i6 + 5] = positions[i3 + 2] + nms[i3 + 2] * length;
        }
        return verts;
      }

      function applyDefaultGeometryOptions(options) {
        options = options || {};
        if (options.includeNormal === undefined) {
          options.includeNormal = true;
        }
        if (options.includeUV === undefined) {
          options.includeUV = true;
        }
        return options;
      }

      function box(options) {
        options = options || {};
        const ws = options.widthSegments || 1;
        const hs = options.heightSegments || 1;
        const ls = options.lengthSegments || 1;
        const hw = (options.width || 1) / 2;
        const hh = (options.height || 1) / 2;
        const hl = (options.length || 1) / 2;
        const corners = [Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl)];
        const faceAxes = [[2, 3, 1], [4, 5, 7], [7, 6, 2], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
        const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
        const faceTangents = [[-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [0, 0, -1, 1], [0, 0, 1, 1]];
        const positions = [];
        const normals = [];
        const uvs = [];
        const tangents = [];
        const indices = [];
        const minPos = new Vec3(-hw, -hh, -hl);
        const maxPos = new Vec3(hw, hh, hl);
        const boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
        function _buildPlane(side, uSegments, vSegments) {
          let u;
          let v;
          let ix;
          let iy;
          const offset = positions.length / 3;
          const faceAxe = faceAxes[side];
          const faceNormal = faceNormals[side];
          const faceTangent = faceTangents[side];
          for (iy = 0; iy <= vSegments; iy++) {
            for (ix = 0; ix <= uSegments; ix++) {
              u = ix / uSegments;
              v = iy / vSegments;
              Vec3.lerp(temp1$3, corners[faceAxe[0]], corners[faceAxe[1]], u);
              Vec3.lerp(temp2$3, corners[faceAxe[0]], corners[faceAxe[2]], v);
              Vec3.subtract(temp3$1, temp2$3, corners[faceAxe[0]]);
              Vec3.add(r$1, temp1$3, temp3$1);
              positions.push(r$1.x, r$1.y, r$1.z);
              normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
              uvs.push(u, v);
              tangents.push(faceTangent[0], faceTangent[1], faceTangent[2], faceTangent[3]);
              if (ix < uSegments && iy < vSegments) {
                const useg1 = uSegments + 1;
                const a = ix + iy * useg1;
                const b = ix + (iy + 1) * useg1;
                const c = ix + 1 + (iy + 1) * useg1;
                const d = ix + 1 + iy * useg1;
                indices.push(offset + a, offset + d, offset + b);
                indices.push(offset + b, offset + d, offset + c);
              }
            }
          }
        }
        _buildPlane(0, ws, hs);
        _buildPlane(4, ls, hs);
        _buildPlane(1, ws, hs);
        _buildPlane(5, ls, hs);
        _buildPlane(3, ws, ls);
        _buildPlane(2, ws, ls);
        return {
          positions,
          normals,
          uvs,
          tangents,
          indices,
          minPos,
          maxPos,
          boundingRadius
        };
      }
      const temp1$3 = new Vec3();
      const temp2$3 = new Vec3();
      const temp3$1 = new Vec3();
      const r$1 = new Vec3();
      const c0 = new Vec3();
      const c1 = new Vec3();
      const c2 = new Vec3();
      const c3 = new Vec3();
      const c4 = new Vec3();
      const c5 = new Vec3();
      const c6 = new Vec3();
      const c7 = new Vec3();

      const temp1$2 = new Vec3(0, 0, 0);
      const temp2$2 = new Vec3(0, 0, 0);
      function cylinder(radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts = {}) {
        const halfHeight = height * 0.5;
        const radialSegments = opts.radialSegments || 32;
        const heightSegments = opts.heightSegments || 1;
        const capped = opts.capped !== undefined ? opts.capped : true;
        const arc = opts.arc || 2.0 * Math.PI;
        let cntCap = 0;
        if (capped) {
          if (radiusTop > 0) {
            cntCap++;
          }
          if (radiusBottom > 0) {
            cntCap++;
          }
        }
        let vertCount = (radialSegments + 1) * (heightSegments + 1);
        if (capped) {
          vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
        }
        let indexCount = radialSegments * heightSegments * 2 * 3;
        if (capped) {
          indexCount += radialSegments * cntCap * 3;
        }
        const indices = new Array(indexCount);
        const positions = new Array(vertCount * 3);
        const normals = new Array(vertCount * 3);
        const uvs = new Array(vertCount * 2);
        const maxRadius = Math.max(radiusTop, radiusBottom);
        const minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);
        const maxPos = new Vec3(maxRadius, halfHeight, maxRadius);
        const boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
        let index = 0;
        let indexOffset = 0;
        generateTorso();
        if (capped) {
          if (radiusBottom > 0) {
            generateCap(false);
          }
          if (radiusTop > 0) {
            generateCap(true);
          }
        }
        return {
          positions,
          normals,
          uvs,
          indices,
          minPos,
          maxPos,
          boundingRadius
        };
        function generateTorso() {
          const indexArray = [];
          const r = radiusTop - radiusBottom;
          const slope = r * r / height * Math.sign(r);
          for (let y = 0; y <= heightSegments; y++) {
            const indexRow = [];
            const v = y / heightSegments;
            const radius = v * r + radiusBottom;
            for (let x = 0; x <= radialSegments; ++x) {
              const u = x / radialSegments;
              const theta = u * arc;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              positions[3 * index] = radius * sinTheta;
              positions[3 * index + 1] = v * height - halfHeight;
              positions[3 * index + 2] = radius * cosTheta;
              Vec3.normalize(temp1$2, Vec3.set(temp2$2, sinTheta, -slope, cosTheta));
              normals[3 * index] = temp1$2.x;
              normals[3 * index + 1] = temp1$2.y;
              normals[3 * index + 2] = temp1$2.z;
              uvs[2 * index] = (1 - u) * 2 % 1;
              uvs[2 * index + 1] = v;
              indexRow.push(index);
              ++index;
            }
            indexArray.push(indexRow);
          }
          for (let y = 0; y < heightSegments; ++y) {
            for (let x = 0; x < radialSegments; ++x) {
              const i1 = indexArray[y][x];
              const i2 = indexArray[y + 1][x];
              const i3 = indexArray[y + 1][x + 1];
              const i4 = indexArray[y][x + 1];
              indices[indexOffset] = i1;
              ++indexOffset;
              indices[indexOffset] = i4;
              ++indexOffset;
              indices[indexOffset] = i2;
              ++indexOffset;
              indices[indexOffset] = i4;
              ++indexOffset;
              indices[indexOffset] = i3;
              ++indexOffset;
              indices[indexOffset] = i2;
              ++indexOffset;
            }
          }
        }
        function generateCap(top) {
          const radius = top ? radiusTop : radiusBottom;
          const sign = top ? 1 : -1;
          const centerIndexStart = index;
          for (let x = 1; x <= radialSegments; ++x) {
            positions[3 * index] = 0;
            positions[3 * index + 1] = halfHeight * sign;
            positions[3 * index + 2] = 0;
            normals[3 * index] = 0;
            normals[3 * index + 1] = sign;
            normals[3 * index + 2] = 0;
            uvs[2 * index] = 0.5;
            uvs[2 * index + 1] = 0.5;
            ++index;
          }
          const centerIndexEnd = index;
          for (let x = 0; x <= radialSegments; ++x) {
            const u = x / radialSegments;
            const theta = u * arc;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            positions[3 * index] = radius * sinTheta;
            positions[3 * index + 1] = halfHeight * sign;
            positions[3 * index + 2] = radius * cosTheta;
            normals[3 * index] = 0;
            normals[3 * index + 1] = sign;
            normals[3 * index + 2] = 0;
            uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
            uvs[2 * index + 1] = 0.5 + cosTheta * 0.5;
            ++index;
          }
          for (let x = 0; x < radialSegments; ++x) {
            const c = centerIndexStart + x;
            const i = centerIndexEnd + x;
            if (top) {
              indices[indexOffset] = i + 1;
              ++indexOffset;
              indices[indexOffset] = c;
              ++indexOffset;
              indices[indexOffset] = i;
              ++indexOffset;
            } else {
              indices[indexOffset] = c;
              ++indexOffset;
              indices[indexOffset] = i + 1;
              ++indexOffset;
              indices[indexOffset] = i;
              ++indexOffset;
            }
          }
        }
      }

      function cone(radius = 0.5, height = 1, opts = {}) {
        return cylinder(0, radius, height, opts);
      }

      function applyDefaultPlaneOptions(options) {
        options = applyDefaultGeometryOptions(options);
        options.width = options.width || 10;
        options.length = options.length || 10;
        options.widthSegments = options.widthSegments || 10;
        options.lengthSegments = options.lengthSegments || 10;
        return options;
      }
      const temp1$1 = new Vec3(0, 0, 0);
      const temp2$1 = new Vec3(0, 0, 0);
      const temp3 = new Vec3(0, 0, 0);
      const r = new Vec3(0, 0, 0);
      const c00 = new Vec3(0, 0, 0);
      const c10 = new Vec3(0, 0, 0);
      const c01 = new Vec3(0, 0, 0);
      function plane(options) {
        const normalizedOptions = applyDefaultPlaneOptions(options);
        const {
          width,
          length,
          widthSegments: uSegments,
          lengthSegments: vSegments
        } = normalizedOptions;
        const hw = width * 0.5;
        const hl = length * 0.5;
        const positions = [];
        const uvs = [];
        const indices = [];
        const minPos = new Vec3(-hw, 0, -hl);
        const maxPos = new Vec3(hw, 0, hl);
        const boundingRadius = Math.sqrt(width * width + length * length);
        Vec3.set(c00, -hw, 0, hl);
        Vec3.set(c10, hw, 0, hl);
        Vec3.set(c01, -hw, 0, -hl);
        for (let y = 0; y <= vSegments; y++) {
          for (let x = 0; x <= uSegments; x++) {
            const u = x / uSegments;
            const v = y / vSegments;
            Vec3.lerp(temp1$1, c00, c10, u);
            Vec3.lerp(temp2$1, c00, c01, v);
            Vec3.subtract(temp3, temp2$1, c00);
            Vec3.add(r, temp1$1, temp3);
            positions.push(r.x, r.y, r.z);
            if (normalizedOptions.includeUV) {
              uvs.push(u, v);
            }
            if (x < uSegments && y < vSegments) {
              const useg1 = uSegments + 1;
              const a = x + y * useg1;
              const b = x + (y + 1) * useg1;
              const c = x + 1 + (y + 1) * useg1;
              const d = x + 1 + y * useg1;
              indices.push(a, d, b);
              indices.push(d, c, b);
            }
          }
        }
        const result = {
          positions,
          indices,
          minPos,
          maxPos,
          boundingRadius
        };
        if (normalizedOptions.includeNormal) {
          const nVertex = (vSegments + 1) * (uSegments + 1);
          const normals = new Array(3 * nVertex);
          result.normals = normals;
          for (let i = 0; i < nVertex; ++i) {
            normals[i * 3 + 0] = 0;
            normals[i * 3 + 1] = 1;
            normals[i * 3 + 2] = 0;
          }
        }
        if (normalizedOptions.includeUV) {
          result.uvs = uvs;
        }
        return result;
      }

      function quad(options) {
        const normalizedOptions = applyDefaultGeometryOptions(options);
        const result = {
          positions: [-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0],
          indices: [0, 3, 1, 3, 2, 1],
          minPos: {
            x: -0.5,
            y: -0.5,
            z: 0
          },
          maxPos: {
            x: 0.5,
            y: 0.5,
            z: 0
          },
          boundingRadius: Math.sqrt(0.5 * 0.5 + 0.5 * 0.5)
        };
        if (normalizedOptions.includeNormal !== false) {
          result.normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
        }
        if (normalizedOptions.includeUV !== false) {
          result.uvs = [0, 0, 0, 1, 1, 1, 1, 0];
        }
        return result;
      }

      function sphere(radius = 0.5, opts = {}) {
        const segments = opts.segments !== undefined ? opts.segments : 32;
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        const minPos = new Vec3(-radius, -radius, -radius);
        const maxPos = new Vec3(radius, radius, radius);
        const boundingRadius = radius;
        for (let lat = 0; lat <= segments; ++lat) {
          const theta = lat * Math.PI / segments;
          const sinTheta = Math.sin(theta);
          const cosTheta = -Math.cos(theta);
          for (let lon = 0; lon <= segments; ++lon) {
            const phi = lon * 2 * Math.PI / segments - Math.PI / 2.0;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
            const x = sinPhi * sinTheta;
            const y = cosTheta;
            const z = cosPhi * sinTheta;
            const u = lon / segments;
            const v = lat / segments;
            positions.push(x * radius, y * radius, z * radius);
            normals.push(x, y, z);
            uvs.push(u, v);
            if (lat < segments && lon < segments) {
              const seg1 = segments + 1;
              const a = seg1 * lat + lon;
              const b = seg1 * (lat + 1) + lon;
              const c = seg1 * (lat + 1) + lon + 1;
              const d = seg1 * lat + lon + 1;
              indices.push(a, d, b);
              indices.push(d, c, b);
            }
          }
        }
        return {
          positions,
          indices,
          normals,
          uvs,
          minPos,
          maxPos,
          boundingRadius
        };
      }

      function torus(radius = 0.4, tube = 0.1, opts = {}) {
        const radialSegments = opts.radialSegments || 32;
        const tubularSegments = opts.tubularSegments || 32;
        const arc = opts.arc || 2.0 * Math.PI;
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        const minPos = new Vec3(-radius - tube, -tube, -radius - tube);
        const maxPos = new Vec3(radius + tube, tube, radius + tube);
        const boundingRadius = radius + tube;
        for (let j = 0; j <= radialSegments; j++) {
          for (let i = 0; i <= tubularSegments; i++) {
            const u = i / tubularSegments;
            const v = j / radialSegments;
            const u1 = u * arc;
            const v1 = v * Math.PI * 2;
            const x = (radius + tube * Math.cos(v1)) * Math.sin(u1);
            const y = tube * Math.sin(v1);
            const z = (radius + tube * Math.cos(v1)) * Math.cos(u1);
            const nx = Math.sin(u1) * Math.cos(v1);
            const ny = Math.sin(v1);
            const nz = Math.cos(u1) * Math.cos(v1);
            positions.push(x, y, z);
            normals.push(nx, ny, nz);
            uvs.push(u, v);
            if (i < tubularSegments && j < radialSegments) {
              const seg1 = tubularSegments + 1;
              const a = seg1 * j + i;
              const b = seg1 * (j + 1) + i;
              const c = seg1 * (j + 1) + i + 1;
              const d = seg1 * j + i + 1;
              indices.push(a, d, b);
              indices.push(d, c, b);
            }
          }
        }
        return {
          positions,
          normals,
          uvs,
          indices,
          minPos,
          maxPos,
          boundingRadius
        };
      }

      const temp1 = new Vec3(0, 0, 0);
      const temp2 = new Vec3(0, 0, 0);
      function capsule(radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts = {}) {
        const torsoHeight = height - radiusTop - radiusBottom;
        const sides = opts.sides || 32;
        const heightSegments = opts.heightSegments || 32;
        const bottomProp = radiusBottom / height;
        const torProp = torsoHeight / height;
        const topProp = radiusTop / height;
        const bottomSegments = Math.floor(heightSegments * bottomProp);
        const topSegments = Math.floor(heightSegments * topProp);
        const torSegments = Math.floor(heightSegments * torProp);
        const topOffset = torsoHeight + radiusBottom - height / 2;
        const torOffset = radiusBottom - height / 2;
        const bottomOffset = radiusBottom - height / 2;
        const arc = opts.arc || 2.0 * Math.PI;
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        const maxRadius = Math.max(radiusTop, radiusBottom);
        const minPos = new Vec3(-maxRadius, -height / 2, -maxRadius);
        const maxPos = new Vec3(maxRadius, height / 2, maxRadius);
        const boundingRadius = height / 2;
        let index = 0;
        const indexArray = [];
        generateBottom();
        generateTorso();
        generateTop();
        return {
          positions,
          normals,
          uvs,
          indices,
          minPos,
          maxPos,
          boundingRadius
        };
        function generateTorso() {
          const slope = (radiusTop - radiusBottom) / torsoHeight;
          for (let y = 0; y <= torSegments; y++) {
            const indexRow = [];
            const lat = y / torSegments;
            const radius = lat * (radiusTop - radiusBottom) + radiusBottom;
            for (let x = 0; x <= sides; ++x) {
              const u = x / sides;
              const v = lat * torProp + bottomProp;
              const theta = u * arc - arc / 4;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              positions.push(radius * sinTheta);
              positions.push(lat * torsoHeight + torOffset);
              positions.push(radius * cosTheta);
              Vec3.normalize(temp1, Vec3.set(temp2, sinTheta, -slope, cosTheta));
              normals.push(temp1.x);
              normals.push(temp1.y);
              normals.push(temp1.z);
              uvs.push(u, v);
              indexRow.push(index);
              ++index;
            }
            indexArray.push(indexRow);
          }
          for (let y = 0; y < torSegments; ++y) {
            for (let x = 0; x < sides; ++x) {
              const i1 = indexArray[y][x];
              const i2 = indexArray[y + 1][x];
              const i3 = indexArray[y + 1][x + 1];
              const i4 = indexArray[y][x + 1];
              indices.push(i1);
              indices.push(i4);
              indices.push(i2);
              indices.push(i4);
              indices.push(i3);
              indices.push(i2);
            }
          }
        }
        function generateBottom() {
          for (let lat = 0; lat <= bottomSegments; ++lat) {
            const theta = lat * Math.PI / bottomSegments / 2;
            const sinTheta = Math.sin(theta);
            const cosTheta = -Math.cos(theta);
            for (let lon = 0; lon <= sides; ++lon) {
              const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
              const sinPhi = Math.sin(phi);
              const cosPhi = Math.cos(phi);
              const x = sinPhi * sinTheta;
              const y = cosTheta;
              const z = cosPhi * sinTheta;
              const u = lon / sides;
              const v = lat / heightSegments;
              positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
              normals.push(x, y, z);
              uvs.push(u, v);
              if (lat < bottomSegments && lon < sides) {
                const seg1 = sides + 1;
                const a = seg1 * lat + lon;
                const b = seg1 * (lat + 1) + lon;
                const c = seg1 * (lat + 1) + lon + 1;
                const d = seg1 * lat + lon + 1;
                indices.push(a, d, b);
                indices.push(d, c, b);
              }
              ++index;
            }
          }
        }
        function generateTop() {
          for (let lat = 0; lat <= topSegments; ++lat) {
            const theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
            const sinTheta = Math.sin(theta);
            const cosTheta = -Math.cos(theta);
            for (let lon = 0; lon <= sides; ++lon) {
              const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
              const sinPhi = Math.sin(phi);
              const cosPhi = Math.cos(phi);
              const x = sinPhi * sinTheta;
              const y = cosTheta;
              const z = cosPhi * sinTheta;
              const u = lon / sides;
              const v = lat / heightSegments + (1 - topProp);
              positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
              normals.push(x, y, z);
              uvs.push(u, v);
              if (lat < topSegments && lon < sides) {
                const seg1 = sides + 1;
                const a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
                const b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
                const c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
                const d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                indices.push(a, d, b);
                indices.push(d, c, b);
              }
            }
          }
        }
      }

      function applyDefaultCircleOptions(options) {
        options = applyDefaultGeometryOptions(options);
        options.segments = 64;
        return options;
      }
      function circle(options) {
        const normalizedOptions = applyDefaultCircleOptions(options);
        const segments = normalizedOptions.segments;
        const positions = new Array(3 * (segments + 1));
        positions[0] = 0;
        positions[1] = 0;
        positions[2] = 0;
        const indices = new Array(1 + segments * 2);
        indices[0] = 0;
        const step = Math.PI * 2 / segments;
        for (let iSegment = 0; iSegment < segments; ++iSegment) {
          const angle = step * iSegment;
          const x = Math.cos(angle);
          const y = Math.sin(angle);
          const p = (iSegment + 1) * 3;
          positions[p + 0] = x;
          positions[p + 1] = y;
          positions[p + 2] = 0;
          const i = iSegment * 2;
          indices[1 + i] = iSegment + 1;
          indices[1 + (i + 1)] = iSegment + 2;
        }
        if (segments > 0) {
          indices[indices.length - 1] = 1;
        }
        const result = {
          positions,
          indices,
          minPos: {
            x: 1,
            y: 1,
            z: 0
          },
          maxPos: {
            x: -1,
            y: -1,
            z: 0
          },
          boundingRadius: 1,
          primitiveMode: PrimitiveMode.TRIANGLE_FAN
        };
        return result;
      }

      function translate(geometry, offset) {
        const x = offset.x || 0;
        const y = offset.y || 0;
        const z = offset.z || 0;
        const nVertex = Math.floor(geometry.positions.length / 3);
        for (let iVertex = 0; iVertex < nVertex; ++iVertex) {
          const iX = iVertex * 3;
          const iY = iVertex * 3 + 1;
          const iZ = iVertex * 3 + 2;
          geometry.positions[iX] += x;
          geometry.positions[iY] += y;
          geometry.positions[iZ] += z;
        }
        if (geometry.minPos) {
          geometry.minPos.x += x;
          geometry.minPos.y += y;
          geometry.minPos.z += z;
        }
        if (geometry.maxPos) {
          geometry.maxPos.x += x;
          geometry.maxPos.y += y;
          geometry.maxPos.z += z;
        }
        return geometry;
      }
      function scale(geometry, value) {
        var _value$x, _value$y, _value$z;
        const x = (_value$x = value.x) !== null && _value$x !== void 0 ? _value$x : 1.0;
        const y = (_value$y = value.y) !== null && _value$y !== void 0 ? _value$y : 1.0;
        const z = (_value$z = value.z) !== null && _value$z !== void 0 ? _value$z : 1.0;
        const nVertex = Math.floor(geometry.positions.length / 3);
        for (let iVertex = 0; iVertex < nVertex; ++iVertex) {
          const iX = iVertex * 3;
          const iY = iVertex * 3 + 1;
          const iZ = iVertex * 3 + 2;
          geometry.positions[iX] *= x;
          geometry.positions[iY] *= y;
          geometry.positions[iZ] *= z;
        }
        const {
          minPos,
          maxPos
        } = geometry;
        if (minPos) {
          minPos.x *= x;
          minPos.y *= y;
          minPos.z *= z;
        }
        if (maxPos) {
          maxPos.x *= x;
          maxPos.y *= y;
          maxPos.z *= z;
        }
        if (minPos && maxPos) {
          if (x < 0) {
            const tmp = minPos.x;
            minPos.x = maxPos.x;
            maxPos.x = tmp;
          }
          if (y < 0) {
            const tmp = minPos.y;
            minPos.y = maxPos.y;
            maxPos.y = tmp;
          }
          if (z < 0) {
            const tmp = minPos.z;
            minPos.z = maxPos.z;
            maxPos.z = tmp;
          }
        }
        if (typeof geometry.boundingRadius !== 'undefined') {
          geometry.boundingRadius *= Math.max(Math.max(Math.abs(x), Math.abs(y)), Math.abs(z));
        }
        return geometry;
      }
      function wireframed(geometry) {
        const {
          indices
        } = geometry;
        if (!indices) {
          return geometry;
        }
        if (geometry.primitiveMode && geometry.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
          return geometry;
        }
        const offsets = [[0, 1], [1, 2], [2, 0]];
        const lines = [];
        const lineIDs = {};
        for (let i = 0; i < indices.length; i += 3) {
          for (let k = 0; k < 3; ++k) {
            const i1 = indices[i + offsets[k][0]];
            const i2 = indices[i + offsets[k][1]];
            const id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            if (lineIDs[id] === undefined) {
              lineIDs[id] = 0;
              lines.push(i1, i2);
            }
          }
        }
        geometry.indices = lines;
        geometry.primitiveMode = PrimitiveMode.LINE_LIST;
        return geometry;
      }

      var primitives = /*#__PURE__*/Object.freeze({
        __proto__: null,
        box: box,
        cone: cone,
        cylinder: cylinder,
        plane: plane,
        quad: quad,
        sphere: sphere,
        torus: torus,
        capsule: capsule,
        circle: circle,
        translate: translate,
        scale: scale,
        wireframed: wireframed,
        wireframe: wireframe,
        invWinding: invWinding,
        toWavefrontOBJ: toWavefrontOBJ,
        normals: normals,
        applyDefaultGeometryOptions: applyDefaultGeometryOptions
      });
      exports('primitives', primitives);

      function setWrap(object, wrapper) {
        object.__cc_wrapper__ = wrapper;
      }
      function getWrap(object) {
        return object.__cc_wrapper__;
      }
      function maxComponent(v) {
        return Math.max(v.x, Math.max(v.y, v.z));
      }
      const VEC3_0 = new Vec3();
      const TriggerEventObject$1 = {
        type: 'onTriggerEnter',
        selfCollider: null,
        otherCollider: null,
        impl: null
      };
      const CharacterTriggerEventObject$1 = {
        type: 'onControllerTriggerEnter',
        collider: null,
        characterController: null,
        impl: null
      };
      const CollisionEventObject$1 = {
        type: 'onCollisionEnter',
        selfCollider: null,
        otherCollider: null,
        contacts: [],
        impl: null
      };
      function shrinkPositions(buffer) {
        const pos = [];
        const posHashMap = {};
        if (buffer.length >= 3) {
          pos[0] = buffer[0];
          pos[1] = buffer[1];
          pos[2] = buffer[2];
          const len = buffer.length;
          for (let i = 3; i < len; i += 3) {
            const p0 = buffer[i];
            const p1 = buffer[i + 1];
            const p2 = buffer[i + 2];
            const str = String(p0) + String(p1) + String(p2);
            const hash = murmurhash2_32_gc(str, 666);
            if (posHashMap[hash] !== str) {
              posHashMap[hash] = str;
              pos.push(p0);
              pos.push(p1);
              pos.push(p2);
            }
          }
        }
        return pos;
      }
      function absolute(v) {
        v.x = Math.abs(v.x);
        v.y = Math.abs(v.y);
        v.z = Math.abs(v.z);
        return v;
      }

      var util = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setWrap: setWrap,
        getWrap: getWrap,
        maxComponent: maxComponent,
        VEC3_0: VEC3_0,
        TriggerEventObject: TriggerEventObject$1,
        CharacterTriggerEventObject: CharacterTriggerEventObject$1,
        CollisionEventObject: CollisionEventObject$1,
        shrinkPositions: shrinkPositions,
        absolute: absolute,
        cylinder: cylinder
      });

      var _dec$Z, _dec2$T, _dec3$G, _dec4$z, _dec5$w, _dec6$j, _dec7$f, _dec8$c, _dec9$b, _dec10$7, _class$X, _class2$W, _initializer$T, _initializer2$P, _initializer3$E, _initializer4$y, _initializer5$s, _initializer6$m, _initializer7$j, _initializer8$h, _initializer9$f, _initializer10$d, _class3$p;
      let ProbeResolution;
      (function (ProbeResolution) {
        ProbeResolution[ProbeResolution["Low_256x256"] = 256] = "Low_256x256";
        ProbeResolution[ProbeResolution["Medium_512x512"] = 512] = "Medium_512x512";
        ProbeResolution[ProbeResolution["High_768x768"] = 768] = "High_768x768";
      })(ProbeResolution || (ProbeResolution = {}));
      let ReflectionProbe = exports('ReflectionProbe', (_dec$Z = ccclass$6('cc.ReflectionProbe'), _dec2$T = type$6(Vec3), _dec3$G = type$6(Enum(ProbeType)), _dec4$z = type$6(Enum(ProbeResolution)), _dec5$w = type$6(Enum(ProbeClearFlag)), _dec6$j = type$6(Color$1), _dec7$f = type$6(Layers.BitMask), _dec8$c = type$6(Camera), _dec9$b = type$6(CCBoolean), _dec10$7 = type$6(TextureCube), _dec$Z(_class$X = (_class2$W = (_class3$p = class ReflectionProbe extends Component {
        constructor(...args) {
          super(...args);
          this._lastSize = new Vec3();
          this._resolution = _initializer$T && _initializer$T();
          this._clearFlag = _initializer2$P && _initializer2$P();
          this._backgroundColor = _initializer3$E && _initializer3$E();
          this._visibility = _initializer4$y && _initializer4$y();
          this._probeType = _initializer5$s && _initializer5$s();
          this._cubemap = _initializer6$m && _initializer6$m();
          this._size = _initializer7$j && _initializer7$j();
          this._sourceCamera = _initializer8$h && _initializer8$h();
          this._probeId = _initializer9$f && _initializer9$f();
          this._fastBake = _initializer10$d && _initializer10$d();
          this._probe = null;
          this._previewSphere = null;
          this._previewPlane = null;
          this._sourceCameraPos = new Vec3(0, 0, 0);
          this._position = new Vec3(0, 0, 0);
        }
        set size(value) {
          this._size.set(value);
          absolute(this._size);
          this.probe.size = this._size;
          if (this.probe) {
            this.probe.updateBoundingBox();
            ReflectionProbeManager.probeManager.onUpdateProbes();
            ReflectionProbeManager.probeManager.updateProbeData();
            ReflectionProbeManager.probeManager.updateProbeOfModels();
          }
        }
        get size() {
          return this._size;
        }
        set probeType(value) {
          this.probe.probeType = value;
          if (value !== this._probeType) {
            const lastSize = this._size.clone();
            const lastSizeIsNoExist = Vec3.equals(this._lastSize, Vec3.ZERO);
            this._probeType = value;
            if (this._probeType === ProbeType.CUBE) {
              if (lastSizeIsNoExist) {
                this._size.set(ReflectionProbe.DEFAULT_CUBE_SIZE);
              }
              this.probe.switchProbeType(value, null);
              ReflectionProbeManager.probeManager.clearPlanarReflectionMap(this.probe);
            } else {
              if (lastSizeIsNoExist) {
                this._size.set(ReflectionProbe.DEFAULT_PLANER_SIZE);
              }
              if (!this._sourceCamera) {
                warn('the reflection camera is invalid, please set the reflection camera');
              } else {
                this.probe.switchProbeType(value, this._sourceCamera.camera);
              }
            }
            if (!lastSizeIsNoExist) {
              this._size.set(this._lastSize);
            }
            this._lastSize.set(lastSize);
            this.size = this._size;
          }
        }
        get probeType() {
          return this._probeType;
        }
        set resolution(value) {
          this._resolution = value;
          this.probe.resolution = value;
        }
        get resolution() {
          return this._resolution;
        }
        set clearFlag(value) {
          this._clearFlag = value;
          this.probe.clearFlag = this._clearFlag;
        }
        get clearFlag() {
          return this._clearFlag;
        }
        set backgroundColor(val) {
          this._backgroundColor = val;
          this.probe.backgroundColor = this._backgroundColor;
        }
        get backgroundColor() {
          return this._backgroundColor;
        }
        get visibility() {
          return this._visibility;
        }
        set visibility(val) {
          this._visibility = val;
          this.probe.visibility = this._visibility;
        }
        set sourceCamera(camera) {
          this._sourceCamera = camera;
          if (camera) {
            this.visibility = camera.visibility;
            this.clearFlag = camera.clearFlags;
            this.backgroundColor = camera.clearColor;
            if (this.probeType === ProbeType.PLANAR) {
              this.probe.switchProbeType(this.probeType, camera.camera);
            }
          }
        }
        get sourceCamera() {
          return this._sourceCamera;
        }
        get fastBake() {
          return this._fastBake;
        }
        set fastBake(val) {
          this._fastBake = val;
        }
        set cubemap(val) {
          this._cubemap = val;
          this.probe.cubemap = val;
          ReflectionProbeManager.probeManager.onUpdateProbes();
        }
        get cubemap() {
          return this._cubemap;
        }
        get probe() {
          return this._probe;
        }
        set previewSphere(val) {
          this._previewSphere = val;
          if (this.probe) {
            this.probe.previewSphere = val;
            if (this._previewSphere) {
              ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
            }
          }
        }
        get previewSphere() {
          return this._previewSphere;
        }
        set previewPlane(val) {
          this._previewPlane = val;
          if (this.probe) {
            this.probe.previewPlane = val;
            if (this._previewPlane) {
              ReflectionProbeManager.probeManager.updatePreviewPlane(this.probe);
            }
          }
        }
        get previewPlane() {
          return this._previewPlane;
        }
        onLoad() {
          this._createProbe();
        }
        onEnable() {
          if (this._probe) {
            const probe = ReflectionProbeManager.probeManager.getProbeById(this._probeId);
            if (probe !== null && probe !== this._probe) {
              this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();
              this._probe.updateProbeId(this._probeId);
            }
            ReflectionProbeManager.probeManager.register(this._probe);
            ReflectionProbeManager.probeManager.onUpdateProbes();
            this._probe.enable();
          }
        }
        onDisable() {
          if (this._probe) {
            ReflectionProbeManager.probeManager.unregister(this._probe);
            this._probe.disable();
          }
        }
        start() {
          if (this._sourceCamera && this.probeType === ProbeType.PLANAR) {
            this.probe.renderPlanarReflection(this.sourceCamera.camera);
            ReflectionProbeManager.probeManager.filterModelsForPlanarReflection();
          }
          ReflectionProbeManager.probeManager.updateProbeData();
          this._position = this.node.getWorldPosition().clone();
        }
        onDestroy() {
          if (this.probe) {
            this.probe.destroy();
          }
        }
        update(dt) {
          if (!this.probe) return;
          if (this.probeType === ProbeType.PLANAR && this.sourceCamera) {
            if (this.sourceCamera.node.hasChangedFlags & TransformBit.TRS || !this._sourceCameraPos.equals(this.sourceCamera.node.getWorldPosition())) {
              this._sourceCameraPos = this.sourceCamera.node.getWorldPosition();
              this.probe.renderPlanarReflection(this.sourceCamera.camera);
            }
          }
          if (this.node.hasChangedFlags & TransformBit.POSITION) {
            this.probe.updateBoundingBox();
            ReflectionProbeManager.probeManager.onUpdateProbes();
            ReflectionProbeManager.probeManager.updateProbeData();
          }
          {
            const worldPos = this.node.getWorldPosition();
            if (!this._position.equals(worldPos)) {
              this._position = worldPos;
              this.probe.updateBoundingBox();
              ReflectionProbeManager.probeManager.updateProbeData();
              ReflectionProbeManager.probeManager.updateProbeOfModels();
            }
          }
        }
        clearBakedCubemap() {
          this.cubemap = null;
          ReflectionProbeManager.probeManager.updateBakedCubemap(this.probe);
          ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
        }
        _createProbe() {
          if (this._probeId === -1 || ReflectionProbeManager.probeManager.exists(this._probeId)) {
            this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();
          }
          this._probe = new ReflectionProbe$1(this._probeId);
          if (this._probe) {
            const cameraNode = new Node$1('ReflectionProbeCamera');
            cameraNode.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
            this.node.scene.addChild(cameraNode);
            this._probe.initialize(this.node, cameraNode);
            if (this.enabled) {
              ReflectionProbeManager.probeManager.register(this._probe);
            }
            this._probe.resolution = this._resolution;
            this._probe.clearFlag = this._clearFlag;
            this._probe.backgroundColor = this._backgroundColor;
            this._probe.visibility = this._visibility;
            this._probe.probeType = this._probeType;
            this._probe.size = this._size;
            this._probe.cubemap = this._cubemap;
          }
        }
      }, _class3$p.DEFAULT_CUBE_SIZE = new Vec3(1, 1, 1), _class3$p.DEFAULT_PLANER_SIZE = new Vec3(5, 0.5, 5), _class3$p), (_initializer$T = applyDecoratedInitializer(_class2$W.prototype, "_resolution", [serializable$6], function () {
        return 256;
      }), _initializer2$P = applyDecoratedInitializer(_class2$W.prototype, "_clearFlag", [serializable$6], function () {
        return ProbeClearFlag.SKYBOX;
      }), _initializer3$E = applyDecoratedInitializer(_class2$W.prototype, "_backgroundColor", [serializable$6], function () {
        return new Color$1(0, 0, 0, 255);
      }), _initializer4$y = applyDecoratedInitializer(_class2$W.prototype, "_visibility", [serializable$6], function () {
        return CAMERA_DEFAULT_MASK;
      }), _initializer5$s = applyDecoratedInitializer(_class2$W.prototype, "_probeType", [serializable$6], function () {
        return ProbeType.CUBE;
      }), _initializer6$m = applyDecoratedInitializer(_class2$W.prototype, "_cubemap", [serializable$6], function () {
        return null;
      }), _initializer7$j = applyDecoratedInitializer(_class2$W.prototype, "_size", [serializable$6], function () {
        return new Vec3(1, 1, 1);
      }), _initializer8$h = applyDecoratedInitializer(_class2$W.prototype, "_sourceCamera", [serializable$6], function () {
        return null;
      }), _initializer9$f = applyDecoratedInitializer(_class2$W.prototype, "_probeId", [serializable$6], function () {
        return -1;
      }), _initializer10$d = applyDecoratedInitializer(_class2$W.prototype, "_fastBake", [serializable$6], function () {
        return false;
      }), _applyDecoratedDescriptor(_class2$W.prototype, "size", [_dec2$T], Object.getOwnPropertyDescriptor(_class2$W.prototype, "size"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "probeType", [_dec3$G], Object.getOwnPropertyDescriptor(_class2$W.prototype, "probeType"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "resolution", [_dec4$z], Object.getOwnPropertyDescriptor(_class2$W.prototype, "resolution"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "clearFlag", [_dec5$w], Object.getOwnPropertyDescriptor(_class2$W.prototype, "clearFlag"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "backgroundColor", [_dec6$j], Object.getOwnPropertyDescriptor(_class2$W.prototype, "backgroundColor"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "visibility", [_dec7$f], Object.getOwnPropertyDescriptor(_class2$W.prototype, "visibility"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "sourceCamera", [_dec8$c], Object.getOwnPropertyDescriptor(_class2$W.prototype, "sourceCamera"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "fastBake", [_dec9$b], Object.getOwnPropertyDescriptor(_class2$W.prototype, "fastBake"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "cubemap", [_dec10$7], Object.getOwnPropertyDescriptor(_class2$W.prototype, "cubemap"), _class2$W.prototype)), _class2$W)) || _class$X));

      legacyCC.utils = utils;

      let AudioEvent;
      (function (AudioEvent) {
        AudioEvent["PLAYED"] = "play";
        AudioEvent["PAUSED"] = "pause";
        AudioEvent["STOPPED"] = "stop";
        AudioEvent["SEEKED"] = "seeked";
        AudioEvent["ENDED"] = "ended";
        AudioEvent["INTERRUPTION_BEGIN"] = "interruptionBegin";
        AudioEvent["INTERRUPTION_END"] = "interruptionEnd";
        AudioEvent["USER_GESTURE"] = "on_gesture";
      })(AudioEvent || (AudioEvent = {}));
      let AudioType;
      (function (AudioType) {
        AudioType[AudioType["DOM_AUDIO"] = 0] = "DOM_AUDIO";
        AudioType[AudioType["WEB_AUDIO"] = 1] = "WEB_AUDIO";
        AudioType[AudioType["MINIGAME_AUDIO"] = 2] = "MINIGAME_AUDIO";
        AudioType[AudioType["NATIVE_AUDIO"] = 3] = "NATIVE_AUDIO";
        AudioType[AudioType["UNKNOWN_AUDIO"] = 4] = "UNKNOWN_AUDIO";
      })(AudioType || (AudioType = {}));
      let AudioState;
      (function (AudioState) {
        AudioState[AudioState["INIT"] = 0] = "INIT";
        AudioState[AudioState["PLAYING"] = 1] = "PLAYING";
        AudioState[AudioState["PAUSED"] = 2] = "PAUSED";
        AudioState[AudioState["STOPPED"] = 3] = "STOPPED";
        AudioState[AudioState["INTERRUPTED"] = 4] = "INTERRUPTED";
      })(AudioState || (AudioState = {}));
      class AudioPCMDataView {
        constructor(...args) {
          this._bufferView = void 0;
          this._normalizeFactor = 1;
          if (args.length === 2) {
            this._bufferView = args[0];
            this._normalizeFactor = args[1];
          } else {
            const arrayBuffer = args[0];
            const Ctor = args[1];
            const normalizeFactor = args[2];
            this._bufferView = new Ctor(arrayBuffer);
            this._normalizeFactor = normalizeFactor;
          }
        }
        get length() {
          return this._bufferView.length;
        }
        getData(offset) {
          return this._bufferView[offset] * this._normalizeFactor;
        }
      } exports('AudioPCMDataView', AudioPCMDataView);

      function removeUnneededCalls(instance) {
        const size = instance._operationQueue.length;
        const tmpQueue = instance._operationQueue.slice();
        const reserveOps = [];
        let seekSearched = false;
        for (let i = size - 1; i >= 0; i--) {
          const opInfo = tmpQueue[i];
          if (opInfo.op === 'stop') {
            reserveOps.push(opInfo);
            break;
          } else if (opInfo.op === 'seek') {
            if (!seekSearched) {
              reserveOps.push(opInfo);
              seekSearched = true;
            }
          } else if (seekSearched) {
            reserveOps.push(opInfo);
            break;
          } else if (reserveOps.length === 0) {
            reserveOps.push(opInfo);
          }
        }
        instance._operationQueue = reserveOps.reverse();
      }
      let operationId = 0;
      function _tryCallingRecursively(target, opInfo) {
        if (opInfo.invoking) {
          return;
        }
        opInfo.invoking = true;
        opInfo.func.call(target, ...opInfo.args).then(() => {
          opInfo.invoking = false;
          target._operationQueue.shift();
          target._eventTarget.emit(opInfo.id.toString());
          removeUnneededCalls(target);
          const nextOpInfo = target._operationQueue[0];
          if (nextOpInfo) {
            _tryCallingRecursively(target, nextOpInfo);
          }
        }).catch(e => {});
      }
      function enqueueOperation(target, propertyKey, descriptor) {
        const originalOperation = descriptor.value;
        descriptor.value = function (...args) {
          return new Promise(resolve => {
            const id = operationId++;
            const instance = this;
            instance._operationQueue.push({
              op: propertyKey,
              id,
              func: originalOperation,
              args,
              invoking: false
            });
            instance._eventTarget.once(id.toString(), resolve);
            const opInfo = instance._operationQueue[0];
            _tryCallingRecursively(instance, opInfo);
          });
        };
      }

      var _class2$V, _class3$o;
      const urlCount = {};
      const audioEngine = jsb.AudioEngine;
      const INVALID_AUDIO_ID = -1;
      var AudioBufferFormat;
      (function (AudioBufferFormat) {
        AudioBufferFormat[AudioBufferFormat["UNKNOWN"] = 0] = "UNKNOWN";
        AudioBufferFormat[AudioBufferFormat["SIGNED_8"] = 1] = "SIGNED_8";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_8"] = 2] = "UNSIGNED_8";
        AudioBufferFormat[AudioBufferFormat["SIGNED_16"] = 3] = "SIGNED_16";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_16"] = 4] = "UNSIGNED_16";
        AudioBufferFormat[AudioBufferFormat["SIGNED_32"] = 5] = "SIGNED_32";
        AudioBufferFormat[AudioBufferFormat["UNSIGNED_32"] = 6] = "UNSIGNED_32";
        AudioBufferFormat[AudioBufferFormat["FLOAT_32"] = 7] = "FLOAT_32";
        AudioBufferFormat[AudioBufferFormat["FLOAT_64"] = 8] = "FLOAT_64";
      })(AudioBufferFormat || (AudioBufferFormat = {}));
      const bufferConstructorMap = {
        [AudioBufferFormat.UNKNOWN]: undefined,
        [AudioBufferFormat.SIGNED_8]: {
          ctor: Int8Array,
          maxValue: 127
        },
        [AudioBufferFormat.UNSIGNED_8]: {
          ctor: Uint8Array,
          maxValue: 255
        },
        [AudioBufferFormat.SIGNED_16]: {
          ctor: Int16Array,
          maxValue: 32767
        },
        [AudioBufferFormat.UNSIGNED_16]: {
          ctor: Uint16Array,
          maxValue: 65535
        },
        [AudioBufferFormat.SIGNED_32]: {
          ctor: Int32Array,
          maxValue: 2147483647
        },
        [AudioBufferFormat.UNSIGNED_32]: {
          ctor: Uint32Array,
          maxValue: 4294967295
        },
        [AudioBufferFormat.FLOAT_32]: {
          ctor: Float32Array,
          maxValue: 1
        },
        [AudioBufferFormat.FLOAT_64]: {
          ctor: Float64Array,
          maxValue: 1
        }
      };
      class OneShotAudio {
        get onPlay() {
          return this._onPlayCb;
        }
        set onPlay(cb) {
          this._onPlayCb = cb;
        }
        get onEnd() {
          return this._onEndCb;
        }
        set onEnd(cb) {
          this._onEndCb = cb;
        }
        constructor(url, volume) {
          this._id = INVALID_AUDIO_ID;
          this._url = void 0;
          this._volume = void 0;
          this._onPlayCb = void 0;
          this._onEndCb = void 0;
          this._url = url;
          this._volume = volume;
        }
        play() {
          var _this$onPlay;
          this._id = jsb.AudioEngine.play2d(this._url, false, this._volume);
          jsb.AudioEngine.setFinishCallback(this._id, () => {
            var _this$onEnd;
            (_this$onEnd = this.onEnd) === null || _this$onEnd === void 0 ? void 0 : _this$onEnd.call(this);
          });
          (_this$onPlay = this.onPlay) === null || _this$onPlay === void 0 ? void 0 : _this$onPlay.call(this);
        }
        stop() {
          if (this._id === INVALID_AUDIO_ID) {
            return;
          }
          jsb.AudioEngine.stop(this._id);
        }
      }
      let AudioPlayer = (_class2$V = (_class3$o = class AudioPlayer {
        constructor(url) {
          this._url = void 0;
          this._id = INVALID_AUDIO_ID;
          this._state = AudioState.INIT;
          this._pcmHeader = void 0;
          this._eventTarget = new EventTarget();
          this._operationQueue = [];
          this._cachedState = {
            duration: 1,
            loop: false,
            currentTime: 0,
            volume: 1
          };
          this._url = url;
          this._pcmHeader = null;
          game.on(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
          game.on(Game.EVENT_RESUME, this._onInterruptedEnd, this);
        }
        destroy() {
          game.off(Game.EVENT_PAUSE, this._onInterruptedBegin, this);
          game.off(Game.EVENT_RESUME, this._onInterruptedEnd, this);
          if (--urlCount[this._url] <= 0) {
            audioEngine.uncache(this._url);
          }
        }
        _onInterruptedBegin() {
          if (this._state === AudioState.PLAYING) {
            this.pause().then(() => {
              this._state = AudioState.INTERRUPTED;
              this._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
            }).catch(e => {});
          }
        }
        _onInterruptedEnd() {
          if (this._state === AudioState.INTERRUPTED) {
            this.play().then(() => {
              this._eventTarget.emit(AudioEvent.INTERRUPTION_END);
            }).catch(e => {});
          }
        }
        static load(url, opts) {
          return new Promise((resolve, reject) => {
            AudioPlayer.loadNative(url, opts).then(url => {
              resolve(new AudioPlayer(url));
            }).catch(err => reject(err));
          });
        }
        static loadNative(url, opts) {
          return new Promise((resolve, reject) => {
            if (systemInfo.platform === Platform.WIN32) {
              audioEngine.preload(url, isSuccess => {
                console.debug('somehow preload success on windows');
              });
              resolve(url);
            } else {
              audioEngine.preload(url, isSuccess => {
                if (isSuccess) {
                  resolve(url);
                } else {
                  reject(new Error('load audio failed'));
                }
              });
            }
          });
        }
        static loadOneShotAudio(url, volume, opts) {
          return new Promise((resolve, reject) => {
            AudioPlayer.loadNative(url, opts).then(url => {
              resolve(new OneShotAudio(url, volume));
            }).catch(reject);
          });
        }
        get _isValid() {
          return this._id !== INVALID_AUDIO_ID;
        }
        get src() {
          return this._url;
        }
        get type() {
          return AudioType.NATIVE_AUDIO;
        }
        get state() {
          return this._state;
        }
        get loop() {
          if (!this._isValid) {
            return this._cachedState.loop;
          }
          return audioEngine.isLoop(this._id);
        }
        set loop(val) {
          if (this._isValid) {
            audioEngine.setLoop(this._id, val);
          }
          this._cachedState.loop = val;
        }
        get volume() {
          if (!this._isValid) {
            return this._cachedState.volume;
          }
          return audioEngine.getVolume(this._id);
        }
        set volume(val) {
          val = clamp01(val);
          if (this._isValid) {
            audioEngine.setVolume(this._id, val);
          }
          this._cachedState.volume = val;
        }
        get duration() {
          if (!this._isValid) {
            return this._cachedState.duration;
          }
          return audioEngine.getDuration(this._id);
        }
        get currentTime() {
          if (!this._isValid) {
            return this._cachedState.currentTime;
          }
          return audioEngine.getCurrentTime(this._id);
        }
        get sampleRate() {
          if (this._pcmHeader === null) {
            this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url);
          }
          return this._pcmHeader.sampleRate;
        }
        getPCMData(channelIndex) {
          const arrayBuffer = audioEngine.getOriginalPCMBuffer(this._url, channelIndex);
          if (this._pcmHeader === null) {
            this._pcmHeader = jsb.AudioEngine.getPCMHeader(this._url);
          }
          const audioBufferInfo = bufferConstructorMap[this._pcmHeader.audioFormat];
          if (!arrayBuffer || !audioBufferInfo) {
            return undefined;
          }
          return new AudioPCMDataView(arrayBuffer, audioBufferInfo.ctor, 1 / audioBufferInfo.maxValue);
        }
        seek(time) {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.setCurrentTime(this._id, time);
            }
            this._cachedState.currentTime = time;
            return resolve();
          });
        }
        play() {
          return new Promise(resolve => {
            if (this._isValid) {
              if (this._state === AudioState.PAUSED || this._state === AudioState.INTERRUPTED) {
                audioEngine.resume(this._id);
              } else if (this._state === AudioState.PLAYING) {
                audioEngine.pause(this._id);
                audioEngine.setCurrentTime(this._id, 0);
                audioEngine.resume(this._id);
              }
            } else {
              this._id = audioEngine.play2d(this._url, this._cachedState.loop, this._cachedState.volume);
              if (this._isValid) {
                if (this._cachedState.currentTime !== 0) {
                  audioEngine.setCurrentTime(this._id, this._cachedState.currentTime);
                  this._cachedState.currentTime = 0;
                }
                audioEngine.setFinishCallback(this._id, () => {
                  this._cachedState.currentTime = 0;
                  this._id = INVALID_AUDIO_ID;
                  this._state = AudioState.INIT;
                  this._eventTarget.emit(AudioEvent.ENDED);
                });
              }
            }
            this._state = AudioState.PLAYING;
            resolve();
          });
        }
        pause() {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.pause(this._id);
            }
            this._state = AudioState.PAUSED;
            resolve();
          });
        }
        stop() {
          return new Promise(resolve => {
            if (this._isValid) {
              audioEngine.stop(this._id);
            }
            this._state = AudioState.STOPPED;
            this._id = INVALID_AUDIO_ID;
            this._cachedState.currentTime = 0;
            resolve();
          });
        }
        onInterruptionBegin(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
        }
        offInterruptionBegin(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
        }
        onInterruptionEnd(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
        }
        offInterruptionEnd(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
        }
        onEnded(cb) {
          this._eventTarget.on(AudioEvent.ENDED, cb);
        }
        offEnded(cb) {
          this._eventTarget.off(AudioEvent.ENDED, cb);
        }
      }, _class3$o.maxAudioChannel = audioEngine.getMaxAudioInstance(), _class3$o), (_applyDecoratedDescriptor(_class2$V.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$V.prototype, "seek"), _class2$V.prototype), _applyDecoratedDescriptor(_class2$V.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$V.prototype, "play"), _class2$V.prototype), _applyDecoratedDescriptor(_class2$V.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$V.prototype, "pause"), _class2$V.prototype), _applyDecoratedDescriptor(_class2$V.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class2$V.prototype, "stop"), _class2$V.prototype)), _class2$V);
      legacyCC.AudioPlayer = AudioPlayer;

      var _dec$Y, _class$W, _class2$U, _initializer$S, _class3$n;
      let AudioClip = exports('AudioClip', (_dec$Y = ccclass$6('cc.AudioClip'), _dec$Y(_class$W = (_class2$U = (_class3$n = class AudioClip extends Asset {
        constructor(...args) {
          super(...args);
          this._duration = _initializer$S && _initializer$S();
          this._loadMode = AudioType.UNKNOWN_AUDIO;
          this._meta = null;
          this._player = null;
        }
        set duration(v) {
          this._duration = v;
        }
        destroy() {
          var _this$_player;
          const destroyResult = super.destroy();
          (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
          this._player = null;
          if (this._meta) {
            this._meta.player = null;
          }
          return destroyResult;
        }
        set _nativeAsset(meta) {
          this._meta = meta;
          if (meta) {
            this._loadMode = meta.type;
            this._player = meta.player;
          } else {
            this._meta = null;
            this._loadMode = AudioType.UNKNOWN_AUDIO;
            this._duration = 0;
          }
        }
        get _nativeAsset() {
          return this._meta;
        }
        get _nativeDep() {
          return {
            uuid: this._uuid,
            audioLoadMode: this.loadMode,
            ext: this._native,
            __isNative__: true
          };
        }
        get loadMode() {
          return this._loadMode;
        }
        validate() {
          return !!this._meta;
        }
        getDuration() {
          if (this._duration) {
            return this._duration;
          }
          return this._meta ? this._meta.duration : 0;
        }
        get state() {
          return this._player ? this._player.state : AudioState.INIT;
        }
        getCurrentTime() {
          return this._player ? this._player.currentTime : 0;
        }
        getVolume() {
          return this._player ? this._player.volume : 0;
        }
        getLoop() {
          return this._player ? this._player.loop : false;
        }
        setCurrentTime(time) {
          var _this$_player2;
          (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.seek(time).catch(e => {});
        }
        setVolume(volume) {
          if (this._player) {
            this._player.volume = volume;
          }
        }
        setLoop(loop) {
          if (this._player) {
            this._player.loop = loop;
          }
        }
        play() {
          var _this$_player3;
          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().catch(e => {});
        }
        pause() {
          var _this$_player4;
          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().catch(e => {});
        }
        stop() {
          var _this$_player5;
          (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().catch(e => {});
        }
        playOneShot(volume = 1) {
          if (this._nativeAsset) {
            AudioPlayer.loadOneShotAudio(this._nativeAsset.url, volume).then(oneShotAudio => {
              oneShotAudio.play();
            }).catch(e => {});
          }
        }
      }, _class3$n.AudioType = AudioType, _class3$n), (_initializer$S = applyDecoratedInitializer(_class2$U.prototype, "_duration", [serializable$6], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$U.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$U.prototype, "_nativeDep"), _class2$U.prototype)), _class2$U)) || _class$W));
      legacyCC.AudioClip = AudioClip;

      function loadAudioPlayer(url, options, onComplete) {
        AudioPlayer.load(url, {
          audioLoadMode: options.audioLoadMode
        }).then(player => {
          const audioMeta = {
            player,
            url,
            duration: player.duration,
            type: player.type
          };
          onComplete(null, audioMeta);
        }).catch(err => {
          onComplete(err);
        });
      }
      function createAudioClip(id, data, options, onComplete) {
        const out = new AudioClip();
        out._nativeUrl = id;
        out._nativeAsset = data;
        out.duration = data.duration;
        onComplete(null, out);
      }
      downloader$1.register({
        '.mp3': loadAudioPlayer,
        '.ogg': loadAudioPlayer,
        '.wav': loadAudioPlayer,
        '.m4a': loadAudioPlayer
      });
      factory.register({
        '.mp3': createAudioClip,
        '.ogg': createAudioClip,
        '.wav': createAudioClip,
        '.m4a': createAudioClip
      });

      class AudioManager {
        constructor() {
          this._oneShotAudioInfoList = [];
          this._audioPlayerInfoList = [];
        }
        _findIndex(audioInfoList, audio) {
          return audioInfoList.findIndex(item => item.audio === audio);
        }
        _tryAddPlaying(audioInfoList, audio) {
          const idx = this._findIndex(audioInfoList, audio);
          if (idx > -1) {
            audioInfoList[idx].playTime = performance.now();
            return false;
          }
          audioInfoList.push({
            audio,
            playTime: performance.now()
          });
          return true;
        }
        addPlaying(audio) {
          if (audio instanceof AudioPlayer) {
            this._tryAddPlaying(this._audioPlayerInfoList, audio);
          } else {
            this._tryAddPlaying(this._oneShotAudioInfoList, audio);
          }
        }
        _tryRemovePlaying(audioInfoList, audio) {
          const idx = this._findIndex(audioInfoList, audio);
          if (idx === -1) {
            return false;
          }
          fastRemoveAt$2(audioInfoList, idx);
          return true;
        }
        removePlaying(audio) {
          if (audio instanceof AudioPlayer) {
            this._tryRemovePlaying(this._audioPlayerInfoList, audio);
          } else {
            this._tryRemovePlaying(this._oneShotAudioInfoList, audio);
          }
        }
        discardOnePlayingIfNeeded() {
          if (this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < AudioPlayer.maxAudioChannel) {
            return;
          }
          let audioInfoToDiscard;
          if (this._oneShotAudioInfoList.length > 0) {
            this._oneShotAudioInfoList.forEach(audioInfo => {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          } else {
            this._audioPlayerInfoList.forEach(audioInfo => {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          }
          if (audioInfoToDiscard) {
            audioInfoToDiscard.audio.stop();
            this.removePlaying(audioInfoToDiscard.audio);
          }
        }
        pause() {
          this._oneShotAudioInfoList.forEach(info => {
            info.audio.stop();
          });
          this._audioPlayerInfoList.forEach(info => {
            info.audio.pause().catch(e => {});
          });
        }
        resume() {
          this._audioPlayerInfoList.forEach(info => {
            info.audio.play().catch(e => {});
          });
        }
      }
      const audioManager = new AudioManager();

      var _dec$X, _dec2$S, _dec3$F, _class$V, _class2$T, _initializer$R, _initializer2$O, _initializer3$D, _initializer4$x, _class3$m;
      const _LOADED_EVENT = 'audiosource-loaded';
      var AudioSourceEventType;
      (function (AudioSourceEventType) {
        AudioSourceEventType["STARTED"] = "started";
        AudioSourceEventType["ENDED"] = "ended";
      })(AudioSourceEventType || (AudioSourceEventType = {}));
      var AudioOperationType;
      (function (AudioOperationType) {
        AudioOperationType["PLAY"] = "play";
        AudioOperationType["STOP"] = "stop";
        AudioOperationType["PAUSE"] = "pause";
        AudioOperationType["SEEK"] = "seek";
      })(AudioOperationType || (AudioOperationType = {}));
      let AudioSource = (_dec$X = ccclass$6('cc.AudioSource'), _dec2$S = type$6(AudioClip), _dec3$F = type$6(AudioClip), _dec$X(_class$V = (_class2$T = (_class3$m = class AudioSource extends Component {
        constructor(...args) {
          super(...args);
          this._clip = _initializer$R && _initializer$R();
          this._player = null;
          this._hasRegisterListener = false;
          this._loop = _initializer2$O && _initializer2$O();
          this._playOnAwake = _initializer3$D && _initializer3$D();
          this._volume = _initializer4$x && _initializer4$x();
          this._cachedCurrentTime = -1;
          this._operationsBeforeLoading = [];
          this._isLoaded = false;
          this._lastSetClip = null;
        }
        static get maxAudioChannel() {
          return AudioPlayer.maxAudioChannel;
        }
        _resetPlayer() {
          if (this._player) {
            audioManager.removePlaying(this._player);
            this._unregisterListener();
            this._player.destroy();
            this._player = null;
          }
        }
        set clip(val) {
          if (val === this._clip) {
            return;
          }
          this._clip = val;
          this._syncPlayer();
        }
        get clip() {
          return this._clip;
        }
        _syncPlayer() {
          const clip = this._clip;
          if (this._lastSetClip === clip) {
            return;
          }
          if (!clip) {
            this._lastSetClip = null;
            this._resetPlayer();
            return;
          }
          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }
          this._isLoaded = false;
          this._lastSetClip = clip;
          this._operationsBeforeLoading.length = 0;
          AudioPlayer.load(clip._nativeAsset.url, {
            audioLoadMode: clip.loadMode
          }).then(player => {
            var _this$node;
            if (this._lastSetClip !== clip) {
              player.destroy();
              return;
            }
            this._isLoaded = true;
            this._resetPlayer();
            this._player = player;
            this._syncStates();
            (_this$node = this.node) === null || _this$node === void 0 ? void 0 : _this$node.emit(_LOADED_EVENT);
          }).catch(e => {});
        }
        _registerListener() {
          if (!this._hasRegisterListener && this._player) {
            const player = this._player;
            player.onEnded(() => {
              var _this$node2;
              audioManager.removePlaying(player);
              (_this$node2 = this.node) === null || _this$node2 === void 0 ? void 0 : _this$node2.emit(AudioSourceEventType.ENDED, this);
            });
            player.onInterruptionBegin(() => {
              audioManager.removePlaying(player);
            });
            player.onInterruptionEnd(() => {
              if (this._player === player) {
                audioManager.addPlaying(player);
              }
            });
            this._hasRegisterListener = true;
          }
        }
        _unregisterListener() {
          if (this._player && this._hasRegisterListener) {
            this._player.offEnded();
            this._player.offInterruptionBegin();
            this._player.offInterruptionEnd();
            this._hasRegisterListener = false;
          }
        }
        set loop(val) {
          this._loop = val;
          if (this._player) {
            this._player.loop = val;
          }
        }
        get loop() {
          return this._loop;
        }
        set playOnAwake(val) {
          this._playOnAwake = val;
        }
        get playOnAwake() {
          return this._playOnAwake;
        }
        set volume(val) {
          if (Number.isNaN(val)) {
            console.warn('illegal audio volume!');
            return;
          }
          val = clamp$1(val, 0, 1);
          if (this._player) {
            this._player.volume = val;
            this._volume = this._player.volume;
          } else {
            this._volume = val;
          }
        }
        get volume() {
          return this._volume;
        }
        onLoad() {
          this._syncPlayer();
        }
        onEnable() {
          if (this._playOnAwake && !this.playing) {
            this.play();
          }
        }
        onDisable() {
          const rootNode = this._getRootNode();
          if (rootNode !== null && rootNode !== void 0 && rootNode._persistNode) {
            return;
          }
          this.pause();
        }
        onDestroy() {
          this.stop();
          this.clip = null;
        }
        getPCMData(channelIndex) {
          return new Promise(resolve => {
            if (channelIndex !== 0 && channelIndex !== 1) {
              console.warn('Only support channel index 0 or 1 to get buffer');
              resolve(undefined);
              return;
            }
            if (this._player) {
              resolve(this._player.getPCMData(channelIndex));
            } else {
              var _this$node3;
              (_this$node3 = this.node) === null || _this$node3 === void 0 ? void 0 : _this$node3.once(_LOADED_EVENT, () => {
                var _this$_player;
                resolve((_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.getPCMData(channelIndex));
              });
            }
          });
        }
        getSampleRate() {
          return new Promise(resolve => {
            if (this._player) {
              resolve(this._player.sampleRate);
            } else {
              var _this$node4;
              (_this$node4 = this.node) === null || _this$node4 === void 0 ? void 0 : _this$node4.once(_LOADED_EVENT, () => {
                resolve(this._player.sampleRate);
              });
            }
          });
        }
        _getRootNode() {
          var _currentNode, _currentNode$parent;
          let currentNode = this.node;
          let currentGrandparentNode = (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : (_currentNode$parent = _currentNode.parent) === null || _currentNode$parent === void 0 ? void 0 : _currentNode$parent.parent;
          while (currentGrandparentNode) {
            var _currentNode2, _currentNode3, _currentNode3$parent;
            currentNode = (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.parent;
            currentGrandparentNode = (_currentNode3 = currentNode) === null || _currentNode3 === void 0 ? void 0 : (_currentNode3$parent = _currentNode3.parent) === null || _currentNode3$parent === void 0 ? void 0 : _currentNode3$parent.parent;
          }
          return currentNode;
        }
        play() {
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.PLAY,
              params: null
            });
            return;
          }
          this._registerListener();
          audioManager.discardOnePlayingIfNeeded();
          if (this.state === AudioState.PLAYING) {
            var _this$_player2;
            (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.stop().catch(e => {});
          }
          const player = this._player;
          if (player) {
            player.play().then(() => {
              var _this$node5;
              (_this$node5 = this.node) === null || _this$node5 === void 0 ? void 0 : _this$node5.emit(AudioSourceEventType.STARTED, this);
            }).catch(e => {
              audioManager.removePlaying(player);
            });
            audioManager.addPlaying(player);
          }
        }
        pause() {
          var _this$_player3;
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.PAUSE,
              params: null
            });
            return;
          }
          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.pause().catch(e => {});
        }
        stop() {
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.STOP,
              params: null
            });
            return;
          }
          if (this._player) {
            this._player.stop().catch(e => {});
            audioManager.removePlaying(this._player);
          }
        }
        playOneShot(clip, volumeScale = 1) {
          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }
          let player;
          AudioPlayer.loadOneShotAudio(clip._nativeAsset.url, this._volume * volumeScale, {
            audioLoadMode: clip.loadMode
          }).then(oneShotAudio => {
            player = oneShotAudio;
            audioManager.discardOnePlayingIfNeeded();
            oneShotAudio.onEnd = () => {
              audioManager.removePlaying(oneShotAudio);
            };
            oneShotAudio.play();
            audioManager.addPlaying(oneShotAudio);
          }).catch(e => {
            if (player) {
              audioManager.removePlaying(player);
            }
          });
        }
        _syncStates() {
          if (this._player) {
            this._player.loop = this._loop;
            this._player.volume = this._volume;
            this._operationsBeforeLoading.forEach(opInfo => {
              if (opInfo.op === AudioOperationType.SEEK) {
                this._cachedCurrentTime = opInfo.params && opInfo.params[0];
                if (this._player) {
                  this._player.seek(this._cachedCurrentTime).catch(e => {});
                }
              } else {
                var _this$opInfo$op;
                (_this$opInfo$op = this[opInfo.op]) === null || _this$opInfo$op === void 0 ? void 0 : _this$opInfo$op.call(this);
              }
            });
            this._operationsBeforeLoading.length = 0;
          }
        }
        set currentTime(num) {
          var _this$_player4;
          if (Number.isNaN(num)) {
            console.warn('illegal audio time!');
            return;
          }
          num = clamp$1(num, 0, this.duration);
          if (!this._isLoaded && this.clip) {
            this._operationsBeforeLoading.push({
              op: AudioOperationType.SEEK,
              params: [num]
            });
            return;
          }
          this._cachedCurrentTime = num;
          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.seek(this._cachedCurrentTime).catch(e => {});
        }
        get currentTime() {
          return this._player ? this._player.currentTime : this._cachedCurrentTime < 0 ? 0 : this._cachedCurrentTime;
        }
        get duration() {
          var _this$_clip$getDurati, _this$_clip;
          return (_this$_clip$getDurati = (_this$_clip = this._clip) === null || _this$_clip === void 0 ? void 0 : _this$_clip.getDuration()) !== null && _this$_clip$getDurati !== void 0 ? _this$_clip$getDurati : this._player ? this._player.duration : 0;
        }
        get state() {
          return this._player ? this._player.state : AudioState.INIT;
        }
        get playing() {
          return this.state === AudioSource.AudioState.PLAYING;
        }
      }, _class3$m.AudioState = AudioState, _class3$m.EventType = AudioSourceEventType, _class3$m), (_initializer$R = applyDecoratedInitializer(_class2$T.prototype, "_clip", [_dec2$S], function () {
        return null;
      }), _initializer2$O = applyDecoratedInitializer(_class2$T.prototype, "_loop", [serializable$6], function () {
        return false;
      }), _initializer3$D = applyDecoratedInitializer(_class2$T.prototype, "_playOnAwake", [serializable$6], function () {
        return true;
      }), _initializer4$x = applyDecoratedInitializer(_class2$T.prototype, "_volume", [serializable$6], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$T.prototype, "clip", [_dec3$F], Object.getOwnPropertyDescriptor(_class2$T.prototype, "clip"), _class2$T.prototype)), _class2$T)) || _class$V); exports({ AudioSource: AudioSource, AudioSourceComponent: AudioSource });

      replaceProperty(AudioClip, 'AudioClip', [{
        name: 'PlayingState',
        newName: 'AudioState',
        target: AudioSource,
        targetName: 'AudioSource'
      }]);
      markAsWarning(AudioClip.prototype, 'AudioClip.prototype', ['state', 'play', 'pause', 'stop', 'playOneShot', 'setCurrentTime', 'setVolume', 'setLoop', 'getCurrentTime', 'getVolume', 'getLoop'].map(item => ({
        name: item,
        suggest: `please use AudioSource.prototype.${item} instead`
      })));

      legacyCC.AudioSourceComponent = AudioSource;
      setClassAlias(AudioSource, 'cc.AudioSourceComponent');

      legacyCC.log = log;
      legacyCC.warn = warn;
      legacyCC.error = error;
      legacyCC.assert = assert;
      legacyCC._throw = _throw;
      legacyCC.logID = logID;
      legacyCC.warnID = warnID;
      legacyCC.errorID = errorID;
      legacyCC.assertID = assertID;
      legacyCC.debug = debug$1;
      legacyCC.path = {
        join,
        extname,
        mainFileName,
        basename,
        dirname,
        changeExtname,
        changeBasename,
        _normalize,
        stripSep,
        get sep() {
          return getSeperator();
        }
      };

      let LightType;
      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["POINT"] = 3] = "POINT";
        LightType[LightType["RANGED_DIRECTIONAL"] = 4] = "RANGED_DIRECTIONAL";
        LightType[LightType["UNKNOWN"] = 5] = "UNKNOWN";
      })(LightType || (LightType = {}));

      let UpdateFrequency;
      (function (UpdateFrequency) {
        UpdateFrequency[UpdateFrequency["PER_INSTANCE"] = 0] = "PER_INSTANCE";
        UpdateFrequency[UpdateFrequency["PER_BATCH"] = 1] = "PER_BATCH";
        UpdateFrequency[UpdateFrequency["PER_PHASE"] = 2] = "PER_PHASE";
        UpdateFrequency[UpdateFrequency["PER_PASS"] = 3] = "PER_PASS";
        UpdateFrequency[UpdateFrequency["COUNT"] = 4] = "COUNT";
      })(UpdateFrequency || (UpdateFrequency = {}));
      let ParameterType;
      (function (ParameterType) {
        ParameterType[ParameterType["CONSTANTS"] = 0] = "CONSTANTS";
        ParameterType[ParameterType["CBV"] = 1] = "CBV";
        ParameterType[ParameterType["UAV"] = 2] = "UAV";
        ParameterType[ParameterType["SRV"] = 3] = "SRV";
        ParameterType[ParameterType["TABLE"] = 4] = "TABLE";
        ParameterType[ParameterType["SSV"] = 5] = "SSV";
      })(ParameterType || (ParameterType = {}));
      let ResourceResidency;
      (function (ResourceResidency) {
        ResourceResidency[ResourceResidency["MANAGED"] = 0] = "MANAGED";
        ResourceResidency[ResourceResidency["MEMORYLESS"] = 1] = "MEMORYLESS";
        ResourceResidency[ResourceResidency["PERSISTENT"] = 2] = "PERSISTENT";
        ResourceResidency[ResourceResidency["EXTERNAL"] = 3] = "EXTERNAL";
        ResourceResidency[ResourceResidency["BACKBUFFER"] = 4] = "BACKBUFFER";
      })(ResourceResidency || (ResourceResidency = {}));
      let QueueHint;
      (function (QueueHint) {
        QueueHint[QueueHint["NONE"] = 0] = "NONE";
        QueueHint[QueueHint["OPAQUE"] = 1] = "OPAQUE";
        QueueHint[QueueHint["MASK"] = 2] = "MASK";
        QueueHint[QueueHint["BLEND"] = 3] = "BLEND";
        QueueHint[QueueHint["RENDER_OPAQUE"] = 1] = "RENDER_OPAQUE";
        QueueHint[QueueHint["RENDER_CUTOUT"] = 2] = "RENDER_CUTOUT";
        QueueHint[QueueHint["RENDER_TRANSPARENT"] = 3] = "RENDER_TRANSPARENT";
      })(QueueHint || (QueueHint = {}));
      let ResourceDimension;
      (function (ResourceDimension) {
        ResourceDimension[ResourceDimension["BUFFER"] = 0] = "BUFFER";
        ResourceDimension[ResourceDimension["TEXTURE1D"] = 1] = "TEXTURE1D";
        ResourceDimension[ResourceDimension["TEXTURE2D"] = 2] = "TEXTURE2D";
        ResourceDimension[ResourceDimension["TEXTURE3D"] = 3] = "TEXTURE3D";
      })(ResourceDimension || (ResourceDimension = {}));
      let ResourceFlags;
      (function (ResourceFlags) {
        ResourceFlags[ResourceFlags["NONE"] = 0] = "NONE";
        ResourceFlags[ResourceFlags["UNIFORM"] = 1] = "UNIFORM";
        ResourceFlags[ResourceFlags["INDIRECT"] = 2] = "INDIRECT";
        ResourceFlags[ResourceFlags["STORAGE"] = 4] = "STORAGE";
        ResourceFlags[ResourceFlags["SAMPLED"] = 8] = "SAMPLED";
        ResourceFlags[ResourceFlags["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
        ResourceFlags[ResourceFlags["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
        ResourceFlags[ResourceFlags["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
        ResourceFlags[ResourceFlags["SHADING_RATE"] = 128] = "SHADING_RATE";
        ResourceFlags[ResourceFlags["TRANSFER_SRC"] = 256] = "TRANSFER_SRC";
        ResourceFlags[ResourceFlags["TRANSFER_DST"] = 512] = "TRANSFER_DST";
      })(ResourceFlags || (ResourceFlags = {}));
      let TaskType;
      (function (TaskType) {
        TaskType[TaskType["SYNC"] = 0] = "SYNC";
        TaskType[TaskType["ASYNC"] = 1] = "ASYNC";
      })(TaskType || (TaskType = {}));
      let SceneFlags;
      (function (SceneFlags) {
        SceneFlags[SceneFlags["NONE"] = 0] = "NONE";
        SceneFlags[SceneFlags["OPAQUE"] = 1] = "OPAQUE";
        SceneFlags[SceneFlags["MASK"] = 2] = "MASK";
        SceneFlags[SceneFlags["BLEND"] = 4] = "BLEND";
        SceneFlags[SceneFlags["OPAQUE_OBJECT"] = 1] = "OPAQUE_OBJECT";
        SceneFlags[SceneFlags["CUTOUT_OBJECT"] = 2] = "CUTOUT_OBJECT";
        SceneFlags[SceneFlags["TRANSPARENT_OBJECT"] = 4] = "TRANSPARENT_OBJECT";
        SceneFlags[SceneFlags["SHADOW_CASTER"] = 8] = "SHADOW_CASTER";
        SceneFlags[SceneFlags["UI"] = 16] = "UI";
        SceneFlags[SceneFlags["DEFAULT_LIGHTING"] = 32] = "DEFAULT_LIGHTING";
        SceneFlags[SceneFlags["VOLUMETRIC_LIGHTING"] = 64] = "VOLUMETRIC_LIGHTING";
        SceneFlags[SceneFlags["CLUSTERED_LIGHTING"] = 128] = "CLUSTERED_LIGHTING";
        SceneFlags[SceneFlags["PLANAR_SHADOW"] = 256] = "PLANAR_SHADOW";
        SceneFlags[SceneFlags["GEOMETRY"] = 512] = "GEOMETRY";
        SceneFlags[SceneFlags["PROFILER"] = 1024] = "PROFILER";
        SceneFlags[SceneFlags["DRAW_INSTANCING"] = 2048] = "DRAW_INSTANCING";
        SceneFlags[SceneFlags["DRAW_NON_INSTANCING"] = 4096] = "DRAW_NON_INSTANCING";
        SceneFlags[SceneFlags["REFLECTION_PROBE"] = 8192] = "REFLECTION_PROBE";
        SceneFlags[SceneFlags["GPU_DRIVEN"] = 16384] = "GPU_DRIVEN";
        SceneFlags[SceneFlags["NON_BUILTIN"] = 32768] = "NON_BUILTIN";
        SceneFlags[SceneFlags["ALL"] = 4294967295] = "ALL";
      })(SceneFlags || (SceneFlags = {}));
      let LightingMode;
      (function (LightingMode) {
        LightingMode[LightingMode["NONE"] = 0] = "NONE";
        LightingMode[LightingMode["DEFAULT"] = 1] = "DEFAULT";
        LightingMode[LightingMode["CLUSTERED"] = 2] = "CLUSTERED";
      })(LightingMode || (LightingMode = {}));
      let AttachmentType;
      (function (AttachmentType) {
        AttachmentType[AttachmentType["RENDER_TARGET"] = 0] = "RENDER_TARGET";
        AttachmentType[AttachmentType["DEPTH_STENCIL"] = 1] = "DEPTH_STENCIL";
        AttachmentType[AttachmentType["SHADING_RATE"] = 2] = "SHADING_RATE";
      })(AttachmentType || (AttachmentType = {}));
      let AccessType;
      (function (AccessType) {
        AccessType[AccessType["READ"] = 0] = "READ";
        AccessType[AccessType["READ_WRITE"] = 1] = "READ_WRITE";
        AccessType[AccessType["WRITE"] = 2] = "WRITE";
      })(AccessType || (AccessType = {}));
      let ClearValueType;
      (function (ClearValueType) {
        ClearValueType[ClearValueType["NONE"] = 0] = "NONE";
        ClearValueType[ClearValueType["FLOAT_TYPE"] = 1] = "FLOAT_TYPE";
        ClearValueType[ClearValueType["INT_TYPE"] = 2] = "INT_TYPE";
      })(ClearValueType || (ClearValueType = {}));
      class LightInfo {
        constructor(light = null, level = 0, culledByLight = false, probe = null) {
          this.light = void 0;
          this.probe = void 0;
          this.level = void 0;
          this.culledByLight = void 0;
          this.light = light;
          this.probe = probe;
          this.level = level;
          this.culledByLight = culledByLight;
        }
        reset(light = null, level = 0, culledByLight = false, probe = null) {
          this.light = light;
          this.probe = probe;
          this.level = level;
          this.culledByLight = culledByLight;
        }
      }
      let DescriptorTypeOrder;
      (function (DescriptorTypeOrder) {
        DescriptorTypeOrder[DescriptorTypeOrder["UNIFORM_BUFFER"] = 0] = "UNIFORM_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["DYNAMIC_UNIFORM_BUFFER"] = 1] = "DYNAMIC_UNIFORM_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["SAMPLER_TEXTURE"] = 2] = "SAMPLER_TEXTURE";
        DescriptorTypeOrder[DescriptorTypeOrder["SAMPLER"] = 3] = "SAMPLER";
        DescriptorTypeOrder[DescriptorTypeOrder["TEXTURE"] = 4] = "TEXTURE";
        DescriptorTypeOrder[DescriptorTypeOrder["STORAGE_BUFFER"] = 5] = "STORAGE_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["DYNAMIC_STORAGE_BUFFER"] = 6] = "DYNAMIC_STORAGE_BUFFER";
        DescriptorTypeOrder[DescriptorTypeOrder["STORAGE_IMAGE"] = 7] = "STORAGE_IMAGE";
        DescriptorTypeOrder[DescriptorTypeOrder["INPUT_ATTACHMENT"] = 8] = "INPUT_ATTACHMENT";
      })(DescriptorTypeOrder || (DescriptorTypeOrder = {}));
      let ResolveFlags;
      (function (ResolveFlags) {
        ResolveFlags[ResolveFlags["NONE"] = 0] = "NONE";
        ResolveFlags[ResolveFlags["COLOR"] = 1] = "COLOR";
        ResolveFlags[ResolveFlags["DEPTH"] = 2] = "DEPTH";
        ResolveFlags[ResolveFlags["STENCIL"] = 4] = "STENCIL";
      })(ResolveFlags || (ResolveFlags = {}));
      class UploadPair {
        constructor(source = new Uint8Array(0), target = '', mipLevels = 0xFFFFFFFF, numSlices = 0xFFFFFFFF, targetMostDetailedMip = 0, targetFirstSlice = 0, targetPlaneSlice = 0) {
          this.source = void 0;
          this.target = void 0;
          this.mipLevels = void 0;
          this.numSlices = void 0;
          this.targetMostDetailedMip = void 0;
          this.targetFirstSlice = void 0;
          this.targetPlaneSlice = void 0;
          this.source = source;
          this.target = target;
          this.mipLevels = mipLevels;
          this.numSlices = numSlices;
          this.targetMostDetailedMip = targetMostDetailedMip;
          this.targetFirstSlice = targetFirstSlice;
          this.targetPlaneSlice = targetPlaneSlice;
        }
        reset(target = '', mipLevels = 0xFFFFFFFF, numSlices = 0xFFFFFFFF, targetMostDetailedMip = 0, targetFirstSlice = 0, targetPlaneSlice = 0) {
          this.target = target;
          this.mipLevels = mipLevels;
          this.numSlices = numSlices;
          this.targetMostDetailedMip = targetMostDetailedMip;
          this.targetFirstSlice = targetFirstSlice;
          this.targetPlaneSlice = targetPlaneSlice;
        }
      }

      new Viewport();
      new Rect();
      function SRGBToLinear(out, gamma) {
        out.x = gamma.x * gamma.x;
        out.y = gamma.y * gamma.y;
        out.z = gamma.z * gamma.z;
      }
      let profilerCamera = null;
      function getProfilerCamera() {
        return profilerCamera;
      }

      const _rangedDirLightBoundingBox = new AABB(0.0, 0.0, 0.0, 0.5, 0.5, 0.5);
      const _tmpBoundingBox = new AABB();
      let AntiAliasing;
      (function (AntiAliasing) {
        AntiAliasing[AntiAliasing["NONE"] = 0] = "NONE";
        AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
        AntiAliasing[AntiAliasing["FXAAHQ"] = 2] = "FXAAHQ";
      })(AntiAliasing || (AntiAliasing = {}));
      function getRTFormatBeforeToneMapping(ppl) {
        const useFloatOutput = ppl.getMacroBool('CC_USE_FLOAT_OUTPUT');
        return ppl.pipelineSceneData.isHDR && useFloatOutput && supportsRGBA16HalfFloatTexture(ppl.device) ? Format.RGBA16F : Format.RGBA8;
      }
      function validPunctualLightsCulling(pipeline, camera) {
        const sceneData = pipeline.pipelineSceneData;
        const validPunctualLights = sceneData.validPunctualLights;
        validPunctualLights.length = 0;
        const _sphere = Sphere.create(0, 0, 0, 1);
        const {
          spotLights
        } = camera.scene;
        for (let i = 0; i < spotLights.length; i++) {
          const light = spotLights[i];
          if (light.baked && !camera.node.scene.globals.disableLightmap) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          sphereLights
        } = camera.scene;
        for (let i = 0; i < sphereLights.length; i++) {
          const light = sphereLights[i];
          if (light.baked && !camera.node.scene.globals.disableLightmap) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          pointLights
        } = camera.scene;
        for (let i = 0; i < pointLights.length; i++) {
          const light = pointLights[i];
          if (light.baked) {
            continue;
          }
          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        const {
          rangedDirLights
        } = camera.scene;
        for (let i = 0; i < rangedDirLights.length; i++) {
          const light = rangedDirLights[i];
          AABB.transform(_tmpBoundingBox, _rangedDirLightBoundingBox, light.node.getWorldMatrix());
          if (intersect.aabbFrustum(_tmpBoundingBox, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }
        sceneData.validPunctualLights = validPunctualLights;
      }
      const _cameras = [];
      function getCameraUniqueID(camera) {
        if (!_cameras.includes(camera)) {
          _cameras.push(camera);
        }
        return _cameras.indexOf(camera);
      }
      function getLoadOpOfClearFlag(clearFlag, attachment) {
        let loadOp = LoadOp.CLEAR;
        if (!(clearFlag & ClearFlagBit.COLOR) && attachment === AttachmentType.RENDER_TARGET) {
          if (clearFlag & SKYBOX_FLAG) {
            loadOp = LoadOp.CLEAR;
          } else {
            loadOp = LoadOp.LOAD;
          }
        }
        if ((clearFlag & ClearFlagBit.DEPTH_STENCIL) !== ClearFlagBit.DEPTH_STENCIL && attachment === AttachmentType.DEPTH_STENCIL) {
          if (!(clearFlag & ClearFlagBit.DEPTH)) loadOp = LoadOp.LOAD;
          if (!(clearFlag & ClearFlagBit.STENCIL)) loadOp = LoadOp.LOAD;
        }
        return loadOp;
      }
      function getRenderArea(camera, width, height, light = null, level = 0, out = undefined) {
        out = out || new Rect();
        const vp = camera ? camera.viewport : new Rect(0, 0, 1, 1);
        const w = width;
        const h = height;
        out.x = vp.x * w;
        out.y = vp.y * h;
        out.width = vp.width * w;
        out.height = vp.height * h;
        if (light) {
          switch (light.type) {
            case LightType.DIRECTIONAL:
              {
                const mainLight = light;
                if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1) {
                  out.x = 0;
                  out.y = 0;
                  out.width = w;
                  out.height = h;
                } else {
                  const screenSpaceSignY = legacyCC.director.root.device.capabilities.screenSpaceSignY;
                  out.x = level % 2 * 0.5 * w;
                  if (screenSpaceSignY > 0) {
                    out.y = (1 - Math.floor(level / 2)) * 0.5 * h;
                  } else {
                    out.y = Math.floor(level / 2) * 0.5 * h;
                  }
                  out.width = 0.5 * w;
                  out.height = 0.5 * h;
                }
                break;
              }
            case LightType.SPOT:
              {
                out.x = 0;
                out.y = 0;
                out.width = w;
                out.height = h;
                break;
              }
          }
        }
        return out;
      }
      class PostInfo {
        _init() {
          this.postMaterial = new Material();
          this.postMaterial.name = 'builtin-post-process-material';
          this.postMaterial.initialize({
            effectName: 'pipeline/post-process',
            defines: {
              ANTIALIAS_TYPE: this.antiAliasing
            }
          });
          for (let i = 0; i < this.postMaterial.passes.length; ++i) {
            this.postMaterial.passes[i].tryCompile();
          }
        }
        constructor(antiAliasing = AntiAliasing.NONE) {
          this.antiAliasing = AntiAliasing.NONE;
          this.antiAliasing = antiAliasing;
          this._init();
        }
      }
      class ShadowInfo {
        constructor() {
          this.shadowEnabled = false;
          this.mainLightShadowNames = new Array();
          this.spotLightShadowNames = new Array();
          this.validLights = [];
        }
        reset() {
          this.shadowEnabled = false;
          this.mainLightShadowNames.length = 0;
          this.spotLightShadowNames.length = 0;
          this.validLights.length = 0;
        }
      }
      new ShadowInfo();
      class GBufferInfo {
        constructor() {
          this.color = void 0;
          this.normal = void 0;
          this.emissive = void 0;
          this.ds = void 0;
        }
      }
      class LightingInfo {
        _init() {
          this.deferredLightingMaterial = new Material();
          this.deferredLightingMaterial.name = 'builtin-deferred-material';
          this.deferredLightingMaterial.initialize({
            effectName: 'pipeline/deferred-lighting',
            defines: {
              CC_ENABLE_CLUSTERED_LIGHT_CULLING: this.enableCluster,
              CC_RECEIVE_SHADOW: 1
            }
          });
          for (let i = 0; i < this.deferredLightingMaterial.passes.length; ++i) {
            this.deferredLightingMaterial.passes[i].tryCompile();
          }
        }
        constructor(clusterEn) {
          this.enableCluster = void 0;
          this.enableCluster = clusterEn ? 1 : 0;
          this._init();
        }
      }
      new Vec3();
      new Vec3();
      new Vec4();
      new Vec4();
      new Vec2();
      const MAX_LIGHTS_PER_CLUSTER = 200;
      const CLUSTERS_X = 16;
      const CLUSTERS_Y = 8;
      const CLUSTERS_Z = 24;
      const CLUSTER_COUNT = CLUSTERS_X * CLUSTERS_Y * CLUSTERS_Z;
      class ClusterLightData {
        _initMaterial(id, effect) {
          const mat = new Material();
          mat.name = id;
          mat.initialize({
            effectName: effect
          });
          for (let i = 0; i < mat.passes.length; ++i) {
            mat.passes[i].tryCompile();
          }
          return mat;
        }
        _init() {
          this.clusterBuildCS = this._initMaterial('builtin-cluster-build-cs-material', 'pipeline/cluster-build');
          this.clusterLightCullingCS = this._initMaterial('builtin-cluster-culling-cs-material', 'pipeline/cluster-culling');
          this.dispatchX = CLUSTERS_X / this.clusters_x_threads;
          this.dispatchY = CLUSTERS_Y / this.clusters_y_threads;
          this.dispatchZ = CLUSTERS_Z / this.clusters_z_threads;
        }
        constructor() {
          this.clusters_x_threads = 16;
          this.clusters_y_threads = 8;
          this.clusters_z_threads = 1;
          this.dispatchX = 1;
          this.dispatchY = 1;
          this.dispatchZ = 1;
          this._init();
        }
      }
      let _clusterLightData = null;
      function buildLightClusterBuildPass(camera, clusterData, ppl) {
        const cameraID = getCameraUniqueID(camera);
        const clusterBufferName = `clusterBuffer${cameraID}`;
        const clusterBufferSize = CLUSTER_COUNT * 2 * 4 * 4;
        if (!ppl.containsResource(clusterBufferName)) {
          ppl.addStorageBuffer(clusterBufferName, Format.UNKNOWN, clusterBufferSize, ResourceResidency.MANAGED);
        }
        ppl.updateStorageBuffer(clusterBufferName, clusterBufferSize);
        const clusterPass = ppl.addComputePass('cluster-build-cs');
        clusterPass.addStorageBuffer(clusterBufferName, AccessType.WRITE, 'b_clustersBuffer');
        clusterPass.addQueue().addDispatch(clusterData.dispatchX, clusterData.dispatchY, clusterData.dispatchZ, clusterData.clusterBuildCS, 0);
        const width = camera.width * ppl.pipelineSceneData.shadingScale;
        const height = camera.height * ppl.pipelineSceneData.shadingScale;
        if ('setCurrConstant' in clusterPass) {
          clusterPass.addConstant('CCConst', 'cluster-build-cs');
        }
        clusterPass.setVec4('cc_nearFar', new Vec4(camera.nearClip, camera.farClip, camera.getClipSpaceMinz(), 0));
        clusterPass.setVec4('cc_viewPort', new Vec4(0, 0, width, height));
        clusterPass.setVec4('cc_workGroup', new Vec4(CLUSTERS_X, CLUSTERS_Y, CLUSTERS_Z, 0));
        clusterPass.setMat4('cc_matView', camera.matView);
        clusterPass.setMat4('cc_matProjInv', camera.matProjInv);
      }
      function buildLightClusterCullingPass(camera, clusterData, ppl) {
        const cameraID = getCameraUniqueID(camera);
        const clusterBufferName = `clusterBuffer${cameraID}`;
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterGlobalIndexBufferName = `globalIndexBuffer${cameraID}`;
        const clusterLightIndicesBufferName = `clusterLightIndicesBuffer${cameraID}`;
        const clusterLightGridBufferName = `clusterLightGridBuffer${cameraID}`;
        const lightIndexBufferSize = MAX_LIGHTS_PER_CLUSTER * CLUSTER_COUNT * 4;
        const lightGridBufferSize = CLUSTER_COUNT * 4 * 4;
        if (!ppl.containsResource(clusterLightIndicesBufferName)) {
          ppl.addStorageBuffer(clusterLightIndicesBufferName, Format.UNKNOWN, lightIndexBufferSize, ResourceResidency.MANAGED);
        }
        if (!ppl.containsResource(clusterLightGridBufferName)) {
          ppl.addStorageBuffer(clusterLightGridBufferName, Format.UNKNOWN, lightGridBufferSize, ResourceResidency.MANAGED);
        }
        const clusterPass = ppl.addComputePass('cluster-culling-cs');
        clusterPass.addStorageBuffer(clusterLightBufferName, AccessType.READ, 'b_ccLightsBuffer');
        clusterPass.addStorageBuffer(clusterBufferName, AccessType.READ, 'b_clustersBuffer');
        clusterPass.addStorageBuffer(clusterLightIndicesBufferName, AccessType.WRITE, 'b_clusterLightIndicesBuffer');
        clusterPass.addStorageBuffer(clusterLightGridBufferName, AccessType.WRITE, 'b_clusterLightGridBuffer');
        clusterPass.addStorageBuffer(clusterGlobalIndexBufferName, AccessType.WRITE, 'b_globalIndexBuffer');
        clusterPass.addQueue().addDispatch(clusterData.dispatchX, clusterData.dispatchY, clusterData.dispatchZ, clusterData.clusterLightCullingCS, 0);
        const width = camera.width * ppl.pipelineSceneData.shadingScale;
        const height = camera.height * ppl.pipelineSceneData.shadingScale;
        if ('setCurrConstant' in clusterPass) {
          clusterPass.addConstant('CCConst', 'cluster-build-cs');
        }
        clusterPass.setVec4('cc_nearFar', new Vec4(camera.nearClip, camera.farClip, camera.getClipSpaceMinz(), 0));
        clusterPass.setVec4('cc_viewPort', new Vec4(width, height, width, height));
        clusterPass.setVec4('cc_workGroup', new Vec4(CLUSTERS_X, CLUSTERS_Y, CLUSTERS_Z, 0));
        clusterPass.setMat4('cc_matView', camera.matView);
        clusterPass.setMat4('cc_matProjInv', camera.matProjInv);
      }
      function buildLightBuffer(size, floatPerLight, camera, pipeline) {
        const buffer = new ArrayBuffer(size);
        const view = new Float32Array(buffer);
        const data = pipeline.pipelineSceneData;
        const lightMeterScale = 10000.0;
        const exposure = camera.exposure;
        let index = 0;
        for (const light of data.validPunctualLights) {
          const offset = index * floatPerLight;
          const positionOffset = offset + 0;
          const colorOffset = offset + 4;
          const sizeRangeAngleOffset = offset + 8;
          const directionOffset = offset + 12;
          const boundSizeOffset = offset + 16;
          let luminanceHDR = 0;
          let luminanceLDR = 0;
          let position;
          if (light.type === LightType.POINT) {
            const point = light;
            position = point.position;
            luminanceLDR = point.luminanceLDR;
            luminanceHDR = point.luminanceHDR;
            view[sizeRangeAngleOffset] = 0;
            view[sizeRangeAngleOffset + 1] = point.range;
            view[sizeRangeAngleOffset + 2] = 0;
            view[sizeRangeAngleOffset + 3] = 0;
          } else if (light.type === LightType.SPHERE) {
            const sphere = light;
            position = sphere.position;
            luminanceLDR = sphere.luminanceLDR;
            luminanceHDR = sphere.luminanceHDR;
            view[sizeRangeAngleOffset] = sphere.size;
            view[sizeRangeAngleOffset + 1] = sphere.range;
            view[sizeRangeAngleOffset + 2] = 0;
            view[sizeRangeAngleOffset + 3] = 0;
          } else if (light.type === LightType.SPOT) {
            const spot = light;
            position = spot.position;
            luminanceLDR = spot.luminanceLDR;
            luminanceHDR = spot.luminanceHDR;
            view[sizeRangeAngleOffset] = spot.size;
            view[sizeRangeAngleOffset + 1] = spot.range;
            view[sizeRangeAngleOffset + 2] = spot.spotAngle;
            view[sizeRangeAngleOffset + 3] = 0;
            const dir = spot.direction;
            view[directionOffset] = dir.x;
            view[directionOffset + 1] = dir.y;
            view[directionOffset + 2] = dir.z;
            view[directionOffset + 3] = 0;
          } else if (light.type === LightType.RANGED_DIRECTIONAL) {
            const directional = light;
            position = directional.position;
            luminanceLDR = directional.illuminanceLDR;
            luminanceHDR = directional.illuminanceHDR;
            const right = directional.right;
            view[sizeRangeAngleOffset] = right.x;
            view[sizeRangeAngleOffset + 1] = right.y;
            view[sizeRangeAngleOffset + 2] = right.z;
            view[sizeRangeAngleOffset + 3] = 0;
            const dir = directional.direction;
            view[directionOffset] = dir.x;
            view[directionOffset + 1] = dir.y;
            view[directionOffset + 2] = dir.z;
            view[directionOffset + 3] = 0;
            const scale = directional.scale;
            view[boundSizeOffset] = scale.x * 0.5;
            view[boundSizeOffset + 1] = scale.y * 0.5;
            view[boundSizeOffset + 2] = scale.z * 0.5;
            view[boundSizeOffset + 3] = 0;
          }
          view[positionOffset] = position.x;
          view[positionOffset + 1] = position.y;
          view[positionOffset + 2] = position.z;
          view[positionOffset + 3] = light.type;
          const color = light.color;
          if (light.useColorTemperature) {
            const tempRGB = light.colorTemperatureRGB;
            view[colorOffset] = color.x * tempRGB.x;
            view[colorOffset + 1] = color.y * tempRGB.y;
            view[colorOffset + 2] = color.z * tempRGB.z;
          } else {
            view[colorOffset] = color.x;
            view[colorOffset + 1] = color.y;
            view[colorOffset + 2] = color.z;
          }
          view[colorOffset + 3] = data.isHDR ? luminanceHDR * exposure * lightMeterScale : luminanceLDR;
          index++;
        }
        view[3 * 4 + 3] = data.validPunctualLights.length;
        return buffer;
      }
      function buildClusterLightData(camera, pipeline) {
        validPunctualLightsCulling(pipeline, camera);
        const data = pipeline.pipelineSceneData;
        const validLightCountForBuffer = nextPow2(Math.max(data.validPunctualLights.length, 1));
        const lightBufferFloatNum = 20;
        const clusterLightBufferSize = validLightCountForBuffer * 4 * lightBufferFloatNum;
        const cameraID = getCameraUniqueID(camera);
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterGlobalIndexBufferName = `globalIndexBuffer${cameraID}`;
        const ppl = pipeline;
        if (!ppl.containsResource(clusterGlobalIndexBufferName)) {
          ppl.addStorageBuffer(clusterGlobalIndexBufferName, Format.UNKNOWN, 4, ResourceResidency.PERSISTENT);
        }
        if (!ppl.containsResource(clusterLightBufferName)) {
          ppl.addStorageBuffer(clusterLightBufferName, Format.UNKNOWN, clusterLightBufferSize, ResourceResidency.PERSISTENT);
        }
        ppl.updateStorageBuffer(clusterLightBufferName, clusterLightBufferSize);
        const buffer = buildLightBuffer(clusterLightBufferSize, lightBufferFloatNum, camera, pipeline);
        const globalIndexBuffer = new ArrayBuffer(4);
        const globalIndexBufferView = new Uint32Array(globalIndexBuffer);
        globalIndexBufferView[0] = 0;
        const uploadPair1 = new UploadPair(new Uint8Array(buffer), clusterLightBufferName);
        const uploadPair2 = new UploadPair(new Uint8Array(globalIndexBuffer), clusterGlobalIndexBufferName);
        ppl.addUploadPass([uploadPair1, uploadPair2]);
      }
      function buildClusterPasses(camera, pipeline) {
        buildClusterLightData(camera, pipeline);
        const ppl = pipeline;
        if (!_clusterLightData) _clusterLightData = new ClusterLightData();
        buildLightClusterBuildPass(camera, _clusterLightData, ppl);
        buildLightClusterCullingPass(camera, _clusterLightData, ppl);
      }

      function isUICamera(camera) {
        const scene = camera.scene;
        const batches = scene.batches;
        for (let i = 0; batches && i < batches.length; i++) {
          const batch = batches[i];
          if (camera.visibility & batch.visFlags) {
            return true;
          }
        }
        return false;
      }

      class CameraInfo {
        constructor(camera, id, windowID, width, height) {
          this.camera = void 0;
          this.id = 0xFFFFFFFF;
          this.windowID = 0xFFFFFFFF;
          this.width = 0;
          this.height = 0;
          this.camera = camera;
          this.id = id;
          this.windowID = windowID;
          this.width = width;
          this.height = height;
        }
      }
      const cameraInfos = new Map();
      const windowInfos = new Map();
      function prepareRenderWindow(camera) {
        let windowID = windowInfos.get(camera.window);
        if (windowID === undefined) {
          windowID = windowInfos.size;
          windowInfos.set(camera.window, windowID);
        }
        return windowID;
      }
      function prepareResource(ppl, camera, initResourceFunc, updateResourceFunc) {
        let info = cameraInfos.get(camera);
        if (info !== undefined) {
          let width = camera.window.width;
          let height = camera.window.height;
          if (width === 0) {
            width = 1;
          }
          if (height === 0) {
            height = 1;
          }
          const windowID = prepareRenderWindow(camera);
          info.width = width;
          info.height = height;
          info.windowID = windowID;
          updateResourceFunc(ppl, info);
          return info;
        }
        const windowID = prepareRenderWindow(camera);
        info = new CameraInfo(camera, cameraInfos.size, windowID, camera.window.width ? camera.window.width : 1, camera.window.height ? camera.window.height : 1);
        initResourceFunc(ppl, info);
        cameraInfos.set(camera, info);
        return info;
      }
      function buildShadowRes(ppl, name, width, height) {
        const fboW = width;
        const fboH = height;
        const shadowMapName = name;
        const device = ppl.device;
        if (!ppl.containsResource(shadowMapName)) {
          const format = supportsR32FloatTexture(device) ? Format.R32F : Format.RGBA8;
          ppl.addRenderTarget(shadowMapName, format, fboW, fboH, ResourceResidency.MANAGED);
          ppl.addDepthStencil(`${shadowMapName}Depth`, Format.DEPTH_STENCIL, fboW, fboH, ResourceResidency.MANAGED);
        }
        ppl.updateRenderTarget(shadowMapName, fboW, fboH);
        ppl.updateDepthStencil(`${shadowMapName}Depth`, fboW, fboH);
      }
      const shadowInfo = new ShadowInfo();
      function setupShadowRes(ppl, cameraInfo) {
        const camera = cameraInfo.camera;
        validPunctualLightsCulling(ppl, camera);
        const pipeline = ppl;
        const shadow = pipeline.pipelineSceneData.shadows;
        const validPunctualLights = ppl.pipelineSceneData.validPunctualLights;
        const shadows = ppl.pipelineSceneData.shadows;
        shadowInfo.reset();
        if (!shadow.enabled || shadow.type !== ShadowType$2.ShadowMap) {
          return shadowInfo;
        }
        shadowInfo.shadowEnabled = true;
        const _validLights = shadowInfo.validLights;
        let n = 0;
        let m = 0;
        for (; n < shadow.maxReceived && m < validPunctualLights.length;) {
          const light = validPunctualLights[m];
          if (light.type === LightType$1.SPOT) {
            const spotLight = light;
            if (spotLight.shadowEnabled) {
              _validLights.push(light);
              n++;
            }
          }
          m++;
        }
        const {
          mainLight
        } = camera.scene;
        const mapWidth = shadows.size.x;
        const mapHeight = shadows.size.y;
        if (mainLight && mainLight.shadowEnabled) {
          shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
          if (mainLight.shadowFixedArea) {
            buildShadowRes(ppl, shadowInfo.mainLightShadowNames[0], mapWidth, mapHeight);
          } else {
            const csmLevel = pipeline.pipelineSceneData.csmSupported ? mainLight.csmLevel : 1;
            shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
            for (let i = 0; i < csmLevel; i++) {
              buildShadowRes(ppl, shadowInfo.mainLightShadowNames[0], mapWidth, mapHeight);
            }
          }
        }
        for (let l = 0; l < _validLights.length; l++) {
          _validLights[l];
          const passName = `SpotLightShadow${l.toString()}${cameraInfo.id}`;
          shadowInfo.spotLightShadowNames[l] = passName;
          buildShadowRes(ppl, shadowInfo.spotLightShadowNames[l], mapWidth, mapHeight);
        }
        return shadowInfo;
      }
      const updateShadowRes = setupShadowRes;
      let shadowPass;
      function buildShadowPass(passName, ppl, camera, light, level, width, height) {
        const fboW = width;
        const fboH = height;
        const area = getRenderArea(camera, width, height, light, level);
        width = area.width;
        height = area.height;
        const shadowMapName = passName;
        if (!level) {
          shadowPass = ppl.addRenderPass(width, height, 'default');
          shadowPass.name = passName;
          shadowPass.setViewport(new Viewport(0, 0, fboW, fboH));
          shadowPass.addRenderTarget(shadowMapName, LoadOp.CLEAR, StoreOp.STORE, new Color(1, 1, 1, camera.clearColor.w));
          shadowPass.addDepthStencil(`${shadowMapName}Depth`, LoadOp.CLEAR, StoreOp.DISCARD, camera.clearDepth, camera.clearStencil, ClearFlagBit.DEPTH_STENCIL);
        }
        const queue = shadowPass.addQueue(QueueHint.RENDER_OPAQUE, 'shadow-caster');
        queue.addSceneOfCamera(camera, new LightInfo(light, level), SceneFlags.SHADOW_CASTER);
        queue.setViewport(new Viewport(area.x, area.y, area.width, area.height));
      }
      function setupShadowPass(ppl, cameraInfo) {
        if (!shadowInfo.shadowEnabled) return;
        const camera = cameraInfo.camera;
        const shadows = ppl.pipelineSceneData.shadows;
        const mapWidth = shadows.size.x;
        const mapHeight = shadows.size.y;
        const {
          mainLight
        } = camera.scene;
        if (mainLight && mainLight.shadowEnabled) {
          shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
          if (mainLight.shadowFixedArea) {
            buildShadowPass(shadowInfo.mainLightShadowNames[0], ppl, camera, mainLight, 0, mapWidth, mapHeight);
          } else {
            const csmLevel = ppl.pipelineSceneData.csmSupported ? mainLight.csmLevel : 1;
            shadowInfo.mainLightShadowNames[0] = `MainLightShadow${cameraInfo.id}`;
            for (let i = 0; i < csmLevel; i++) {
              buildShadowPass(shadowInfo.mainLightShadowNames[0], ppl, camera, mainLight, i, mapWidth, mapHeight);
            }
          }
        }
        for (let l = 0; l < shadowInfo.validLights.length; l++) {
          const light = shadowInfo.validLights[l];
          const passName = `SpotLightShadow${l.toString()}${cameraInfo.id}`;
          shadowInfo.spotLightShadowNames[l] = passName;
          buildShadowPass(passName, ppl, camera, light, 0, mapWidth, mapHeight);
        }
      }
      function setupForwardRes(ppl, cameraInfo, isOffScreen = false) {
        const camera = cameraInfo.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        setupShadowRes(ppl, cameraInfo);
        if (!isOffScreen) {
          ppl.addRenderWindow(`ForwardColor${cameraInfo.id}`, Format.BGRA8, width, height, cameraInfo.camera.window);
        } else {
          ppl.addRenderTarget(`ForwardColor${cameraInfo.id}`, getRTFormatBeforeToneMapping(ppl), width, height, ResourceResidency.PERSISTENT);
        }
        ppl.addDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, Format.DEPTH_STENCIL, width, height);
      }
      function updateForwardRes(ppl, cameraInfo, isOffScreen = false) {
        const camera = cameraInfo.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        updateShadowRes(ppl, cameraInfo);
        if (!isOffScreen) {
          ppl.updateRenderWindow(`ForwardColor${cameraInfo.id}`, cameraInfo.camera.window);
        } else {
          ppl.updateRenderTarget(`ForwardColor${cameraInfo.id}`, width, height);
        }
        ppl.updateDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, width, height);
      }
      function setupDeferredForward(ppl, cameraInfo, inputColor, clusterLighting) {
        const area = getRenderArea(cameraInfo.camera, cameraInfo.camera.window.width, cameraInfo.camera.window.height);
        const width = area.width;
        const height = area.height;
        const forwardPass = ppl.addRenderPass(width, height, 'default');
        const camera = cameraInfo.camera;
        forwardPass.addRenderTarget(inputColor, LoadOp.LOAD, StoreOp.STORE);
        forwardPass.addDepthStencil(gBufferInfo.ds, LoadOp.LOAD, StoreOp.DISCARD);
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            forwardPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            forwardPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        let sceneFlags = SceneFlags.OPAQUE_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.CUTOUT_OBJECT | SceneFlags.DRAW_INSTANCING;
        sceneFlags |= clusterLighting ? SceneFlags.CLUSTERED_LIGHTING : SceneFlags.DEFAULT_LIGHTING;
        forwardPass.addQueue(QueueHint.RENDER_OPAQUE, 'deferred-forward').addSceneOfCamera(camera, new LightInfo(), sceneFlags);
        forwardPass.addQueue(QueueHint.RENDER_TRANSPARENT, 'deferred-forward').addSceneOfCamera(camera, new LightInfo(), SceneFlags.TRANSPARENT_OBJECT | SceneFlags.GEOMETRY);
      }
      function setupForwardPass(ppl, cameraInfo, isOffScreen = false, enabledAlpha = true) {
        setupShadowPass(ppl, cameraInfo);
        const cameraID = cameraInfo.id;
        const area = getRenderArea(cameraInfo.camera, cameraInfo.camera.window.width, cameraInfo.camera.window.height);
        const width = area.width;
        const height = area.height;
        const forwardPass = ppl.addRenderPass(width, height, 'default');
        forwardPass.name = `ForwardPass${cameraID}`;
        forwardPass.setViewport(new Viewport(area.x, area.y, width, height));
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            forwardPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            forwardPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        const camera = cameraInfo.camera;
        forwardPass.addRenderTarget(`ForwardColor${cameraInfo.id}`, isOffScreen ? LoadOp.CLEAR : getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, new Color(camera.clearColor.x, camera.clearColor.y, camera.clearColor.z, camera.clearColor.w));
        forwardPass.addDepthStencil(`ForwardDepthStencil${cameraInfo.id}`, isOffScreen ? LoadOp.CLEAR : getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), isOffScreen ? StoreOp.DISCARD : StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        forwardPass.addQueue(QueueHint.RENDER_OPAQUE).addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.PLANAR_SHADOW | SceneFlags.CUTOUT_OBJECT | SceneFlags.DEFAULT_LIGHTING | SceneFlags.DRAW_INSTANCING);
        let sceneFlags = SceneFlags.TRANSPARENT_OBJECT | SceneFlags.GEOMETRY;
        if (!isOffScreen) {
          sceneFlags |= SceneFlags.UI;
          forwardPass.showStatistics = true;
        }
        if (enabledAlpha) {
          forwardPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), sceneFlags);
        }
        return {
          rtName: `ForwardColor${cameraInfo.id}`,
          dsName: `ForwardDepthStencil${cameraInfo.id}`
        };
      }
      const gBufferInfo = new GBufferInfo();
      function setupGBufferRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = `gBufferPassColorCamera${info.id}`;
        const gBufferPassNormal = `gBufferPassNormal${info.id}`;
        const gBufferPassEmissive = `gBufferPassEmissive${info.id}`;
        const gBufferPassDSName = `gBufferPassDSCamera${info.id}`;
        const colFormat = Format.RGBA16F;
        ppl.addRenderTarget(gBufferPassRTName, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addRenderTarget(gBufferPassEmissive, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addRenderTarget(gBufferPassNormal, colFormat, width, height, ResourceResidency.MANAGED);
        ppl.addDepthStencil(gBufferPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
        gBufferInfo.color = gBufferPassRTName;
        gBufferInfo.normal = gBufferPassNormal;
        gBufferInfo.emissive = gBufferPassEmissive;
        gBufferInfo.ds = gBufferPassDSName;
      }
      function updateGBufferRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = `gBufferPassColorCamera${info.id}`;
        const gBufferPassNormal = `gBufferPassNormal${info.id}`;
        const gBufferPassEmissive = `gBufferPassEmissive${info.id}`;
        const gBufferPassDSName = `gBufferPassDSCamera${info.id}`;
        ppl.updateRenderTarget(gBufferPassRTName, width, height);
        ppl.updateRenderTarget(gBufferPassEmissive, width, height);
        ppl.updateRenderTarget(gBufferPassNormal, width, height);
        ppl.updateDepthStencil(gBufferPassDSName, width, height);
      }
      new Color(0, 0, 0, 0);
      function setupGBufferPass(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const gBufferPassRTName = gBufferInfo.color;
        const gBufferPassNormal = gBufferInfo.normal;
        const gBufferPassEmissive = gBufferInfo.emissive;
        const gBufferPassDSName = gBufferInfo.ds;
        const gBufferPass = ppl.addRenderPass(width, height, 'gbuffer');
        gBufferPass.name = `CameraGBufferPass${info.id}`;
        gBufferPass.setViewport(new Viewport(area.x, area.y, width, height));
        const rtColor = new Color(0, 0, 0, 0);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          if (ppl.pipelineSceneData.isHDR) {
            SRGBToLinear(rtColor, camera.clearColor);
          } else {
            rtColor.x = camera.clearColor.x;
            rtColor.y = camera.clearColor.y;
            rtColor.z = camera.clearColor.z;
          }
        }
        gBufferPass.addRenderTarget(gBufferPassRTName, LoadOp.CLEAR, StoreOp.STORE, rtColor);
        gBufferPass.addRenderTarget(gBufferPassEmissive, LoadOp.CLEAR, StoreOp.STORE, new Color(0, 0, 0, 0));
        gBufferPass.addRenderTarget(gBufferPassNormal, LoadOp.CLEAR, StoreOp.STORE, new Color(0, 0, 0, 0));
        gBufferPass.addDepthStencil(gBufferPassDSName, LoadOp.CLEAR, StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        gBufferPass.addQueue(QueueHint.RENDER_OPAQUE, 'gbuffer').addSceneOfCamera(camera, new LightInfo(), SceneFlags.OPAQUE_OBJECT | SceneFlags.CUTOUT_OBJECT);
        return gBufferPass;
      }
      function setupLightingRes(ppl, info) {
        setupShadowRes(ppl, info);
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        ppl.addRenderTarget(deferredLightingPassRTName, Format.RGBA8, width, height, ResourceResidency.MANAGED);
      }
      function updateLightingRes(ppl, info) {
        updateShadowRes(ppl, info);
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        ppl.updateRenderTarget(deferredLightingPassRTName, width, height);
      }
      let lightingInfo;
      function setupLightingPass(pipeline, info, useCluster) {
        setupShadowPass(pipeline, info);
        if (!lightingInfo) {
          lightingInfo = new LightingInfo(useCluster);
        }
        const ppl = pipeline;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const cameraID = getCameraUniqueID(camera);
        const deferredLightingPassRTName = `deferredLightingPassRTName${info.id}`;
        const lightingPass = ppl.addRenderPass(width, height, 'deferred-lighting');
        lightingPass.name = `CameraLightingPass${info.id}`;
        lightingPass.setViewport(new Viewport(area.x, area.y, width, height));
        for (const dirShadowName of shadowInfo.mainLightShadowNames) {
          if (ppl.containsResource(dirShadowName)) {
            lightingPass.addTexture(dirShadowName, 'cc_shadowMap');
          }
        }
        for (const spotShadowName of shadowInfo.spotLightShadowNames) {
          if (ppl.containsResource(spotShadowName)) {
            lightingPass.addTexture(spotShadowName, 'cc_spotShadowMap');
          }
        }
        if (ppl.containsResource(gBufferInfo.color)) {
          lightingPass.addTexture(gBufferInfo.color, 'albedoMap');
          lightingPass.addTexture(gBufferInfo.normal, 'normalMap');
          lightingPass.addTexture(gBufferInfo.emissive, 'emissiveMap');
          lightingPass.addTexture(gBufferInfo.ds, 'depthStencil');
        }
        const clusterLightBufferName = `clusterLightBuffer${cameraID}`;
        const clusterLightIndicesBufferName = `clusterLightIndicesBuffer${cameraID}`;
        const clusterLightGridBufferName = `clusterLightGridBuffer${cameraID}`;
        if (ppl.containsResource(clusterLightBufferName)) {
          lightingPass.addStorageBuffer(clusterLightBufferName, AccessType.READ, 'b_ccLightsBuffer');
          lightingPass.addStorageBuffer(clusterLightIndicesBufferName, AccessType.READ, 'b_clusterLightIndicesBuffer');
          lightingPass.addStorageBuffer(clusterLightGridBufferName, AccessType.READ, 'b_clusterLightGridBuffer');
        }
        const lightingClearColor = new Color(0, 0, 0, 0);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          lightingClearColor.x = camera.clearColor.x;
          lightingClearColor.y = camera.clearColor.y;
          lightingClearColor.z = camera.clearColor.z;
        }
        lightingClearColor.w = 0;
        lightingPass.addRenderTarget(deferredLightingPassRTName, LoadOp.CLEAR, StoreOp.STORE, lightingClearColor);
        lightingPass.addQueue(QueueHint.RENDER_TRANSPARENT).addCameraQuad(camera, lightingInfo.deferredLightingMaterial, 0, SceneFlags.VOLUMETRIC_LIGHTING);
        return {
          rtName: deferredLightingPassRTName
        };
      }
      function setupPostprocessRes(ppl, info) {
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        ppl.addRenderWindow(postprocessPassRTName, Format.BGRA8, width, height, camera.window);
        ppl.addDepthStencil(postprocessPassDS, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
      }
      function updatePostprocessRes(ppl, info) {
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        ppl.updateRenderWindow(postprocessPassRTName, camera.window);
        ppl.updateDepthStencil(postprocessPassDS, width, height);
      }
      let postInfo;
      function setupPostprocessPass(ppl, info, inputTex) {
        if (!postInfo) {
          postInfo = new PostInfo();
        }
        const cameraID = info.id;
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const postprocessPassRTName = `postprocessPassRTName${cameraID}`;
        const postprocessPassDS = `postprocessPassDS${cameraID}`;
        const postprocessPass = ppl.addRenderPass(width, height, 'post-process');
        postprocessPass.name = `CameraPostprocessPass${cameraID}`;
        postprocessPass.setViewport(new Viewport(area.x, area.y, area.width, area.height));
        if (ppl.containsResource(inputTex)) {
          postprocessPass.addTexture(inputTex, 'outputResultMap');
        }
        const postClearColor = new Color(0, 0, 0, camera.clearColor.w);
        if (camera.clearFlag & ClearFlagBit.COLOR) {
          postClearColor.x = camera.clearColor.x;
          postClearColor.y = camera.clearColor.y;
          postClearColor.z = camera.clearColor.z;
        }
        postprocessPass.addRenderTarget(postprocessPassRTName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, postClearColor);
        postprocessPass.addDepthStencil(postprocessPassDS, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        postprocessPass.addQueue(QueueHint.NONE).addCameraQuad(camera, postInfo.postMaterial, 0, SceneFlags.NONE);
        if (getProfilerCamera() === camera) {
          postprocessPass.showStatistics = true;
        }
        return {
          rtName: postprocessPassRTName,
          dsName: postprocessPassDS
        };
      }
      function setupUIRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        ppl.addRenderWindow(dsUIAndProfilerPassRTName, Format.BGRA8, width, height, camera.window);
        ppl.addDepthStencil(dsUIAndProfilerPassDSName, Format.DEPTH_STENCIL, width, height, ResourceResidency.MANAGED);
      }
      function updateUIRes(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        ppl.updateRenderWindow(dsUIAndProfilerPassRTName, camera.window);
        ppl.updateDepthStencil(dsUIAndProfilerPassDSName, width, height);
      }
      function setupUIPass(ppl, info) {
        const camera = info.camera;
        const area = getRenderArea(camera, camera.window.width, camera.window.height);
        const width = area.width;
        const height = area.height;
        const dsUIAndProfilerPassRTName = `dsUIAndProfilerPassColor${info.id}`;
        const dsUIAndProfilerPassDSName = `dsUIAndProfilerPassDS${info.id}`;
        const uiAndProfilerPass = ppl.addRenderPass(width, height, 'default');
        uiAndProfilerPass.name = `CameraUIAndProfilerPass${info.id}`;
        uiAndProfilerPass.setViewport(new Viewport(area.x, area.y, width, height));
        uiAndProfilerPass.addRenderTarget(dsUIAndProfilerPassRTName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.RENDER_TARGET), StoreOp.STORE, new Color(camera.clearColor.x, camera.clearColor.y, camera.clearColor.z, camera.clearColor.w));
        uiAndProfilerPass.addDepthStencil(dsUIAndProfilerPassDSName, getLoadOpOfClearFlag(camera.clearFlag, AttachmentType.DEPTH_STENCIL), StoreOp.STORE, camera.clearDepth, camera.clearStencil, camera.clearFlag);
        const sceneFlags = SceneFlags.UI;
        uiAndProfilerPass.addQueue(QueueHint.RENDER_TRANSPARENT).addSceneOfCamera(camera, new LightInfo(), sceneFlags);
        if (getProfilerCamera() === camera) {
          uiAndProfilerPass.showStatistics = true;
        }
      }

      class ForwardPipelineBuilder {
        setup(cameras, ppl) {
          for (let i = 0; i < cameras.length; i++) {
            const camera = cameras[i];
            if (camera.scene === null) {
              continue;
            }
            ppl.update(camera);
            const info = prepareResource(ppl, camera, this.initResource, this.updateResource);
            setupForwardPass(ppl, info);
          }
        }
        initResource(ppl, cameraInfo) {
          setupForwardRes(ppl, cameraInfo);
        }
        updateResource(ppl, cameraInfo) {
          updateForwardRes(ppl, cameraInfo);
        }
      } exports('ForwardPipelineBuilder', ForwardPipelineBuilder);
      class DeferredPipelineBuilder {
        setup(cameras, ppl) {
          for (let i = 0; i < cameras.length; ++i) {
            const camera = cameras[i];
            if (!camera.scene) {
              continue;
            }
            ppl.update(camera);
            const useCluster = ppl.device.hasFeature(Feature.COMPUTE_SHADER);
            const isGameView = camera.cameraUsage === CameraUsage.GAME || camera.cameraUsage === CameraUsage.GAME_VIEW;
            const info = prepareResource(ppl, camera, this.initResource, this.updateResource);
            if (!isGameView) {
              setupForwardPass(ppl, info);
              continue;
            }
            if (!isUICamera(camera)) {
              if (useCluster) {
                buildClusterPasses(camera, ppl);
              }
              setupGBufferPass(ppl, info);
              const lightInfo = setupLightingPass(ppl, info, useCluster);
              setupDeferredForward(ppl, info, lightInfo.rtName, useCluster);
              setupPostprocessPass(ppl, info, lightInfo.rtName);
              continue;
            }
            setupUIPass(ppl, info);
          }
        }
        initResource(ppl, cameraInfo) {
          if (!isUICamera(cameraInfo.camera)) {
            setupGBufferRes(ppl, cameraInfo);
            setupLightingRes(ppl, cameraInfo);
            setupPostprocessRes(ppl, cameraInfo);
          } else {
            setupUIRes(ppl, cameraInfo);
          }
        }
        updateResource(ppl, cameraInfo) {
          if (!isUICamera(cameraInfo.camera)) {
            updateGBufferRes(ppl, cameraInfo);
            updateLightingRes(ppl, cameraInfo);
            updatePostprocessRes(ppl, cameraInfo);
          } else {
            updateUIRes(ppl, cameraInfo);
          }
        }
      } exports('DeferredPipelineBuilder', DeferredPipelineBuilder);

      const Destroyed = CCObject.Flags.Destroyed;
      const PersistentMask = CCObject.Flags.PersistentMask;
      const objsToClearTmpVar = [];
      function hasImplementedInstantiate(original) {
        return typeof original._instantiate === 'function';
      }
      function instantiate(original, internalForce) {
        let clone;
        if (isCCObject(original)) {
          if (hasImplementedInstantiate(original)) {
            legacyCC.game._isCloning = true;
            clone = original._instantiate(null, true);
            legacyCC.game._isCloning = false;
            {
              updateChildrenForDeserialize(clone);
            }
            return clone;
          } else if (original instanceof legacyCC.Asset) {
            throw new TypeError(getError(6903));
          }
        }
        legacyCC.game._isCloning = true;
        clone = doInstantiate(original);
        legacyCC.game._isCloning = false;
        {
          updateChildrenForDeserialize(clone);
        }
        return clone;
      }
      function doInstantiate(obj, parent) {
        let clone;
        if (obj._iN$t) {
          clone = obj._iN$t;
        } else if (obj.constructor) {
          const Klass = obj.constructor;
          clone = new Klass();
        } else {
          clone = Object.create(null);
        }
        enumerateObject(obj, clone, parent);
        for (let i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
          objsToClearTmpVar[i]._iN$t = null;
        }
        objsToClearTmpVar.length = 0;
        return clone;
      }
      function enumerateCCClass(klass, obj, clone, parent) {
        const props = klass.__values__;
        for (let p = 0; p < props.length; p++) {
          const key = props[p];
          const value = obj[key];
          if (typeof value === 'object' && value) {
            const initValue = clone[key];
            if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
              initValue.set(value);
            } else {
              clone[key] = value._iN$t || instantiateObj(value, parent);
            }
          } else {
            clone[key] = value;
          }
        }
      }
      function enumerateObject(obj, clone, parent) {
        value(obj, '_iN$t', clone, true);
        objsToClearTmpVar.push(obj);
        const klass = obj.constructor;
        if (isCCClassOrFastDefined(klass)) {
          enumerateCCClass(klass, obj, clone, parent);
        } else {
          for (const key in obj) {
            if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
              continue;
            }
            const value = obj[key];
            if (typeof value === 'object' && value) {
              if (value === clone) {
                continue;
              }
              clone[key] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[key] = value;
            }
          }
        }
        if (isCCObject(obj)) {
          clone._objFlags &= PersistentMask;
        }
      }
      function instantiateObj(obj, parent) {
        if (obj instanceof ValueType) {
          return obj.clone();
        }
        if (obj instanceof legacyCC.Asset) {
          return obj;
        }
        let clone;
        if (ArrayBuffer.isView(obj)) {
          const len = obj.length;
          clone = new obj.constructor(len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);
          for (let i = 0; i < len; ++i) {
            clone[i] = obj[i];
          }
          return clone;
        }
        if (Array.isArray(obj)) {
          const len = obj.length;
          clone = new Array(len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);
          for (let i = 0; i < len; ++i) {
            const value = obj[i];
            if (typeof value === 'object' && value) {
              clone[i] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[i] = value;
            }
          }
          return clone;
        } else if (obj._objFlags & Destroyed) {
          return null;
        }
        const ctor = obj.constructor;
        if (isCCClassOrFastDefined(ctor)) {
          if (parent) {
            if (parent instanceof Component) {
              if (obj instanceof Node$1 || obj instanceof Component) {
                return obj;
              }
            } else if (parent instanceof Node$1) {
              if (obj instanceof Node$1) {
                if (!obj.isChildOf(parent)) {
                  return obj;
                }
              } else if (obj instanceof Component) {
                if (obj.node && !obj.node.isChildOf(parent)) {
                  return obj;
                }
              }
            }
          }
          clone = new ctor();
        } else if (ctor === Object) {
          clone = {};
        } else if (!ctor) {
          clone = Object.create(null);
        } else {
          return obj;
        }
        enumerateObject(obj, clone, parent);
        return clone;
      }
      instantiate._clone = doInstantiate;
      legacyCC.instantiate = instantiate;

      class NodePool {
        constructor(poolHandlerComp) {
          this.poolHandlerComp = void 0;
          this._pool = void 0;
          this.poolHandlerComp = poolHandlerComp;
          this._pool = [];
        }
        size() {
          return this._pool.length;
        }
        clear() {
          const count = this._pool.length;
          for (let i = 0; i < count; ++i) {
            this._pool[i].destroy();
          }
          this._pool.length = 0;
        }
        put(obj) {
          if (obj && this._pool.indexOf(obj) === -1) {
            obj.removeFromParent();
            const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.unuse) {
              handler.unuse();
            }
            this._pool.push(obj);
          }
        }
        get(...args) {
          const last = this._pool.length - 1;
          if (last < 0) {
            return null;
          } else {
            const obj = this._pool[last];
            this._pool.length = last;
            const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.reuse) {
              handler.reuse(arguments);
            }
            return obj;
          }
        }
      } exports('NodePool', NodePool);
      legacyCC.NodePool = NodePool;

      var _globalThis$jsb, _globalJsb$copyTextTo;
      const globalJsb = (_globalThis$jsb = globalThis.jsb) !== null && _globalThis$jsb !== void 0 ? _globalThis$jsb : {};
      {
        Object.defineProperty(globalJsb, 'reflection', {
          get() {
            if (globalJsb.__bridge !== undefined) return globalJsb.__bridge;
            if (globalThis.JavascriptJavaBridge && (sys.os === sys.OS.ANDROID || sys.os === sys.OS.OHOS)) {
              globalJsb.__bridge = new globalThis.JavascriptJavaBridge();
            } else if (globalThis.JavaScriptObjCBridge && (sys.os === sys.OS.IOS || sys.os === sys.OS.OSX)) {
              globalJsb.__bridge = new globalThis.JavaScriptObjCBridge();
            } else {
              globalJsb.__bridge = null;
            }
            return globalJsb.__bridge;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__bridge = value;
          }
        });
        Object.defineProperty(globalJsb, 'bridge', {
          get() {
            if (globalJsb.__ccbridge !== undefined) return globalJsb.__ccbridge;
            if (globalThis.ScriptNativeBridge && sys.os === sys.OS.ANDROID || sys.os === sys.OS.IOS || sys.os === sys.OS.OSX || sys.os === sys.OS.OHOS) {
              globalJsb.__ccbridge = new ScriptNativeBridge();
            } else {
              globalJsb.__ccbridge = null;
            }
            return globalJsb.__ccbridge;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__ccbridge = value;
          }
        });
        const JsbBridgeWrapper = {
          eventMap: new Map(),
          addNativeEventListener(eventName, listener) {
            if (!this.eventMap.get(eventName)) {
              this.eventMap.set(eventName, []);
            }
            const arr = this.eventMap.get(eventName);
            if (!arr.find(listener)) {
              arr.push(listener);
            }
          },
          dispatchEventToNative(eventName, arg) {
            globalJsb.bridge.sendToNative(eventName, arg);
          },
          removeAllListenersForEvent(eventName) {
            return this.eventMap.delete(eventName);
          },
          removeNativeEventListener(eventName, listener) {
            const arr = this.eventMap.get(eventName);
            if (!arr) {
              return false;
            }
            for (let i = 0, l = arr.length; i < l; i++) {
              if (arr[i] === listener) {
                arr.splice(i, 1);
                return true;
              }
            }
            return true;
          },
          removeAllListeners() {
            this.eventMap.clear();
          },
          triggerEvent(eventName, arg) {
            const arr = this.eventMap.get(eventName);
            if (!arr) {
              console.error(`${eventName} does not exist`);
              return;
            }
            arr.map(listener => listener.call(null, arg));
          }
        };
        Object.defineProperty(globalJsb, 'jsbBridgeWrapper', {
          get() {
            if (globalJsb.__JsbBridgeWrapper !== undefined) return globalJsb.__JsbBridgeWrapper;
            if (globalThis.ScriptNativeBridge && sys.os === sys.OS.ANDROID || sys.os === sys.OS.IOS || sys.os === sys.OS.OSX || sys.os === sys.OS.OHOS) {
              globalJsb.__JsbBridgeWrapper = JsbBridgeWrapper;
              globalJsb.bridge.onNative = (methodName, arg1) => {
                globalJsb.__JsbBridgeWrapper.triggerEvent(methodName, arg1);
              };
            } else {
              globalJsb.__JsbBridgeWrapper = null;
            }
            return globalJsb.__JsbBridgeWrapper;
          },
          enumerable: true,
          configurable: true,
          set(value) {
            globalJsb.__JsbBridgeWrapper = value;
          }
        });
        const originSaveImageData = globalJsb.saveImageData;
        globalJsb.saveImageData = (data, width, height, filePath) => {
          return new Promise((resolve, reject) => {
            originSaveImageData(data, width, height, filePath, isSuccess => {
              if (isSuccess) {
                resolve();
              } else {
                reject();
              }
            });
          });
        };
      }
      const native = exports('native', {
        DownloaderHints: globalJsb.DownloaderHints,
        Downloader: globalJsb.Downloader,
        zipUtils: globalJsb.zipUtils,
        fileUtils: globalJsb.fileUtils,
        DebugRenderer: globalJsb.DebugRenderer,
        copyTextToClipboard: (_globalJsb$copyTextTo = globalJsb.copyTextToClipboard) === null || _globalJsb$copyTextTo === void 0 ? void 0 : _globalJsb$copyTextTo.bind(globalJsb),
        garbageCollect: globalJsb.garbageCollect,
        reflection: globalJsb.reflection,
        bridge: globalJsb.bridge,
        jsbBridgeWrapper: globalJsb.jsbBridgeWrapper,
        AssetsManager: globalJsb.AssetsManager,
        EventAssetsManager: globalJsb.EventAssetsManager,
        Manifest: globalJsb.Manifest,
        saveImageData: globalJsb.saveImageData,
        process: globalJsb.process,
        adpf: globalJsb.adpf
      });

      legacyCC.renderer = renderer;

      var _dec$W, _dec2$R, _dec3$E, _class$U, _class2$S, _initializer$Q, _initializer2$N, _initializer3$C, _initializer4$w, _initializer5$r;
      let Billboard = (_dec$W = ccclass$6('cc.Billboard'), _dec2$R = type$6(Texture2D$1), _dec3$E = type$6(Texture2D$1), _dec$W(_class$U = (_class2$S = class Billboard extends Component {
        get texture() {
          return this._texture;
        }
        set texture(val) {
          this._texture = val;
          this.updateTexture();
        }
        updateTexture() {
          if (this._material) {
            this._material.setProperty('mainTexture', this._texture);
          }
        }
        get height() {
          return this._height;
        }
        set height(val) {
          this._height = val;
          this.updateHeight();
        }
        updateHeight() {
          if (this._material) {
            this._uniform.y = this._height;
            this._material.setProperty('cc_size_rotation', this._uniform);
          }
        }
        get width() {
          return this._width;
        }
        set width(val) {
          this._width = val;
          this.updateWidth();
        }
        updateWidth() {
          if (this._material) {
            this._uniform.x = this._width;
            this._material.setProperty('cc_size_rotation', this._uniform);
          }
        }
        get rotation() {
          return Math.round(toDegree(this._rotation) * 100) / 100;
        }
        set rotation(val) {
          this._rotation = toRadian(val);
          this.updateRotation();
        }
        updateRotation() {
          if (this._material) {
            this._uniform.z = this._rotation;
            this._material.setProperty('cc_size_rotation', this._uniform);
          }
        }
        get technique() {
          return this._techIndex;
        }
        set technique(val) {
          var _this$_material, _this$_material$effec;
          val = Math.floor(val);
          const techs = (_this$_material = this._material) === null || _this$_material === void 0 ? void 0 : (_this$_material$effec = _this$_material.effectAsset) === null || _this$_material$effec === void 0 ? void 0 : _this$_material$effec.techniques;
          if (techs && val >= techs.length) {
            val = techs.length - 1;
          }
          if (val < 0) {
            val = 0;
          }
          this._techIndex = val;
          this.updateTechnique();
        }
        updateTechnique() {
          if (this._model && this._mesh && this._material && this._material.technique !== this._techIndex) {
            this.detachFromScene();
            this._model.destroy();
            this._model = null;
            this._material.destroy();
            this._material = null;
            this._mesh.destroy();
            this._mesh = null;
            this.createModel();
            this.updateWidth();
            this.updateHeight();
            this.updateRotation();
            this.updateTexture();
            if (this.enabled) {
              this.attachToScene();
              this._model.enabled = true;
            } else {
              this._model.enabled = false;
            }
          }
        }
        constructor() {
          super();
          this._texture = _initializer$Q && _initializer$Q();
          this._height = _initializer2$N && _initializer2$N();
          this._width = _initializer3$C && _initializer3$C();
          this._rotation = _initializer4$w && _initializer4$w();
          this._techIndex = _initializer5$r && _initializer5$r();
          this._model = null;
          this._mesh = null;
          this._material = null;
          this._uniform = new Vec4(1, 1, 0, 0);
        }
        onLoad() {
          this.createModel();
        }
        onEnable() {
          this.attachToScene();
          this._model.enabled = true;
          this.updateWidth();
          this.updateHeight();
          this.updateRotation();
          this.updateTexture();
          this.updateTechnique();
        }
        onDisable() {
          this.detachFromScene();
        }
        attachToScene() {
          if (this._model && this.node && this.node.scene) {
            if (this._model.scene) {
              this.detachFromScene();
            }
            this._getRenderScene().addModel(this._model);
          }
        }
        detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        }
        createModel() {
          this._mesh = createMesh({
            primitiveMode: PrimitiveMode.TRIANGLE_LIST,
            positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            uvs: [0, 0, 1, 0, 0, 1, 1, 1],
            colors: [Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a],
            attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8UI, true)],
            indices: [0, 1, 2, 1, 2, 3]
          }, undefined, {
            calculateBounds: false
          });
          const model = this._model = legacyCC.director.root.createModel(Model, this.node);
          model.node = model.transform = this.node;
          if (this._material == null) {
            this._material = new Material();
            this._material.copy(builtinResMgr.get('default-billboard-material'), {
              technique: this._techIndex
            });
          }
          model.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
        }
      }, (_initializer$Q = applyDecoratedInitializer(_class2$S.prototype, "_texture", [_dec2$R], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$S.prototype, "texture", [_dec3$E], Object.getOwnPropertyDescriptor(_class2$S.prototype, "texture"), _class2$S.prototype), _initializer2$N = applyDecoratedInitializer(_class2$S.prototype, "_height", [serializable$6], function () {
        return 0;
      }), _initializer3$C = applyDecoratedInitializer(_class2$S.prototype, "_width", [serializable$6], function () {
        return 0;
      }), _initializer4$w = applyDecoratedInitializer(_class2$S.prototype, "_rotation", [serializable$6], function () {
        return 0;
      }), _initializer5$r = applyDecoratedInitializer(_class2$S.prototype, "_techIndex", [serializable$6], function () {
        return 0;
      })), _class2$S)) || _class$U); exports({ Billboard: Billboard, BillboardComponent: Billboard });

      const _vertex_attrs$1 = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      const _temp_v1 = new Vec3();
      const _temp_v2 = new Vec3();
      class LineModel extends Model {
        constructor() {
          super();
          this._capacity = void 0;
          this._vertSize = 0;
          this._vBuffer = null;
          this._vertAttrsFloatCount = 0;
          this._vdataF32 = null;
          this._vdataUint32 = null;
          this._subMeshData = null;
          this._vertCount = 0;
          this._indexCount = 0;
          this._material = null;
          this._iaVertCount = 0;
          this._iaIndexCount = 0;
          {
            this._registerListeners();
          }
          this.type = ModelType.LINE;
          this._capacity = 100;
        }
        setCapacity(capacity) {
          this._capacity = capacity;
          this.createBuffer();
        }
        createBuffer() {
          this._vertSize = 0;
          for (const a of _vertex_attrs$1) {
            a.offset = this._vertSize;
            this._vertSize += FormatInfos[a.format].size;
          }
          this._vertAttrsFloatCount = this._vertSize / 4;
          this._vBuffer = this.createSubMeshData();
          this._vdataF32 = new Float32Array(this._vBuffer);
          this._vdataUint32 = new Uint32Array(this._vBuffer);
        }
        updateMaterial(mat) {
          this._material = mat;
          super.setSubModelMaterial(0, mat);
        }
        createSubMeshData() {
          if (this._subMeshData) {
            this.destroySubMeshData();
          }
          this._vertCount = 2;
          this._indexCount = 6;
          const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize));
          const vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
          vertexBuffer.update(vBuffer);
          const indices = new Uint16Array((this._capacity - 1) * this._indexCount);
          let dst = 0;
          for (let i = 0; i < this._capacity - 1; ++i) {
            const baseIdx = 2 * i;
            indices[dst++] = baseIdx;
            indices[dst++] = baseIdx + 1;
            indices[dst++] = baseIdx + 2;
            indices[dst++] = baseIdx + 3;
            indices[dst++] = baseIdx + 2;
            indices[dst++] = baseIdx + 1;
          }
          const indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          indexBuffer.update(indices);
          this._iaVertCount = this._capacity * this._vertCount;
          this._iaIndexCount = (this._capacity - 1) * this._indexCount;
          this._subMeshData = new RenderingSubMesh([vertexBuffer], _vertex_attrs$1, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
          this.initSubModel(0, this._subMeshData, this._material);
          return vBuffer;
        }
        addLineVertexData(positions, width, color) {
          if (positions.length > 1) {
            let offset = 0;
            Vec3.subtract(_temp_v1, positions[1], positions[0]);
            this._vdataF32[offset++] = positions[0].x;
            this._vdataF32[offset++] = positions[0].y;
            this._vdataF32[offset++] = positions[0].z;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = width.evaluate(0, 1);
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
            this._vdataF32[offset++] = positions[0].x;
            this._vdataF32[offset++] = positions[0].y;
            this._vdataF32[offset++] = positions[0].z;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = width.evaluate(0, 1);
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
            for (let i = 1; i < positions.length - 1; i++) {
              Vec3.subtract(_temp_v1, positions[i - 1], positions[i]);
              Vec3.subtract(_temp_v2, positions[i + 1], positions[i]);
              Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
              const seg = i / positions.length;
              this._vdataF32[offset++] = positions[i].x;
              this._vdataF32[offset++] = positions[i].y;
              this._vdataF32[offset++] = positions[i].z;
              this._vdataF32[offset++] = 0;
              this._vdataF32[offset++] = width.evaluate(seg, 1);
              this._vdataF32[offset++] = seg;
              this._vdataF32[offset++] = 0;
              this._vdataF32[offset++] = _temp_v2.x;
              this._vdataF32[offset++] = _temp_v2.y;
              this._vdataF32[offset++] = _temp_v2.z;
              this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
              this._vdataF32[offset++] = positions[i].x;
              this._vdataF32[offset++] = positions[i].y;
              this._vdataF32[offset++] = positions[i].z;
              this._vdataF32[offset++] = 1;
              this._vdataF32[offset++] = width.evaluate(seg, 1);
              this._vdataF32[offset++] = seg;
              this._vdataF32[offset++] = 1;
              this._vdataF32[offset++] = _temp_v2.x;
              this._vdataF32[offset++] = _temp_v2.y;
              this._vdataF32[offset++] = _temp_v2.z;
              this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
            }
            Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]);
            this._vdataF32[offset++] = positions[positions.length - 1].x;
            this._vdataF32[offset++] = positions[positions.length - 1].y;
            this._vdataF32[offset++] = positions[positions.length - 1].z;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = width.evaluate(1, 1);
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = 0;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
            this._vdataF32[offset++] = positions[positions.length - 1].x;
            this._vdataF32[offset++] = positions[positions.length - 1].y;
            this._vdataF32[offset++] = positions[positions.length - 1].z;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = width.evaluate(1, 1);
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = 1;
            this._vdataF32[offset++] = _temp_v1.x;
            this._vdataF32[offset++] = _temp_v1.y;
            this._vdataF32[offset++] = _temp_v1.z;
            this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
          }
          this.updateIA(Math.max(0, positions.length - 1));
        }
        updateIA(count) {
          const ia = this._subModels[0].inputAssembler;
          ia.vertexBuffers[0].update(this._vdataF32);
          ia.firstIndex = 0;
          ia.indexCount = this._indexCount * count;
          ia.vertexCount = this._iaVertCount;
        }
        destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();
            this._subMeshData = null;
          }
        }
      }

      var _dec$V, _class$T, _class2$R;
      const setClassAttr = CCClass.Attr.setClassAttr;
      const SerializableTable$1 = [['mode', 'constant', 'multiplier'], ['mode', 'spline', 'multiplier'], ['mode', 'splineMin', 'splineMax', 'multiplier'], ['mode', 'constantMin', 'constantMax', 'multiplier']];
      const Mode$3 = Enum({
        Constant: 0,
        Curve: 1,
        TwoCurves: 2,
        TwoConstants: 3
      });
      let CurveRange = exports('CurveRange', (_dec$V = ccclass$6('cc.CurveRange'), _dec$V(_class$T = (_class2$R = class CurveRange {
        set mode(mode) {
          this._mode = mode;
          switch (mode) {
            case Mode$3.Constant:
              break;
            case Mode$3.TwoConstants:
              break;
            case Mode$3.Curve:
              if (!this.spline) this.spline = constructLegacyCurveAndConvert();
              break;
            case Mode$3.TwoCurves:
              if (!this.splineMax) this.splineMax = constructLegacyCurveAndConvert();
              if (!this.splineMin) this.splineMin = constructLegacyCurveAndConvert();
              break;
          }
        }
        get mode() {
          return this._mode;
        }
        get curve() {
          var _this$_curve;
          return (_this$_curve = this._curve) !== null && _this$_curve !== void 0 ? _this$_curve : this._curve = new AnimationCurve(this.spline);
        }
        set curve(value) {
          this._curve = value;
          this.spline = value._internalCurve;
        }
        get curveMin() {
          var _this$_curveMin;
          return (_this$_curveMin = this._curveMin) !== null && _this$_curveMin !== void 0 ? _this$_curveMin : this._curveMin = new AnimationCurve(this.splineMin);
        }
        set curveMin(value) {
          this._curveMin = value;
          this.splineMin = value._internalCurve;
        }
        get curveMax() {
          var _this$_curveMax;
          return (_this$_curveMax = this._curveMax) !== null && _this$_curveMax !== void 0 ? _this$_curveMax : this._curveMax = new AnimationCurve(this.splineMax);
        }
        set curveMax(value) {
          this._curveMax = value;
          this.splineMax = value._internalCurve;
        }
        constructor() {
          this.constant = 0;
          this.constantMin = 0;
          this.constantMax = 0;
          this.multiplier = 1;
          this._mode = Mode$3.Constant;
        }
        evaluate(time, rndRatio) {
          switch (this._mode) {
            default:
            case Mode$3.Constant:
              return this.constant;
            case Mode$3.Curve:
              return this.spline.evaluate(time) * this.multiplier;
            case Mode$3.TwoCurves:
              return lerp(this.splineMin.evaluate(time), this.splineMax.evaluate(time), rndRatio) * this.multiplier;
            case Mode$3.TwoConstants:
              return lerp(this.constantMin, this.constantMax, rndRatio);
          }
        }
        getMax() {
          switch (this._mode) {
            default:
            case Mode$3.Constant:
              return this.constant;
            case Mode$3.Curve:
              return this.multiplier;
            case Mode$3.TwoConstants:
              return this.constantMax;
            case Mode$3.TwoCurves:
              return this.multiplier;
          }
        }
        isZero() {
          switch (this._mode) {
            default:
            case Mode$3.Constant:
              return approx(this.constant, 0.0, EPSILON$2);
            case Mode$3.Curve:
              return approx(this.multiplier, 0.0, EPSILON$2);
            case Mode$3.TwoConstants:
              return approx(Math.max(Math.abs(this.constantMax), Math.abs(this.constantMin)), 0.0, EPSILON$2);
            case Mode$3.TwoCurves:
              return approx(this.multiplier, 0.0, EPSILON$2);
          }
        }
        _onBeforeSerialize(props) {
          return SerializableTable$1[this._mode];
        }
      }, _class2$R.Mode = Mode$3, _class2$R)) || _class$T));
      CCClass.fastDefine('cc.CurveRange', CurveRange, {
        multiplier: 1,
        constantMax: 0,
        constantMin: 0,
        constant: 0,
        mode: Mode$3.Constant,
        splineMax: Object.freeze(constructLegacyCurveAndConvert()),
        splineMin: Object.freeze(constructLegacyCurveAndConvert()),
        spline: Object.freeze(constructLegacyCurveAndConvert())
      });
      setClassAttr(CurveRange, 'multiplier', 'visible', true);
      setClassAttr(CurveRange, 'constantMax', 'visible', true);
      setClassAttr(CurveRange, 'constantMin', 'visible', true);
      setClassAttr(CurveRange, 'constant', 'visible', true);
      setPropertyEnumType(CurveRange, 'mode', Mode$3);
      setClassAttr(CurveRange, 'mode', 'visible', true);
      setClassAttr(CurveRange, 'splineMax', 'type', 'Object');
      setClassAttr(CurveRange, 'splineMax', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'splineMax', 'visible', true);
      setClassAttr(CurveRange, 'splineMin', 'type', 'Object');
      setClassAttr(CurveRange, 'splineMin', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'splineMin', 'visible', true);
      setClassAttr(CurveRange, 'spline', 'type', 'Object');
      setClassAttr(CurveRange, 'spline', 'ctor', RealCurve);
      setClassAttr(CurveRange, 'spline', 'visible', true);
      function evaluateCurve(cr, time, index) {
        switch (cr.mode) {
          case Mode$3.Constant:
            return cr.constant;
          case Mode$3.Curve:
            return cr.spline.evaluate(time) * cr.multiplier;
          case Mode$3.TwoCurves:
            return index === 0 ? cr.splineMin.evaluate(time) * cr.multiplier : cr.splineMax.evaluate(time) * cr.multiplier;
          case Mode$3.TwoConstants:
            return index === 0 ? cr.constantMin : cr.constantMax;
          default:
            return 0;
        }
      }
      function evaluateHeight$1(cr) {
        switch (cr.mode) {
          case Mode$3.TwoConstants:
            return 2;
          case Mode$3.TwoCurves:
            return 2;
          default:
            return 1;
        }
      }
      function packTexture(data, width, height) {
        const image = new ImageAsset$1({
          width,
          height,
          _data: data,
          _compressed: false,
          format: PixelFormat.RGBA32F
        });
        const texture = new Texture2D$1();
        texture.setFilters(Filter.NEAREST, Filter.NEAREST);
        texture.setMipFilter(Filter.NONE);
        texture.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
        texture.image = image;
        return texture;
      }
      function updateTexture(tex, data, width, height) {
        if (tex === null || width !== tex.width || height !== tex.height) {
          if (tex) {
            tex.destroy();
          }
          tex = packTexture(data, width, height);
        } else {
          tex.uploadData(data);
        }
        return tex;
      }
      function packCurveRangeZ(tex, data, samples, cr, discrete) {
        const height = evaluateHeight$1(cr);
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }
        const interval = 1.0 / (samples - 1);
        let offset = 0;
        for (let h = 0; h < height; h++) {
          for (let j = 0; j < samples; j++) {
            const value = evaluateCurve(cr, interval * j, h);
            data[offset + 2] = value;
            offset += 4;
          }
        }
        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeN(tex, data, samples, cr, discrete) {
        const height = evaluateHeight$1(cr);
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }
        const interval = 1.0 / (samples - 1);
        let sum = 0;
        let average = 0;
        let offset = 0;
        for (let h = 0; h < height; h++) {
          sum = 0;
          for (let j = 0; j < samples; j++) {
            const value = evaluateCurve(cr, interval * j, h);
            if (discrete) {
              average = value;
            } else {
              sum += value;
              average = sum / (j + 1);
            }
            data[offset] = average;
            data[offset + 1] = average;
            data[offset + 2] = average;
            offset += 4;
          }
        }
        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXY(tex, data, samples, x, y, discrete) {
        const height = Math.max(evaluateHeight$1(x), evaluateHeight$1(y));
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }
        const curves = [x, y];
        const interval = 1.0 / (samples - 1);
        for (let h = 0; h < height; h++) {
          for (let i = 0; i < 2; i++) {
            const cr = curves[i];
            let sum = 0;
            let average = 0;
            for (let j = 0; j < samples; j++) {
              const value = evaluateCurve(cr, interval * j, h);
              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }
              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }
        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXYZ(tex, data, samples, x, y, z, discrete) {
        const height = Math.max(evaluateHeight$1(x), evaluateHeight$1(y), evaluateHeight$1(z));
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }
        const curves = [x, y, z];
        const interval = 1.0 / (samples - 1);
        for (let h = 0; h < height; h++) {
          for (let i = 0; i < 3; i++) {
            const cr = curves[i];
            let sum = 0;
            let average = 0;
            for (let j = 0; j < samples; j++) {
              const value = evaluateCurve(cr, interval * j, h);
              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }
              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }
        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }
      function packCurveRangeXYZW(tex, data, samples, x, y, z, w, discrete) {
        const height = Math.max(evaluateHeight$1(x), evaluateHeight$1(y), evaluateHeight$1(z), evaluateHeight$1(w));
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Float32Array(samples * height * 4);
        }
        const curves = [x, y, z, w];
        const interval = 1.0 / (samples - 1);
        for (let h = 0; h < height; h++) {
          for (let i = 0; i < 4; i++) {
            const cr = curves[i];
            let sum = 0;
            let average = 0;
            for (let j = 0; j < samples; j++) {
              const value = evaluateCurve(cr, interval * j, h);
              if (discrete) {
                average = value;
              } else {
                sum += value;
                average = sum / (j + 1);
              }
              data[(h * samples + j) * 4 + i] = average;
            }
          }
        }
        return {
          texture: updateTexture(tex, data, samples, height),
          texdata: data
        };
      }

      var _dec$U, _dec2$Q, _dec3$D, _dec4$y, _dec5$v, _dec6$i, _class$S, _class2$Q, _initializer$P, _initializer2$M, _initializer3$B, _initializer4$v, _initializer5$q, _initializer6$l, _initializer7$i, _class3$l;
      const SerializableTable = EDITOR ;
      const Mode$2 = Enum({
        Color: 0,
        Gradient: 1,
        TwoColors: 2,
        TwoGradients: 3,
        RandomColor: 4
      });
      const tempColor = new Color$1();
      const tempColor2 = new Color$1();
      let GradientRange = exports('GradientRange', (_dec$U = ccclass$6('cc.GradientRange'), _dec2$Q = type$6(Mode$2), _dec3$D = type$6(Gradient), _dec4$y = type$6(Gradient), _dec5$v = type$6(Gradient), _dec6$i = type$6(Mode$2), _dec$U(_class$S = (_class2$Q = (_class3$l = class GradientRange {
        constructor() {
          this.color = _initializer$P && _initializer$P();
          this.colorMin = _initializer2$M && _initializer2$M();
          this.colorMax = _initializer3$B && _initializer3$B();
          this.gradient = _initializer4$v && _initializer4$v();
          this.gradientMin = _initializer5$q && _initializer5$q();
          this.gradientMax = _initializer6$l && _initializer6$l();
          this._mode = _initializer7$i && _initializer7$i();
          this._color = Color$1.WHITE.clone();
        }
        get mode() {
          return this._mode;
        }
        set mode(m) {
          this._mode = m;
        }
        evaluate(time, rndRatio) {
          switch (this._mode) {
            case Mode$2.Color:
              return this.color;
            case Mode$2.TwoColors:
              Color$1.lerp(this._color, this.colorMin, this.colorMax, rndRatio);
              return this._color;
            case Mode$2.RandomColor:
              return this.gradient.getRandomColor(this._color);
            case Mode$2.Gradient:
              return this.gradient.evaluateFast(this._color, time);
            case Mode$2.TwoGradients:
              Color$1.lerp(this._color, this.gradientMin.evaluateFast(tempColor, time), this.gradientMax.evaluateFast(tempColor2, time), rndRatio);
              return this._color;
            default:
              return this.color;
          }
        }
        _onBeforeSerialize(props) {
          return SerializableTable[this._mode];
        }
      }, _class3$l.Mode = Mode$2, _class3$l), (_applyDecoratedDescriptor(_class2$Q.prototype, "mode", [_dec2$Q], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "mode"), _class2$Q.prototype), _initializer$P = applyDecoratedInitializer(_class2$Q.prototype, "color", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer2$M = applyDecoratedInitializer(_class2$Q.prototype, "colorMin", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer3$B = applyDecoratedInitializer(_class2$Q.prototype, "colorMax", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer4$v = applyDecoratedInitializer(_class2$Q.prototype, "gradient", [_dec3$D], function () {
        return new Gradient();
      }), _initializer5$q = applyDecoratedInitializer(_class2$Q.prototype, "gradientMin", [_dec4$y], function () {
        return new Gradient();
      }), _initializer6$l = applyDecoratedInitializer(_class2$Q.prototype, "gradientMax", [_dec5$v], function () {
        return new Gradient();
      }), _initializer7$i = applyDecoratedInitializer(_class2$Q.prototype, "_mode", [_dec6$i], function () {
        return Mode$2.Color;
      })), _class2$Q)) || _class$S));
      function evaluateGradient(gr, time, index) {
        switch (gr.mode) {
          case Mode$2.Color:
            return gr.color;
          case Mode$2.TwoColors:
            return index === 0 ? gr.colorMin : gr.colorMax;
          case Mode$2.RandomColor:
            return gr.gradient.getRandomColor(tempColor);
          case Mode$2.Gradient:
            return gr.gradient.evaluateFast(tempColor, time);
          case Mode$2.TwoGradients:
            return index === 0 ? gr.gradientMin.evaluateFast(tempColor, time) : gr.gradientMax.evaluateFast(tempColor, time);
          default:
            return gr.color;
        }
      }
      function evaluateHeight(gr) {
        switch (gr.mode) {
          case Mode$2.TwoColors:
            return 2;
          case Mode$2.TwoGradients:
            return 2;
          default:
            return 1;
        }
      }
      function packGradientRange(tex, data, samples, gr) {
        const height = evaluateHeight(gr);
        const len = samples * height * 4;
        if (data === null || data.length !== len) {
          data = new Uint8Array(samples * height * 4);
        }
        const interval = 1.0 / (samples - 1);
        let offset = 0;
        for (let h = 0; h < height; h++) {
          for (let j = 0; j < samples; j++) {
            const color = evaluateGradient(gr, interval * j, h);
            data[offset] = color.r;
            data[offset + 1] = color.g;
            data[offset + 2] = color.b;
            data[offset + 3] = color.a;
            offset += 4;
          }
        }
        if (tex === null || samples !== tex.width || height !== tex.height) {
          if (tex) {
            tex.destroy();
          }
          tex = new Texture2D$1();
          tex.create(samples, height, PixelFormat.RGBA8888);
          tex.setFilters(Filter.LINEAR, Filter.LINEAR);
          tex.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
        }
        tex.uploadData(data);
        return {
          texture: tex,
          texdata: data
        };
      }

      var _dec$T, _dec2$P, _dec3$C, _dec4$x, _dec5$u, _dec6$h, _dec7$e, _dec8$b, _dec9$a, _dec10$6, _class$R, _class2$P, _initializer$O, _initializer2$L, _initializer3$A, _initializer4$u, _initializer5$p, _initializer6$k, _initializer7$h, _initializer8$g;
      const CC_USE_WORLD_SPACE$2 = 'CC_USE_WORLD_SPACE';
      const define = {
        CC_USE_WORLD_SPACE: false,
        CC_USE_WORLD_SCALE: true
      };
      let Line = (_dec$T = ccclass$6('cc.Line'), _dec2$P = type$6(Texture2D$1), _dec3$C = type$6(Texture2D$1), _dec4$x = type$6(Material), _dec5$u = type$6([Vec3]), _dec6$h = type$6([Vec3]), _dec7$e = type$6(CurveRange), _dec8$b = type$6(GradientRange), _dec9$a = type$6(Vec2), _dec10$6 = type$6(Vec2), _dec$T(_class$R = (_class2$P = class Line extends ModelRenderer {
        get texture() {
          return this._texture;
        }
        set texture(val) {
          this._texture = val;
          if (this.material) {
            this.material.setProperty('mainTexture', val);
          }
        }
        get lineMaterial() {
          return this.getSharedMaterial(0);
        }
        set lineMaterial(val) {
          this.setSharedMaterial(val, 0);
        }
        get sharedMaterials() {
          return super.sharedMaterials;
        }
        set sharedMaterials(val) {
          super.sharedMaterials = val;
        }
        get worldSpace() {
          return this._worldSpace;
        }
        set worldSpace(val) {
          this._worldSpace = val;
          const matIns = this.getMaterialInstance(0);
          if (matIns) {
            define[CC_USE_WORLD_SPACE$2] = this.worldSpace;
            matIns.recompileShaders(define);
            if (this._models[0]) {
              this._models[0].setSubModelMaterial(0, matIns);
            }
          }
        }
        get positions() {
          return this._positions;
        }
        set positions(val) {
          this._positions = val;
          if (this._models[0]) {
            const lineModel = this._models[0];
            lineModel.addLineVertexData(this._positions, this.width, this.color);
          }
        }
        get width() {
          return this._width;
        }
        set width(val) {
          this._width = val;
          if (this._models[0]) {
            const lineModel = this._models[0];
            lineModel.addLineVertexData(this._positions, this._width, this._color);
          }
        }
        get color() {
          return this._color;
        }
        set color(val) {
          this._color = val;
          if (this._models[0]) {
            const lineModel = this._models[0];
            lineModel.addLineVertexData(this._positions, this._width, this._color);
          }
        }
        get tile() {
          return this._tile;
        }
        set tile(val) {
          this._tile.set(val);
          if (this.material) {
            this._tile_offset.x = this._tile.x;
            this._tile_offset.y = this._tile.y;
            this.material.setProperty('mainTiling_Offset', this._tile_offset);
          }
        }
        get offset() {
          return this._offset;
        }
        set offset(val) {
          this._offset.set(val);
          if (this.material) {
            this._tile_offset.z = this._offset.x;
            this._tile_offset.w = this._offset.y;
            this.material.setProperty('mainTiling_Offset', this._tile_offset);
          }
        }
        constructor() {
          super();
          this._texture = _initializer$O && _initializer$O();
          this._material = _initializer2$L && _initializer2$L();
          this._worldSpace = _initializer3$A && _initializer3$A();
          this._positions = _initializer4$u && _initializer4$u();
          this._width = _initializer5$p && _initializer5$p();
          this._color = _initializer6$k && _initializer6$k();
          this._tile = _initializer7$h && _initializer7$h();
          this._tile_offset = new Vec4();
          this._offset = _initializer8$g && _initializer8$g();
        }
        onLoad() {
          const model = legacyCC.director.root.createModel(LineModel);
          if (this._models.length === 0) {
            this._models.push(model);
          } else {
            this._models[0] = model;
          }
          model.node = model.transform = this.node;
          if (this._material) {
            this.lineMaterial = this._material;
            this._material = null;
          }
          if (this.lineMaterial === null) {
            const mat = builtinResMgr.get('default-trail-material');
            this.material = mat;
          }
          const matIns = this.getMaterialInstance(0);
          if (matIns) {
            define[CC_USE_WORLD_SPACE$2] = this.worldSpace;
            matIns.recompileShaders(define);
            model.updateMaterial(matIns);
          }
          model.setCapacity(100);
        }
        onEnable() {
          super.onEnable();
          if (this._models.length === 0 || !this._models[0]) {
            return;
          }
          this._attachToScene();
          this.texture = this._texture;
          this.tile = this._tile;
          this.offset = this._offset;
          const lineModel = this._models[0];
          lineModel.addLineVertexData(this._positions, this.width, this.color);
        }
        onDisable() {
          if (this._models.length > 0 && this._models[0]) {
            this._detachFromScene();
          }
        }
        _attachToScene() {
          super._attachToScene();
          if (this._models.length > 0 && this._models[0] && this.node && this.node.scene) {
            const lineModel = this._models[0];
            if (lineModel.scene) {
              this._detachFromScene();
            }
            this._getRenderScene().addModel(lineModel);
          }
        }
        _detachFromScene() {
          super._detachFromScene();
          if (this._models.length > 0 && this._models[0]) {
            const lineModel = this._models[0];
            if (lineModel.scene) {
              lineModel.scene.removeModel(lineModel);
            }
          }
        }
        _onMaterialModified(index, material) {
          super._onMaterialModified(index, material);
          const matIns = this.getMaterialInstance(0);
          if (matIns) {
            define[CC_USE_WORLD_SPACE$2] = this.worldSpace;
            matIns.recompileShaders(define);
            if (this._models[0]) {
              const lineModel = this._models[0];
              lineModel.updateMaterial(matIns);
            }
          }
        }
      }, (_initializer$O = applyDecoratedInitializer(_class2$P.prototype, "_texture", [_dec2$P], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$P.prototype, "texture", [_dec3$C], Object.getOwnPropertyDescriptor(_class2$P.prototype, "texture"), _class2$P.prototype), _initializer2$L = applyDecoratedInitializer(_class2$P.prototype, "_material", [serializable$6], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$P.prototype, "lineMaterial", [_dec4$x], Object.getOwnPropertyDescriptor(_class2$P.prototype, "lineMaterial"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "sharedMaterials", [override, serializable$6], Object.getOwnPropertyDescriptor(_class2$P.prototype, "sharedMaterials"), _class2$P.prototype), _initializer3$A = applyDecoratedInitializer(_class2$P.prototype, "_worldSpace", [serializable$6], function () {
        return false;
      }), _initializer4$u = applyDecoratedInitializer(_class2$P.prototype, "_positions", [_dec5$u], function () {
        return [];
      }), _applyDecoratedDescriptor(_class2$P.prototype, "positions", [_dec6$h], Object.getOwnPropertyDescriptor(_class2$P.prototype, "positions"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "width", [_dec7$e], Object.getOwnPropertyDescriptor(_class2$P.prototype, "width"), _class2$P.prototype), _initializer5$p = applyDecoratedInitializer(_class2$P.prototype, "_width", [serializable$6], function () {
        return new CurveRange();
      }), _applyDecoratedDescriptor(_class2$P.prototype, "color", [_dec8$b], Object.getOwnPropertyDescriptor(_class2$P.prototype, "color"), _class2$P.prototype), _initializer6$k = applyDecoratedInitializer(_class2$P.prototype, "_color", [serializable$6], function () {
        return new GradientRange();
      }), _initializer7$h = applyDecoratedInitializer(_class2$P.prototype, "_tile", [serializable$6], function () {
        return new Vec2(1, 1);
      }), _applyDecoratedDescriptor(_class2$P.prototype, "tile", [_dec9$a], Object.getOwnPropertyDescriptor(_class2$P.prototype, "tile"), _class2$P.prototype), _initializer8$g = applyDecoratedInitializer(_class2$P.prototype, "_offset", [serializable$6], function () {
        return new Vec2(0, 0);
      }), _applyDecoratedDescriptor(_class2$P.prototype, "offset", [_dec10$6], Object.getOwnPropertyDescriptor(_class2$P.prototype, "offset"), _class2$P.prototype)), _class2$P)) || _class$R); exports({ Line: Line, LineComponent: Line });

      class Particle {
        constructor(particleSystem) {
          this.particleSystem = void 0;
          this.position = void 0;
          this.velocity = void 0;
          this.animatedVelocity = void 0;
          this.ultimateVelocity = void 0;
          this.angularVelocity = void 0;
          this.axisOfRotation = void 0;
          this.rotation = void 0;
          this.startEuler = void 0;
          this.startRotation = void 0;
          this.startRotated = void 0;
          this.deltaQuat = void 0;
          this.deltaMat = void 0;
          this.localMat = void 0;
          this.startSize = void 0;
          this.size = void 0;
          this.startColor = void 0;
          this.color = void 0;
          this.randomSeed = void 0;
          this.remainingLifetime = void 0;
          this.loopCount = void 0;
          this.lastLoop = void 0;
          this.trailDelay = void 0;
          this.startLifetime = void 0;
          this.emitAccumulator0 = void 0;
          this.emitAccumulator1 = void 0;
          this.frameIndex = void 0;
          this.startRow = void 0;
          this.particleSystem = particleSystem;
          this.position = new Vec3(0, 0, 0);
          this.velocity = new Vec3(0, 0, 0);
          this.animatedVelocity = new Vec3(0, 0, 0);
          this.ultimateVelocity = new Vec3(0, 0, 0);
          this.angularVelocity = new Vec3(0, 0, 0);
          this.axisOfRotation = new Vec3(0, 0, 0);
          this.rotation = new Vec3(0, 0, 0);
          this.startEuler = new Vec3(0, 0, 0);
          this.startRotation = new Quat();
          this.startRotated = false;
          this.deltaQuat = new Quat();
          this.deltaMat = new Mat4();
          this.localMat = new Mat4();
          this.startSize = new Vec3(0, 0, 0);
          this.size = new Vec3(0, 0, 0);
          this.startColor = Color$1.WHITE.clone();
          this.color = Color$1.WHITE.clone();
          this.randomSeed = 0;
          this.remainingLifetime = 0.0;
          this.loopCount = 0;
          this.lastLoop = 0;
          this.trailDelay = 0;
          this.startLifetime = 0.0;
          this.emitAccumulator0 = 0.0;
          this.emitAccumulator1 = 0.0;
          this.frameIndex = 0.0;
          this.startRow = 0;
        }
        reset() {
          this.rotation.set(0, 0, 0);
          this.startEuler.set(0, 0, 0);
          this.startRotation.set(0, 0, 0, 1);
          this.startRotated = false;
          this.deltaQuat.set(0, 0, 0, 1);
          this.deltaMat.identity();
          this.localMat.identity();
        }
      }
      Particle.INDENTIFY_NEG_QUAT = 10;
      Particle.R2D = 180.0 / Math.PI;
      const PARTICLE_MODULE_NAME = {
        COLOR: 'colorModule',
        FORCE: 'forceModule',
        LIMIT: 'limitModule',
        ROTATION: 'rotationModule',
        SIZE: 'sizeModule',
        VELOCITY: 'velocityModule',
        TEXTURE: 'textureModule',
        NOISE: 'noiseModule'
      };
      const PARTICLE_MODULE_ORDER = ['sizeModule', 'colorModule', 'forceModule', 'velocityModule', 'limitModule', 'rotationModule', 'textureModule', 'noiseModule'];
      const PARTICLE_MODULE_PROPERTY = ['_colorOverLifetimeModule', '_shapeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule', '_trailModule'];
      class ParticleModuleBase {
        constructor() {
          this.target = null;
          this.needUpdate = false;
          this.needAnimate = true;
          this.name = void 0;
        }
        bindTarget(target) {
          this.target = target;
        }
        update(space, trans) {}
      }

      const Space = Enum({
        World: 0,
        Local: 1,
        Custom: 2
      });
      const CullingMode = Enum({
        Pause: 0,
        PauseAndCatchup: 1,
        AlwaysSimulate: 2
      });
      const AlignmentSpace = Enum({
        World: 0,
        Local: 1,
        View: 2
      });
      const RenderMode = Enum({
        Billboard: 0,
        StrecthedBillboard: 1,
        HorizontalBillboard: 2,
        VerticalBillboard: 3,
        Mesh: 4
      });
      const ShapeType = Enum({
        Box: 0,
        Circle: 1,
        Cone: 2,
        Sphere: 3,
        Hemisphere: 4
      });
      const EmitLocation = Enum({
        Base: 0,
        Edge: 1,
        Shell: 2,
        Volume: 3
      });
      const ArcMode = Enum({
        Random: 0,
        Loop: 1,
        PingPong: 2
      });
      const TrailMode = Enum({
        Particles: 0
      });
      const TextureMode = Enum({
        Stretch: 0
      });
      const ModuleRandSeed = {
        LIMIT: 23541,
        SIZE: 39825,
        TEXTURE: 90794,
        COLOR: 91041,
        FORCE: 212165,
        ROTATION: 125292,
        VELOCITY_X: 197866,
        VELOCITY_Y: 156497,
        VELOCITY_Z: 984136
      };

      const particleEmitZAxis = new Vec3(0, 0, -1);
      function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
        if (moduleSpace !== systemSpace) {
          if (systemSpace === Space.World) {
            Mat4.getRotation(outQuat, worldTransform);
          } else {
            Mat4.invert(worldTransform, worldTransform);
            Mat4.getRotation(outQuat, worldTransform);
          }
          return true;
        } else {
          Quat.set(outQuat, 0, 0, 0, 1);
          return false;
        }
      }
      function fixedAngleUnitVector2(out, theta) {
        Vec2.set(out, Math.cos(theta), Math.sin(theta));
      }
      function randomUnitVector(out) {
        const z = randomRange(-1, 1);
        const a = randomRange(0, 2 * Math.PI);
        const r = Math.sqrt(1 - z * z);
        const x = r * Math.cos(a);
        const y = r * Math.sin(a);
        Vec3.set(out, x, y, z);
      }
      function randomPointBetweenSphere(out, minRadius, maxRadius) {
        randomUnitVector(out);
        Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
      }
      function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
        fixedAngleUnitVector2(out, theta);
        out.z = 0;
        Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
      }
      function randomPointInCube(out, extents) {
        Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
      }
      function randomSortArray(arr) {
        for (let i = 0; i < arr.length; i++) {
          const transpose = i + randomRangeInt(0, arr.length - i);
          const val = arr[transpose];
          arr[transpose] = arr[i];
          arr[i] = val;
        }
      }
      function randomSign() {
        let sgn = randomRange(-1, 1);
        if (sgn === 0) {
          sgn++;
        }
        return sign$1(sgn);
      }
      function isCurveTwoValues(curve) {
        const Mode = CurveRange.Mode;
        switch (curve.mode) {
          case Mode.TwoCurves:
          case Mode.TwoConstants:
            return true;
          default:
            return false;
        }
      }
      function isGradientTwoValues(color) {
        const Mode = GradientRange.Mode;
        switch (color.mode) {
          case Mode.TwoGradients:
          case Mode.TwoColors:
            return true;
          default:
            return false;
        }
      }

      var _dec$S, _dec2$O, _class$Q, _class2$O, _initializer$N, _initializer2$K;
      const COLOR_OVERTIME_RAND_OFFSET = ModuleRandSeed.COLOR;
      let ColorOvertimeModule = (_dec$S = ccclass$6('cc.ColorOvertimeModule'), _dec2$O = type$6(GradientRange), _dec$S(_class$Q = (_class2$O = class ColorOvertimeModule extends ParticleModuleBase {
        constructor(...args) {
          super(...args);
          this._enable = _initializer$N && _initializer$N();
          this.color = _initializer2$K && _initializer2$K();
          this.name = PARTICLE_MODULE_NAME.COLOR;
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        animate(particle) {
          particle.color.set(particle.startColor);
          const rand = isGradientTwoValues(this.color) ? pseudoRandom(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET) : 0;
          particle.color.multiply(this.color.evaluate(1.0 - particle.remainingLifetime / particle.startLifetime, rand));
        }
      }, (_initializer$N = applyDecoratedInitializer(_class2$O.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$K = applyDecoratedInitializer(_class2$O.prototype, "color", [_dec2$O, serializable$6], function () {
        return new GradientRange();
      })), _class2$O)) || _class$Q);

      var _dec$R, _dec2$N, _dec3$B, _dec4$w, _dec5$t, _class$P, _class2$N, _initializer$M, _initializer2$J, _initializer3$z, _initializer4$t, _initializer5$o;
      const FORCE_OVERTIME_RAND_OFFSET = ModuleRandSeed.FORCE;
      const _temp_v3$2 = new Vec3();
      let ForceOvertimeModule = (_dec$R = ccclass$6('cc.ForceOvertimeModule'), _dec2$N = type$6(CurveRange), _dec3$B = type$6(CurveRange), _dec4$w = type$6(CurveRange), _dec5$t = type$6(Space), _dec$R(_class$P = (_class2$N = class ForceOvertimeModule extends ParticleModuleBase {
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        constructor() {
          super();
          this._enable = _initializer$M && _initializer$M();
          this.x = _initializer2$J && _initializer2$J();
          this.y = _initializer3$z && _initializer3$z();
          this.z = _initializer4$t && _initializer4$t();
          this.space = _initializer5$o && _initializer5$o();
          this.randomized = false;
          this.rotation = void 0;
          this.needTransform = void 0;
          this.name = PARTICLE_MODULE_NAME.FORCE;
          this.rotation = new Quat();
          this.needTransform = false;
          this.needUpdate = true;
        }
        update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
        animate(p, dt) {
          const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          const randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
          const randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
          const randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET) : 0;
          const force = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, randX), this.y.evaluate(normalizedTime, randY), this.z.evaluate(normalizedTime, randZ));
          if (this.needTransform) {
            Vec3.transformQuat(force, force, this.rotation);
          }
          Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
          Vec3.copy(p.ultimateVelocity, p.velocity);
        }
      }, (_initializer$M = applyDecoratedInitializer(_class2$N.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$J = applyDecoratedInitializer(_class2$N.prototype, "x", [_dec2$N, serializable$6], function () {
        return new CurveRange();
      }), _initializer3$z = applyDecoratedInitializer(_class2$N.prototype, "y", [_dec3$B, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$t = applyDecoratedInitializer(_class2$N.prototype, "z", [_dec4$w, serializable$6], function () {
        return new CurveRange();
      }), _initializer5$o = applyDecoratedInitializer(_class2$N.prototype, "space", [_dec5$t, serializable$6], function () {
        return Space.Local;
      })), _class2$N)) || _class$P);

      var _dec$Q, _dec2$M, _dec3$A, _dec4$v, _dec5$s, _dec6$g, _class$O, _class2$M, _initializer$L, _initializer2$I, _initializer3$y, _initializer4$s, _initializer5$n, _initializer6$j, _initializer7$g, _initializer8$f;
      const LIMIT_VELOCITY_RAND_OFFSET = ModuleRandSeed.LIMIT;
      const _temp_v3$1 = new Vec3();
      const _temp_v3_1 = new Vec3();
      let LimitVelocityOvertimeModule = (_dec$Q = ccclass$6('cc.LimitVelocityOvertimeModule'), _dec2$M = type$6(CurveRange), _dec3$A = type$6(CurveRange), _dec4$v = type$6(CurveRange), _dec5$s = type$6(CurveRange), _dec6$g = type$6(Space), _dec$Q(_class$O = (_class2$M = class LimitVelocityOvertimeModule extends ParticleModuleBase {
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        constructor() {
          super();
          this._enable = _initializer$L && _initializer$L();
          this.limitX = _initializer2$I && _initializer2$I();
          this.limitY = _initializer3$y && _initializer3$y();
          this.limitZ = _initializer4$s && _initializer4$s();
          this.limit = _initializer5$n && _initializer5$n();
          this.dampen = _initializer6$j && _initializer6$j();
          this.separateAxes = _initializer7$g && _initializer7$g();
          this.space = _initializer8$f && _initializer8$f();
          this.drag = null;
          this.multiplyDragByParticleSize = false;
          this.multiplyDragByParticleVelocity = false;
          this.name = PARTICLE_MODULE_NAME.LIMIT;
          this.rotation = void 0;
          this.needTransform = void 0;
          this.rotation = new Quat();
          this.needTransform = false;
          this.needUpdate = true;
        }
        update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
        animate(p, dt) {
          const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          const dampedVel = _temp_v3$1;
          if (this.separateAxes) {
            const randX = isCurveTwoValues(this.limitX) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
            const randY = isCurveTwoValues(this.limitY) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
            const randZ = isCurveTwoValues(this.limitZ) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
            Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, randX), this.limitY.evaluate(normalizedTime, randY), this.limitZ.evaluate(normalizedTime, randZ));
            if (this.needTransform) {
              Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation);
            }
            Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen));
          } else {
            Vec3.normalize(dampedVel, p.ultimateVelocity);
            const rand = isCurveTwoValues(this.limit) ? pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET) : 0;
            Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, rand), this.dampen));
          }
          Vec3.copy(p.ultimateVelocity, dampedVel);
          Vec3.copy(p.velocity, p.ultimateVelocity);
        }
      }, (_initializer$L = applyDecoratedInitializer(_class2$M.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$I = applyDecoratedInitializer(_class2$M.prototype, "limitX", [_dec2$M, serializable$6], function () {
        return new CurveRange();
      }), _initializer3$y = applyDecoratedInitializer(_class2$M.prototype, "limitY", [_dec3$A, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$s = applyDecoratedInitializer(_class2$M.prototype, "limitZ", [_dec4$v, serializable$6], function () {
        return new CurveRange();
      }), _initializer5$n = applyDecoratedInitializer(_class2$M.prototype, "limit", [_dec5$s, serializable$6], function () {
        return new CurveRange();
      }), _initializer6$j = applyDecoratedInitializer(_class2$M.prototype, "dampen", [serializable$6], function () {
        return 3;
      }), _initializer7$g = applyDecoratedInitializer(_class2$M.prototype, "separateAxes", [serializable$6], function () {
        return false;
      }), _initializer8$f = applyDecoratedInitializer(_class2$M.prototype, "space", [_dec6$g, serializable$6], function () {
        return Space.Local;
      })), _class2$M)) || _class$O);
      function dampenBeyondLimit(vel, limit, dampen) {
        const sgn = Math.sign(vel);
        let abs = Math.abs(vel);
        if (abs > limit) {
          const absToGive = abs - abs * dampen;
          if (absToGive > limit) {
            abs = absToGive;
          } else {
            abs = limit;
          }
        }
        return abs * sgn;
      }

      var _dec$P, _dec2$L, _dec3$z, _dec4$u, _class$N, _class2$L, _initializer$K, _initializer2$H, _initializer3$x, _initializer4$r, _initializer5$m;
      const ROTATION_OVERTIME_RAND_OFFSET = ModuleRandSeed.ROTATION;
      let RotationOvertimeModule = (_dec$P = ccclass$6('cc.RotationOvertimeModule'), _dec2$L = type$6(CurveRange), _dec3$z = type$6(CurveRange), _dec4$u = type$6(CurveRange), _dec$P(_class$N = (_class2$L = class RotationOvertimeModule extends ParticleModuleBase {
        constructor(...args) {
          super(...args);
          this._enable = _initializer$K && _initializer$K();
          this._separateAxes = _initializer2$H && _initializer2$H();
          this.x = _initializer3$x && _initializer3$x();
          this.y = _initializer4$r && _initializer4$r();
          this.z = _initializer5$m && _initializer5$m();
          this.name = PARTICLE_MODULE_NAME.ROTATION;
          this._startMat = new Mat4();
          this._matRot = new Mat4();
          this._quatRot = new Quat();
          this._otherEuler = new Vec3();
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        get separateAxes() {
          return this._separateAxes;
        }
        set separateAxes(val) {
          this._separateAxes = val;
        }
        _processRotation(p, r2d) {
          const renderMode = p.particleSystem.processor.getInfo().renderMode;
          if (renderMode !== RenderMode.Mesh) {
            if (renderMode === RenderMode.StrecthedBillboard) {
              this._quatRot.set(0, 0, 0, 1);
            }
          }
          Quat.normalize(this._quatRot, this._quatRot);
          if (this._quatRot.w < 0.0) {
            this._quatRot.x += Particle.INDENTIFY_NEG_QUAT;
          }
        }
        animate(p, dt) {
          const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          const randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
          const renderMode = p.particleSystem.processor.getInfo().renderMode;
          if (!this._separateAxes || renderMode === RenderMode.VerticalBillboard || renderMode === RenderMode.HorizontalBillboard) {
            Quat.fromEuler(p.deltaQuat, 0, 0, this.z.evaluate(normalizedTime, randZ) * dt * Particle.R2D);
          } else {
            const randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
            const randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET) : 0;
            Quat.fromEuler(p.deltaQuat, this.x.evaluate(normalizedTime, randX) * dt * Particle.R2D, this.y.evaluate(normalizedTime, randY) * dt * Particle.R2D, this.z.evaluate(normalizedTime, randZ) * dt * Particle.R2D);
          }
          p.deltaMat = Mat4.fromQuat(p.deltaMat, p.deltaQuat);
          p.localMat = p.localMat.multiply(p.deltaMat);
          if (!p.startRotated) {
            if (renderMode !== RenderMode.Mesh) {
              if (renderMode === RenderMode.StrecthedBillboard) {
                p.startEuler.set(0, 0, 0);
              } else if (renderMode !== RenderMode.Billboard) {
                p.startEuler.set(0, 0, p.startEuler.z);
              }
            }
            Quat.fromEuler(p.startRotation, p.startEuler.x * Particle.R2D, p.startEuler.y * Particle.R2D, p.startEuler.z * Particle.R2D);
            p.startRotated = true;
          }
          this._startMat = Mat4.fromQuat(this._startMat, p.startRotation);
          this._matRot = this._startMat.multiply(p.localMat);
          Mat4.getRotation(this._quatRot, this._matRot);
          this._processRotation(p, Particle.R2D);
          p.rotation.set(this._quatRot.x, this._quatRot.y, this._quatRot.z);
        }
      }, (_initializer$K = applyDecoratedInitializer(_class2$L.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$H = applyDecoratedInitializer(_class2$L.prototype, "_separateAxes", [serializable$6], function () {
        return false;
      }), _initializer3$x = applyDecoratedInitializer(_class2$L.prototype, "x", [_dec2$L, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$r = applyDecoratedInitializer(_class2$L.prototype, "y", [_dec3$z, serializable$6], function () {
        return new CurveRange();
      }), _initializer5$m = applyDecoratedInitializer(_class2$L.prototype, "z", [_dec4$u, serializable$6], function () {
        return new CurveRange();
      })), _class2$L)) || _class$N);

      var _dec$O, _dec2$K, _dec3$y, _dec4$t, _dec5$r, _class$M, _class2$K, _initializer$J, _initializer2$G, _initializer3$w, _initializer4$q, _initializer5$l, _initializer6$i;
      const SIZE_OVERTIME_RAND_OFFSET = ModuleRandSeed.SIZE;
      let SizeOvertimeModule = (_dec$O = ccclass$6('cc.SizeOvertimeModule'), _dec2$K = type$6(CurveRange), _dec3$y = type$6(CurveRange), _dec4$t = type$6(CurveRange), _dec5$r = type$6(CurveRange), _dec$O(_class$M = (_class2$K = class SizeOvertimeModule extends ParticleModuleBase {
        constructor(...args) {
          super(...args);
          this._enable = _initializer$J && _initializer$J();
          this.separateAxes = _initializer2$G && _initializer2$G();
          this.size = _initializer3$w && _initializer3$w();
          this.x = _initializer4$q && _initializer4$q();
          this.y = _initializer5$l && _initializer5$l();
          this.z = _initializer6$i && _initializer6$i();
          this.name = PARTICLE_MODULE_NAME.SIZE;
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        animate(particle, dt) {
          if (!this.separateAxes) {
            const rand = isCurveTwoValues(this.size) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
            Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, rand));
          } else {
            const currLifetime = 1 - particle.remainingLifetime / particle.startLifetime;
            const randX = isCurveTwoValues(this.x) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
            const randY = isCurveTwoValues(this.y) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
            const randZ = isCurveTwoValues(this.z) ? pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET) : 0;
            particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, randX);
            particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, randY);
            particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, randZ);
          }
        }
      }, (_initializer$J = applyDecoratedInitializer(_class2$K.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$G = applyDecoratedInitializer(_class2$K.prototype, "separateAxes", [serializable$6], function () {
        return false;
      }), _initializer3$w = applyDecoratedInitializer(_class2$K.prototype, "size", [_dec2$K, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$q = applyDecoratedInitializer(_class2$K.prototype, "x", [_dec3$y, serializable$6], function () {
        return new CurveRange();
      }), _initializer5$l = applyDecoratedInitializer(_class2$K.prototype, "y", [_dec4$t, serializable$6], function () {
        return new CurveRange();
      }), _initializer6$i = applyDecoratedInitializer(_class2$K.prototype, "z", [_dec5$r, serializable$6], function () {
        return new CurveRange();
      })), _class2$K)) || _class$M);

      var _dec$N, _dec2$J, _dec3$x, _dec4$s, _dec5$q, _dec6$f, _dec7$d, _dec8$a, _class$L, _class2$J, _initializer$I, _initializer2$F, _initializer3$v, _initializer4$p, _initializer5$k, _initializer6$h, _initializer7$f, _initializer8$e, _initializer9$e, _initializer10$c, _initializer11$c, _initializer12$a, _initializer13$9;
      const TEXTURE_ANIMATION_RAND_OFFSET = ModuleRandSeed.TEXTURE;
      const Mode$1 = Enum({
        Grid: 0
      });
      const Animation = Enum({
        WholeSheet: 0,
        SingleRow: 1
      });
      let TextureAnimationModule = (_dec$N = ccclass$6('cc.TextureAnimationModule'), _dec2$J = formerlySerializedAs$3('numTilesX'), _dec3$x = formerlySerializedAs$3('numTilesY'), _dec4$s = type$6(Mode$1), _dec5$q = type$6(Mode$1), _dec6$f = type$6(Animation), _dec7$d = type$6(CurveRange), _dec8$a = type$6(CurveRange), _dec$N(_class$L = (_class2$J = class TextureAnimationModule extends ParticleModuleBase {
        constructor(...args) {
          super(...args);
          this._enable = _initializer$I && _initializer$I();
          this._numTilesX = _initializer2$F && _initializer2$F();
          this._numTilesY = _initializer3$v && _initializer3$v();
          this._mode = _initializer4$p && _initializer4$p();
          this.animation = _initializer5$k && _initializer5$k();
          this.frameOverTime = _initializer6$h && _initializer6$h();
          this.startFrame = _initializer7$f && _initializer7$f();
          this.cycleCount = _initializer8$e && _initializer8$e();
          this._flipU = _initializer9$e && _initializer9$e();
          this._flipV = _initializer10$c && _initializer10$c();
          this._uvChannelMask = _initializer11$c && _initializer11$c();
          this.randomRow = _initializer12$a && _initializer12$a();
          this.rowIndex = _initializer13$9 && _initializer13$9();
          this.name = PARTICLE_MODULE_NAME.TEXTURE;
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.updateMaterialParams();
          this.target.enableModule(this.name, val, this);
        }
        get mode() {
          return this._mode;
        }
        set mode(val) {
          if (val !== Mode$1.Grid) {
            error('particle texture animation\'s sprites is not supported!');
          }
        }
        get numTilesX() {
          return this._numTilesX;
        }
        set numTilesX(val) {
          if (this._numTilesX !== val) {
            this._numTilesX = val;
            this.target.updateMaterialParams();
          }
        }
        get numTilesY() {
          return this._numTilesY;
        }
        set numTilesY(val) {
          if (this._numTilesY !== val) {
            this._numTilesY = val;
            this.target.updateMaterialParams();
          }
        }
        get flipU() {
          return this._flipU;
        }
        set flipU(val) {
          error('particle texture animation\'s flipU is not supported!');
        }
        get flipV() {
          return this._flipV;
        }
        set flipV(val) {
          error('particle texture animation\'s flipV is not supported!');
        }
        get uvChannelMask() {
          return this._uvChannelMask;
        }
        set uvChannelMask(val) {
          error('particle texture animation\'s uvChannelMask is not supported!');
        }
        init(p) {
          p.startRow = Math.floor(random() * this.numTilesY);
        }
        animate(p, dt) {
          const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          const randStart = isCurveTwoValues(this.startFrame) ? pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET) : 0;
          const randFrame = isCurveTwoValues(this.frameOverTime) ? pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET) : 0;
          const startFrame = this.startFrame.evaluate(normalizedTime, randStart) / (this.numTilesX * this.numTilesY);
          if (this.animation === Animation.WholeSheet) {
            p.frameIndex = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1);
          } else if (this.animation === Animation.SingleRow) {
            const rowLength = 1 / this.numTilesY;
            if (this.randomRow) {
              const f = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1);
              const from = p.startRow * rowLength;
              const to = from + rowLength;
              p.frameIndex = lerp(from, to, f);
            } else {
              const from = this.rowIndex * rowLength;
              const to = from + rowLength;
              p.frameIndex = lerp(from, to, repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, randFrame) + startFrame), 1));
            }
          }
        }
      }, (_initializer$I = applyDecoratedInitializer(_class2$J.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$F = applyDecoratedInitializer(_class2$J.prototype, "_numTilesX", [_dec2$J], function () {
        return 0;
      }), _initializer3$v = applyDecoratedInitializer(_class2$J.prototype, "_numTilesY", [_dec3$x], function () {
        return 0;
      }), _initializer4$p = applyDecoratedInitializer(_class2$J.prototype, "_mode", [_dec4$s], function () {
        return Mode$1.Grid;
      }), _applyDecoratedDescriptor(_class2$J.prototype, "mode", [_dec5$q], Object.getOwnPropertyDescriptor(_class2$J.prototype, "mode"), _class2$J.prototype), _initializer5$k = applyDecoratedInitializer(_class2$J.prototype, "animation", [_dec6$f, serializable$6], function () {
        return Animation.WholeSheet;
      }), _initializer6$h = applyDecoratedInitializer(_class2$J.prototype, "frameOverTime", [_dec7$d, serializable$6], function () {
        return new CurveRange();
      }), _initializer7$f = applyDecoratedInitializer(_class2$J.prototype, "startFrame", [_dec8$a, serializable$6], function () {
        return new CurveRange();
      }), _initializer8$e = applyDecoratedInitializer(_class2$J.prototype, "cycleCount", [serializable$6], function () {
        return 0;
      }), _initializer9$e = applyDecoratedInitializer(_class2$J.prototype, "_flipU", [serializable$6], function () {
        return 0;
      }), _initializer10$c = applyDecoratedInitializer(_class2$J.prototype, "_flipV", [serializable$6], function () {
        return 0;
      }), _initializer11$c = applyDecoratedInitializer(_class2$J.prototype, "_uvChannelMask", [serializable$6], function () {
        return -1;
      }), _initializer12$a = applyDecoratedInitializer(_class2$J.prototype, "randomRow", [serializable$6], function () {
        return false;
      }), _initializer13$9 = applyDecoratedInitializer(_class2$J.prototype, "rowIndex", [serializable$6], function () {
        return 0;
      })), _class2$J)) || _class$L);

      var _dec$M, _dec2$I, _dec3$w, _dec4$r, _dec5$p, _dec6$e, _class$K, _class2$I, _initializer$H, _initializer2$E, _initializer3$u, _initializer4$o, _initializer5$j, _initializer6$g;
      const VELOCITY_X_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_X;
      const VELOCITY_Y_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Y;
      const VELOCITY_Z_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Z;
      const _temp_v3 = new Vec3();
      let VelocityOvertimeModule = (_dec$M = ccclass$6('cc.VelocityOvertimeModule'), _dec2$I = type$6(CurveRange), _dec3$w = type$6(CurveRange), _dec4$r = type$6(CurveRange), _dec5$p = type$6(CurveRange), _dec6$e = type$6(Space), _dec$M(_class$K = (_class2$I = class VelocityOvertimeModule extends ParticleModuleBase {
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        constructor() {
          super();
          this._enable = _initializer$H && _initializer$H();
          this.x = _initializer2$E && _initializer2$E();
          this.y = _initializer3$u && _initializer3$u();
          this.z = _initializer4$o && _initializer4$o();
          this.speedModifier = _initializer5$j && _initializer5$j();
          this.space = _initializer6$g && _initializer6$g();
          this.rotation = void 0;
          this.needTransform = void 0;
          this.name = PARTICLE_MODULE_NAME.VELOCITY;
          this.rotation = new Quat();
          this.speedModifier.constant = 1;
          this.needTransform = false;
          this.needUpdate = true;
        }
        update(space, worldTransform) {
          this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
        animate(p, dt) {
          const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
          const randX = isCurveTwoValues(this.x) ? pseudoRandom(p.randomSeed ^ VELOCITY_X_OVERTIME_RAND_OFFSET) : 0;
          const randY = isCurveTwoValues(this.y) ? pseudoRandom(p.randomSeed ^ VELOCITY_Y_OVERTIME_RAND_OFFSET) : 0;
          const randZ = isCurveTwoValues(this.z) ? pseudoRandom(p.randomSeed ^ VELOCITY_Z_OVERTIME_RAND_OFFSET) : 0;
          const randSpeed = isCurveTwoValues(this.speedModifier) ? pseudoRandom(p.randomSeed + VELOCITY_X_OVERTIME_RAND_OFFSET) : 0;
          const vel = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, randX), this.y.evaluate(normalizedTime, randY), this.z.evaluate(normalizedTime, randZ));
          if (this.needTransform) {
            Vec3.transformQuat(vel, vel, this.rotation);
          }
          Vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
          Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
          Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, randSpeed));
        }
      }, (_initializer$H = applyDecoratedInitializer(_class2$I.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$E = applyDecoratedInitializer(_class2$I.prototype, "x", [_dec2$I, serializable$6], function () {
        return new CurveRange();
      }), _initializer3$u = applyDecoratedInitializer(_class2$I.prototype, "y", [_dec3$w, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$o = applyDecoratedInitializer(_class2$I.prototype, "z", [_dec4$r, serializable$6], function () {
        return new CurveRange();
      }), _initializer5$j = applyDecoratedInitializer(_class2$I.prototype, "speedModifier", [_dec5$p, serializable$6], function () {
        return new CurveRange();
      }), _initializer6$g = applyDecoratedInitializer(_class2$I.prototype, "space", [_dec6$e, serializable$6], function () {
        return Space.Local;
      })), _class2$I)) || _class$K);

      var _dec$L, _dec2$H, _class$J, _class2$H, _initializer$G, _initializer2$D, _initializer3$t, _initializer4$n;
      let Burst = exports('Burst', (_dec$L = ccclass$6('cc.Burst'), _dec2$H = type$6(CurveRange), _dec$L(_class$J = (_class2$H = class Burst {
        get time() {
          return this._time;
        }
        set time(val) {
          this._time = val;
          this._curTime = val;
        }
        get repeatCount() {
          return this._repeatCount;
        }
        set repeatCount(val) {
          this._repeatCount = val;
          this._remainingCount = val;
        }
        constructor() {
          this._time = _initializer$G && _initializer$G();
          this._repeatCount = _initializer2$D && _initializer2$D();
          this.repeatInterval = _initializer3$t && _initializer3$t();
          this.count = _initializer4$n && _initializer4$n();
          this._remainingCount = void 0;
          this._curTime = void 0;
          this._remainingCount = 0;
          this._curTime = 0.0;
        }
        update(psys, dt) {
          if (this._remainingCount === 0) {
            this._remainingCount = this._repeatCount;
            this._curTime = this._time;
          }
          if (this._remainingCount > 0) {
            let preFrameTime = repeat$2(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
            preFrameTime = preFrameTime > 0.0 ? preFrameTime : 0.0;
            const curFrameTime = repeat$2(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
            if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
              psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime));
              this._curTime += this.repeatInterval;
              --this._remainingCount;
            }
          }
        }
        reset() {
          this._remainingCount = 0;
          this._curTime = 0.0;
        }
        getMaxCount(psys) {
          return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
        }
      }, (_initializer$G = applyDecoratedInitializer(_class2$H.prototype, "_time", [serializable$6], function () {
        return 0;
      }), _initializer2$D = applyDecoratedInitializer(_class2$H.prototype, "_repeatCount", [serializable$6], function () {
        return 1;
      }), _initializer3$t = applyDecoratedInitializer(_class2$H.prototype, "repeatInterval", [serializable$6], function () {
        return 1;
      }), _initializer4$n = applyDecoratedInitializer(_class2$H.prototype, "count", [_dec2$H, serializable$6], function () {
        return new CurveRange();
      })), _class2$H)) || _class$J));

      var _dec$K, _dec2$G, _dec3$v, _dec4$q, _dec5$o, _dec6$d, _dec7$c, _class$I, _class2$G, _initializer$F, _initializer2$C, _initializer3$s, _initializer4$m, _initializer5$i, _initializer6$f, _initializer7$e, _initializer8$d, _initializer9$d, _initializer10$b, _initializer11$b, _initializer12$9, _initializer13$8, _initializer14$6, _initializer15$4, _initializer16$4, _initializer17$3, _initializer18$3, _initializer19$2;
      const _intermediVec = new Vec3(0, 0, 0);
      const _intermediArr = [];
      const _unitBoxExtent = new Vec3(0.5, 0.5, 0.5);
      let ShapeModule = (_dec$K = ccclass$6('cc.ShapeModule'), _dec2$G = type$6(ShapeType), _dec3$v = formerlySerializedAs$3('shapeType'), _dec4$q = type$6(ShapeType), _dec5$o = type$6(EmitLocation), _dec6$d = type$6(ArcMode), _dec7$c = type$6(CurveRange), _dec$K(_class$I = (_class2$G = class ShapeModule {
        get position() {
          return this._position;
        }
        set position(val) {
          this._position = val;
          this.constructMat();
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(val) {
          this._rotation = val;
          this.constructMat();
        }
        get scale() {
          return this._scale;
        }
        set scale(val) {
          this._scale = val;
          this.constructMat();
        }
        get arc() {
          return toDegree(this._arc);
        }
        set arc(val) {
          this._arc = toRadian(val);
        }
        get angle() {
          return Math.round(toDegree(this._angle) * 100) / 100;
        }
        set angle(val) {
          this._angle = toRadian(val);
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          this._enable = val;
        }
        get shapeType() {
          return this._shapeType;
        }
        set shapeType(val) {
          this._shapeType = val;
          switch (this._shapeType) {
            case ShapeType.Box:
              if (this.emitFrom === EmitLocation.Base) {
                this.emitFrom = EmitLocation.Volume;
              }
              break;
            case ShapeType.Cone:
              if (this.emitFrom === EmitLocation.Edge) {
                this.emitFrom = EmitLocation.Base;
              }
              break;
            case ShapeType.Sphere:
            case ShapeType.Hemisphere:
              if (this.emitFrom === EmitLocation.Base || this.emitFrom === EmitLocation.Edge) {
                this.emitFrom = EmitLocation.Volume;
              }
              break;
          }
        }
        constructor() {
          this._enable = _initializer$F && _initializer$F();
          this._shapeType = _initializer2$C && _initializer2$C();
          this.emitFrom = _initializer3$s && _initializer3$s();
          this.alignToDirection = _initializer4$m && _initializer4$m();
          this.randomDirectionAmount = _initializer5$i && _initializer5$i();
          this.sphericalDirectionAmount = _initializer6$f && _initializer6$f();
          this.randomPositionAmount = _initializer7$e && _initializer7$e();
          this.radius = _initializer8$d && _initializer8$d();
          this.radiusThickness = _initializer9$d && _initializer9$d();
          this.arcMode = _initializer10$b && _initializer10$b();
          this.arcSpread = _initializer11$b && _initializer11$b();
          this.arcSpeed = _initializer12$9 && _initializer12$9();
          this.length = _initializer13$8 && _initializer13$8();
          this.boxThickness = _initializer14$6 && _initializer14$6();
          this._position = _initializer15$4 && _initializer15$4();
          this._rotation = _initializer16$4 && _initializer16$4();
          this._scale = _initializer17$3 && _initializer17$3();
          this._arc = _initializer18$3 && _initializer18$3();
          this._angle = _initializer19$2 && _initializer19$2();
          this.mat = void 0;
          this.quat = void 0;
          this.particleSystem = void 0;
          this.lastTime = void 0;
          this.totalAngle = void 0;
          this.mat = new Mat4();
          this.quat = new Quat();
          this.particleSystem = null;
          this.lastTime = 0;
          this.totalAngle = 0;
        }
        onInit(ps) {
          this.particleSystem = ps;
          this.constructMat();
          this.lastTime = this.particleSystem._time;
        }
        emit(p) {
          switch (this.shapeType) {
            case ShapeType.Box:
              boxEmit(this.emitFrom, this.boxThickness, p.position, p.velocity);
              break;
            case ShapeType.Circle:
              circleEmit(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
              break;
            case ShapeType.Cone:
              coneEmit(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
              break;
            case ShapeType.Sphere:
              sphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
              break;
            case ShapeType.Hemisphere:
              hemisphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
              break;
            default:
              console.warn(`${this.shapeType} shapeType is not supported by ShapeModule.`);
          }
          if (this.randomPositionAmount > 0) {
            p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
            p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
            p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
          }
          Vec3.transformQuat(p.velocity, p.velocity, this.quat);
          Vec3.transformMat4(p.position, p.position, this.mat);
          if (this.sphericalDirectionAmount > 0) {
            const sphericalVel = Vec3.normalize(_intermediVec, p.position);
            Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
          }
          this.lastTime = this.particleSystem._time;
        }
        constructMat() {
          Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
          Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
        }
        generateArcAngle() {
          if (this.arcMode === ArcMode.Random) {
            return randomRange(0, this._arc);
          }
          let angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
          this.totalAngle = angle;
          if (this.arcSpread !== 0) {
            angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread;
          }
          switch (this.arcMode) {
            case ArcMode.Loop:
              return repeat$2(angle, this._arc);
            case ArcMode.PingPong:
              return pingPong(angle, this._arc);
            default:
              return repeat$2(angle, this._arc);
          }
        }
      }, (_initializer$F = applyDecoratedInitializer(_class2$G.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$C = applyDecoratedInitializer(_class2$G.prototype, "_shapeType", [_dec2$G, _dec3$v], function () {
        return ShapeType.Cone;
      }), _applyDecoratedDescriptor(_class2$G.prototype, "shapeType", [_dec4$q], Object.getOwnPropertyDescriptor(_class2$G.prototype, "shapeType"), _class2$G.prototype), _initializer3$s = applyDecoratedInitializer(_class2$G.prototype, "emitFrom", [_dec5$o, serializable$6], function () {
        return EmitLocation.Volume;
      }), _initializer4$m = applyDecoratedInitializer(_class2$G.prototype, "alignToDirection", [serializable$6], function () {
        return false;
      }), _initializer5$i = applyDecoratedInitializer(_class2$G.prototype, "randomDirectionAmount", [serializable$6], function () {
        return 0;
      }), _initializer6$f = applyDecoratedInitializer(_class2$G.prototype, "sphericalDirectionAmount", [serializable$6], function () {
        return 0;
      }), _initializer7$e = applyDecoratedInitializer(_class2$G.prototype, "randomPositionAmount", [serializable$6], function () {
        return 0;
      }), _initializer8$d = applyDecoratedInitializer(_class2$G.prototype, "radius", [serializable$6], function () {
        return 1;
      }), _initializer9$d = applyDecoratedInitializer(_class2$G.prototype, "radiusThickness", [serializable$6], function () {
        return 1;
      }), _initializer10$b = applyDecoratedInitializer(_class2$G.prototype, "arcMode", [_dec6$d, serializable$6], function () {
        return ArcMode.Random;
      }), _initializer11$b = applyDecoratedInitializer(_class2$G.prototype, "arcSpread", [serializable$6], function () {
        return 0;
      }), _initializer12$9 = applyDecoratedInitializer(_class2$G.prototype, "arcSpeed", [_dec7$c, serializable$6], function () {
        return new CurveRange();
      }), _initializer13$8 = applyDecoratedInitializer(_class2$G.prototype, "length", [serializable$6], function () {
        return 5;
      }), _initializer14$6 = applyDecoratedInitializer(_class2$G.prototype, "boxThickness", [serializable$6], function () {
        return new Vec3(0, 0, 0);
      }), _initializer15$4 = applyDecoratedInitializer(_class2$G.prototype, "_position", [serializable$6], function () {
        return new Vec3(0, 0, 0);
      }), _initializer16$4 = applyDecoratedInitializer(_class2$G.prototype, "_rotation", [serializable$6], function () {
        return new Vec3(0, 0, 0);
      }), _initializer17$3 = applyDecoratedInitializer(_class2$G.prototype, "_scale", [serializable$6], function () {
        return new Vec3(1, 1, 1);
      }), _initializer18$3 = applyDecoratedInitializer(_class2$G.prototype, "_arc", [serializable$6], function () {
        return toRadian(360);
      }), _initializer19$2 = applyDecoratedInitializer(_class2$G.prototype, "_angle", [serializable$6], function () {
        return toRadian(25);
      })), _class2$G)) || _class$I);
      function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
            Vec3.normalize(dir, pos);
            break;
          case EmitLocation.Shell:
            randomUnitVector(pos);
            Vec3.multiplyScalar(pos, pos, radius);
            Vec3.normalize(dir, pos);
            break;
          default:
            console.warn(`${emitFrom} is not supported for sphere emitter.`);
        }
      }
      function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
            if (pos.z > 0) {
              pos.z *= -1;
            }
            Vec3.normalize(dir, pos);
            break;
          case EmitLocation.Shell:
            randomUnitVector(pos);
            Vec3.multiplyScalar(pos, pos, radius);
            if (pos.z > 0) {
              pos.z *= -1;
            }
            Vec3.normalize(dir, pos);
            break;
          default:
            console.warn(`${emitFrom} is not supported for hemisphere emitter.`);
        }
      }
      function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Base:
            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle) * radius;
            Vec3.normalize(dir, dir);
            pos.z = 0;
            break;
          case EmitLocation.Shell:
            fixedAngleUnitVector2(pos, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle);
            Vec3.normalize(dir, dir);
            Vec2.multiplyScalar(pos, pos, radius);
            pos.z = 0;
            break;
          case EmitLocation.Volume:
            randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
            Vec2.multiplyScalar(dir, pos, Math.sin(angle));
            dir.z = -Math.cos(angle) * radius;
            Vec3.normalize(dir, dir);
            pos.z = 0;
            Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
            break;
          default:
            console.warn(`${emitFrom} is not supported for cone emitter.`);
        }
      }
      function boxEmit(emitFrom, boxThickness, pos, dir) {
        switch (emitFrom) {
          case EmitLocation.Volume:
            randomPointInCube(pos, _unitBoxExtent);
            break;
          case EmitLocation.Shell:
            _intermediArr.splice(0, _intermediArr.length);
            _intermediArr.push(randomRange(-0.5, 0.5));
            _intermediArr.push(randomRange(-0.5, 0.5));
            _intermediArr.push(randomSign() * 0.5);
            randomSortArray(_intermediArr);
            applyBoxThickness(_intermediArr, boxThickness);
            Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
            break;
          case EmitLocation.Edge:
            _intermediArr.splice(0, _intermediArr.length);
            _intermediArr.push(randomRange(-0.5, 0.5));
            _intermediArr.push(randomSign() * 0.5);
            _intermediArr.push(randomSign() * 0.5);
            randomSortArray(_intermediArr);
            applyBoxThickness(_intermediArr, boxThickness);
            Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
            break;
          default:
            console.warn(`${emitFrom} is not supported for box emitter.`);
        }
        Vec3.copy(dir, particleEmitZAxis);
      }
      function circleEmit(radius, radiusThickness, theta, pos, dir) {
        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
        Vec3.normalize(dir, pos);
      }
      function applyBoxThickness(pos, thickness) {
        if (thickness.x > 0) {
          pos[0] += 0.5 * randomRange(-thickness.x, thickness.x);
          pos[0] = clamp$1(pos[0], -0.5, 0.5);
        }
        if (thickness.y > 0) {
          pos[1] += 0.5 * randomRange(-thickness.y, thickness.y);
          pos[1] = clamp$1(pos[1], -0.5, 0.5);
        }
        if (thickness.z > 0) {
          pos[2] += 0.5 * randomRange(-thickness.z, thickness.z);
          pos[2] = clamp$1(pos[2], -0.5, 0.5);
        }
      }

      const _uvs$1 = [0, 0, 1, 0, 0, 1, 1, 1];
      const _uvs_ins = [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0];
      class ParticleBatchModel extends Model {
        constructor() {
          super();
          this._capacity = void 0;
          this._bufferSize = void 0;
          this._vertAttrs = void 0;
          this._vertAttribSize = void 0;
          this._vBuffer = void 0;
          this._vertAttrsFloatCount = void 0;
          this._vdataF32 = void 0;
          this._vdataUint32 = void 0;
          this._subMeshData = void 0;
          this._mesh = void 0;
          this._vertCount = 0;
          this._indexCount = 0;
          this._startTimeOffset = 0;
          this._lifeTimeOffset = 0;
          this._material = null;
          this._vertAttribSizeStatic = void 0;
          this._vertStaticAttrsFloatCount = void 0;
          this._insBuffers = void 0;
          this._insIndices = void 0;
          this._useInstance = void 0;
          this._iaVertCount = 0;
          this._iaIndexCount = 0;
          {
            this._registerListeners();
          }
          this.type = ModelType.PARTICLE_BATCH;
          this._capacity = 0;
          this._bufferSize = 16;
          this._vertAttrs = null;
          this._vertAttribSize = 0;
          this._vBuffer = null;
          this._vertAttrsFloatCount = 0;
          this._vdataF32 = null;
          this._vdataUint32 = null;
          this._vertAttribSizeStatic = 0;
          this._vertStaticAttrsFloatCount = 0;
          this._insBuffers = [];
          this._insIndices = null;
          if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
            this._useInstance = false;
          } else {
            this._useInstance = true;
          }
          this._subMeshData = null;
          this._mesh = null;
        }
        setCapacity(capacity) {
          const capChanged = this._capacity !== capacity;
          this._capacity = capacity;
          this._bufferSize = Math.max(this._capacity, 16);
          if (this._subMeshData && capChanged) {
            this.rebuild();
          }
        }
        setVertexAttributes(mesh, attrs) {
          if (!this._useInstance) {
            if (this._mesh === mesh && this._vertAttrs === attrs) {
              return;
            }
            this._mesh = mesh;
            this._vertAttrs = attrs;
            this._vertAttribSize = 0;
            for (const a of this._vertAttrs) {
              a.offset = this._vertAttribSize;
              this._vertAttribSize += FormatInfos[a.format].size;
            }
            this._vertAttrsFloatCount = this._vertAttribSize / 4;
            this.rebuild();
          } else {
            this.setVertexAttributesIns(mesh, attrs);
          }
        }
        setVertexAttributesIns(mesh, attrs) {
          if (this._mesh === mesh && this._vertAttrs === attrs) {
            return;
          }
          this._mesh = mesh;
          this._vertAttrs = attrs;
          this._vertAttribSize = 0;
          this._vertAttribSizeStatic = 0;
          for (const a of this._vertAttrs) {
            if (a.stream === 0) {
              a.offset = this._vertAttribSize;
              this._vertAttribSize += FormatInfos[a.format].size;
            } else if (a.stream === 1) {
              a.offset = this._vertAttribSizeStatic;
              this._vertAttribSizeStatic += FormatInfos[a.format].size;
            }
          }
          this._vertAttrsFloatCount = this._vertAttribSize / 4;
          this._vertStaticAttrsFloatCount = this._vertAttribSizeStatic / 4;
          this.rebuild();
        }
        createSubMeshData() {
          this.destroySubMeshData();
          this._vertCount = 4;
          this._indexCount = 6;
          if (this._mesh) {
            this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
            this._indexCount = this._mesh.struct.primitives[0].indexView.count;
          }
          const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._bufferSize * this._vertCount, this._vertAttribSize));
          const vBuffer = new ArrayBuffer(this._vertAttribSize * this._bufferSize * this._vertCount);
          if (this._mesh && this._capacity > 0) {
            let vOffset = this._vertAttrs[this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD)].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSize, vOffset);
            let vIdx = this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD3);
            vOffset = this._vertAttrs[vIdx++].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSize, vOffset);
            vOffset = this._vertAttrs[vIdx++].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSize, vOffset);
            vOffset = this._vertAttrs[vIdx++].offset;
            if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSize, vOffset)) {
              const vb = new Uint32Array(vBuffer);
              for (let iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color$1.WHITE._val;
              }
            }
            const vbFloatArray = new Float32Array(vBuffer);
            for (let i = 1; i < this._capacity; i++) {
              vbFloatArray.copyWithin(i * this._vertAttribSize * this._vertCount / 4, 0, this._vertAttribSize * this._vertCount / 4);
            }
          }
          vertexBuffer.update(vBuffer);
          const indices = new Uint16Array(this._bufferSize * this._indexCount);
          if (this._mesh && this._capacity > 0) {
            this._mesh.copyIndices(0, indices);
            for (let i = 1; i < this._capacity; i++) {
              for (let j = 0; j < this._indexCount; j++) {
                indices[i * this._indexCount + j] = indices[j] + i * this._vertCount;
              }
            }
          } else {
            let dst = 0;
            for (let i = 0; i < this._capacity; ++i) {
              const baseIdx = 4 * i;
              indices[dst++] = baseIdx;
              indices[dst++] = baseIdx + 1;
              indices[dst++] = baseIdx + 2;
              indices[dst++] = baseIdx + 3;
              indices[dst++] = baseIdx + 2;
              indices[dst++] = baseIdx + 1;
            }
          }
          const indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._bufferSize * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          indexBuffer.update(indices);
          this._iaVertCount = this._capacity * this._vertCount;
          this._iaIndexCount = this._capacity * this._indexCount;
          this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
          this.initSubModel(0, this._subMeshData, this._material);
          return vBuffer;
        }
        createSubMeshDataInsDynamic() {
          this._insBuffers.length = 0;
          this.destroySubMeshData();
          const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSize * this._bufferSize, this._vertAttribSize));
          const vBuffer = new ArrayBuffer(this._vertAttribSize * this._bufferSize);
          vertexBuffer.update(vBuffer);
          this._insBuffers.push(vertexBuffer);
          return vBuffer;
        }
        createSubMeshDataInsStatic() {
          this._vertCount = 4;
          this._indexCount = 6;
          if (this._mesh) {
            this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
            this._indexCount = this._mesh.struct.primitives[0].indexView.count;
          }
          const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertAttribSizeStatic * this._vertCount, this._vertAttribSizeStatic));
          const vBuffer = new ArrayBuffer(this._vertAttribSizeStatic * this._vertCount);
          if (this._mesh) {
            let vIdx = this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD);
            let vOffset = this._vertAttrs[vIdx].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertAttribSizeStatic, vOffset);
            vIdx = this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD3);
            vOffset = this._vertAttrs[vIdx++].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertAttribSizeStatic, vOffset);
            vOffset = this._vertAttrs[vIdx++].offset;
            this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertAttribSizeStatic, vOffset);
            vOffset = this._vertAttrs[vIdx++].offset;
            if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertAttribSizeStatic, vOffset)) {
              const vb = new Uint32Array(vBuffer);
              for (let iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                vb[iVertex * this._vertStaticAttrsFloatCount + vOffset / 4] = Color$1.WHITE._val;
              }
            }
          } else {
            const vbFloatArray = new Float32Array(vBuffer);
            for (let i = 0; i < _uvs_ins.length; ++i) {
              vbFloatArray[i] = _uvs_ins[i];
            }
          }
          vertexBuffer.update(vBuffer);
          const indices = new Uint16Array(this._indexCount);
          if (this._mesh) {
            this._mesh.copyIndices(0, indices);
          } else {
            indices[0] = 0;
            indices[1] = 1;
            indices[2] = 2;
            indices[3] = 3;
            indices[4] = 2;
            indices[5] = 1;
          }
          const indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          indexBuffer.update(indices);
          this._insIndices = indexBuffer;
          this._iaVertCount = this._vertCount;
          this._iaIndexCount = this._indexCount;
          this._insBuffers.push(vertexBuffer);
        }
        createInsSubmesh() {
          this._subMeshData = new RenderingSubMesh(this._insBuffers, this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, this._insIndices);
          this.initSubModel(0, this._subMeshData, this._material);
        }
        updateMaterial(mat) {
          this._material = mat;
          this.setSubModelMaterial(0, mat);
        }
        addParticleVertexData(index, pvdata) {
          if (!this._useInstance) {
            if (!this._mesh) {
              let offset = index * this._vertAttrsFloatCount;
              this._vdataF32[offset++] = pvdata.position.x;
              this._vdataF32[offset++] = pvdata.position.y;
              this._vdataF32[offset++] = pvdata.position.z;
              this._vdataF32[offset++] = pvdata.texcoord.x;
              this._vdataF32[offset++] = pvdata.texcoord.y;
              this._vdataF32[offset++] = pvdata.texcoord.z;
              this._vdataF32[offset++] = pvdata.size.x;
              this._vdataF32[offset++] = pvdata.size.y;
              this._vdataF32[offset++] = pvdata.size.z;
              this._vdataF32[offset++] = pvdata.rotation.x;
              this._vdataF32[offset++] = pvdata.rotation.y;
              this._vdataF32[offset++] = pvdata.rotation.z;
              this._vdataUint32[offset++] = pvdata.color;
              if (pvdata.velocity) {
                this._vdataF32[offset++] = pvdata.velocity.x;
                this._vdataF32[offset++] = pvdata.velocity.y;
                this._vdataF32[offset++] = pvdata.velocity.z;
              }
            } else {
              for (let i = 0; i < this._vertCount; i++) {
                let offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                this._vdataF32[offset++] = pvdata.position.x;
                this._vdataF32[offset++] = pvdata.position.y;
                this._vdataF32[offset++] = pvdata.position.z;
                offset += 2;
                this._vdataF32[offset++] = pvdata.texcoord.z;
                this._vdataF32[offset++] = pvdata.size.x;
                this._vdataF32[offset++] = pvdata.size.y;
                this._vdataF32[offset++] = pvdata.size.z;
                this._vdataF32[offset++] = pvdata.rotation.x;
                this._vdataF32[offset++] = pvdata.rotation.y;
                this._vdataF32[offset++] = pvdata.rotation.z;
                this._vdataUint32[offset++] = pvdata.color;
              }
            }
          } else {
            this.addParticleVertexDataIns(index, pvdata);
          }
        }
        addParticleVertexDataIns(index, pvdata) {
          let offset = index * this._vertAttrsFloatCount;
          if (!this._mesh) {
            this._vdataF32[offset++] = pvdata.position.x;
            this._vdataF32[offset++] = pvdata.position.y;
            this._vdataF32[offset++] = pvdata.position.z;
            this._vdataF32[offset++] = pvdata.texcoord.z;
            this._vdataF32[offset++] = pvdata.size.x;
            this._vdataF32[offset++] = pvdata.size.y;
            this._vdataF32[offset++] = pvdata.size.z;
            this._vdataF32[offset++] = pvdata.rotation.x;
            this._vdataF32[offset++] = pvdata.rotation.y;
            this._vdataF32[offset++] = pvdata.rotation.z;
            this._vdataUint32[offset++] = pvdata.color;
            if (pvdata.velocity) {
              this._vdataF32[offset++] = pvdata.velocity.x;
              this._vdataF32[offset++] = pvdata.velocity.y;
              this._vdataF32[offset++] = pvdata.velocity.z;
            }
          } else {
            this._vdataF32[offset++] = pvdata.position.x;
            this._vdataF32[offset++] = pvdata.position.y;
            this._vdataF32[offset++] = pvdata.position.z;
            this._vdataF32[offset++] = pvdata.texcoord.z;
            this._vdataF32[offset++] = pvdata.size.x;
            this._vdataF32[offset++] = pvdata.size.y;
            this._vdataF32[offset++] = pvdata.size.z;
            this._vdataF32[offset++] = pvdata.rotation.x;
            this._vdataF32[offset++] = pvdata.rotation.y;
            this._vdataF32[offset++] = pvdata.rotation.z;
            this._vdataUint32[offset++] = pvdata.color;
          }
        }
        addGPUParticleVertexData(p, num, time) {
          if (!this._useInstance) {
            let offset = num * this._vertAttrsFloatCount * this._vertCount;
            for (let i = 0; i < this._vertCount; i++) {
              let idx = offset;
              this._vdataF32[idx++] = p.position.x;
              this._vdataF32[idx++] = p.position.y;
              this._vdataF32[idx++] = p.position.z;
              this._vdataF32[idx++] = time;
              this._vdataF32[idx++] = p.startSize.x;
              this._vdataF32[idx++] = p.startSize.y;
              this._vdataF32[idx++] = p.startSize.z;
              this._vdataF32[idx++] = _uvs$1[2 * i];
              this._vdataF32[idx++] = p.rotation.x;
              this._vdataF32[idx++] = p.rotation.y;
              this._vdataF32[idx++] = p.rotation.z;
              this._vdataF32[idx++] = _uvs$1[2 * i + 1];
              this._vdataF32[idx++] = p.startColor.r / 255.0;
              this._vdataF32[idx++] = p.startColor.g / 255.0;
              this._vdataF32[idx++] = p.startColor.b / 255.0;
              this._vdataF32[idx++] = p.startColor.a / 255.0;
              this._vdataF32[idx++] = p.velocity.x;
              this._vdataF32[idx++] = p.velocity.y;
              this._vdataF32[idx++] = p.velocity.z;
              this._vdataF32[idx++] = p.startLifetime;
              this._vdataF32[idx++] = p.randomSeed;
              offset += this._vertAttrsFloatCount;
            }
          } else {
            this.addGPUParticleVertexDataIns(p, num, time);
          }
        }
        addGPUParticleVertexDataIns(p, num, time) {
          let offset = num * this._vertAttrsFloatCount;
          let idx = offset;
          this._vdataF32[idx++] = p.position.x;
          this._vdataF32[idx++] = p.position.y;
          this._vdataF32[idx++] = p.position.z;
          this._vdataF32[idx++] = time;
          this._vdataF32[idx++] = p.startSize.x;
          this._vdataF32[idx++] = p.startSize.y;
          this._vdataF32[idx++] = p.startSize.z;
          this._vdataF32[idx++] = p.frameIndex;
          this._vdataF32[idx++] = p.rotation.x;
          this._vdataF32[idx++] = p.rotation.y;
          this._vdataF32[idx++] = p.rotation.z;
          this._vdataF32[idx++] = p.startColor.r / 255.0;
          this._vdataF32[idx++] = p.startColor.g / 255.0;
          this._vdataF32[idx++] = p.startColor.b / 255.0;
          this._vdataF32[idx++] = p.startColor.a / 255.0;
          this._vdataF32[idx++] = p.velocity.x;
          this._vdataF32[idx++] = p.velocity.y;
          this._vdataF32[idx++] = p.velocity.z;
          this._vdataF32[idx++] = p.startLifetime;
          this._vdataF32[idx++] = p.randomSeed;
          offset += this._vertAttrsFloatCount;
        }
        updateGPUParticles(num, time, dt) {
          if (!this._useInstance) {
            const pSize = this._vertAttrsFloatCount * this._vertCount;
            let pBaseIndex = 0;
            let startTime = 0;
            let lifeTime = 0;
            let lastBaseIndex = 0;
            let interval = 0;
            for (let i = 0; i < num; ++i) {
              pBaseIndex = i * pSize;
              startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
              lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
              interval = time - startTime;
              if (lifeTime - interval < dt) {
                lastBaseIndex = --num * pSize;
                this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);
                i--;
              }
            }
            return num;
          } else {
            return this.updateGPUParticlesIns(num, time, dt);
          }
        }
        updateGPUParticlesIns(num, time, dt) {
          const pSize = this._vertAttrsFloatCount;
          let pBaseIndex = 0;
          let startTime = 0;
          let lifeTime = 0;
          let lastBaseIndex = 0;
          let interval = 0;
          for (let i = 0; i < num; ++i) {
            pBaseIndex = i * pSize;
            startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
            lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
            interval = time - startTime;
            if (lifeTime - interval < dt) {
              lastBaseIndex = --num * pSize;
              this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);
              i--;
            }
          }
          return num;
        }
        constructAttributeIndex() {
          if (!this._vertAttrs) {
            return;
          }
          let vIdx = this._vertAttrs.findIndex(val => val.name === 'a_position_starttime');
          let vOffset = this._vertAttrs[vIdx].offset;
          this._startTimeOffset = vOffset / 4 + 3;
          vIdx = this._vertAttrs.findIndex(val => val.name === 'a_dir_life');
          vOffset = this._vertAttrs[vIdx].offset;
          this._lifeTimeOffset = vOffset / 4 + 3;
        }
        updateIA(count) {
          if (!this._useInstance) {
            if (count <= 0) {
              return;
            }
            const ia = this._subModels[0].inputAssembler;
            ia.vertexBuffers[0].update(this._vdataF32);
            ia.firstIndex = 0;
            ia.indexCount = this._indexCount * count;
            ia.vertexCount = this._iaVertCount;
          } else {
            this.updateIAIns(count);
          }
        }
        updateIAIns(count) {
          if (count <= 0) {
            return;
          }
          const ia = this._subModels[0].inputAssembler;
          ia.vertexBuffers[0].update(this._vdataF32);
          ia.instanceCount = count;
          ia.firstIndex = 0;
          ia.indexCount = this._indexCount;
          ia.instanceCount = count;
          ia.vertexCount = this._iaVertCount;
        }
        clear() {
          if (!this._useInstance) {
            this._subModels[0].inputAssembler.indexCount = 0;
          } else {
            this.clearIns();
          }
        }
        clearIns() {
          this._subModels[0].inputAssembler.instanceCount = 0;
        }
        destroy() {
          super.destroy();
          this.doDestroy();
        }
        doDestroy() {
          this._vBuffer = null;
          this._vdataF32 = null;
          this._vdataUint32 = null;
          this._insBuffers = [];
          this._insIndices = null;
          this._vertAttrs = null;
          this._material = null;
          this._mesh = null;
          this.destroySubMeshData();
        }
        rebuild() {
          if (!this._useInstance) {
            this._vBuffer = this.createSubMeshData();
            this._vdataF32 = new Float32Array(this._vBuffer);
            this._vdataUint32 = new Uint32Array(this._vBuffer);
          } else {
            this.rebuildIns();
          }
        }
        rebuildIns() {
          this._vBuffer = this.createSubMeshDataInsDynamic();
          this._vdataF32 = new Float32Array(this._vBuffer);
          this._vdataUint32 = new Uint32Array(this._vBuffer);
          this.createSubMeshDataInsStatic();
          this.createInsSubmesh();
        }
        destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();
            this._subMeshData = null;
          }
        }
        set useInstance(value) {
          if (this._useInstance !== value) {
            this._useInstance = value;
          }
        }
        get useInstance() {
          return this._useInstance;
        }
      }

      class ParticleSystemRendererBase {
        get model() {
          return this._model;
        }
        constructor(info) {
          this._particleSystem = null;
          this._model = null;
          this._renderInfo = null;
          this._vertAttrs = [];
          this._useInstance = void 0;
          this._renderInfo = info;
          if (!deviceManager.gfxDevice.hasFeature(Feature.INSTANCED_ARRAYS)) {
            this._useInstance = false;
          } else {
            this._useInstance = true;
          }
        }
        getUseInstance() {
          return this._useInstance;
        }
        getInfo() {
          return this._renderInfo;
        }
        onInit(ps) {
          this._particleSystem = ps;
        }
        onEnable() {
          if (!this._particleSystem) {
            return;
          }
          this.attachToScene();
          const model = this._model;
          if (model) {
            model.node = model.transform = this._particleSystem.node;
          }
        }
        onDisable() {
          this.detachFromScene();
        }
        onDestroy() {
          if (this._model) {
            legacyCC.director.root.destroyModel(this._model);
            this._model = null;
          }
        }
        attachToScene() {
          if (this._model) {
            var _this$_particleSystem;
            if (this._model.scene) {
              this.detachFromScene();
            }
            (_this$_particleSystem = this._particleSystem) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem._getRenderScene().addModel(this._model);
          }
        }
        detachFromScene() {
          if (this._model && this._model.scene) {
            this._model.scene.removeModel(this._model);
          }
        }
        setVertexAttributes() {
          if (this._model) {
            this.updateVertexAttrib();
            this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
          }
        }
        clear() {
          if (this._model) this._model.enabled = false;
        }
        getModel() {
          return this._model;
        }
        _initModel() {
          if (!this._model && this._particleSystem) {
            this._model = legacyCC.director.root.createModel(ParticleBatchModel);
            this._model.setCapacity(this._particleSystem.capacity);
            this._model.visFlags = this._particleSystem.visibility;
          }
        }
        updateTrailMaterial() {}
        getDefaultTrailMaterial() {
          return null;
        }
      }

      class ParticleNoise {
        constructor(permutation) {
          this.permutation = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
          this.accSpeed = new Vec3();
          this.noiseSpeed = new Vec3();
          this.noiseFrequency = 0.0;
          this.noiseAbs = new Vec3();
          this.noiseAmplitude = new Vec3();
          this.octaves = new Vec3();
          this.dt = 0.0;
          this.point = new Vec3();
          this.result = new Vec3();
          this.mixOut = new Vec2();
          if (permutation) {
            this.permutation = permutation;
          }
        }
        noise(x, y, z, min = 0, max = 1) {
          const p = new Array(512);
          for (let i = 0; i < 256; i++) {
            p[256 + i] = p[i] = this.permutation[i];
          }
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          const u = this.fade(x);
          const v = this.fade(y);
          const w = this.fade(z);
          const A = p[X] + Y;
          const AA = p[A] + Z;
          const AB = p[A + 1] + Z;
          const B = p[X + 1] + Y;
          const BA = p[B] + Z;
          const BB = p[B + 1] + Z;
          const val = this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(p[AA], x, y, z), this.grad(p[BA], x - 1, y, z)), this.lerp(u, this.grad(p[AB], x, y - 1, z), this.grad(p[BB], x - 1, y - 1, z))), this.lerp(v, this.lerp(u, this.grad(p[AA + 1], x, y, z - 1), this.grad(p[BA + 1], x - 1, y, z - 1)), this.lerp(u, this.grad(p[AB + 1], x, y - 1, z - 1), this.grad(p[BB + 1], x - 1, y - 1, z - 1)))));
          return min + val * (max - min);
        }
        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }
        lerp(t, a, b) {
          return a + t * (b - a);
        }
        grad(hash, x, y, z) {
          const h = hash & 15;
          const u = h < 8 ? x : y;
          const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
          return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        scale(n) {
          return (1 + n) / 2;
        }
        setSpeed(x, y, z) {
          this.noiseSpeed.set(x, y, z);
        }
        setFrequency(f) {
          this.noiseFrequency = f;
        }
        setAbs(x, y, z) {
          this.noiseAbs.set(x, y, z);
        }
        setAmplititude(x, y, z) {
          this.noiseAmplitude.set(x, y, z);
        }
        setOctaves(x, y, z) {
          this.octaves.set(x, y, z);
        }
        setTime(t) {
          this.dt = t;
        }
        setSamplePoint(p) {
          this.point.set(p);
        }
        getResult() {
          return this.result;
        }
        getNoise(sx, sy, sz, time, offset, noiseFrequency, octaves) {
          let frequency = noiseFrequency;
          let sum = 0.0;
          sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0);
          if (octaves.x === 1) {
            return sum;
          }
          let amplitude = 1.0;
          let range = 1.0;
          for (let i = 1; i < octaves.x; ++i) {
            amplitude *= octaves.y;
            frequency *= octaves.z;
            range += amplitude;
            sum += this.noise(sx * frequency, sy * frequency, sz * frequency, -1.0, 1.0) * amplitude;
          }
          return sum / range;
        }
        getNoiseMix(out, point, time, offSpeed, noiseFrequency, octaves) {
          out.x = this.getNoise(point.x, point.y, point.z, time, offSpeed, noiseFrequency, octaves);
          out.y = this.getNoise(point.y, point.z, point.x, time, offSpeed, noiseFrequency, octaves);
        }
        getNoiseParticle() {
          this.accSpeed.set(this.noiseSpeed.x * this.dt, this.noiseSpeed.y * this.dt, this.noiseSpeed.z * this.dt);
          const axisOffset = 1000.0;
          const sampX = this.getNoise(this.point.z + this.accSpeed.x, this.point.y, this.point.x, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          const sampY = this.getNoise(this.point.x + axisOffset, this.point.z + this.accSpeed.y, this.point.y, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          const sampZ = this.getNoise(this.point.y, this.point.x + axisOffset, this.point.z + this.accSpeed.z, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
          this.result.set(sampX * this.noiseAmplitude.x, sampY * this.noiseAmplitude.y, sampZ * this.noiseAmplitude.z);
        }
        getPreview(out, width, height) {
          for (let h = 0; h < height; ++h) {
            for (let w = 0; w < width; ++w) {
              const sampx = (w - width * 0.5) / width + this.noiseSpeed.x * this.dt;
              const sampy = (h - height * 0.5) / height + this.noiseSpeed.y * this.dt;
              const pix = this.getNoise(sampx, sampy, 0.0, this.dt, this.accSpeed, this.noiseFrequency, this.octaves);
              out[h * width + w] = (pix + 1.0) * 0.5;
            }
          }
        }
      }

      const _tempNodeScale$1 = new Vec4();
      const _tempAttribUV = new Vec3();
      const _tempWorldTrans$1 = new Mat4();
      const _tempParentInverse = new Mat4();
      const _node_rot$1 = new Quat();
      new Vec3();
      const _anim_module$1 = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_noiseModule'];
      const _uvs = [0, 0, 1, 0, 0, 1, 1, 1];
      const CC_USE_WORLD_SPACE$1 = 'CC_USE_WORLD_SPACE';
      const CC_RENDER_MODE$1 = 'CC_RENDER_MODE';
      const ROTATION_OVER_TIME_MODULE_ENABLE$1 = 'ROTATION_OVER_TIME_MODULE_ENABLE';
      const INSTANCE_PARTICLE$1 = 'CC_INSTANCE_PARTICLE';
      const RENDER_MODE_BILLBOARD$1 = 0;
      const RENDER_MODE_STRETCHED_BILLBOARD$1 = 1;
      const RENDER_MODE_HORIZONTAL_BILLBOARD$1 = 2;
      const RENDER_MODE_VERTICAL_BILLBOARD$1 = 3;
      const RENDER_MODE_MESH$1 = 4;
      const _vertex_attrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
      const _vertex_attrs_stretch = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F)];
      const _vertex_attrs_mesh = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
      const _vertex_attrs_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
      const _vertex_attrs_stretch_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1)];
      const _vertex_attrs_mesh_ins = [new Attribute(AttributeName.ATTR_TEX_COORD4, Format.RGBA32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F, false, 0, true), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
      const _matInsInfo$1 = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      class PVData {
        constructor() {
          this.position = void 0;
          this.texcoord = void 0;
          this.size = void 0;
          this.rotation = void 0;
          this.color = void 0;
          this.velocity = void 0;
          this.position = new Vec3();
          this.texcoord = new Vec3();
          this.size = new Vec3();
          this.rotation = new Vec3();
          this.color = 0;
          this.velocity = null;
        }
      }
      class ParticleSystemRendererCPU extends ParticleSystemRendererBase {
        constructor(info) {
          super(info);
          this._defines = void 0;
          this._trailDefines = void 0;
          this._frameTile_velLenScale = void 0;
          this._tmp_velLenScale = void 0;
          this._defaultMat = null;
          this._node_scale = void 0;
          this._particleVertexData = void 0;
          this._particles = null;
          this._defaultTrailMat = null;
          this._updateList = new Map();
          this._animateList = new Map();
          this._runAnimateList = new Array();
          this._fillDataFunc = null;
          this._uScaleHandle = 0;
          this._uLenHandle = 0;
          this._uNodeRotHandle = 0;
          this._alignSpace = AlignmentSpace.View;
          this._inited = false;
          this._localMat = new Mat4();
          this._gravity = new Vec4();
          this.noise = new ParticleNoise();
          this._model = null;
          this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
          this._tmp_velLenScale = this._frameTile_velLenScale.clone();
          this._node_scale = new Vec3();
          this._particleVertexData = new PVData();
          this._defines = {
            CC_USE_WORLD_SPACE: true,
            CC_USE_BILLBOARD: true,
            CC_USE_STRETCHED_BILLBOARD: false,
            CC_USE_HORIZONTAL_BILLBOARD: false,
            CC_USE_VERTICAL_BILLBOARD: false
          };
          this._trailDefines = {
            CC_USE_WORLD_SPACE: true
          };
        }
        onInit(ps) {
          super.onInit(ps);
          this._particles = new RecyclePool(() => new Particle(this), 16);
          this._setVertexAttrib();
          this._setFillFunc();
          this._initModuleList();
          this._initModel();
          this.updateMaterialParams();
          this.updateTrailMaterial();
          this.setVertexAttributes();
          this._inited = true;
        }
        clear() {
          super.clear();
          this._particles.reset();
          if (this._particleSystem && this._particleSystem._trailModule) {
            this._particleSystem._trailModule.clear();
          }
          this.updateRenderData();
          this._model.enabled = false;
        }
        updateRenderMode() {
          this._setVertexAttrib();
          this._setFillFunc();
          this.updateMaterialParams();
          this.setVertexAttributes();
        }
        onDestroy() {
          var _this$_particles;
          (_this$_particles = this._particles) === null || _this$_particles === void 0 ? void 0 : _this$_particles.destroy();
          super.onDestroy();
        }
        getFreeParticle() {
          if (this._particleSystem && this._particles.length >= this._particleSystem.capacity) {
            return null;
          }
          return this._particles.add();
        }
        getDefaultTrailMaterial() {
          return this._defaultTrailMat;
        }
        setNewParticle(p) {}
        _initModuleList() {
          _anim_module$1.forEach(val => {
            if (!this._particleSystem) {
              return;
            }
            const pm = this._particleSystem[val];
            if (pm && pm.enable) {
              if (pm.needUpdate) {
                this._updateList[pm.name] = pm;
              }
              if (pm.needAnimate) {
                this._animateList[pm.name] = pm;
              }
            }
          });
          this._runAnimateList.length = 0;
          for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            const p = this._animateList[PARTICLE_MODULE_ORDER[i]];
            if (p) {
              this._runAnimateList.push(p);
            }
          }
        }
        enableModule(name, val, pm) {
          if (val) {
            if (pm.needUpdate) {
              this._updateList[pm.name] = pm;
            }
            if (pm.needAnimate) {
              this._animateList[pm.name] = pm;
            }
          } else {
            delete this._animateList[name];
            delete this._updateList[name];
          }
          this._runAnimateList.length = 0;
          for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            const p = this._animateList[PARTICLE_MODULE_ORDER[i]];
            if (p) {
              this._runAnimateList.push(p);
            }
          }
          this.updateMaterialParams();
        }
        updateAlignSpace(space) {
          this._alignSpace = space;
        }
        getDefaultMaterial() {
          return this._defaultMat;
        }
        updateRotation(pass) {
          if (pass) {
            this.doUpdateRotation(pass);
          }
        }
        doUpdateRotation(pass) {
          const mode = this._renderInfo.renderMode;
          if (mode !== RenderMode.Mesh && this._alignSpace === AlignmentSpace.View) {
            return;
          }
          if (this._alignSpace === AlignmentSpace.Local) {
            var _this$_particleSystem;
            (_this$_particleSystem = this._particleSystem) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.node.getRotation(_node_rot$1);
          } else if (this._alignSpace === AlignmentSpace.World) {
            var _this$_particleSystem2;
            (_this$_particleSystem2 = this._particleSystem) === null || _this$_particleSystem2 === void 0 ? void 0 : _this$_particleSystem2.node.getWorldRotation(_node_rot$1);
          } else if (this._alignSpace === AlignmentSpace.View) {
            var _this$_particleSystem3, _this$_particleSystem4;
            _node_rot$1.set(0.0, 0.0, 0.0, 1.0);
            const cameraLst = (_this$_particleSystem3 = this._particleSystem) === null || _this$_particleSystem3 === void 0 ? void 0 : (_this$_particleSystem4 = _this$_particleSystem3.node.scene.renderScene) === null || _this$_particleSystem4 === void 0 ? void 0 : _this$_particleSystem4.cameras;
            if (cameraLst !== undefined) {
              for (let i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                const camera = cameraLst[i];
                const checkCamera = (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;
                if (checkCamera) {
                  Quat.fromViewUp(_node_rot$1, camera.forward);
                  break;
                }
              }
            }
          } else {
            _node_rot$1.set(0.0, 0.0, 0.0, 1.0);
          }
          pass.setUniform(this._uNodeRotHandle, _node_rot$1);
        }
        updateScale(pass) {
          if (pass) {
            this.doUpdateScale(pass);
          }
        }
        doUpdateScale(pass) {
          var _this$_particleSystem5, _this$_particleSystem6, _this$_particleSystem7;
          const nodeScale = this._node_scale;
          switch ((_this$_particleSystem5 = this._particleSystem) === null || _this$_particleSystem5 === void 0 ? void 0 : _this$_particleSystem5.scaleSpace) {
            case Space.Local:
              (_this$_particleSystem6 = this._particleSystem) === null || _this$_particleSystem6 === void 0 ? void 0 : _this$_particleSystem6.node.getScale(nodeScale);
              break;
            case Space.World:
              (_this$_particleSystem7 = this._particleSystem) === null || _this$_particleSystem7 === void 0 ? void 0 : _this$_particleSystem7.node.getWorldScale(nodeScale);
              break;
          }
          pass.setUniform(this._uScaleHandle, _tempNodeScale$1.set(nodeScale.x, nodeScale.y, nodeScale.z));
        }
        updateParticles(dt) {
          const ps = this._particleSystem;
          if (!ps) {
            return this._particles.length;
          }
          ps.node.getWorldMatrix(_tempWorldTrans$1);
          const mat = ps.getMaterialInstance(0) || this._defaultMat;
          const pass = mat.passes[0];
          this.doUpdateScale(pass);
          this.doUpdateRotation(pass);
          this._updateList.forEach((value, key) => {
            value.update(ps.simulationSpace, _tempWorldTrans$1);
          });
          const trailModule = ps._trailModule;
          const trailEnable = trailModule && trailModule.enable;
          if (trailEnable) {
            trailModule.update();
          }
          const useGravity = !ps.gravityModifier.isZero();
          if (useGravity) {
            if (ps.simulationSpace === Space.Local) {
              const r = ps.node.getRotation();
              Mat4.fromQuat(this._localMat, r);
              this._localMat.transpose();
            }
            if (ps.node.parent) {
              const r = ps.node.parent.getWorldRotation();
              Mat4.fromQuat(_tempParentInverse, r);
              _tempParentInverse.transpose();
            }
          }
          for (let i = 0; i < this._particles.length; ++i) {
            const p = this._particles.data[i];
            p.remainingLifetime -= dt;
            Vec3.set(p.animatedVelocity, 0, 0, 0);
            if (p.remainingLifetime < 0.0) {
              if (trailEnable) {
                trailModule.removeParticle(p);
              }
              this._particles.removeAt(i);
              --i;
              continue;
            }
            if (useGravity) {
              const rand = isCurveTwoValues(ps.gravityModifier) ? pseudoRandom(p.randomSeed) : 0;
              if (ps.simulationSpace === Space.Local) {
                const time = 1 - p.remainingLifetime / p.startLifetime;
                const gravityFactor = -ps.gravityModifier.evaluate(time, rand) * 9.8 * dt;
                this._gravity.x = 0.0;
                this._gravity.y = gravityFactor;
                this._gravity.z = 0.0;
                this._gravity.w = 1.0;
                if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                  if (ps.node.parent) {
                    this._gravity = this._gravity.transformMat4(_tempParentInverse);
                  }
                  this._gravity = this._gravity.transformMat4(this._localMat);
                  p.velocity.x += this._gravity.x;
                  p.velocity.y += this._gravity.y;
                  p.velocity.z += this._gravity.z;
                }
              } else {
                p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
              }
            }
            Vec3.copy(p.ultimateVelocity, p.velocity);
            this._runAnimateList.forEach(value => {
              value.animate(p, dt);
            });
            Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
            if (trailEnable) {
              trailModule.animate(p, dt);
            }
          }
          this._model.enabled = this._particles.length > 0;
          return this._particles.length;
        }
        getNoisePreview(out, width, height) {
          this._runAnimateList.forEach(value => {
            if (value.name === PARTICLE_MODULE_NAME.NOISE) {
              const m = value;
              m.getNoisePreview(out, this._particleSystem, width, height);
            }
          });
        }
        updateRenderData() {
          let idx = 0;
          for (let i = 0; i < this._particles.length; ++i) {
            const p = this._particles.data[i];
            let fi = 0;
            const textureModule = this._particleSystem._textureAnimationModule;
            if (textureModule && textureModule.enable) {
              fi = p.frameIndex;
            }
            idx = i * 4;
            this._fillDataFunc(p, idx, fi);
          }
        }
        beforeRender() {
          this._model.updateIA(this._particles.length);
        }
        getParticleCount() {
          return this._particles.length;
        }
        onMaterialModified(index, material) {
          if (!this._inited) {
            return;
          }
          if (index === 0) {
            this.updateMaterialParams();
          } else {
            this.updateTrailMaterial();
          }
        }
        onRebuildPSO(index, material) {
          if (this._model && index === 0) {
            this._model.setSubModelMaterial(0, material);
          }
          const trailModule = this._particleSystem._trailModule;
          const trailModel = trailModule === null || trailModule === void 0 ? void 0 : trailModule.getModel();
          if (trailModel && index === 1) {
            trailModel.setSubModelMaterial(0, material);
          }
        }
        _setFillFunc() {
          if (this._renderInfo.renderMode === RenderMode.Mesh) {
            this._fillDataFunc = this._fillMeshData;
          } else if (this._renderInfo.renderMode === RenderMode.StrecthedBillboard) {
            this._fillDataFunc = this._fillStrecthedData;
          } else {
            this._fillDataFunc = this._fillNormalData;
          }
        }
        _fillMeshData(p, idx, fi) {
          const i = idx / 4;
          Vec3.copy(this._particleVertexData.position, p.position);
          _tempAttribUV.z = fi;
          Vec3.copy(this._particleVertexData.texcoord, _tempAttribUV);
          Vec3.copy(this._particleVertexData.size, p.size);
          Vec3.copy(this._particleVertexData.rotation, p.rotation);
          this._particleVertexData.color = p.color._val;
          this._model.addParticleVertexData(i, this._particleVertexData);
        }
        _fillStrecthedData(p, idx, fi) {
          if (!this._useInstance) {
            for (let j = 0; j < 4; ++j) {
              Vec3.copy(this._particleVertexData.position, p.position);
              _tempAttribUV.x = _uvs[2 * j];
              _tempAttribUV.y = _uvs[2 * j + 1];
              _tempAttribUV.z = fi;
              Vec3.copy(this._particleVertexData.texcoord, _tempAttribUV);
              Vec3.copy(this._particleVertexData.size, p.size);
              Vec3.copy(this._particleVertexData.rotation, p.rotation);
              this._particleVertexData.color = p.color._val;
              this._particleVertexData.velocity = p.ultimateVelocity;
              this._model.addParticleVertexData(idx++, this._particleVertexData);
            }
          } else {
            this._fillStrecthedDataIns(p, idx, fi);
          }
        }
        _fillStrecthedDataIns(p, idx, fi) {
          const i = idx / 4;
          Vec3.copy(this._particleVertexData.position, p.position);
          _tempAttribUV.z = fi;
          Vec3.copy(this._particleVertexData.texcoord, _tempAttribUV);
          Vec3.copy(this._particleVertexData.size, p.size);
          Vec3.copy(this._particleVertexData.rotation, p.rotation);
          this._particleVertexData.color = p.color._val;
          this._particleVertexData.velocity = p.ultimateVelocity;
          this._model.addParticleVertexData(i, this._particleVertexData);
        }
        _fillNormalData(p, idx, fi) {
          if (!this._useInstance) {
            for (let j = 0; j < 4; ++j) {
              Vec3.copy(this._particleVertexData.position, p.position);
              _tempAttribUV.x = _uvs[2 * j];
              _tempAttribUV.y = _uvs[2 * j + 1];
              _tempAttribUV.z = fi;
              Vec3.copy(this._particleVertexData.texcoord, _tempAttribUV);
              Vec3.copy(this._particleVertexData.size, p.size);
              Vec3.copy(this._particleVertexData.rotation, p.rotation);
              this._particleVertexData.color = p.color._val;
              this._model.addParticleVertexData(idx++, this._particleVertexData);
            }
          } else {
            this._fillNormalDataIns(p, idx, fi);
          }
        }
        _fillNormalDataIns(p, idx, fi) {
          const i = idx / 4;
          Vec3.copy(this._particleVertexData.position, p.position);
          _tempAttribUV.z = fi;
          Vec3.copy(this._particleVertexData.texcoord, _tempAttribUV);
          Vec3.copy(this._particleVertexData.size, p.size);
          Vec3.copy(this._particleVertexData.rotation, p.rotation);
          this._particleVertexData.color = p.color._val;
          this._model.addParticleVertexData(i, this._particleVertexData);
        }
        updateVertexAttrib() {
          if (this._renderInfo.renderMode !== RenderMode.Mesh) {
            return;
          }
          if (this._renderInfo.mesh) {
            const format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);
            if (format) {
              let type = Format.RGBA8;
              for (let i = 0; i < FormatInfos.length; ++i) {
                if (FormatInfos[i].name === format.name) {
                  type = i;
                  break;
                }
              }
              this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            } else {
              const type = Format.RGBA8;
              this._vertAttrs[7] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            }
          }
        }
        _setVertexAttrib() {
          if (!this._useInstance) {
            switch (this._renderInfo.renderMode) {
              case RenderMode.StrecthedBillboard:
                this._vertAttrs = _vertex_attrs_stretch.slice();
                break;
              case RenderMode.Mesh:
                this._vertAttrs = _vertex_attrs_mesh.slice();
                break;
              default:
                this._vertAttrs = _vertex_attrs.slice();
            }
          } else {
            this._setVertexAttribIns();
          }
        }
        _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case RenderMode.StrecthedBillboard:
              this._vertAttrs = _vertex_attrs_stretch_ins.slice();
              break;
            case RenderMode.Mesh:
              this._vertAttrs = _vertex_attrs_mesh_ins.slice();
              break;
            default:
              this._vertAttrs = _vertex_attrs_ins.slice();
          }
        }
        updateMaterialParams() {
          if (!this._particleSystem) {
            return;
          }
          const ps = this._particleSystem;
          const shareMaterial = ps.sharedMaterial;
          if (shareMaterial != null) {
            this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
          }
          if (ps.sharedMaterial == null && this._defaultMat == null) {
            _matInsInfo$1.parent = builtinResMgr.get('default-particle-material');
            _matInsInfo$1.owner = this._particleSystem;
            _matInsInfo$1.subModelIdx = 0;
            this._defaultMat = new MaterialInstance(_matInsInfo$1);
            _matInsInfo$1.parent = null;
            _matInsInfo$1.owner = null;
            _matInsInfo$1.subModelIdx = 0;
            if (this._renderInfo.mainTexture !== null) {
              this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
            }
          }
          const mat = ps.getMaterialInstance(0) || this._defaultMat;
          if (ps.simulationSpace === Space.World) {
            this._defines[CC_USE_WORLD_SPACE$1] = true;
          } else {
            this._defines[CC_USE_WORLD_SPACE$1] = false;
          }
          const pass = mat.passes[0];
          this._uScaleHandle = pass.getHandle('scale');
          this._uLenHandle = pass.getHandle('frameTile_velLenScale');
          this._uNodeRotHandle = pass.getHandle('nodeRotation');
          const renderMode = this._renderInfo.renderMode;
          const vlenScale = this._frameTile_velLenScale;
          if (renderMode === RenderMode.Billboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_BILLBOARD$1;
          } else if (renderMode === RenderMode.StrecthedBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_STRETCHED_BILLBOARD$1;
            vlenScale.z = this._renderInfo.velocityScale;
            vlenScale.w = this._renderInfo.lengthScale;
          } else if (renderMode === RenderMode.HorizontalBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_HORIZONTAL_BILLBOARD$1;
          } else if (renderMode === RenderMode.VerticalBillboard) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_VERTICAL_BILLBOARD$1;
          } else if (renderMode === RenderMode.Mesh) {
            this._defines[CC_RENDER_MODE$1] = RENDER_MODE_MESH$1;
          } else {
            warn(`particle system renderMode ${renderMode} not support.`);
          }
          const textureModule = ps._textureAnimationModule;
          if (textureModule && textureModule.enable) {
            Vec4.copy(this._tmp_velLenScale, vlenScale);
            Vec2.set(this._tmp_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
            pass.setUniform(this._uLenHandle, this._tmp_velLenScale);
          } else {
            pass.setUniform(this._uLenHandle, vlenScale);
          }
          let enable = false;
          const roationModule = this._particleSystem._rotationOvertimeModule;
          enable = roationModule ? roationModule.enable : false;
          this._defines[ROTATION_OVER_TIME_MODULE_ENABLE$1] = enable;
          this._defines[INSTANCE_PARTICLE$1] = this._useInstance;
          mat.recompileShaders(this._defines);
          if (this._model) {
            this._model.updateMaterial(mat);
          }
        }
        updateTrailMaterial() {
          if (!this._particleSystem) {
            return;
          }
          const ps = this._particleSystem;
          const trailModule = ps._trailModule;
          if (trailModule && trailModule.enable) {
            if (ps.simulationSpace === Space.World || trailModule.space === Space.World) {
              this._trailDefines[CC_USE_WORLD_SPACE$1] = true;
            } else {
              this._trailDefines[CC_USE_WORLD_SPACE$1] = false;
            }
            let mat = ps.getMaterialInstance(1);
            if (mat === null && this._defaultTrailMat === null) {
              _matInsInfo$1.parent = builtinResMgr.get('default-trail-material');
              _matInsInfo$1.owner = this._particleSystem;
              _matInsInfo$1.subModelIdx = 1;
              this._defaultTrailMat = new MaterialInstance(_matInsInfo$1);
              _matInsInfo$1.parent = null;
              _matInsInfo$1.owner = null;
              _matInsInfo$1.subModelIdx = 0;
            }
            mat = mat || this._defaultTrailMat;
            mat.recompileShaders(this._trailDefines);
            trailModule.updateMaterial();
          }
        }
        setUseInstance(value) {
          if (this._useInstance === value) {
            return;
          }
          this._useInstance = value;
          if (this._model) {
            this._model.useInstance = value;
            this._model.doDestroy();
          }
          this.updateRenderMode();
        }
      }

      const _tempNodeScale = new Vec4();
      const _tempWorldTrans = new Mat4();
      const _tempVec4 = new Vec4();
      const _world_rot = new Quat();
      const _node_rot = new Quat();
      new Vec3();
      const _sample_num = 32;
      const _sample_interval = 1.0 / _sample_num;
      const CC_USE_WORLD_SPACE = 'CC_USE_WORLD_SPACE';
      const CC_RENDER_MODE = 'CC_RENDER_MODE';
      const RENDER_MODE_BILLBOARD = 0;
      const RENDER_MODE_STRETCHED_BILLBOARD = 1;
      const RENDER_MODE_HORIZONTAL_BILLBOARD = 2;
      const RENDER_MODE_VERTICAL_BILLBOARD = 3;
      const RENDER_MODE_MESH = 4;
      const COLOR_OVER_TIME_MODULE_ENABLE = 'COLOR_OVER_TIME_MODULE_ENABLE';
      const ROTATION_OVER_TIME_MODULE_ENABLE = 'ROTATION_OVER_TIME_MODULE_ENABLE';
      const SIZE_OVER_TIME_MODULE_ENABLE = 'SIZE_OVER_TIME_MODULE_ENABLE';
      const VELOCITY_OVER_TIME_MODULE_ENABLE = 'VELOCITY_OVER_TIME_MODULE_ENABLE';
      const FORCE_OVER_TIME_MODULE_ENABLE = 'FORCE_OVER_TIME_MODULE_ENABLE';
      const TEXTURE_ANIMATION_MODULE_ENABLE = 'TEXTURE_ANIMATION_MODULE_ENABLE';
      const USE_VK_SHADER = 'USE_VK_SHADER';
      const INSTANCE_PARTICLE = 'CC_INSTANCE_PARTICLE';
      const _vert_attr_name = {
        POSITION_STARTTIME: 'a_position_starttime',
        VERT_SIZE_UV: 'a_size_uv',
        VERT_ROTATION_UV: 'a_rotation_uv',
        COLOR: 'a_color',
        DIR_LIFE: 'a_dir_life',
        RANDOM_SEED: 'a_rndSeed',
        VERT_SIZE_FID: 'a_size_fid',
        VERT_ROTATION: 'a_rotation',
        VERT_UV: 'a_uv'
      };
      const _gpu_vert_attr = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F)];
      const _gpu_vert_attr_mesh = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
      const _gpu_vert_attr_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION, Format.RGB32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F, false, 0, true), new Attribute(_vert_attr_name.VERT_UV, Format.RGB32F, false, 1)];
      const _gpu_vert_attr_mesh_ins = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_SIZE_FID, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.VERT_ROTATION, Format.RGB32F, false, 0, true), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F, false, 0, true), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F, false, 0, true), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F, false, 1), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true, 1)];
      const _matInsInfo = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      class ParticleSystemRendererGPU extends ParticleSystemRendererBase {
        constructor(info) {
          super(info);
          this._defines = void 0;
          this._frameTile_velLenScale = void 0;
          this._unifrom_velLenScale = void 0;
          this._tmp_velLenScale = void 0;
          this._node_scale = void 0;
          this._vertAttrs = [];
          this._defaultMat = null;
          this._particleNum = 0;
          this._tempParticle = null;
          this._colorTexture = null;
          this._forceTexture = null;
          this._velocityTexture = null;
          this._rotationTexture = null;
          this._sizeTexture = null;
          this._animTexture = null;
          this._colorData = null;
          this._forceData = null;
          this._velocityData = null;
          this._rotationData = null;
          this._sizeData = null;
          this._animData = null;
          this._uTimeHandle = 0;
          this._uRotHandle = 0;
          this._uNodeRotHandle = 0;
          this._alignSpace = AlignmentSpace.View;
          this._inited = false;
          this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
          this._unifrom_velLenScale = this._frameTile_velLenScale.clone();
          this._tmp_velLenScale = this._frameTile_velLenScale.clone();
          this._node_scale = new Vec3();
          this._defines = {
            CC_USE_WORLD_SPACE: true,
            CC_USE_BILLBOARD: true,
            CC_USE_STRETCHED_BILLBOARD: false,
            CC_USE_HORIZONTAL_BILLBOARD: false,
            CC_USE_VERTICAL_BILLBOARD: false,
            COLOR_OVER_TIME_MODULE_ENABLE: false
          };
          this._tempParticle = new Particle(null);
          this._particleNum = 0;
        }
        onInit(ps) {
          super.onInit(ps);
          this._setVertexAttrib();
          this._initModel();
          this.updateMaterialParams();
          this.setVertexAttributes();
          this._inited = true;
        }
        updateRenderMode() {
          this._setVertexAttrib();
          this.updateMaterialParams();
          this.setVertexAttributes();
        }
        setVertexAttributes() {
          super.setVertexAttributes();
          this._model.constructAttributeIndex();
        }
        clear() {
          super.clear();
          this._particleNum = 0;
          this.updateRenderData();
        }
        onDestroy() {
          super.onDestroy();
          if (this._forceTexture) this._forceTexture.destroy();
          if (this._velocityTexture) this._velocityTexture.destroy();
          if (this._colorTexture) this._colorTexture.destroy();
          if (this._sizeTexture) this._sizeTexture.destroy();
          if (this._rotationTexture) this._rotationTexture.destroy();
          if (this._animTexture) this._animTexture.destroy();
          this._forceData = null;
          this._velocityData = null;
          this._colorData = null;
          this._sizeData = null;
          this._rotationData = null;
          this._animData = null;
        }
        enableModule(name, val, pm) {
          var _this$_particleSystem;
          const mat = ((_this$_particleSystem = this._particleSystem) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.getMaterialInstance(0)) || this._defaultMat;
          if (!mat) {
            return;
          }
          this.initShaderUniform(mat);
          mat.recompileShaders(this._defines);
          if (this._model) {
            this._model.setSubModelMaterial(0, mat);
          }
        }
        getFreeParticle() {
          var _this$_particleSystem2;
          if (this._particleSystem && this._particleNum >= ((_this$_particleSystem2 = this._particleSystem) === null || _this$_particleSystem2 === void 0 ? void 0 : _this$_particleSystem2.capacity)) {
            return null;
          }
          return this._tempParticle;
        }
        setNewParticle(p) {
          if (!this._particleSystem) {
            return;
          }
          this._model.addGPUParticleVertexData(p, this._particleNum, this._particleSystem.time);
          this._particleNum++;
        }
        getDefaultMaterial() {
          return this._defaultMat;
        }
        updateRotation(pass) {
          if (pass) {
            this.doUpdateRotation(pass);
          }
        }
        doUpdateRotation(pass) {
          const mode = this._renderInfo.renderMode;
          if (mode !== RenderMode.Mesh && this._alignSpace === AlignmentSpace.View) {
            return;
          }
          if (this._alignSpace === AlignmentSpace.Local) {
            var _this$_particleSystem3;
            (_this$_particleSystem3 = this._particleSystem) === null || _this$_particleSystem3 === void 0 ? void 0 : _this$_particleSystem3.node.getRotation(_node_rot);
          } else if (this._alignSpace === AlignmentSpace.World) {
            var _this$_particleSystem4;
            (_this$_particleSystem4 = this._particleSystem) === null || _this$_particleSystem4 === void 0 ? void 0 : _this$_particleSystem4.node.getWorldRotation(_node_rot);
          } else if (this._alignSpace === AlignmentSpace.View) {
            var _this$_particleSystem5, _this$_particleSystem6;
            _node_rot.set(0.0, 0.0, 0.0, 1.0);
            const cameraLst = (_this$_particleSystem5 = this._particleSystem) === null || _this$_particleSystem5 === void 0 ? void 0 : (_this$_particleSystem6 = _this$_particleSystem5.node.scene.renderScene) === null || _this$_particleSystem6 === void 0 ? void 0 : _this$_particleSystem6.cameras;
            if (cameraLst !== undefined && this._particleSystem) {
              for (let i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                const camera = cameraLst[i];
                const checkCamera = (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;
                if (checkCamera) {
                  Quat.fromViewUp(_node_rot, camera.forward);
                  break;
                }
              }
            }
          } else {
            _node_rot.set(0.0, 0.0, 0.0, 1.0);
          }
          pass.setUniform(this._uNodeRotHandle, _node_rot);
        }
        updateScale(pass) {
          if (pass) {
            this.doUpdateScale(pass);
          }
        }
        doUpdateScale(pass) {
          var _this$_particleSystem7;
          const nodeScale = this._node_scale;
          switch ((_this$_particleSystem7 = this._particleSystem) === null || _this$_particleSystem7 === void 0 ? void 0 : _this$_particleSystem7.scaleSpace) {
            case Space.Local:
              this._particleSystem.node.getScale(nodeScale);
              break;
            case Space.World:
              this._particleSystem.node.getWorldScale(nodeScale);
              break;
          }
          pass.setUniform(pass.getHandle('scale'), _tempNodeScale.set(nodeScale.x, nodeScale.y, nodeScale.z));
        }
        updateParticles(dt) {
          if (!this._particleSystem) {
            return this._particleNum;
          }
          this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem.time, dt);
          this.updateShaderUniform(dt);
          this._model.enabled = this._particleNum > 0;
          return this._particleNum;
        }
        updateRenderData() {}
        beforeRender() {
          this._model.updateIA(this._particleNum);
        }
        updateAlignSpace(space) {
          this._alignSpace = space;
        }
        updateShaderUniform(dt) {
          if (!this._particleSystem) {
            return;
          }
          const mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;
          if (!mat) {
            return;
          }
          const pass = mat.passes[0];
          _tempVec4.x = this._particleSystem.time;
          _tempVec4.y = dt;
          pass.setUniform(this._uTimeHandle, _tempVec4);
          this._particleSystem.node.getWorldRotation(_world_rot);
          pass.setUniform(this._uRotHandle, _world_rot);
          this.doUpdateRotation(pass);
        }
        initShaderUniform(mat) {
          var _this$_particleSystem8, _this$_particleSystem9, _this$_particleSystem10, _this$_particleSystem11, _this$_particleSystem12, _this$_particleSystem13;
          const pass = mat.passes[0];
          this._uTimeHandle = pass.getHandle('u_timeDelta');
          this._uRotHandle = pass.getHandle('u_worldRot');
          this._uNodeRotHandle = pass.getHandle('nodeRotation');
          this.doUpdateScale(pass);
          pass.setUniform(pass.getHandle('frameTile_velLenScale'), this._unifrom_velLenScale);
          _tempVec4.x = _sample_num;
          _tempVec4.y = _sample_interval;
          pass.setUniform(pass.getHandle('u_sampleInfo'), _tempVec4);
          let enable = false;
          const forceModule = (_this$_particleSystem8 = this._particleSystem) === null || _this$_particleSystem8 === void 0 ? void 0 : _this$_particleSystem8._forceOvertimeModule;
          enable = forceModule ? forceModule.enable : false;
          this._defines[FORCE_OVER_TIME_MODULE_ENABLE] = enable;
          if (enable) {
            const packed = packCurveRangeXYZ(this._forceTexture, this._forceData, _sample_num, forceModule.x, forceModule.y, forceModule.z);
            this._forceTexture = packed.texture;
            this._forceData = packed.texdata;
            const handle = pass.getHandle('force_over_time_tex0');
            const binding = Pass.getBindingFromHandle(handle);
            pass.bindSampler(binding, this._forceTexture.getGFXSampler());
            pass.bindTexture(binding, this._forceTexture.getGFXTexture());
            const spaceHandle = pass.getHandle('u_force_space');
            pass.setUniform(spaceHandle, forceModule.space);
            const modeHandle = pass.getHandle('u_force_mode');
            pass.setUniform(modeHandle, this._forceTexture.height);
          }
          const velocityModule = (_this$_particleSystem9 = this._particleSystem) === null || _this$_particleSystem9 === void 0 ? void 0 : _this$_particleSystem9._velocityOvertimeModule;
          enable = velocityModule ? velocityModule.enable : false;
          this._defines[VELOCITY_OVER_TIME_MODULE_ENABLE] = enable;
          if (enable) {
            const packed = packCurveRangeXYZW(this._velocityTexture, this._velocityData, _sample_num, velocityModule.x, velocityModule.y, velocityModule.z, velocityModule.speedModifier);
            this._velocityTexture = packed.texture;
            this._velocityData = packed.texdata;
            const handle = pass.getHandle('velocity_over_time_tex0');
            const binding = Pass.getBindingFromHandle(handle);
            pass.bindSampler(binding, this._velocityTexture.getGFXSampler());
            pass.bindTexture(binding, this._velocityTexture.getGFXTexture());
            const spaceHandle = pass.getHandle('u_velocity_space');
            pass.setUniform(spaceHandle, velocityModule.space);
            const modeHandle = pass.getHandle('u_velocity_mode');
            pass.setUniform(modeHandle, this._velocityTexture.height);
          }
          const colorModule = (_this$_particleSystem10 = this._particleSystem) === null || _this$_particleSystem10 === void 0 ? void 0 : _this$_particleSystem10._colorOverLifetimeModule;
          enable = colorModule ? colorModule.enable : false;
          this._defines[COLOR_OVER_TIME_MODULE_ENABLE] = enable;
          if (enable) {
            const packed = packGradientRange(this._colorTexture, this._colorData, _sample_num, colorModule.color);
            this._colorTexture = packed.texture;
            this._colorData = packed.texdata;
            const handle = pass.getHandle('color_over_time_tex0');
            const binding = Pass.getBindingFromHandle(handle);
            pass.bindSampler(binding, this._colorTexture.getGFXSampler());
            pass.bindTexture(binding, this._colorTexture.getGFXTexture());
            const modeHandle = pass.getHandle('u_color_mode');
            pass.setUniform(modeHandle, this._colorTexture.height);
          }
          const roationModule = (_this$_particleSystem11 = this._particleSystem) === null || _this$_particleSystem11 === void 0 ? void 0 : _this$_particleSystem11._rotationOvertimeModule;
          enable = roationModule ? roationModule.enable : false;
          this._defines[ROTATION_OVER_TIME_MODULE_ENABLE] = enable;
          if (enable) {
            let packed;
            if (roationModule.separateAxes) {
              packed = packCurveRangeXYZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.x, roationModule.y, roationModule.z);
            } else {
              packed = packCurveRangeZ(this._rotationTexture, this._rotationData, _sample_num, roationModule.z);
            }
            this._rotationTexture = packed.texture;
            this._rotationData = packed.texdata;
            if (this._rotationTexture) {
              const handle = pass.getHandle('rotation_over_time_tex0');
              const binding = Pass.getBindingFromHandle(handle);
              pass.bindSampler(binding, this._rotationTexture.getGFXSampler());
              pass.bindTexture(binding, this._rotationTexture.getGFXTexture());
              const modeHandle = pass.getHandle('u_rotation_mode');
              pass.setUniform(modeHandle, this._rotationTexture.height);
            }
          }
          const sizeModule = (_this$_particleSystem12 = this._particleSystem) === null || _this$_particleSystem12 === void 0 ? void 0 : _this$_particleSystem12._sizeOvertimeModule;
          enable = sizeModule ? sizeModule.enable : false;
          this._defines[SIZE_OVER_TIME_MODULE_ENABLE] = enable;
          if (enable) {
            let packed;
            if (sizeModule.separateAxes) {
              packed = packCurveRangeXYZ(this._sizeTexture, this._sizeData, _sample_num, sizeModule.x, sizeModule.y, sizeModule.z, true);
            } else {
              packed = packCurveRangeN(this._sizeTexture, this._sizeData, _sample_num, sizeModule.size, true);
            }
            this._sizeTexture = packed.texture;
            this._sizeData = packed.texdata;
            if (this._sizeTexture) {
              const handle = pass.getHandle('size_over_time_tex0');
              const binding = Pass.getBindingFromHandle(handle);
              pass.bindSampler(binding, this._sizeTexture.getGFXSampler());
              pass.bindTexture(binding, this._sizeTexture.getGFXTexture());
              const modeHandle = pass.getHandle('u_size_mode');
              pass.setUniform(modeHandle, this._sizeTexture.height);
            }
          }
          const textureModule = (_this$_particleSystem13 = this._particleSystem) === null || _this$_particleSystem13 === void 0 ? void 0 : _this$_particleSystem13._textureAnimationModule;
          enable = textureModule ? textureModule.enable : false;
          this._defines[TEXTURE_ANIMATION_MODULE_ENABLE] = enable;
          if (enable) {
            const packed = packCurveRangeXY(this._animTexture, this._animData, _sample_num, textureModule.startFrame, textureModule.frameOverTime, true);
            this._animTexture = packed.texture;
            this._animData = packed.texdata;
            const handle = pass.getHandle('texture_animation_tex0');
            const binding = Pass.getBindingFromHandle(handle);
            pass.bindSampler(binding, this._animTexture.getGFXSampler());
            pass.bindTexture(binding, this._animTexture.getGFXTexture());
            const infoHandle = pass.getHandle('u_anim_info');
            _tempVec4.x = this._animTexture.height;
            _tempVec4.y = textureModule.numTilesX * textureModule.numTilesY;
            _tempVec4.z = textureModule.cycleCount;
            pass.setUniform(infoHandle, _tempVec4);
          }
          this._defines[USE_VK_SHADER] = deviceManager.gfxDevice.gfxAPI === API.VULKAN;
          this._defines[INSTANCE_PARTICLE] = this._useInstance;
        }
        getParticleCount() {
          return this._particleNum;
        }
        onMaterialModified(index, material) {
          if (!this._inited) {
            return;
          }
          this.updateMaterialParams();
        }
        onRebuildPSO(index, material) {
          if (this._model && index === 0) {
            this._model.setSubModelMaterial(0, material);
          }
        }
        updateVertexAttrib() {
          if (this._renderInfo.renderMode !== RenderMode.Mesh) {
            return;
          }
          if (this._renderInfo.mesh) {
            const format = this._renderInfo.mesh.readAttributeFormat(0, AttributeName.ATTR_COLOR);
            if (format) {
              let type = Format.RGBA8;
              for (let i = 0; i < FormatInfos.length; ++i) {
                if (FormatInfos[i].name === format.name) {
                  type = i;
                  break;
                }
              }
              this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            } else {
              const type = Format.RGBA8;
              this._vertAttrs[9] = new Attribute(AttributeName.ATTR_COLOR1, type, true, !this._useInstance ? 0 : 1);
            }
          }
        }
        _setVertexAttrib() {
          if (!this._useInstance) {
            switch (this._renderInfo.renderMode) {
              case RenderMode.StrecthedBillboard:
                this._vertAttrs = _gpu_vert_attr.slice();
                break;
              case RenderMode.Mesh:
                this._vertAttrs = _gpu_vert_attr_mesh.slice();
                break;
              default:
                this._vertAttrs = _gpu_vert_attr.slice();
            }
          } else {
            this._setVertexAttribIns();
          }
        }
        _setVertexAttribIns() {
          switch (this._renderInfo.renderMode) {
            case RenderMode.StrecthedBillboard:
              this._vertAttrs = _gpu_vert_attr_ins.slice();
              break;
            case RenderMode.Mesh:
              this._vertAttrs = _gpu_vert_attr_mesh_ins.slice();
              break;
            default:
              this._vertAttrs = _gpu_vert_attr_ins.slice();
          }
        }
        updateMaterialParams() {
          if (!this._particleSystem) {
            return;
          }
          const ps = this._particleSystem;
          const shareMaterial = ps.sharedMaterial;
          if (shareMaterial !== null) {
            this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);
          }
          if (ps.sharedMaterial == null && this._defaultMat == null) {
            _matInsInfo.parent = builtinResMgr.get('default-particle-gpu-material');
            _matInsInfo.owner = ps;
            _matInsInfo.subModelIdx = 0;
            this._defaultMat = new MaterialInstance(_matInsInfo);
            _matInsInfo.parent = null;
            _matInsInfo.owner = null;
            _matInsInfo.subModelIdx = 0;
            if (this._renderInfo.mainTexture !== null) {
              this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
            }
          }
          const mat = ps.getMaterialInstance(0) || this._defaultMat;
          ps.node.getWorldMatrix(_tempWorldTrans);
          if (ps.simulationSpace === Space.World) {
            this._defines[CC_USE_WORLD_SPACE] = true;
          } else {
            this._defines[CC_USE_WORLD_SPACE] = false;
          }
          const renderMode = this._renderInfo.renderMode;
          if (renderMode === RenderMode.Billboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_BILLBOARD;
          } else if (renderMode === RenderMode.StrecthedBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_STRETCHED_BILLBOARD;
            this._frameTile_velLenScale.z = this._renderInfo.velocityScale;
            this._frameTile_velLenScale.w = this._renderInfo.lengthScale;
          } else if (renderMode === RenderMode.HorizontalBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_HORIZONTAL_BILLBOARD;
          } else if (renderMode === RenderMode.VerticalBillboard) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_VERTICAL_BILLBOARD;
          } else if (renderMode === RenderMode.Mesh) {
            this._defines[CC_RENDER_MODE] = RENDER_MODE_MESH;
          } else {
            warn(`particle system renderMode ${renderMode} not support.`);
          }
          const textureModule = ps._textureAnimationModule;
          if (textureModule && textureModule.enable) {
            Vec2.set(this._frameTile_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
            Vec4.copy(this._unifrom_velLenScale, this._frameTile_velLenScale);
          } else {
            this._tmp_velLenScale.z = this._frameTile_velLenScale.z;
            this._tmp_velLenScale.w = this._frameTile_velLenScale.w;
            Vec4.copy(this._unifrom_velLenScale, this._tmp_velLenScale);
          }
          this.initShaderUniform(mat);
          mat.recompileShaders(this._defines);
          if (this._model) {
            this._model.updateMaterial(mat);
          }
        }
        setUseInstance(value) {
          if (this._useInstance === value) {
            return;
          }
          this._useInstance = value;
          if (this._model) {
            this._model.useInstance = value;
            this._model.doDestroy();
          }
          this.updateRenderMode();
        }
        getNoisePreview(out, width, height) {}
      }

      var _dec$J, _dec2$F, _dec3$u, _dec4$p, _dec5$n, _dec6$c, _dec7$b, _dec8$9, _dec9$9, _class$H, _class2$F, _initializer$E, _initializer2$B, _initializer3$r, _initializer4$l, _initializer5$h, _initializer6$e, _initializer7$d, _initializer8$c, _initializer9$c, _class3$k;
      function isSupportGPUParticle() {
        const device = director.root.device;
        if (device.capabilities.maxVertexTextureUnits >= 8 && device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) {
          return true;
        }
        legacyCC.warn('Maybe the device has restrictions on vertex textures or does not support float textures.');
        return false;
      }
      let ParticleSystemRenderer = (_dec$J = ccclass$6('cc.ParticleSystemRenderer'), _dec2$F = type$6(RenderMode), _dec3$u = type$6(RenderMode), _dec4$p = type$6(Mesh), _dec5$n = type$6(Material), _dec6$c = type$6(Material), _dec7$b = type$6(Material), _dec8$9 = type$6(Material), _dec9$9 = type$6(AlignmentSpace), _dec$J(_class$H = (_class2$F = (_class3$k = class ParticleSystemRenderer {
        constructor() {
          this._renderMode = _initializer$E && _initializer$E();
          this._velocityScale = _initializer2$B && _initializer2$B();
          this._lengthScale = _initializer3$r && _initializer3$r();
          this._mesh = _initializer4$l && _initializer4$l();
          this._cpuMaterial = _initializer5$h && _initializer5$h();
          this._gpuMaterial = _initializer6$e && _initializer6$e();
          this._mainTexture = _initializer7$d && _initializer7$d();
          this._useGPU = _initializer8$c && _initializer8$c();
          this._alignSpace = _initializer9$c && _initializer9$c();
          this._particleSystem = null;
        }
        get renderMode() {
          return this._renderMode;
        }
        set renderMode(val) {
          if (this._renderMode === val) {
            return;
          }
          this._renderMode = val;
          if (this._particleSystem) {
            this._particleSystem.processor.updateRenderMode();
          }
        }
        get velocityScale() {
          return this._velocityScale;
        }
        set velocityScale(val) {
          this._velocityScale = val;
          if (this._particleSystem) {
            this._particleSystem.processor.updateMaterialParams();
          }
        }
        get lengthScale() {
          return this._lengthScale;
        }
        set lengthScale(val) {
          this._lengthScale = val;
          if (this._particleSystem) {
            this._particleSystem.processor.updateMaterialParams();
          }
        }
        get mesh() {
          return this._mesh;
        }
        set mesh(val) {
          this._mesh = val;
          if (this._particleSystem) {
            this._particleSystem.processor.setVertexAttributes();
          }
        }
        get particleMaterial() {
          if (!this._particleSystem) {
            return null;
          }
          return this._particleSystem.getSharedMaterial(0);
        }
        set particleMaterial(val) {
          if (this._particleSystem) {
            this._particleSystem.setSharedMaterial(val, 0);
          }
        }
        get cpuMaterial() {
          return this._cpuMaterial;
        }
        set cpuMaterial(val) {
          if (val === null) {
            return;
          } else {
            const effectName = val.effectName;
            if (effectName.indexOf('particle') === -1 || effectName.indexOf('particle-gpu') !== -1) {
              warnID(6035);
              return;
            }
          }
          this._cpuMaterial = val;
          this.particleMaterial = this._cpuMaterial;
        }
        get gpuMaterial() {
          return this._gpuMaterial;
        }
        set gpuMaterial(val) {
          if (val === null) {
            return;
          } else {
            const effectName = val.effectName;
            if (effectName.indexOf('particle-gpu') === -1) {
              warnID(6035);
              return;
            }
          }
          this._gpuMaterial = val;
          this.particleMaterial = this._gpuMaterial;
        }
        get trailMaterial() {
          if (!this._particleSystem) {
            return null;
          }
          return this._particleSystem.getSharedMaterial(1);
        }
        set trailMaterial(val) {
          if (this._particleSystem) {
            this._particleSystem.setSharedMaterial(val, 1);
          }
        }
        get mainTexture() {
          return this._mainTexture;
        }
        set mainTexture(val) {
          this._mainTexture = val;
        }
        get useGPU() {
          return this._useGPU;
        }
        set useGPU(val) {
          if (this._useGPU === val) {
            return;
          }
          if (!isSupportGPUParticle()) {
            this._useGPU = false;
          } else {
            this._useGPU = val;
          }
          this._switchProcessor();
        }
        get alignSpace() {
          return this._alignSpace;
        }
        set alignSpace(val) {
          this._alignSpace = val;
          this._particleSystem.processor.updateAlignSpace(this._alignSpace);
        }
        create(ps) {
          if (this._particleSystem === null) {
            this._particleSystem = ps;
          } else if (this._particleSystem !== ps) {
            errorID(6033);
          }
        }
        onInit(ps) {
          this.create(ps);
          const useGPU = this._useGPU && isSupportGPUParticle();
          if (!this._particleSystem.processor) {
            this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);
            this._particleSystem.processor.updateAlignSpace(this.alignSpace);
            this._particleSystem.processor.onInit(ps);
          } else {
            errorID(6034);
          }
          if (!useGPU) {
            if (this.particleMaterial && this.particleMaterial.effectName.indexOf('particle-gpu') !== -1) {
              this.particleMaterial = null;
              warnID(6035);
            }
            this.cpuMaterial = this.particleMaterial;
          } else {
            this.gpuMaterial = this.particleMaterial;
          }
        }
        _switchProcessor() {
          if (!this._particleSystem) {
            return;
          }
          if (this._particleSystem.processor) {
            this._particleSystem.processor.detachFromScene();
            this._particleSystem.processor.clear();
            this._particleSystem.processor = null;
          }
          const useGPU = this._useGPU && isSupportGPUParticle();
          if (!useGPU && this.cpuMaterial) {
            this.particleMaterial = this.cpuMaterial;
          }
          if (useGPU && this.gpuMaterial) {
            this.particleMaterial = this.gpuMaterial;
          }
          this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);
          this._particleSystem.processor.updateAlignSpace(this.alignSpace);
          this._particleSystem.processor.onInit(this._particleSystem);
          this._particleSystem.processor.onEnable();
          this._particleSystem.bindModule();
        }
      }, _class3$k.AlignmentSpace = AlignmentSpace, _class3$k), (_applyDecoratedDescriptor(_class2$F.prototype, "renderMode", [_dec2$F], Object.getOwnPropertyDescriptor(_class2$F.prototype, "renderMode"), _class2$F.prototype), _initializer$E = applyDecoratedInitializer(_class2$F.prototype, "_renderMode", [_dec3$u, serializable$6], function () {
        return RenderMode.Billboard;
      }), _initializer2$B = applyDecoratedInitializer(_class2$F.prototype, "_velocityScale", [serializable$6], function () {
        return 1;
      }), _initializer3$r = applyDecoratedInitializer(_class2$F.prototype, "_lengthScale", [serializable$6], function () {
        return 1;
      }), _initializer4$l = applyDecoratedInitializer(_class2$F.prototype, "_mesh", [serializable$6], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$F.prototype, "mesh", [_dec4$p], Object.getOwnPropertyDescriptor(_class2$F.prototype, "mesh"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "particleMaterial", [_dec5$n], Object.getOwnPropertyDescriptor(_class2$F.prototype, "particleMaterial"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "cpuMaterial", [_dec6$c], Object.getOwnPropertyDescriptor(_class2$F.prototype, "cpuMaterial"), _class2$F.prototype), _initializer5$h = applyDecoratedInitializer(_class2$F.prototype, "_cpuMaterial", [serializable$6], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$F.prototype, "gpuMaterial", [_dec7$b], Object.getOwnPropertyDescriptor(_class2$F.prototype, "gpuMaterial"), _class2$F.prototype), _initializer6$e = applyDecoratedInitializer(_class2$F.prototype, "_gpuMaterial", [serializable$6], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$F.prototype, "trailMaterial", [_dec8$9], Object.getOwnPropertyDescriptor(_class2$F.prototype, "trailMaterial"), _class2$F.prototype), _initializer7$d = applyDecoratedInitializer(_class2$F.prototype, "_mainTexture", [serializable$6], function () {
        return null;
      }), _initializer8$c = applyDecoratedInitializer(_class2$F.prototype, "_useGPU", [serializable$6], function () {
        return false;
      }), _applyDecoratedDescriptor(_class2$F.prototype, "alignSpace", [_dec9$9], Object.getOwnPropertyDescriptor(_class2$F.prototype, "alignSpace"), _class2$F.prototype), _initializer9$c = applyDecoratedInitializer(_class2$F.prototype, "_alignSpace", [serializable$6], function () {
        return AlignmentSpace.View;
      })), _class2$F)) || _class$H);

      var _dec$I, _dec2$E, _dec3$t, _dec4$o, _dec5$m, _dec6$b, _dec7$a, _dec8$8, _dec9$8, _class2$E, _class3$j, _initializer$D, _initializer2$A, _initializer3$q, _initializer4$k, _initializer5$g, _initializer6$d, _initializer7$c, _initializer8$b, _initializer9$b, _initializer10$a, _initializer11$a, _initializer12$8, _initializer13$7;
      const PRE_TRIANGLE_INDEX = 1;
      const NEXT_TRIANGLE_INDEX = 1 << 2;
      const DIRECTION_THRESHOLD = Math.cos(toRadian(100));
      const _temp_trailEle = {
        position: new Vec3(),
        velocity: new Vec3()
      };
      const _temp_quat = new Quat();
      const _temp_vec3 = new Vec3();
      const _temp_vec3_1 = new Vec3();
      const _temp_color = new Color$1();
      class TrailSegment {
        constructor(maxTrailElementNum) {
          this.start = void 0;
          this.end = void 0;
          this.trailElements = void 0;
          this.start = -1;
          this.end = -1;
          this.trailElements = [];
          while (maxTrailElementNum--) {
            this.trailElements.push({
              position: new Vec3(),
              lifetime: 0,
              width: 0,
              velocity: new Vec3(),
              direction: 0,
              color: new Color$1()
            });
          }
        }
        getElement(idx) {
          if (this.start === -1) {
            return null;
          }
          if (idx < 0) {
            idx = (idx + this.trailElements.length) % this.trailElements.length;
          }
          if (idx >= this.trailElements.length) {
            idx %= this.trailElements.length;
          }
          return this.trailElements[idx];
        }
        addElement() {
          if (this.trailElements.length === 0) {
            return null;
          }
          if (this.start === -1) {
            this.start = 0;
            this.end = 1;
            return this.trailElements[0];
          }
          if (this.start === this.end) {
            this.trailElements.splice(this.end, 0, {
              position: new Vec3(),
              lifetime: 0,
              width: 0,
              velocity: new Vec3(),
              direction: 0,
              color: new Color$1()
            });
            this.start++;
            this.start %= this.trailElements.length;
          }
          const newEleLoc = this.end++;
          this.end %= this.trailElements.length;
          return this.trailElements[newEleLoc];
        }
        iterateElement(target, f, p, dt) {
          const end = this.start >= this.end ? this.end + this.trailElements.length : this.end;
          for (let i = this.start; i < end; i++) {
            if (f(target, this.trailElements[i % this.trailElements.length], p, dt)) {
              this.start++;
              this.start %= this.trailElements.length;
            }
          }
          if (this.start === end) {
            this.start = -1;
            this.end = -1;
          }
        }
        count() {
          if (this.start < this.end) {
            return this.end - this.start;
          } else {
            return this.trailElements.length + this.end - this.start;
          }
        }
        clear() {
          this.start = -1;
          this.end = -1;
        }
      }
      let TrailModule = (_dec$I = ccclass$6('cc.TrailModule'), _dec2$E = type$6(TrailMode), _dec3$t = type$6(CurveRange), _dec4$o = type$6(Space), _dec5$m = type$6(TextureMode), _dec6$b = type$6(CurveRange), _dec7$a = type$6(GradientRange), _dec8$8 = type$6(GradientRange), _dec9$8 = type$6(Space), _dec$I(_class2$E = (_class3$j = class TrailModule {
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (val === this._enable && this._trailModel) {
            return;
          }
          if (val && !this._enable) {
            this._enable = val;
            if (this._particleSystem.processor) this._particleSystem.processor.updateTrailMaterial();
          }
          if (val && !this._trailModel) {
            this._createModel();
            this.rebuild();
          }
          this._enable = val;
          if (this._trailModel) {
            this._trailModel.enabled = val;
          }
          if (val) this.onEnable();else this.onDisable();
        }
        get minParticleDistance() {
          return this._minParticleDistance;
        }
        set minParticleDistance(val) {
          this._minParticleDistance = val;
          this._minSquaredDistance = val * val;
        }
        get space() {
          return this._space;
        }
        set space(val) {
          this._space = val;
          const ps = this._particleSystem;
          if (ps && ps.processor) {
            ps.processor.updateTrailMaterial();
          }
        }
        getModel() {
          return this._trailModel;
        }
        get inited() {
          return this._inited;
        }
        constructor() {
          this._enable = _initializer$D && _initializer$D();
          this.mode = _initializer2$A && _initializer2$A();
          this.lifeTime = _initializer3$q && _initializer3$q();
          this._minParticleDistance = _initializer4$k && _initializer4$k();
          this.existWithParticles = _initializer5$g && _initializer5$g();
          this.textureMode = _initializer6$d && _initializer6$d();
          this.widthFromParticle = _initializer7$c && _initializer7$c();
          this.widthRatio = _initializer8$b && _initializer8$b();
          this.colorFromParticle = _initializer9$b && _initializer9$b();
          this.colorOverTrail = _initializer10$a && _initializer10$a();
          this.colorOvertime = _initializer11$a && _initializer11$a();
          this._space = _initializer12$8 && _initializer12$8();
          this._particleSystem = _initializer13$7 && _initializer13$7();
          this._minSquaredDistance = 0;
          this._vertSize = void 0;
          this._trailNum = 0;
          this._trailLifetime = 0;
          this.vbOffset = 0;
          this.ibOffset = 0;
          this._trailSegments = null;
          this._particleTrail = void 0;
          this._trailModel = null;
          this._subMeshData = null;
          this._vertAttrs = void 0;
          this._vbF32 = null;
          this._vbUint32 = null;
          this._iBuffer = null;
          this._needTransform = false;
          this._material = null;
          this._psTransform = new Mat4();
          this._iaVertCount = 0;
          this._iaIndexCount = 0;
          this._inited = void 0;
          this._vertAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
          this._vertSize = 0;
          for (const a of this._vertAttrs) {
            this._vertSize += FormatInfos[a.format].size;
          }
          this._particleTrail = new Map();
          this._inited = false;
        }
        onInit(ps) {
          this._particleSystem = ps;
          this.minParticleDistance = this._minParticleDistance;
          let burstCount = 0;
          const psTime = ps.startLifetime.getMax();
          const psRate = ps.rateOverTime.getMax();
          const duration = ps.duration;
          for (let i = 0, len = ps.bursts.length; i < len; i++) {
            const b = ps.bursts[i];
            burstCount += b.getMaxCount(ps) * Math.ceil(psTime / duration);
          }
          if (this.lifeTime.getMax() < 1.0) {
            warnID(6036);
          }
          this._trailNum = Math.ceil(psTime * Math.ceil(this.lifeTime.getMax()) * 60 * (psRate * duration + burstCount));
          this._trailSegments = new Pool(() => new TrailSegment(10), Math.ceil(psRate * duration), obj => obj.trailElements.length = 0);
          if (this._enable) {
            this.enable = this._enable;
          }
          this._inited = true;
        }
        onEnable() {
          this._attachToScene();
        }
        onDisable() {
          this._particleTrail.clear();
          this._detachFromScene();
        }
        _attachToScene() {
          if (this._trailModel) {
            if (this._trailModel.scene) {
              this._detachFromScene();
            }
            this._particleSystem._getRenderScene().addModel(this._trailModel);
          }
        }
        _detachFromScene() {
          if (this._trailModel && this._trailModel.scene) {
            this._trailModel.scene.removeModel(this._trailModel);
          }
        }
        destroy() {
          this.destroySubMeshData();
          if (this._trailModel) {
            director.root.destroyModel(this._trailModel);
            this._trailModel = null;
          }
          if (this._trailSegments) {
            this._trailSegments.destroy();
            this._trailSegments = null;
          }
        }
        play() {
          if (this._trailModel && this._enable) {
            this._trailModel.enabled = true;
          }
        }
        clear() {
          if (this.enable) {
            const trailIter = this._particleTrail.values();
            let trail = trailIter.next();
            while (!trail.done) {
              trail.value.clear();
              trail = trailIter.next();
            }
            this._particleTrail.clear();
            this.updateRenderData();
            if (this._trailModel) this._trailModel.enabled = false;
          }
        }
        updateMaterial() {
          if (this._particleSystem) {
            this._material = this._particleSystem.getMaterialInstance(1) || this._particleSystem.processor._defaultTrailMat;
            if (this._trailModel) {
              this._trailModel.setSubModelMaterial(0, this._material);
            }
          }
        }
        update() {
          this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1);
          if (this.space === Space.World && this._particleSystem._simulationSpace === Space.Local) {
            this._needTransform = true;
            this._particleSystem.node.getWorldMatrix(this._psTransform);
            this._particleSystem.node.getWorldRotation(_temp_quat);
          } else {
            this._needTransform = false;
          }
        }
        animate(p, scaledDt) {
          if (!this._trailSegments) {
            return;
          }
          if (p.loopCount > p.lastLoop) {
            if (p.trailDelay > 1) {
              p.lastLoop = p.loopCount;
              p.trailDelay = 0;
            } else {
              p.trailDelay++;
            }
            return;
          }
          let trail = this._particleTrail.get(p);
          if (!trail) {
            trail = this._trailSegments.alloc();
            this._particleTrail.set(p, trail);
            return;
          }
          let lastSeg = trail.getElement(trail.end - 1);
          if (this._needTransform) {
            Vec3.transformMat4(_temp_vec3, p.position, this._psTransform);
          } else {
            Vec3.copy(_temp_vec3, p.position);
          }
          if (lastSeg) {
            trail.iterateElement(this, this._updateTrailElement, p, scaledDt);
            if (Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance) {
              return;
            }
          }
          lastSeg = trail.addElement();
          if (!lastSeg) {
            return;
          }
          Vec3.copy(lastSeg.position, _temp_vec3);
          lastSeg.lifetime = 0;
          if (this.widthFromParticle) {
            lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1);
          } else {
            lastSeg.width = this.widthRatio.evaluate(0, 1);
          }
          const trailNum = trail.count();
          if (trailNum === 2) {
            const lastSecondTrail = trail.getElement(trail.end - 2);
            Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
          } else if (trailNum > 2) {
            const lastSecondTrail = trail.getElement(trail.end - 2);
            const lastThirdTrail = trail.getElement(trail.end - 3);
            Vec3.subtract(_temp_vec3, lastThirdTrail.position, lastSecondTrail.position);
            Vec3.subtract(_temp_vec3_1, lastSeg.position, lastSecondTrail.position);
            Vec3.subtract(lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);
            if (Vec3.equals(Vec3.ZERO, lastSecondTrail.velocity)) {
              Vec3.copy(lastSecondTrail.velocity, _temp_vec3);
            }
            Vec3.normalize(lastSecondTrail.velocity, lastSecondTrail.velocity);
            this._checkDirectionReverse(lastSecondTrail, lastThirdTrail);
          }
          if (this.colorFromParticle) {
            lastSeg.color.set(p.color);
          } else {
            lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
          }
        }
        removeParticle(p) {
          const trail = this._particleTrail.get(p);
          if (trail && this._trailSegments) {
            trail.clear();
            this._trailSegments.free(trail);
            this._particleTrail.delete(p);
          }
        }
        updateRenderData() {
          this.vbOffset = 0;
          this.ibOffset = 0;
          for (const p of this._particleTrail.keys()) {
            const trailSeg = this._particleTrail.get(p);
            if (trailSeg.start === -1) {
              continue;
            }
            const indexOffset = this.vbOffset * 4 / this._vertSize;
            const end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end;
            const trailNum = end - trailSeg.start;
            const textCoordSeg = 1 / trailNum;
            const startSegEle = trailSeg.trailElements[trailSeg.start];
            this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, NEXT_TRIANGLE_INDEX);
            for (let i = trailSeg.start + 1; i < end; i++) {
              const segEle = trailSeg.trailElements[i % trailSeg.trailElements.length];
              const j = i - trailSeg.start;
              this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
            }
            if (this._needTransform) {
              Vec3.transformMat4(_temp_trailEle.position, p.position, this._psTransform);
            } else {
              Vec3.copy(_temp_trailEle.position, p.position);
            }
            const trailModel = this._trailModel;
            if (trailModel) {
              trailModel.node.invalidateChildren(TransformBit.POSITION);
            }
            if (trailNum === 1 || trailNum === 2) {
              const lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
              Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position);
              this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x;
              this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y;
              this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z;
              this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x;
              this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y;
              this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z;
              Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
              this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
            } else if (trailNum > 2) {
              const lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
              const lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
              Vec3.subtract(_temp_vec3, lastThirdTrail.position, lastSecondTrail.position);
              Vec3.subtract(_temp_vec3_1, _temp_trailEle.position, lastSecondTrail.position);
              Vec3.normalize(_temp_vec3, _temp_vec3);
              Vec3.normalize(_temp_vec3_1, _temp_vec3_1);
              Vec3.subtract(lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);
              Vec3.normalize(lastSecondTrail.velocity, lastSecondTrail.velocity);
              this._checkDirectionReverse(lastSecondTrail, lastThirdTrail);
              this.vbOffset -= this._vertSize / 4 * 2;
              this.ibOffset -= 6;
              this._fillVertexBuffer(lastSecondTrail, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
              Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
              Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity);
              this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
            }
            if (this.widthFromParticle) {
              _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1);
            } else {
              _temp_trailEle.width = this.widthRatio.evaluate(0, 1);
            }
            _temp_trailEle.color = p.color;
            if (Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO)) {
              this.ibOffset -= 3;
            } else {
              this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, PRE_TRIANGLE_INDEX);
            }
          }
          if (this._trailModel) {
            this._trailModel.enabled = this.ibOffset > 0;
          }
        }
        updateIA(count) {
          const subModels = this._trailModel && this._trailModel.subModels;
          if (subModels && subModels.length > 0) {
            const subModel = subModels[0];
            subModel.inputAssembler.vertexBuffers[0].update(this._vbF32);
            subModel.inputAssembler.indexBuffer.update(this._iBuffer);
            subModel.inputAssembler.firstIndex = 0;
            subModel.inputAssembler.indexCount = count;
            subModel.inputAssembler.vertexCount = this._iaVertCount;
          }
        }
        beforeRender() {
          this.updateIA(this.ibOffset);
        }
        _createModel() {
          if (this._trailModel) {
            return;
          }
          this._trailModel = legacyCC.director.root.createModel(Model);
        }
        rebuild() {
          const device = director.root.device;
          const vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertSize * (this._trailNum + 1) * 2, this._vertSize));
          const vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
          this._vbF32 = new Float32Array(vBuffer);
          this._vbUint32 = new Uint32Array(vBuffer);
          vertexBuffer.update(vBuffer);
          const indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, Math.max(1, this._trailNum) * 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          this._iBuffer = new Uint16Array(Math.max(1, this._trailNum) * 6);
          indexBuffer.update(this._iBuffer);
          this._iaVertCount = (this._trailNum + 1) * 2;
          this._iaIndexCount = this._trailNum * 6;
          this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
          const trailModel = this._trailModel;
          if (trailModel && this._material) {
            trailModel.node = trailModel.transform = this._particleSystem.node;
            trailModel.visFlags = this._particleSystem.visibility;
            trailModel.initSubModel(0, this._subMeshData, this._material);
            trailModel.enabled = true;
          }
        }
        _updateTrailElement(module, trailEle, p, dt) {
          trailEle.lifetime += dt;
          if (module.colorFromParticle) {
            trailEle.color.set(p.color);
            trailEle.color.multiply(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
          } else {
            trailEle.color.set(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
          }
          if (module.widthFromParticle) {
            trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
          } else {
            trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
          }
          return trailEle.lifetime > module._trailLifetime;
        }
        _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
          this._vbF32[this.vbOffset++] = trailSeg.position.x;
          this._vbF32[this.vbOffset++] = trailSeg.position.y;
          this._vbF32[this.vbOffset++] = trailSeg.position.z;
          this._vbF32[this.vbOffset++] = trailSeg.direction;
          this._vbF32[this.vbOffset++] = trailSeg.width;
          this._vbF32[this.vbOffset++] = xTexCoord;
          this._vbF32[this.vbOffset++] = 0;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
          _temp_color.set(trailSeg.color);
          _temp_color.multiply(colorModifer);
          this._vbUint32[this.vbOffset++] = _temp_color._val;
          this._vbF32[this.vbOffset++] = trailSeg.position.x;
          this._vbF32[this.vbOffset++] = trailSeg.position.y;
          this._vbF32[this.vbOffset++] = trailSeg.position.z;
          this._vbF32[this.vbOffset++] = 1 - trailSeg.direction;
          this._vbF32[this.vbOffset++] = trailSeg.width;
          this._vbF32[this.vbOffset++] = xTexCoord;
          this._vbF32[this.vbOffset++] = 1;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
          this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
          this._vbUint32[this.vbOffset++] = _temp_color._val;
          if (indexSet & PRE_TRIANGLE_INDEX) {
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
          }
          if (indexSet & NEXT_TRIANGLE_INDEX) {
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2;
          }
        }
        _checkDirectionReverse(currElement, prevElement) {
          if (Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD) {
            currElement.direction = 1 - prevElement.direction;
          } else {
            currElement.direction = prevElement.direction;
          }
        }
        destroySubMeshData() {
          if (this._subMeshData) {
            this._subMeshData.destroy();
            this._subMeshData = null;
          }
        }
      }, (_initializer$D = applyDecoratedInitializer(_class3$j.prototype, "_enable", [serializable$6], function () {
        return false;
      }), _initializer2$A = applyDecoratedInitializer(_class3$j.prototype, "mode", [_dec2$E, serializable$6], function () {
        return TrailMode.Particles;
      }), _initializer3$q = applyDecoratedInitializer(_class3$j.prototype, "lifeTime", [_dec3$t, serializable$6], function () {
        return new CurveRange();
      }), _initializer4$k = applyDecoratedInitializer(_class3$j.prototype, "_minParticleDistance", [serializable$6], function () {
        return 0.1;
      }), _applyDecoratedDescriptor(_class3$j.prototype, "space", [_dec4$o], Object.getOwnPropertyDescriptor(_class3$j.prototype, "space"), _class3$j.prototype), _initializer5$g = applyDecoratedInitializer(_class3$j.prototype, "existWithParticles", [serializable$6], function () {
        return true;
      }), _initializer6$d = applyDecoratedInitializer(_class3$j.prototype, "textureMode", [_dec5$m, serializable$6], function () {
        return TextureMode.Stretch;
      }), _initializer7$c = applyDecoratedInitializer(_class3$j.prototype, "widthFromParticle", [serializable$6], function () {
        return true;
      }), _initializer8$b = applyDecoratedInitializer(_class3$j.prototype, "widthRatio", [_dec6$b, serializable$6], function () {
        return new CurveRange();
      }), _initializer9$b = applyDecoratedInitializer(_class3$j.prototype, "colorFromParticle", [serializable$6], function () {
        return false;
      }), _initializer10$a = applyDecoratedInitializer(_class3$j.prototype, "colorOverTrail", [_dec7$a, serializable$6], function () {
        return new GradientRange();
      }), _initializer11$a = applyDecoratedInitializer(_class3$j.prototype, "colorOvertime", [_dec8$8, serializable$6], function () {
        return new GradientRange();
      }), _initializer12$8 = applyDecoratedInitializer(_class3$j.prototype, "_space", [_dec9$8], function () {
        return Space.World;
      }), _initializer13$7 = applyDecoratedInitializer(_class3$j.prototype, "_particleSystem", [serializable$6], function () {
        return null;
      })), _class3$j)) || _class2$E);

      const _node_mat = new Mat4();
      const _node_parent_inv = new Mat4();
      const _node_rol = new Quat();
      const _node_scale = new Vec3();
      const _anim_module = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule'];
      class ParticleCuller {
        constructor(ps) {
          this._particleSystem = void 0;
          this._processor = void 0;
          this._node = void 0;
          this._particlesAll = void 0;
          this._updateList = new Map();
          this._animateList = new Map();
          this._runAnimateList = new Array();
          this._localMat = new Mat4();
          this._gravity = new Vec4();
          this.minPos = new Vec3();
          this.maxPos = new Vec3();
          this._nodePos = new Vec3();
          this._nodeSize = new Vec3();
          this._particleSystem = ps;
          this._processor = this._particleSystem.processor;
          this._node = ps.node;
          this._particlesAll = [];
          this._initModuleList();
        }
        _updateBoundingNode() {
          this._nodeSize.set(this.maxPos.x - this.minPos.x, this.maxPos.y - this.minPos.y, this.maxPos.z - this.minPos.z);
          this._nodePos.set(this.minPos.x + this._nodeSize.x * 0.5, this.minPos.y + this._nodeSize.y * 0.5, this.minPos.z + this._nodeSize.z * 0.5);
        }
        setBoundingBoxSize(halfExt) {
          this.maxPos.x = this._nodePos.x + halfExt.x;
          this.maxPos.y = this._nodePos.y + halfExt.y;
          this.maxPos.z = this._nodePos.z + halfExt.z;
          this.minPos.x = this._nodePos.x - halfExt.x;
          this.minPos.y = this._nodePos.y - halfExt.y;
          this.minPos.z = this._nodePos.z - halfExt.z;
          this._updateBoundingNode();
        }
        setBoundingBoxCenter(px, py, pz) {
          this.maxPos.x = px + this._nodeSize.x * 0.5;
          this.maxPos.y = py + this._nodeSize.y * 0.5;
          this.maxPos.z = pz + this._nodeSize.z * 0.5;
          this.minPos.x = px - this._nodeSize.x * 0.5;
          this.minPos.y = py - this._nodeSize.y * 0.5;
          this.minPos.z = pz - this._nodeSize.z * 0.5;
          this._updateBoundingNode();
        }
        _initModuleList() {
          _anim_module.forEach(val => {
            const pm = this._particleSystem[val];
            if (pm && pm.enable) {
              if (pm.needUpdate) {
                this._updateList[pm.name] = pm;
              }
              if (pm.needAnimate) {
                this._animateList[pm.name] = pm;
              }
            }
          });
          this._runAnimateList.length = 0;
          for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
            const p = this._animateList[PARTICLE_MODULE_ORDER[i]];
            if (p) {
              this._runAnimateList.push(p);
            }
          }
        }
        _emit(count, dt, particleLst) {
          const ps = this._particleSystem;
          const node = this._node;
          const loopDelta = ps.time % ps.duration / ps.duration;
          node.invalidateChildren(TransformBit.POSITION);
          if (ps.simulationSpace === Space.World) {
            node.getWorldMatrix(_node_mat);
            node.getWorldRotation(_node_rol);
          }
          for (let i = 0; i < count; ++i) {
            const particle = new Particle(ps);
            particle.particleSystem = ps;
            particle.reset();
            const rand = pseudoRandom(randomRangeInt(0, INT_MAX));
            if (ps._shapeModule && ps._shapeModule.enable) {
              ps._shapeModule.emit(particle);
            } else {
              Vec3.set(particle.position, 0, 0, 0);
              Vec3.copy(particle.velocity, particleEmitZAxis);
            }
            if (ps._textureAnimationModule && ps._textureAnimationModule.enable) {
              ps._textureAnimationModule.init(particle);
            }
            const curveStartSpeed = ps.startSpeed.evaluate(loopDelta, rand);
            Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);
            if (ps.simulationSpace === Space.World) {
              Vec3.transformMat4(particle.position, particle.position, _node_mat);
              Vec3.transformQuat(particle.velocity, particle.velocity, _node_rol);
            }
            Vec3.copy(particle.ultimateVelocity, particle.velocity);
            Vec3.set(particle.rotation, 0, 0, 0);
            if (ps.startSize3D) {
              Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), ps.startSizeY.evaluate(loopDelta, rand), ps.startSizeZ.evaluate(loopDelta, rand));
            } else {
              Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), 1, 1);
              particle.startSize.y = particle.startSize.x;
            }
            Vec3.copy(particle.size, particle.startSize);
            particle.startLifetime = ps.startLifetime.evaluate(loopDelta, rand) + dt;
            particle.remainingLifetime = particle.startLifetime;
            particleLst.push(particle);
          }
        }
        _updateParticles(dt, particleLst) {
          const ps = this._particleSystem;
          ps.node.getWorldMatrix(_node_mat);
          switch (ps.scaleSpace) {
            case Space.Local:
              ps.node.getScale(_node_scale);
              break;
            case Space.World:
              ps.node.getWorldScale(_node_scale);
              break;
          }
          this._updateList.forEach((value, key) => {
            value.update(ps.simulationSpace, _node_mat);
          });
          if (ps.simulationSpace === Space.Local) {
            const r = ps.node.getRotation();
            Mat4.fromQuat(this._localMat, r);
            this._localMat.transpose();
          }
          if (ps.node.parent) {
            ps.node.parent.getWorldMatrix(_node_parent_inv);
            _node_parent_inv.invert();
          }
          for (let i = 0; i < particleLst.length; ++i) {
            const p = particleLst[i];
            p.remainingLifetime -= dt;
            Vec3.set(p.animatedVelocity, 0, 0, 0);
            const useGravity = ps.gravityModifier.mode !== Mode$3.Constant || ps.gravityModifier.constant !== 0;
            if (useGravity) {
              const rand = isCurveTwoValues(ps.gravityModifier) ? pseudoRandom(p.randomSeed) : 0;
              if (ps.simulationSpace === Space.Local) {
                const gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
                this._gravity.x = 0.0;
                this._gravity.y = gravityFactor;
                this._gravity.z = 0.0;
                this._gravity.w = 1.0;
                if (!approx(gravityFactor, 0.0, EPSILON$2)) {
                  if (ps.node.parent) {
                    this._gravity = this._gravity.transformMat4(_node_parent_inv);
                  }
                  this._gravity = this._gravity.transformMat4(this._localMat);
                  p.velocity.x += this._gravity.x;
                  p.velocity.y += this._gravity.y;
                  p.velocity.z += this._gravity.z;
                }
              } else {
                p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, rand) * 9.8 * dt;
              }
            }
            Vec3.copy(p.ultimateVelocity, p.velocity);
            this._runAnimateList.forEach(value => {
              value.animate(p, dt);
            });
            Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
          }
        }
        _calculateBounding(isInit) {
          const size = new Vec3();
          const position = new Vec3();
          const subPos = new Vec3();
          const addPos = new Vec3();
          const meshSize = new Vec3(1.0, 1.0, 1.0);
          if (this._processor.getInfo().renderMode === RenderMode.Mesh) {
            const mesh = this._processor.getInfo().mesh;
            if (mesh && mesh.struct.minPosition && mesh.struct.maxPosition) {
              const meshAABB = new AABB();
              AABB.fromPoints(meshAABB, mesh.struct.minPosition, mesh.struct.maxPosition);
              const meshMax = Math.max(meshAABB.halfExtents.x, meshAABB.halfExtents.y, meshAABB.halfExtents.z);
              meshSize.set(meshMax, meshMax, meshMax);
            }
          }
          const worldMat = this._particleSystem.node.worldMatrix;
          for (let i = 0; i < this._particlesAll.length; ++i) {
            const p = this._particlesAll[i];
            Vec3.multiply(size, _node_scale, p.size);
            Vec3.multiply(size, size, meshSize);
            position.set(p.position);
            if (this._particleSystem.simulationSpace !== Space.World) {
              Vec3.transformMat4(position, position, worldMat);
            }
            if (isInit && i === 0) {
              Vec3.subtract(this.minPos, position, size);
              Vec3.add(this.maxPos, position, size);
            } else {
              Vec3.subtract(subPos, position, size);
              Vec3.add(addPos, position, size);
              Vec3.min(this.minPos, this.minPos, subPos);
              Vec3.max(this.maxPos, this.maxPos, addPos);
            }
          }
        }
        calculatePositions() {
          this._emit(this._particleSystem.capacity, 0, this._particlesAll);
          const rand = isCurveTwoValues(this._particleSystem.startLifetime) ? pseudoRandom(randomRangeInt(0, INT_MAX)) : 0;
          this._updateParticles(0, this._particlesAll);
          this._calculateBounding(true);
          this._updateParticles(this._particleSystem.startLifetime.evaluate(0, rand), this._particlesAll);
          this._calculateBounding(false);
          this._updateBoundingNode();
        }
        clear() {
          this._particlesAll.length = 0;
        }
        destroy() {}
      }

      var _dec$H, _dec2$D, _dec3$s, _dec4$n, _dec5$l, _dec6$a, _dec7$9, _dec8$7, _dec9$7, _dec10$5, _dec11$4, _dec12$4, _dec13$4, _dec14$3, _class$G, _class2$D, _initializer$C, _initializer2$z, _initializer3$p, _initializer4$j, _initializer5$f, _initializer6$c, _initializer7$b, _initializer8$a, _initializer9$a, _initializer10$9, _initializer11$9, _initializer12$7, _initializer13$6, _initializer14$5;
      const {
        ccclass,
        serializable,
        displayOrder,
        type,
        range,
        slide,
        visible
      } = _decorator;
      let NoiseModule = (_dec$H = ccclass('cc.NoiseModule'), _dec2$D = type(CCFloat), _dec3$s = type(CCFloat), _dec4$n = type(CCFloat), _dec5$l = type(CCFloat), _dec6$a = type(CCFloat), _dec7$9 = type(CCFloat), _dec8$7 = type(CCFloat), _dec9$7 = type(CCFloat), _dec10$5 = type(CCFloat), _dec11$4 = type(CCFloat), _dec12$4 = type(CCInteger), _dec13$4 = type(CCFloat), _dec14$3 = type(CCFloat), _dec$H(_class$G = (_class2$D = class NoiseModule extends ParticleModuleBase {
        constructor(...args) {
          super(...args);
          this._enable = _initializer$C && _initializer$C();
          this._strengthX = _initializer2$z && _initializer2$z();
          this._strengthY = _initializer3$p && _initializer3$p();
          this._strengthZ = _initializer4$j && _initializer4$j();
          this._noiseSpeedX = _initializer5$f && _initializer5$f();
          this._noiseSpeedY = _initializer6$c && _initializer6$c();
          this._noiseSpeedZ = _initializer7$b && _initializer7$b();
          this._noiseFrequency = _initializer8$a && _initializer8$a();
          this._remapX = _initializer9$a && _initializer9$a();
          this._remapY = _initializer10$9 && _initializer10$9();
          this._remapZ = _initializer11$9 && _initializer11$9();
          this._octaves = _initializer12$7 && _initializer12$7();
          this._octaveMultiplier = _initializer13$6 && _initializer13$6();
          this._octaveScale = _initializer14$5 && _initializer14$5();
          this.name = PARTICLE_MODULE_NAME.NOISE;
          this.noise = new ParticleNoise();
          this.samplePosition = new Vec3();
        }
        get enable() {
          return this._enable;
        }
        set enable(val) {
          if (this._enable === val) return;
          this._enable = val;
          if (!this.target) return;
          this.target.enableModule(this.name, val, this);
        }
        get strengthX() {
          return this._strengthX;
        }
        set strengthX(value) {
          this._strengthX = value;
        }
        get strengthY() {
          return this._strengthY;
        }
        set strengthY(value) {
          this._strengthY = value;
        }
        get strengthZ() {
          return this._strengthZ;
        }
        set strengthZ(value) {
          this._strengthZ = value;
        }
        get noiseSpeedX() {
          return this._noiseSpeedX;
        }
        set noiseSpeedX(value) {
          this._noiseSpeedX = value;
        }
        get noiseSpeedY() {
          return this._noiseSpeedY;
        }
        set noiseSpeedY(value) {
          this._noiseSpeedY = value;
        }
        get noiseSpeedZ() {
          return this._noiseSpeedZ;
        }
        set noiseSpeedZ(value) {
          this._noiseSpeedZ = value;
        }
        get noiseFrequency() {
          return this._noiseFrequency;
        }
        set noiseFrequency(value) {
          this._noiseFrequency = value;
        }
        get remapX() {
          return this._remapX;
        }
        set remapX(value) {
          this._remapX = value;
        }
        get remapY() {
          return this._remapY;
        }
        set remapY(value) {
          this._remapY = value;
        }
        get remapZ() {
          return this._remapZ;
        }
        set remapZ(value) {
          this._remapZ = value;
        }
        get octaves() {
          return this._octaves;
        }
        set octaves(value) {
          this._octaves = value;
        }
        get octaveMultiplier() {
          return this._octaveMultiplier;
        }
        set octaveMultiplier(value) {
          this._octaveMultiplier = value;
        }
        get octaveScale() {
          return this._octaveScale;
        }
        set octaveScale(value) {
          this._octaveScale = value;
        }
        animate(particle, dt) {
          this.noise.setTime(particle.particleSystem.time);
          this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
          this.noise.setFrequency(this.noiseFrequency);
          this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
          this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
          this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
          this.samplePosition.set(particle.position);
          this.samplePosition.add3f(random() * 1.0, random() * 1.0, random() * 1.0);
          this.noise.setSamplePoint(this.samplePosition);
          this.noise.getNoiseParticle();
          const noisePosition = this.noise.getResult();
          noisePosition.multiply3f(random(), random(), random());
          Vec3.add(particle.position, particle.position, noisePosition.multiplyScalar(dt));
        }
        getNoisePreview(out, ps, width, height) {
          this.noise.setTime(ps.time);
          this.noise.setSpeed(this.noiseSpeedX, this.noiseSpeedY, this.noiseSpeedZ);
          this.noise.setFrequency(this.noiseFrequency);
          this.noise.setAbs(this.remapX, this.remapY, this.remapZ);
          this.noise.setAmplititude(this.strengthX, this.strengthY, this.strengthZ);
          this.noise.setOctaves(this.octaves, this.octaveMultiplier, this.octaveScale);
          this.noise.getNoiseParticle();
          this.noise.getPreview(out, width, height);
        }
      }, (_initializer$C = applyDecoratedInitializer(_class2$D.prototype, "_enable", [serializable], function () {
        return false;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "strengthX", [_dec2$D], Object.getOwnPropertyDescriptor(_class2$D.prototype, "strengthX"), _class2$D.prototype), _initializer2$z = applyDecoratedInitializer(_class2$D.prototype, "_strengthX", [serializable], function () {
        return 10;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "strengthY", [_dec3$s], Object.getOwnPropertyDescriptor(_class2$D.prototype, "strengthY"), _class2$D.prototype), _initializer3$p = applyDecoratedInitializer(_class2$D.prototype, "_strengthY", [serializable], function () {
        return 10;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "strengthZ", [_dec4$n], Object.getOwnPropertyDescriptor(_class2$D.prototype, "strengthZ"), _class2$D.prototype), _initializer4$j = applyDecoratedInitializer(_class2$D.prototype, "_strengthZ", [serializable], function () {
        return 10;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "noiseSpeedX", [_dec5$l], Object.getOwnPropertyDescriptor(_class2$D.prototype, "noiseSpeedX"), _class2$D.prototype), _initializer5$f = applyDecoratedInitializer(_class2$D.prototype, "_noiseSpeedX", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "noiseSpeedY", [_dec6$a], Object.getOwnPropertyDescriptor(_class2$D.prototype, "noiseSpeedY"), _class2$D.prototype), _initializer6$c = applyDecoratedInitializer(_class2$D.prototype, "_noiseSpeedY", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "noiseSpeedZ", [_dec7$9], Object.getOwnPropertyDescriptor(_class2$D.prototype, "noiseSpeedZ"), _class2$D.prototype), _initializer7$b = applyDecoratedInitializer(_class2$D.prototype, "_noiseSpeedZ", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "noiseFrequency", [_dec8$7], Object.getOwnPropertyDescriptor(_class2$D.prototype, "noiseFrequency"), _class2$D.prototype), _initializer8$a = applyDecoratedInitializer(_class2$D.prototype, "_noiseFrequency", [serializable], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "remapX", [_dec9$7], Object.getOwnPropertyDescriptor(_class2$D.prototype, "remapX"), _class2$D.prototype), _initializer9$a = applyDecoratedInitializer(_class2$D.prototype, "_remapX", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "remapY", [_dec10$5], Object.getOwnPropertyDescriptor(_class2$D.prototype, "remapY"), _class2$D.prototype), _initializer10$9 = applyDecoratedInitializer(_class2$D.prototype, "_remapY", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "remapZ", [_dec11$4], Object.getOwnPropertyDescriptor(_class2$D.prototype, "remapZ"), _class2$D.prototype), _initializer11$9 = applyDecoratedInitializer(_class2$D.prototype, "_remapZ", [serializable], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "octaves", [_dec12$4], Object.getOwnPropertyDescriptor(_class2$D.prototype, "octaves"), _class2$D.prototype), _initializer12$7 = applyDecoratedInitializer(_class2$D.prototype, "_octaves", [serializable], function () {
        return 1;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "octaveMultiplier", [_dec13$4], Object.getOwnPropertyDescriptor(_class2$D.prototype, "octaveMultiplier"), _class2$D.prototype), _initializer13$6 = applyDecoratedInitializer(_class2$D.prototype, "_octaveMultiplier", [serializable], function () {
        return 0.5;
      }), _applyDecoratedDescriptor(_class2$D.prototype, "octaveScale", [_dec14$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "octaveScale"), _class2$D.prototype), _initializer14$5 = applyDecoratedInitializer(_class2$D.prototype, "_octaveScale", [serializable], function () {
        return 2;
      })), _class2$D)) || _class$G);

      var _dec$G, _dec2$C, _dec3$r, _dec4$m, _dec5$k, _dec6$9, _dec7$8, _dec8$6, _dec9$6, _dec10$4, _dec11$3, _dec12$3, _dec13$3, _dec14$2, _dec15$2, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$1, _dec31$1, _dec32$1, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _dec44$1, _dec45$1, _dec46$1, _dec47$1, _class$F, _class2$C, _initializer$B, _initializer2$y, _initializer3$o, _initializer4$i, _initializer5$e, _initializer6$b, _initializer7$a, _initializer8$9, _initializer9$9, _initializer10$8, _initializer11$8, _initializer12$6, _initializer13$5, _initializer14$4, _initializer15$3, _initializer16$3, _initializer17$2, _initializer18$2, _initializer19$1, _initializer20$1, _initializer21$1, _initializer22$1, _initializer23$1, _initializer24$1, _initializer25$1, _initializer26$1, _initializer27$1, _initializer28$1, _initializer29$1, _initializer30$1, _initializer31$1, _initializer32$1, _initializer33$1, _initializer34$1, _initializer35$1, _initializer36$1, _initializer37$1, _initializer38$1, _initializer39$1, _initializer40$1, _initializer41$1, _class3$i;
      const _world_mat = new Mat4();
      const _world_rol = new Quat();
      const superMaterials = Object.getOwnPropertyDescriptor(Renderer.prototype, 'sharedMaterials');
      let ParticleSystem = (_dec$G = ccclass$6('cc.ParticleSystem'), _dec2$C = executionOrder$1(99), _dec3$r = type$6(GradientRange), _dec4$m = type$6(Space), _dec5$k = formerlySerializedAs$3('startSize'), _dec6$9 = type$6(CurveRange), _dec7$8 = type$6(CurveRange), _dec8$6 = type$6(CurveRange), _dec9$6 = type$6(CurveRange), _dec10$4 = type$6(CurveRange), _dec11$3 = type$6(CurveRange), _dec12$3 = type$6(CurveRange), _dec13$3 = formerlySerializedAs$3('startRotation'), _dec14$2 = type$6(CurveRange), _dec15$2 = type$6(CurveRange), _dec16$2 = type$6(Space), _dec17$2 = type$6(CurveRange), _dec18$2 = type$6(CurveRange), _dec19$2 = type$6(CurveRange), _dec20$2 = type$6([Burst]), _dec21$2 = type$6(CCBoolean), _dec22$2 = type$6(CullingMode), _dec23$2 = type$6(CCFloat), _dec24$2 = type$6(CCFloat), _dec25$2 = type$6(CCFloat), _dec26$2 = formerlySerializedAs$3('enableCulling'), _dec27$2 = type$6(ColorOvertimeModule), _dec28$2 = type$6(ColorOvertimeModule), _dec29$2 = type$6(ShapeModule), _dec30$1 = type$6(ShapeModule), _dec31$1 = type$6(SizeOvertimeModule), _dec32$1 = type$6(SizeOvertimeModule), _dec33$1 = type$6(VelocityOvertimeModule), _dec34$1 = type$6(VelocityOvertimeModule), _dec35$1 = type$6(ForceOvertimeModule), _dec36$1 = type$6(ForceOvertimeModule), _dec37$1 = type$6(LimitVelocityOvertimeModule), _dec38$1 = type$6(LimitVelocityOvertimeModule), _dec39$1 = type$6(RotationOvertimeModule), _dec40$1 = type$6(RotationOvertimeModule), _dec41$1 = type$6(TextureAnimationModule), _dec42$1 = type$6(TextureAnimationModule), _dec43$1 = type$6(NoiseModule), _dec44$1 = type$6(NoiseModule), _dec45$1 = type$6(TrailModule), _dec46$1 = type$6(TrailModule), _dec47$1 = type$6(ParticleSystemRenderer), _dec$G(_class$F = _dec2$C(_class$F = (_class2$C = (_class3$i = class ParticleSystem extends ModelRenderer {
        get capacity() {
          return this._capacity;
        }
        set capacity(val) {
          this._capacity = Math.floor(val > 0 ? val : 0);
          if (this.processor && this.processor.model) {
            this.processor.model.setCapacity(this._capacity);
          }
        }
        get prewarm() {
          return this._prewarm;
        }
        set prewarm(val) {
          if (val === true && this.loop === false) ;
          this._prewarm = val;
        }
        get simulationSpace() {
          return this._simulationSpace;
        }
        set simulationSpace(val) {
          if (val !== this._simulationSpace) {
            this._simulationSpace = val;
            if (this.processor) {
              this.processor.updateMaterialParams();
              this.processor.updateTrailMaterial();
            }
          }
        }
        set renderCulling(value) {
          this._renderCulling = value;
          if (value) {
            if (!this._boundingBox) {
              this._boundingBox = new AABB();
              this._calculateBounding(false);
            }
          }
        }
        get renderCulling() {
          return this._renderCulling;
        }
        get cullingMode() {
          return this._cullingMode;
        }
        set cullingMode(value) {
          this._cullingMode = value;
        }
        get aabbHalfX() {
          const res = this.getBoundingX();
          if (res) {
            return res;
          } else {
            return 0;
          }
        }
        set aabbHalfX(value) {
          this.setBoundingX(value);
        }
        get aabbHalfY() {
          const res = this.getBoundingY();
          if (res) {
            return res;
          } else {
            return 0;
          }
        }
        set aabbHalfY(value) {
          this.setBoundingY(value);
        }
        get aabbHalfZ() {
          const res = this.getBoundingZ();
          if (res) {
            return res;
          } else {
            return 0;
          }
        }
        set aabbHalfZ(value) {
          this.setBoundingZ(value);
        }
        get dataCulling() {
          return this._dataCulling;
        }
        set dataCulling(value) {
          this._dataCulling = value;
        }
        get sharedMaterials() {
          return superMaterials.get.call(this);
        }
        set sharedMaterials(val) {
          superMaterials.set.call(this, val);
        }
        get colorOverLifetimeModule() {
          return this._colorOverLifetimeModule;
        }
        set colorOverLifetimeModule(val) {
          if (!val) return;
          this._colorOverLifetimeModule = val;
        }
        get shapeModule() {
          return this._shapeModule;
        }
        set shapeModule(val) {
          if (!val) return;
          this._shapeModule = val;
        }
        get sizeOvertimeModule() {
          return this._sizeOvertimeModule;
        }
        set sizeOvertimeModule(val) {
          if (!val) return;
          this._sizeOvertimeModule = val;
        }
        get velocityOvertimeModule() {
          return this._velocityOvertimeModule;
        }
        set velocityOvertimeModule(val) {
          if (!val) return;
          this._velocityOvertimeModule = val;
        }
        get forceOvertimeModule() {
          return this._forceOvertimeModule;
        }
        set forceOvertimeModule(val) {
          if (!val) return;
          this._forceOvertimeModule = val;
        }
        get limitVelocityOvertimeModule() {
          return this._limitVelocityOvertimeModule;
        }
        set limitVelocityOvertimeModule(val) {
          if (!val) return;
          this._limitVelocityOvertimeModule = val;
        }
        get rotationOvertimeModule() {
          return this._rotationOvertimeModule;
        }
        set rotationOvertimeModule(val) {
          if (!val) return;
          this._rotationOvertimeModule = val;
        }
        get textureAnimationModule() {
          return this._textureAnimationModule;
        }
        set textureAnimationModule(val) {
          if (!val) return;
          this._textureAnimationModule = val;
        }
        get noiseModule() {
          return this._noiseModule;
        }
        set noiseModule(val) {
          if (!val) return;
          this._noiseModule = val;
        }
        get trailModule() {
          return this._trailModule;
        }
        set trailModule(val) {
          if (!val) return;
          this._trailModule = val;
        }
        constructor() {
          super();
          this.startColor = _initializer$B && _initializer$B();
          this.scaleSpace = _initializer2$y && _initializer2$y();
          this.startSize3D = _initializer3$o && _initializer3$o();
          this.startSizeX = _initializer4$i && _initializer4$i();
          this.startSizeY = _initializer5$e && _initializer5$e();
          this.startSizeZ = _initializer6$b && _initializer6$b();
          this.startSpeed = _initializer7$a && _initializer7$a();
          this.startRotation3D = _initializer8$9 && _initializer8$9();
          this.startRotationX = _initializer9$9 && _initializer9$9();
          this.startRotationY = _initializer10$8 && _initializer10$8();
          this.startRotationZ = _initializer11$8 && _initializer11$8();
          this.startDelay = _initializer12$6 && _initializer12$6();
          this.startLifetime = _initializer13$5 && _initializer13$5();
          this.duration = _initializer14$4 && _initializer14$4();
          this.loop = _initializer15$3 && _initializer15$3();
          this.simulationSpeed = _initializer16$3 && _initializer16$3();
          this.playOnAwake = _initializer17$2 && _initializer17$2();
          this.gravityModifier = _initializer18$2 && _initializer18$2();
          this.rateOverTime = _initializer19$1 && _initializer19$1();
          this.rateOverDistance = _initializer20$1 && _initializer20$1();
          this.bursts = _initializer21$1 && _initializer21$1();
          this._renderCulling = _initializer22$1 && _initializer22$1();
          this._cullingMode = _initializer23$1 && _initializer23$1();
          this._aabbHalfX = _initializer24$1 && _initializer24$1();
          this._aabbHalfY = _initializer25$1 && _initializer25$1();
          this._aabbHalfZ = _initializer26$1 && _initializer26$1();
          this._dataCulling = _initializer27$1 && _initializer27$1();
          this._colorOverLifetimeModule = _initializer28$1 && _initializer28$1();
          this._shapeModule = _initializer29$1 && _initializer29$1();
          this._sizeOvertimeModule = _initializer30$1 && _initializer30$1();
          this._velocityOvertimeModule = _initializer31$1 && _initializer31$1();
          this._forceOvertimeModule = _initializer32$1 && _initializer32$1();
          this._limitVelocityOvertimeModule = _initializer33$1 && _initializer33$1();
          this._rotationOvertimeModule = _initializer34$1 && _initializer34$1();
          this._textureAnimationModule = _initializer35$1 && _initializer35$1();
          this._noiseModule = _initializer36$1 && _initializer36$1();
          this._trailModule = _initializer37$1 && _initializer37$1();
          this.renderer = _initializer38$1 && _initializer38$1();
          this._isPlaying = void 0;
          this._isPaused = void 0;
          this._isStopped = void 0;
          this._isEmitting = void 0;
          this._needToRestart = void 0;
          this._needRefresh = void 0;
          this._time = void 0;
          this._emitRateTimeCounter = void 0;
          this._emitRateDistanceCounter = void 0;
          this._oldWPos = void 0;
          this._curWPos = void 0;
          this._boundingBox = void 0;
          this._culler = void 0;
          this._oldPos = void 0;
          this._curPos = void 0;
          this._isCulled = void 0;
          this._isSimulating = void 0;
          this._customData1 = void 0;
          this._customData2 = void 0;
          this._subEmitters = void 0;
          this._needAttach = void 0;
          this._prewarm = _initializer39$1 && _initializer39$1();
          this._capacity = _initializer40$1 && _initializer40$1();
          this._simulationSpace = _initializer41$1 && _initializer41$1();
          this.processor = null;
          this.rateOverTime.constant = 10;
          this.startLifetime.constant = 5;
          this.startSizeX.constant = 1;
          this.startSpeed.constant = 5;
          this._isPlaying = false;
          this._isPaused = false;
          this._isStopped = true;
          this._isEmitting = false;
          this._needToRestart = false;
          this._needRefresh = true;
          this._needAttach = false;
          this._time = 0.0;
          this._emitRateTimeCounter = 0.0;
          this._emitRateDistanceCounter = 0.0;
          this._oldWPos = new Vec3();
          this._curWPos = new Vec3();
          this._boundingBox = null;
          this._culler = null;
          this._oldPos = null;
          this._curPos = null;
          this._isCulled = false;
          this._isSimulating = true;
          this._customData1 = new Vec2();
          this._customData2 = new Vec2();
          this._subEmitters = [];
        }
        onFocusInEditor() {
          this.renderer.create(this);
        }
        onLoad() {
          this.renderer.onInit(this);
          if (this._shapeModule) this._shapeModule.onInit(this);
          if (this._trailModule && !this.renderer.useGPU && this._trailModule.enable) {
            this._trailModule.onInit(this);
          }
          this.bindModule();
          this._resetPosition();
        }
        _onMaterialModified(index, material) {
          if (this.processor !== null) {
            this.processor.onMaterialModified(index, material);
          }
        }
        _onRebuildPSO(index, material) {
          this.processor.onRebuildPSO(index, material);
        }
        _collectModels() {
          this._models.length = 0;
          this._models.push(this.processor._model);
          if (this._trailModule && this._trailModule.enable && this._trailModule._trailModel) {
            this._models.push(this._trailModule._trailModel);
          }
          return this._models;
        }
        _attachToScene() {
          this.processor.attachToScene();
          if (this._trailModule && this._trailModule.enable) {
            this._trailModule._attachToScene();
          }
        }
        _detachFromScene() {
          this.processor.detachFromScene();
          if (this._trailModule && this._trailModule.enable) {
            this._trailModule._detachFromScene();
          }
          if (this._boundingBox) {
            this._boundingBox = null;
          }
          if (this._culler) {
            this._culler.clear();
            this._culler.destroy();
            this._culler = null;
          }
        }
        bindModule() {
          if (this._colorOverLifetimeModule) this._colorOverLifetimeModule.bindTarget(this.processor);
          if (this._sizeOvertimeModule) this._sizeOvertimeModule.bindTarget(this.processor);
          if (this._rotationOvertimeModule) this._rotationOvertimeModule.bindTarget(this.processor);
          if (this._forceOvertimeModule) this._forceOvertimeModule.bindTarget(this.processor);
          if (this._limitVelocityOvertimeModule) this._limitVelocityOvertimeModule.bindTarget(this.processor);
          if (this._velocityOvertimeModule) this._velocityOvertimeModule.bindTarget(this.processor);
          if (this._textureAnimationModule) this._textureAnimationModule.bindTarget(this.processor);
          if (this._noiseModule) this._noiseModule.bindTarget(this.processor);
        }
        play() {
          if (this._needToRestart) {
            this.reset();
            this._needToRestart = false;
          }
          if (this._isPaused) {
            this._isPaused = false;
          }
          if (this._isStopped) {
            this._isStopped = false;
          }
          this._isPlaying = true;
          this._isEmitting = true;
          this._resetPosition();
          if (this._prewarm) {
            this._prewarmSystem();
          }
          if (this._trailModule) {
            this._trailModule.play();
          }
          if (this.processor) {
            const model = this.processor.getModel();
            if (model) {
              model.enabled = this.enabledInHierarchy;
            }
          }
        }
        pause() {
          if (this._isStopped) {
            warn('pause(): particle system is already stopped.');
            return;
          }
          if (this._isPlaying) {
            this._isPlaying = false;
          }
          this._isPaused = true;
        }
        stopEmitting() {
          this._isEmitting = false;
          this._needToRestart = true;
        }
        stop() {
          if (this._isPlaying || this._isPaused) {
            this.clear();
          }
          if (this._isPlaying) {
            this._isPlaying = false;
          }
          if (this._isPaused) {
            this._isPaused = false;
          }
          if (this._isEmitting) {
            this._isEmitting = false;
          }
          this._isStopped = true;
          this._needRefresh = true;
          this.reset();
        }
        reset() {
          this._time = 0.0;
          this._emitRateTimeCounter = 0.0;
          this._emitRateDistanceCounter = 0.0;
          this._resetPosition();
          for (const burst of this.bursts) {
            burst.reset();
          }
        }
        clear() {
          if (this.enabledInHierarchy) {
            this.processor.clear();
            if (this._trailModule) this._trailModule.clear();
          }
          this._calculateBounding(false);
        }
        getParticleCount() {
          if (this.processor) {
            return this.processor.getParticleCount();
          } else {
            return 0;
          }
        }
        setCustomData1(x, y) {
          Vec2.set(this._customData1, x, y);
        }
        setCustomData2(x, y) {
          Vec2.set(this._customData2, x, y);
        }
        onDestroy() {
          var _this$processor$getMo;
          this.stop();
          if ((_this$processor$getMo = this.processor.getModel()) !== null && _this$processor$getMo !== void 0 && _this$processor$getMo.scene) {
            this.processor.detachFromScene();
            if (this._trailModule && this._trailModule.enable) {
              this._trailModule._detachFromScene();
            }
          }
          legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
          this.processor.onDestroy();
          if (this._trailModule) this._trailModule.destroy();
          if (this._culler) {
            this._culler.clear();
            this._culler.destroy();
            this._culler = null;
          }
        }
        onEnable() {
          super.onEnable();
          legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
          if (this.playOnAwake && !EDITOR_NOT_IN_PREVIEW) {
            this.play();
          }
          this.processor.onEnable();
          if (this._trailModule) this._trailModule.onEnable();
        }
        onDisable() {
          legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
          this.processor.onDisable();
          if (this._trailModule) this._trailModule.onDisable();
          if (this._boundingBox) {
            this._boundingBox = null;
          }
          if (this._culler) {
            this._culler.clear();
            this._culler.destroy();
            this._culler = null;
          }
        }
        _calculateBounding(forceRefresh) {
          if (this._boundingBox) {
            if (!this._culler) {
              this._culler = new ParticleCuller(this);
            }
            this._culler.calculatePositions();
            AABB.fromPoints(this._boundingBox, this._culler.minPos, this._culler.maxPos);
            if (forceRefresh) {
              this.aabbHalfX = this._boundingBox.halfExtents.x;
              this.aabbHalfY = this._boundingBox.halfExtents.y;
              this.aabbHalfZ = this._boundingBox.halfExtents.z;
            } else {
              if (this.aabbHalfX) {
                this.setBoundingX(this.aabbHalfX);
              } else {
                this.aabbHalfX = this._boundingBox.halfExtents.x;
              }
              if (this.aabbHalfY) {
                this.setBoundingY(this.aabbHalfY);
              } else {
                this.aabbHalfY = this._boundingBox.halfExtents.y;
              }
              if (this.aabbHalfZ) {
                this.setBoundingZ(this.aabbHalfZ);
              } else {
                this.aabbHalfZ = this._boundingBox.halfExtents.z;
              }
            }
            this._culler.clear();
          }
        }
        update(dt) {
          const scaledDeltaTime = dt * this.simulationSpeed;
          if (!this.renderCulling) {
            if (this._boundingBox) {
              this._boundingBox = null;
            }
            if (this._culler) {
              this._culler.clear();
              this._culler.destroy();
              this._culler = null;
            }
            this._isSimulating = true;
          } else {
            var _this$node$scene$rend;
            if (!this._boundingBox) {
              this._boundingBox = new AABB();
              this._calculateBounding(false);
            }
            if (!this._curPos) {
              this._curPos = new Vec3();
            }
            this.node.getWorldPosition(this._curPos);
            if (!this._oldPos) {
              this._oldPos = new Vec3();
              this._oldPos.set(this._curPos);
            }
            if (!this._curPos.equals(this._oldPos) && this._boundingBox && this._culler) {
              const dx = this._curPos.x - this._oldPos.x;
              const dy = this._curPos.y - this._oldPos.y;
              const dz = this._curPos.z - this._oldPos.z;
              const center = this._boundingBox.center;
              center.x += dx;
              center.y += dy;
              center.z += dz;
              this._culler.setBoundingBoxCenter(center.x, center.y, center.z);
              this._oldPos.set(this._curPos);
            }
            const cameraLst = (_this$node$scene$rend = this.node.scene.renderScene) === null || _this$node$scene$rend === void 0 ? void 0 : _this$node$scene$rend.cameras;
            let culled = true;
            if (cameraLst !== undefined && this._boundingBox) {
              for (let i = 0; i < cameraLst.length; ++i) {
                const camera = cameraLst[i];
                const visibility = camera.visibility;
                if ((visibility & this.node.layer) === this.node.layer) {
                  if (intersect.aabbFrustum(this._boundingBox, camera.frustum)) {
                    culled = false;
                    break;
                  }
                }
              }
            }
            if (culled) {
              if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                this._isSimulating = false;
              }
              if (!this._isCulled) {
                this.processor.detachFromScene();
                this._isCulled = true;
              }
              if (this._trailModule && this._trailModule.enable) {
                this._trailModule._detachFromScene();
              }
              if (this._cullingMode === CullingMode.PauseAndCatchup) {
                this._time += scaledDeltaTime;
              }
              if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                return;
              }
            } else {
              if (this._isCulled) {
                this._attachToScene();
                this._isCulled = false;
              }
              if (!this._isSimulating) {
                this._isSimulating = true;
              }
            }
            if (!this._isSimulating) {
              return;
            }
          }
          if (this._isPlaying) {
            this._time += scaledDeltaTime;
            this._emit(scaledDeltaTime);
            if (this.processor.updateParticles(scaledDeltaTime) === 0 && !this._isEmitting) {
              this.stop();
            }
          } else {
            const mat = this.getMaterialInstance(0) || this.processor.getDefaultMaterial();
            const pass = mat.passes[0];
            this.processor.updateRotation(pass);
            this.processor.updateScale(pass);
          }
          if (this._needAttach) {
            if (this.getParticleCount() > 0) {
              if (!this._isCulled) {
                var _this$processor$getMo2;
                if (!((_this$processor$getMo2 = this.processor.getModel()) !== null && _this$processor$getMo2 !== void 0 && _this$processor$getMo2.scene)) {
                  this.processor.attachToScene();
                }
                if (this._trailModule && this._trailModule.enable) {
                  var _this$_trailModule$ge;
                  if (!((_this$_trailModule$ge = this._trailModule.getModel()) !== null && _this$_trailModule$ge !== void 0 && _this$_trailModule$ge.scene)) {
                    this._trailModule._attachToScene();
                  }
                }
                this._needAttach = false;
              }
            }
          }
          if (!this.renderer.useGPU && this._trailModule && this._trailModule.enable) {
            if (!this._trailModule.inited) {
              this._trailModule.clear();
              this._trailModule.destroy();
              this._trailModule.onInit(this);
              this._trailModule.enable = false;
              this._trailModule.enable = true;
            }
          }
        }
        beforeRender() {
          var _this$processor$getMo4;
          if (this.getParticleCount() <= 0) {
            var _this$processor$getMo3;
            if ((_this$processor$getMo3 = this.processor.getModel()) !== null && _this$processor$getMo3 !== void 0 && _this$processor$getMo3.scene) {
              this.processor.detachFromScene();
              if (this._trailModule && this._trailModule.enable) {
                this._trailModule._detachFromScene();
              }
              this._needAttach = false;
            }
          } else if (!((_this$processor$getMo4 = this.processor.getModel()) !== null && _this$processor$getMo4 !== void 0 && _this$processor$getMo4.scene)) {
            this._needAttach = true;
          }
          if (!this._isPlaying) return;
          this.processor.updateRenderData();
          this.processor.beforeRender();
          if (this._trailModule && this._trailModule.enable) {
            this._trailModule.updateRenderData();
            this._trailModule.beforeRender();
          }
        }
        _onVisibilityChange(val) {
          if (this.processor.model) {
            this.processor.model.visFlags = val;
          }
        }
        emit(count, dt) {
          const loopDelta = this._time % this.duration / this.duration;
          if (this._needRefresh) {
            this.node.invalidateChildren(TransformBit.POSITION);
            this._needRefresh = false;
          }
          if (this._simulationSpace === Space.World) {
            this.node.getWorldMatrix(_world_mat);
            this.node.getWorldRotation(_world_rol);
          }
          for (let i = 0; i < count; ++i) {
            const particle = this.processor.getFreeParticle();
            if (particle === null) {
              return;
            }
            particle.particleSystem = this;
            particle.reset();
            const rand = pseudoRandom(randomRangeInt(0, INT_MAX));
            if (this._shapeModule && this._shapeModule.enable) {
              this._shapeModule.emit(particle);
            } else {
              Vec3.set(particle.position, 0, 0, 0);
              Vec3.copy(particle.velocity, particleEmitZAxis);
            }
            if (this._textureAnimationModule && this._textureAnimationModule.enable) {
              this._textureAnimationModule.init(particle);
            }
            const curveStartSpeed = this.startSpeed.evaluate(loopDelta, rand);
            Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);
            if (this._simulationSpace === Space.World) {
              Vec3.transformMat4(particle.position, particle.position, _world_mat);
              Vec3.transformQuat(particle.velocity, particle.velocity, _world_rol);
            }
            Vec3.copy(particle.ultimateVelocity, particle.velocity);
            if (this.startRotation3D) {
              particle.startEuler.set(this.startRotationX.evaluate(loopDelta, rand), this.startRotationY.evaluate(loopDelta, rand), this.startRotationZ.evaluate(loopDelta, rand));
            } else {
              particle.startEuler.set(0, 0, this.startRotationZ.evaluate(loopDelta, rand));
            }
            particle.rotation.set(particle.startEuler);
            if (this.startSize3D) {
              Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), this.startSizeY.evaluate(loopDelta, rand), this.startSizeZ.evaluate(loopDelta, rand));
            } else {
              Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), 1, 1);
              particle.startSize.y = particle.startSize.x;
            }
            Vec3.copy(particle.size, particle.startSize);
            particle.startColor.set(this.startColor.evaluate(loopDelta, rand));
            particle.color.set(particle.startColor);
            particle.startLifetime = this.startLifetime.evaluate(loopDelta, rand) + dt;
            particle.remainingLifetime = particle.startLifetime;
            particle.randomSeed = randomRangeInt(0, 233280);
            particle.loopCount++;
            this.processor.setNewParticle(particle);
          }
        }
        _prewarmSystem() {
          this.startDelay.mode = Mode$3.Constant;
          this.startDelay.constant = 0;
          const dt = 1.0;
          const cnt = this.duration / dt;
          for (let i = 0; i < cnt; ++i) {
            this._time += dt;
            this._emit(dt);
            this.processor.updateParticles(dt);
          }
        }
        _emit(dt) {
          const startDelay = this.startDelay.evaluate(0, 1);
          if (this._time > startDelay) {
            if (this._time > this.duration + startDelay) {
              if (!this.loop) {
                this._isEmitting = false;
              }
            }
            if (!this._isEmitting) return;
            this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt;
            if (this._emitRateTimeCounter > 1) {
              const emitNum = Math.floor(this._emitRateTimeCounter);
              this._emitRateTimeCounter -= emitNum;
              this.emit(emitNum, dt);
            }
            const rateOverDistance = this.rateOverDistance.evaluate(this._time / this.duration, 1);
            if (rateOverDistance > 0) {
              Vec3.copy(this._oldWPos, this._curWPos);
              this.node.getWorldPosition(this._curWPos);
              const distance = Vec3.distance(this._curWPos, this._oldWPos);
              this._emitRateDistanceCounter += distance * rateOverDistance;
            }
            if (this._emitRateDistanceCounter > 1) {
              const emitNum = Math.floor(this._emitRateDistanceCounter);
              this._emitRateDistanceCounter -= emitNum;
              this.emit(emitNum, dt);
            }
            for (const burst of this.bursts) {
              burst.update(this, dt);
            }
          }
        }
        _resetPosition() {
          this.node.getWorldPosition(this._oldWPos);
          Vec3.copy(this._curWPos, this._oldWPos);
        }
        addSubEmitter(subEmitter) {
          this._subEmitters.push(subEmitter);
        }
        removeSubEmitter(idx) {
          this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
        }
        addBurst(burst) {
          this.bursts.push(burst);
        }
        removeBurst(idx) {
          this.bursts.splice(this.bursts.indexOf(idx), 1);
        }
        getBoundingX() {
          return this._aabbHalfX;
        }
        getBoundingY() {
          return this._aabbHalfY;
        }
        getBoundingZ() {
          return this._aabbHalfZ;
        }
        setBoundingX(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.x = value;
            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);
            this._aabbHalfX = value;
          }
        }
        setBoundingY(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.y = value;
            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);
            this._aabbHalfY = value;
          }
        }
        setBoundingZ(value) {
          if (this._boundingBox && this._culler) {
            this._boundingBox.halfExtents.z = value;
            this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);
            this._aabbHalfZ = value;
          }
        }
        get isPlaying() {
          return this._isPlaying;
        }
        get isPaused() {
          return this._isPaused;
        }
        get isStopped() {
          return this._isStopped;
        }
        get isEmitting() {
          return this._isEmitting;
        }
        get time() {
          return this._time;
        }
        _onBeforeSerialize(props) {
          return this.dataCulling ? props.filter(p => !PARTICLE_MODULE_PROPERTY.includes(p) || this[p] && this[p].enable) : props;
        }
        getNoisePreview(width, height) {
          const out = [];
          if (this.processor) {
            this.processor.getNoisePreview(out, width, height);
          }
          return out;
        }
      }, _class3$i.CullingMode = CullingMode, _class3$i), (_initializer$B = applyDecoratedInitializer(_class2$C.prototype, "startColor", [_dec3$r, serializable$6], function () {
        return new GradientRange();
      }), _initializer2$y = applyDecoratedInitializer(_class2$C.prototype, "scaleSpace", [_dec4$m, serializable$6], function () {
        return Space.Local;
      }), _initializer3$o = applyDecoratedInitializer(_class2$C.prototype, "startSize3D", [serializable$6], function () {
        return false;
      }), _initializer4$i = applyDecoratedInitializer(_class2$C.prototype, "startSizeX", [_dec5$k, _dec6$9], function () {
        return new CurveRange();
      }), _initializer5$e = applyDecoratedInitializer(_class2$C.prototype, "startSizeY", [_dec7$8, serializable$6], function () {
        return new CurveRange();
      }), _initializer6$b = applyDecoratedInitializer(_class2$C.prototype, "startSizeZ", [_dec8$6, serializable$6], function () {
        return new CurveRange();
      }), _initializer7$a = applyDecoratedInitializer(_class2$C.prototype, "startSpeed", [_dec9$6, serializable$6], function () {
        return new CurveRange();
      }), _initializer8$9 = applyDecoratedInitializer(_class2$C.prototype, "startRotation3D", [serializable$6], function () {
        return false;
      }), _initializer9$9 = applyDecoratedInitializer(_class2$C.prototype, "startRotationX", [_dec10$4, serializable$6], function () {
        return new CurveRange();
      }), _initializer10$8 = applyDecoratedInitializer(_class2$C.prototype, "startRotationY", [_dec11$3, serializable$6], function () {
        return new CurveRange();
      }), _initializer11$8 = applyDecoratedInitializer(_class2$C.prototype, "startRotationZ", [_dec12$3, _dec13$3], function () {
        return new CurveRange();
      }), _initializer12$6 = applyDecoratedInitializer(_class2$C.prototype, "startDelay", [_dec14$2, serializable$6], function () {
        return new CurveRange();
      }), _initializer13$5 = applyDecoratedInitializer(_class2$C.prototype, "startLifetime", [_dec15$2, serializable$6], function () {
        return new CurveRange();
      }), _initializer14$4 = applyDecoratedInitializer(_class2$C.prototype, "duration", [serializable$6], function () {
        return 5.0;
      }), _initializer15$3 = applyDecoratedInitializer(_class2$C.prototype, "loop", [serializable$6], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "simulationSpace", [_dec16$2, serializable$6], Object.getOwnPropertyDescriptor(_class2$C.prototype, "simulationSpace"), _class2$C.prototype), _initializer16$3 = applyDecoratedInitializer(_class2$C.prototype, "simulationSpeed", [serializable$6], function () {
        return 1.0;
      }), _initializer17$2 = applyDecoratedInitializer(_class2$C.prototype, "playOnAwake", [serializable$6], function () {
        return true;
      }), _initializer18$2 = applyDecoratedInitializer(_class2$C.prototype, "gravityModifier", [_dec17$2, serializable$6], function () {
        return new CurveRange();
      }), _initializer19$1 = applyDecoratedInitializer(_class2$C.prototype, "rateOverTime", [_dec18$2, serializable$6], function () {
        return new CurveRange();
      }), _initializer20$1 = applyDecoratedInitializer(_class2$C.prototype, "rateOverDistance", [_dec19$2, serializable$6], function () {
        return new CurveRange();
      }), _initializer21$1 = applyDecoratedInitializer(_class2$C.prototype, "bursts", [_dec20$2, serializable$6], function () {
        return [];
      }), _applyDecoratedDescriptor(_class2$C.prototype, "renderCulling", [_dec21$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "renderCulling"), _class2$C.prototype), _initializer22$1 = applyDecoratedInitializer(_class2$C.prototype, "_renderCulling", [serializable$6], function () {
        return false;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "cullingMode", [_dec22$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "cullingMode"), _class2$C.prototype), _initializer23$1 = applyDecoratedInitializer(_class2$C.prototype, "_cullingMode", [serializable$6], function () {
        return CullingMode.Pause;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "aabbHalfX", [_dec23$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "aabbHalfX"), _class2$C.prototype), _initializer24$1 = applyDecoratedInitializer(_class2$C.prototype, "_aabbHalfX", [serializable$6], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "aabbHalfY", [_dec24$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "aabbHalfY"), _class2$C.prototype), _initializer25$1 = applyDecoratedInitializer(_class2$C.prototype, "_aabbHalfY", [serializable$6], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "aabbHalfZ", [_dec25$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "aabbHalfZ"), _class2$C.prototype), _initializer26$1 = applyDecoratedInitializer(_class2$C.prototype, "_aabbHalfZ", [serializable$6], function () {
        return 0;
      }), _initializer27$1 = applyDecoratedInitializer(_class2$C.prototype, "_dataCulling", [serializable$6, _dec26$2], function () {
        return false;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "sharedMaterials", [override, serializable$6], Object.getOwnPropertyDescriptor(_class2$C.prototype, "sharedMaterials"), _class2$C.prototype), _initializer28$1 = applyDecoratedInitializer(_class2$C.prototype, "_colorOverLifetimeModule", [_dec27$2], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "colorOverLifetimeModule", [_dec28$2], Object.getOwnPropertyDescriptor(_class2$C.prototype, "colorOverLifetimeModule"), _class2$C.prototype), _initializer29$1 = applyDecoratedInitializer(_class2$C.prototype, "_shapeModule", [_dec29$2], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "shapeModule", [_dec30$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "shapeModule"), _class2$C.prototype), _initializer30$1 = applyDecoratedInitializer(_class2$C.prototype, "_sizeOvertimeModule", [_dec31$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "sizeOvertimeModule", [_dec32$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "sizeOvertimeModule"), _class2$C.prototype), _initializer31$1 = applyDecoratedInitializer(_class2$C.prototype, "_velocityOvertimeModule", [_dec33$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "velocityOvertimeModule", [_dec34$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "velocityOvertimeModule"), _class2$C.prototype), _initializer32$1 = applyDecoratedInitializer(_class2$C.prototype, "_forceOvertimeModule", [_dec35$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "forceOvertimeModule", [_dec36$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "forceOvertimeModule"), _class2$C.prototype), _initializer33$1 = applyDecoratedInitializer(_class2$C.prototype, "_limitVelocityOvertimeModule", [_dec37$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "limitVelocityOvertimeModule", [_dec38$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "limitVelocityOvertimeModule"), _class2$C.prototype), _initializer34$1 = applyDecoratedInitializer(_class2$C.prototype, "_rotationOvertimeModule", [_dec39$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "rotationOvertimeModule", [_dec40$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "rotationOvertimeModule"), _class2$C.prototype), _initializer35$1 = applyDecoratedInitializer(_class2$C.prototype, "_textureAnimationModule", [_dec41$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "textureAnimationModule", [_dec42$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "textureAnimationModule"), _class2$C.prototype), _initializer36$1 = applyDecoratedInitializer(_class2$C.prototype, "_noiseModule", [_dec43$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "noiseModule", [_dec44$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "noiseModule"), _class2$C.prototype), _initializer37$1 = applyDecoratedInitializer(_class2$C.prototype, "_trailModule", [_dec45$1], function () {
        return null;
      }), _applyDecoratedDescriptor(_class2$C.prototype, "trailModule", [_dec46$1], Object.getOwnPropertyDescriptor(_class2$C.prototype, "trailModule"), _class2$C.prototype), _initializer38$1 = applyDecoratedInitializer(_class2$C.prototype, "renderer", [_dec47$1, serializable$6], function () {
        return new ParticleSystemRenderer();
      }), _initializer39$1 = applyDecoratedInitializer(_class2$C.prototype, "_prewarm", [serializable$6], function () {
        return false;
      }), _initializer40$1 = applyDecoratedInitializer(_class2$C.prototype, "_capacity", [serializable$6], function () {
        return 100;
      }), _initializer41$1 = applyDecoratedInitializer(_class2$C.prototype, "_simulationSpace", [serializable$6], function () {
        return Space.Local;
      })), _class2$C)) || _class$F) || _class$F); exports({ ParticleSystem: ParticleSystem, ParticleSystemComponent: ParticleSystem });

      class ParticleUtils {
        static instantiate(prefab) {
          if (!this.registeredSceneEvent) {
            director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this);
            this.registeredSceneEvent = true;
          }
          if (!this.particleSystemPool.has(prefab._uuid)) {
            this.particleSystemPool.set(prefab._uuid, new Pool(() => instantiate(prefab) || new Node$1(), 1, prefab => prefab.destroy()));
          }
          return this.particleSystemPool.get(prefab._uuid).alloc();
        }
        static destroy(prefab) {
          if (this.particleSystemPool.has(prefab._prefab.asset._uuid)) {
            this.stop(prefab);
            this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab);
          }
        }
        static play(rootNode) {
          for (const ps of rootNode.getComponentsInChildren(ParticleSystem)) {
            ps.play();
          }
        }
        static stop(rootNode) {
          for (const ps of rootNode.getComponentsInChildren(ParticleSystem)) {
            ps.stop();
          }
        }
        static onSceneUnload() {
          this.particleSystemPool.forEach(value => value.destroy());
          this.particleSystemPool.clear();
        }
      } exports('ParticleUtils', ParticleUtils);
      ParticleUtils.particleSystemPool = new Map();
      ParticleUtils.registeredSceneEvent = false;

      removeProperty(Burst.prototype, 'Burst.prototype', [{
        name: 'minCount'
      }, {
        name: 'maxCount'
      }]);
      replaceProperty(ParticleSystem.prototype, 'ParticleSystem.prototype', [{
        name: 'enableCulling',
        newName: 'dataCulling'
      }]);
      legacyCC.ParticleSystemComponent = ParticleSystem;
      setClassAlias(ParticleSystem, 'cc.ParticleSystemComponent');
      legacyCC.BillboardComponent = Billboard;
      setClassAlias(Billboard, 'cc.BillboardComponent');
      legacyCC.LineComponent = Line;
      setClassAlias(Line, 'cc.LineComponent');

      legacyCC.ParticleUtils = ParticleUtils;

      let ERigidBodyType; exports('ERigidBodyType', ERigidBodyType);
      (function (ERigidBodyType) {
        ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
        ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
        ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
      })(ERigidBodyType || (exports('ERigidBodyType', ERigidBodyType = {})));
      Enum(ERigidBodyType);
      let EAxisDirection; exports('EAxisDirection', EAxisDirection);
      (function (EAxisDirection) {
        EAxisDirection[EAxisDirection["X_AXIS"] = 0] = "X_AXIS";
        EAxisDirection[EAxisDirection["Y_AXIS"] = 1] = "Y_AXIS";
        EAxisDirection[EAxisDirection["Z_AXIS"] = 2] = "Z_AXIS";
      })(EAxisDirection || (exports('EAxisDirection', EAxisDirection = {})));
      Enum(EAxisDirection);
      let ED6Axis;
      (function (ED6Axis) {
        ED6Axis[ED6Axis["X"] = 0] = "X";
        ED6Axis[ED6Axis["Y"] = 1] = "Y";
        ED6Axis[ED6Axis["Z"] = 2] = "Z";
        ED6Axis[ED6Axis["SWING1"] = 3] = "SWING1";
        ED6Axis[ED6Axis["SWING2"] = 4] = "SWING2";
        ED6Axis[ED6Axis["TWIST"] = 5] = "TWIST";
      })(ED6Axis || (ED6Axis = {}));
      Enum(ED6Axis);
      let ESimplexType;
      (function (ESimplexType) {
        ESimplexType[ESimplexType["VERTEX"] = 1] = "VERTEX";
        ESimplexType[ESimplexType["LINE"] = 2] = "LINE";
        ESimplexType[ESimplexType["TRIANGLE"] = 3] = "TRIANGLE";
        ESimplexType[ESimplexType["TETRAHEDRON"] = 4] = "TETRAHEDRON";
      })(ESimplexType || (ESimplexType = {}));
      Enum(ESimplexType);
      let EColliderType; exports('EColliderType', EColliderType);
      (function (EColliderType) {
        EColliderType[EColliderType["BOX"] = 0] = "BOX";
        EColliderType[EColliderType["SPHERE"] = 1] = "SPHERE";
        EColliderType[EColliderType["CAPSULE"] = 2] = "CAPSULE";
        EColliderType[EColliderType["CYLINDER"] = 3] = "CYLINDER";
        EColliderType[EColliderType["CONE"] = 4] = "CONE";
        EColliderType[EColliderType["MESH"] = 5] = "MESH";
        EColliderType[EColliderType["PLANE"] = 6] = "PLANE";
        EColliderType[EColliderType["SIMPLEX"] = 7] = "SIMPLEX";
        EColliderType[EColliderType["TERRAIN"] = 8] = "TERRAIN";
      })(EColliderType || (exports('EColliderType', EColliderType = {})));
      Enum(EColliderType);
      let EConstraintType;
      (function (EConstraintType) {
        EConstraintType[EConstraintType["POINT_TO_POINT"] = 0] = "POINT_TO_POINT";
        EConstraintType[EConstraintType["HINGE"] = 1] = "HINGE";
        EConstraintType[EConstraintType["FIXED"] = 2] = "FIXED";
        EConstraintType[EConstraintType["CONFIGURABLE"] = 3] = "CONFIGURABLE";
      })(EConstraintType || (EConstraintType = {}));
      Enum(EConstraintType);
      let EConstraintMode;
      (function (EConstraintMode) {
        EConstraintMode[EConstraintMode["FREE"] = 0] = "FREE";
        EConstraintMode[EConstraintMode["LIMITED"] = 1] = "LIMITED";
        EConstraintMode[EConstraintMode["LOCKED"] = 2] = "LOCKED";
      })(EConstraintMode || (EConstraintMode = {}));
      Enum(EConstraintMode);
      let EDriverMode;
      (function (EDriverMode) {
        EDriverMode[EDriverMode["DISABLED"] = 0] = "DISABLED";
        EDriverMode[EDriverMode["SERVO"] = 1] = "SERVO";
        EDriverMode[EDriverMode["INDUCTION"] = 2] = "INDUCTION";
      })(EDriverMode || (EDriverMode = {}));
      Enum(EDriverMode);
      let ECharacterControllerType;
      (function (ECharacterControllerType) {
        ECharacterControllerType[ECharacterControllerType["BOX"] = 0] = "BOX";
        ECharacterControllerType[ECharacterControllerType["CAPSULE"] = 1] = "CAPSULE";
      })(ECharacterControllerType || (ECharacterControllerType = {}));
      Enum(ECharacterControllerType);
      let PhysicsGroup;
      (function (PhysicsGroup) {
        PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
      })(PhysicsGroup || (PhysicsGroup = {}));
      Enum(PhysicsGroup);
      let EPhysicsDrawFlags; exports('EPhysicsDrawFlags', EPhysicsDrawFlags);
      (function (EPhysicsDrawFlags) {
        EPhysicsDrawFlags[EPhysicsDrawFlags["NONE"] = 0] = "NONE";
        EPhysicsDrawFlags[EPhysicsDrawFlags["WIRE_FRAME"] = 1] = "WIRE_FRAME";
        EPhysicsDrawFlags[EPhysicsDrawFlags["CONSTRAINT"] = 2] = "CONSTRAINT";
        EPhysicsDrawFlags[EPhysicsDrawFlags["AABB"] = 4] = "AABB";
      })(EPhysicsDrawFlags || (exports('EPhysicsDrawFlags', EPhysicsDrawFlags = {})));
      Enum(EPhysicsDrawFlags);

      function updateLegacyMacro(id) {
        legacyCC._global.CC_PHYSICS_BUILTIN = id === 'builtin';
        legacyCC._global.CC_PHYSICS_CANNON = id === 'cannon.js';
        legacyCC._global.CC_PHYSICS_AMMO = id === 'bullet';
      }
      function register(id, wrapper) {
        log(`[PHYSICS]: register ${id}.`);
        selector.backend[id] = wrapper;
        if (!selector.physicsWorld || selector.id === id) {
          updateLegacyMacro(id);
          const mutableSelector = selector;
          mutableSelector.id = id;
          mutableSelector.wrapper = wrapper;
        }
      }
      let worldInitData;
      function switchTo(id) {
        if (!selector.runInEditor) return;
        const mutableSelector = selector;
        if (selector.physicsWorld && id !== selector.id && selector.backend[id] != null) {
          selector.physicsWorld.destroy();
          log(`[PHYSICS]: switch from ${selector.id} to ${id}.`);
          updateLegacyMacro(id);
          mutableSelector.id = id;
          mutableSelector.wrapper = selector.backend[id];
          mutableSelector.physicsWorld = createPhysicsWorld();
        } else {
          log(`[PHYSICS]: using ${id}.`);
          mutableSelector.physicsWorld = createPhysicsWorld();
        }
        if (worldInitData) {
          const world = mutableSelector.physicsWorld;
          world.setGravity(worldInitData.gravity);
          world.setAllowSleep(worldInitData.allowSleep);
        }
      }
      const selector = {
        id: '',
        switchTo,
        register,
        wrapper: {},
        backend: {},
        physicsWorld: null,
        runInEditor: !EDITOR
      };
      function constructDefaultWorld(data) {
        if (!worldInitData) worldInitData = data;
        if (!selector.runInEditor) return;
        if (!selector.physicsWorld) {
          log(`[PHYSICS]: using ${selector.id}.`);
          const mutableSelector = selector;
          const world = mutableSelector.physicsWorld = createPhysicsWorld();
          world.setGravity(worldInitData.gravity);
          world.setAllowSleep(worldInitData.allowSleep);
        }
      }
      const FUNC = (...v) => 0;
      const ENTIRE_WORLD = {
        impl: null,
        debugDrawFlags: 0,
        debugDrawConstraintSize: 0,
        setGravity: FUNC,
        setAllowSleep: FUNC,
        setDefaultMaterial: FUNC,
        step: FUNC,
        syncAfterEvents: FUNC,
        syncSceneToPhysics: FUNC,
        raycast: FUNC,
        raycastClosest: FUNC,
        sweepBox: FUNC,
        sweepBoxClosest: FUNC,
        sweepSphere: FUNC,
        sweepSphereClosest: FUNC,
        sweepCapsule: FUNC,
        sweepCapsuleClosest: FUNC,
        emitEvents: FUNC,
        destroy: FUNC
      };
      var ECheckType;
      (function (ECheckType) {
        ECheckType[ECheckType["World"] = 0] = "World";
        ECheckType[ECheckType["RigidBody"] = 1] = "RigidBody";
        ECheckType[ECheckType["BoxCollider"] = 2] = "BoxCollider";
        ECheckType[ECheckType["SphereCollider"] = 3] = "SphereCollider";
        ECheckType[ECheckType["CapsuleCollider"] = 4] = "CapsuleCollider";
        ECheckType[ECheckType["MeshCollider"] = 5] = "MeshCollider";
        ECheckType[ECheckType["CylinderCollider"] = 6] = "CylinderCollider";
        ECheckType[ECheckType["ConeCollider"] = 7] = "ConeCollider";
        ECheckType[ECheckType["TerrainCollider"] = 8] = "TerrainCollider";
        ECheckType[ECheckType["SimplexCollider"] = 9] = "SimplexCollider";
        ECheckType[ECheckType["PlaneCollider"] = 10] = "PlaneCollider";
        ECheckType[ECheckType["PointToPointConstraint"] = 11] = "PointToPointConstraint";
        ECheckType[ECheckType["HingeConstraint"] = 12] = "HingeConstraint";
        ECheckType[ECheckType["FixedConstraint"] = 13] = "FixedConstraint";
        ECheckType[ECheckType["ConfigurableConstraint"] = 14] = "ConfigurableConstraint";
        ECheckType[ECheckType["BoxCharacterController"] = 15] = "BoxCharacterController";
        ECheckType[ECheckType["CapsuleCharacterController"] = 16] = "CapsuleCharacterController";
      })(ECheckType || (ECheckType = {}));
      function check(obj, type) {
        if (obj == null) {
          if (selector.id) {
            warn(`${selector.id} physics does not support ${ECheckType[type]}`);
          } else {
            errorID(9600);
          }
          return true;
        }
        return false;
      }
      function createPhysicsWorld() {
        if (check(selector.wrapper.PhysicsWorld, ECheckType.World)) {
          return ENTIRE_WORLD;
        }
        return new selector.wrapper.PhysicsWorld();
      }
      const ENTIRE_RIGID_BODY = {
        impl: null,
        rigidBody: null,
        isAwake: false,
        isSleepy: false,
        isSleeping: false,
        initialize: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setType: FUNC,
        setMass: FUNC,
        setLinearDamping: FUNC,
        setAngularDamping: FUNC,
        useGravity: FUNC,
        setLinearFactor: FUNC,
        setAngularFactor: FUNC,
        setAllowSleep: FUNC,
        wakeUp: FUNC,
        sleep: FUNC,
        clearState: FUNC,
        clearForces: FUNC,
        clearVelocity: FUNC,
        setSleepThreshold: FUNC,
        getSleepThreshold: FUNC,
        getLinearVelocity: FUNC,
        setLinearVelocity: FUNC,
        getAngularVelocity: FUNC,
        setAngularVelocity: FUNC,
        applyForce: FUNC,
        applyLocalForce: FUNC,
        applyImpulse: FUNC,
        applyLocalImpulse: FUNC,
        applyTorque: FUNC,
        applyLocalTorque: FUNC,
        setGroup: FUNC,
        getGroup: FUNC,
        addGroup: FUNC,
        removeGroup: FUNC,
        setMask: FUNC,
        getMask: FUNC,
        addMask: FUNC,
        removeMask: FUNC,
        isUsingCCD: FUNC,
        useCCD: FUNC
      };
      function createRigidBody() {
        if (check(selector.wrapper.RigidBody, ECheckType.RigidBody)) {
          return ENTIRE_RIGID_BODY;
        }
        return new selector.wrapper.RigidBody();
      }
      const CREATE_COLLIDER_PROXY = {
        INITED: false
      };
      const ENTIRE_SHAPE = {
        impl: null,
        collider: null,
        attachedRigidBody: null,
        initialize: FUNC,
        onLoad: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setGroup: FUNC,
        getGroup: FUNC,
        addGroup: FUNC,
        removeGroup: FUNC,
        setMask: FUNC,
        getMask: FUNC,
        addMask: FUNC,
        removeMask: FUNC,
        setMaterial: FUNC,
        setAsTrigger: FUNC,
        setCenter: FUNC,
        getAABB: FUNC,
        getBoundingSphere: FUNC,
        updateSize: FUNC,
        updateRadius: FUNC,
        setRadius: FUNC,
        setCylinderHeight: FUNC,
        setDirection: FUNC,
        setHeight: FUNC,
        setShapeType: FUNC,
        setVertices: FUNC,
        setMesh: FUNC,
        setTerrain: FUNC,
        setNormal: FUNC,
        setConstant: FUNC,
        updateEventListener: FUNC
      };
      function createShape(type) {
        initColliderProxy();
        return CREATE_COLLIDER_PROXY[type]();
      }
      function initColliderProxy() {
        if (CREATE_COLLIDER_PROXY.INITED) return;
        CREATE_COLLIDER_PROXY.INITED = true;
        CREATE_COLLIDER_PROXY[EColliderType.BOX] = function createBoxShape() {
          if (check(selector.wrapper.BoxShape, ECheckType.BoxCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.BoxShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.SPHERE] = function createSphereShape() {
          if (check(selector.wrapper.SphereShape, ECheckType.SphereCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.SphereShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.CAPSULE] = function createCapsuleShape() {
          if (check(selector.wrapper.CapsuleShape, ECheckType.CapsuleCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.CapsuleShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.CYLINDER] = function createCylinderShape() {
          if (check(selector.wrapper.CylinderShape, ECheckType.CylinderCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.CylinderShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.CONE] = function createConeShape() {
          if (check(selector.wrapper.ConeShape, ECheckType.ConeCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.ConeShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.MESH] = function createTrimeshShape() {
          if (check(selector.wrapper.TrimeshShape, ECheckType.MeshCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.TrimeshShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.TERRAIN] = function createTerrainShape() {
          if (check(selector.wrapper.TerrainShape, ECheckType.TerrainCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.TerrainShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.SIMPLEX] = function createSimplexShape() {
          if (check(selector.wrapper.SimplexShape, ECheckType.SimplexCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.SimplexShape();
        };
        CREATE_COLLIDER_PROXY[EColliderType.PLANE] = function createPlaneShape() {
          if (check(selector.wrapper.PlaneShape, ECheckType.PlaneCollider)) {
            return ENTIRE_SHAPE;
          }
          return new selector.wrapper.PlaneShape();
        };
      }
      const CREATE_CONSTRAINT_PROXY = {
        INITED: false
      };
      const ENTIRE_CONSTRAINT = {
        impl: null,
        initialize: FUNC,
        onLoad: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        setEnableCollision: FUNC,
        setConnectedBody: FUNC,
        setPivotA: FUNC,
        setPivotB: FUNC,
        setAxis: FUNC,
        setSecondaryAxis: FUNC,
        setBreakForce: FUNC,
        setBreakTorque: FUNC,
        setConstraintMode: FUNC,
        setLinearLimit: FUNC,
        setAngularExtent: FUNC,
        setLinearSoftConstraint: FUNC,
        setLinearStiffness: FUNC,
        setLinearDamping: FUNC,
        setLinearRestitution: FUNC,
        setSwingSoftConstraint: FUNC,
        setTwistSoftConstraint: FUNC,
        setSwingStiffness: FUNC,
        setSwingDamping: FUNC,
        setSwingRestitution: FUNC,
        setTwistStiffness: FUNC,
        setTwistDamping: FUNC,
        setTwistRestitution: FUNC,
        setDriverMode: FUNC,
        setLinearMotorTarget: FUNC,
        setLinearMotorVelocity: FUNC,
        setLinearMotorForceLimit: FUNC,
        setAngularMotorTarget: FUNC,
        setAngularMotorVelocity: FUNC,
        setAngularMotorForceLimit: FUNC,
        setAutoPivotB: FUNC,
        setLimitEnabled: FUNC,
        setLowerLimit: FUNC,
        setUpperLimit: FUNC,
        setMotorEnabled: FUNC,
        setMotorVelocity: FUNC,
        setMotorForceLimit: FUNC
      };
      function createConstraint(type) {
        initConstraintProxy();
        return CREATE_CONSTRAINT_PROXY[type]();
      }
      function initConstraintProxy() {
        if (CREATE_CONSTRAINT_PROXY.INITED) return;
        CREATE_CONSTRAINT_PROXY.INITED = true;
        CREATE_CONSTRAINT_PROXY[EConstraintType.POINT_TO_POINT] = function createPointToPointConstraint() {
          if (check(selector.wrapper.PointToPointConstraint, ECheckType.PointToPointConstraint)) {
            return ENTIRE_CONSTRAINT;
          }
          return new selector.wrapper.PointToPointConstraint();
        };
        CREATE_CONSTRAINT_PROXY[EConstraintType.HINGE] = function createHingeConstraint() {
          if (check(selector.wrapper.HingeConstraint, ECheckType.HingeConstraint)) {
            return ENTIRE_CONSTRAINT;
          }
          return new selector.wrapper.HingeConstraint();
        };
        CREATE_CONSTRAINT_PROXY[EConstraintType.FIXED] = function createFixedConstraint() {
          if (check(selector.wrapper.FixedConstraint, ECheckType.FixedConstraint)) {
            return ENTIRE_CONSTRAINT;
          }
          return new selector.wrapper.FixedConstraint();
        };
        CREATE_CONSTRAINT_PROXY[EConstraintType.CONFIGURABLE] = function createConfigurableConstraint() {
          if (check(selector.wrapper.ConfigurableConstraint, ECheckType.ConfigurableConstraint)) {
            return ENTIRE_CONSTRAINT;
          }
          return new selector.wrapper.ConfigurableConstraint();
        };
      }
      const CREATE_CHARACTER_CONTROLLER_PROXY = {
        INITED: false
      };
      const ENTIRE_CHARACTER_CONTROLLER = {
        initialize: FUNC,
        onLoad: FUNC,
        onEnable: FUNC,
        onDisable: FUNC,
        onDestroy: FUNC,
        onGround: FUNC,
        getPosition: FUNC,
        setPosition: FUNC,
        setStepOffset: FUNC,
        setSlopeLimit: FUNC,
        setContactOffset: FUNC,
        setDetectCollisions: FUNC,
        setOverlapRecovery: FUNC,
        setGroup: FUNC,
        getGroup: FUNC,
        addGroup: FUNC,
        removeGroup: FUNC,
        setMask: FUNC,
        getMask: FUNC,
        addMask: FUNC,
        removeMask: FUNC,
        move: FUNC,
        syncPhysicsToScene: FUNC,
        updateEventListener: FUNC,
        setHalfHeight: FUNC,
        setHalfSideExtent: FUNC,
        setHalfForwardExtent: FUNC,
        setRadius: FUNC,
        setHeight: FUNC
      };
      function createCharacterController(type) {
        initCharacterControllerProxy();
        return CREATE_CHARACTER_CONTROLLER_PROXY[type]();
      }
      function initCharacterControllerProxy() {
        if (CREATE_CHARACTER_CONTROLLER_PROXY.INITED) return;
        CREATE_CHARACTER_CONTROLLER_PROXY.INITED = true;
        CREATE_CHARACTER_CONTROLLER_PROXY[ECharacterControllerType.BOX] = function createBoxCharacterController() {
          if (check(selector.wrapper.BoxCharacterController, ECheckType.BoxCharacterController)) {
            return ENTIRE_CHARACTER_CONTROLLER;
          }
          return new selector.wrapper.BoxCharacterController();
        };
        CREATE_CHARACTER_CONTROLLER_PROXY[ECharacterControllerType.CAPSULE] = function createCapsuleCharacterController() {
          if (check(selector.wrapper.CapsuleCharacterController, ECheckType.CapsuleCharacterController)) {
            return ENTIRE_CHARACTER_CONTROLLER;
          }
          return new selector.wrapper.CapsuleCharacterController();
        };
      }

      function instantiateWasm(wasmUrl, importObject) {
        return fetchBuffer(wasmUrl).then(arrayBuffer => WebAssembly.instantiate(arrayBuffer, importObject));
      }
      function fetchBuffer(binaryUrl) {
        return new Promise((resolve, reject) => {
          try {
            if (EDITOR) ;
            binaryUrl = `src/cocos-js/${binaryUrl}`;
            const arrayBuffer = native.fileUtils.getDataFromFile(binaryUrl);
            resolve(arrayBuffer);
          } catch (e) {
            reject(e);
          }
        });
      }
      function ensureWasmModuleReady() {
        return Promise.resolve();
      }

      let EBulletType;
      (function (EBulletType) {
        EBulletType[EBulletType["EBulletTypeVec3"] = 0] = "EBulletTypeVec3";
        EBulletType[EBulletType["EBulletTypeQuat"] = 1] = "EBulletTypeQuat";
        EBulletType[EBulletType["EBulletTypeTransform"] = 2] = "EBulletTypeTransform";
        EBulletType[EBulletType["EBulletTypeMotionState"] = 3] = "EBulletTypeMotionState";
        EBulletType[EBulletType["EBulletTypeCollisionObject"] = 4] = "EBulletTypeCollisionObject";
        EBulletType[EBulletType["EBulletTypeCollisionShape"] = 5] = "EBulletTypeCollisionShape";
        EBulletType[EBulletType["EBulletTypeCharacterController"] = 6] = "EBulletTypeCharacterController";
        EBulletType[EBulletType["EBulletTypeStridingMeshInterface"] = 7] = "EBulletTypeStridingMeshInterface";
        EBulletType[EBulletType["EBulletTypeTriangleMesh"] = 8] = "EBulletTypeTriangleMesh";
        EBulletType[EBulletType["EBulletTypeCollisionDispatcher"] = 9] = "EBulletTypeCollisionDispatcher";
        EBulletType[EBulletType["EBulletTypeDbvtBroadPhase"] = 10] = "EBulletTypeDbvtBroadPhase";
        EBulletType[EBulletType["EBulletTypeSequentialImpulseConstraintSolver"] = 11] = "EBulletTypeSequentialImpulseConstraintSolver";
        EBulletType[EBulletType["EBulletTypeCollisionWorld"] = 12] = "EBulletTypeCollisionWorld";
        EBulletType[EBulletType["EBulletTypeTypedConstraint"] = 13] = "EBulletTypeTypedConstraint";
        EBulletType[EBulletType["EBulletTypeDebugDraw"] = 14] = "EBulletTypeDebugDraw";
      })(EBulletType || (EBulletType = {}));
      let EBulletTriangleRaycastFlag;
      (function (EBulletTriangleRaycastFlag) {
        EBulletTriangleRaycastFlag[EBulletTriangleRaycastFlag["NONE"] = 0] = "NONE";
        EBulletTriangleRaycastFlag[EBulletTriangleRaycastFlag["FilterBackfaces"] = 1] = "FilterBackfaces";
        EBulletTriangleRaycastFlag[EBulletTriangleRaycastFlag["KeepUnflippedNormal"] = 2] = "KeepUnflippedNormal";
        EBulletTriangleRaycastFlag[EBulletTriangleRaycastFlag["UseSubSimplexConvexCastRaytest"] = 4] = "UseSubSimplexConvexCastRaytest";
        EBulletTriangleRaycastFlag[EBulletTriangleRaycastFlag["UseGjkConvexCastRaytest"] = 8] = "UseGjkConvexCastRaytest";
      })(EBulletTriangleRaycastFlag || (EBulletTriangleRaycastFlag = {}));
      let EBulletDebugDrawModes;
      (function (EBulletDebugDrawModes) {
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_NoDebug"] = 0] = "DBG_NoDebug";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawWireframe"] = 1] = "DBG_DrawWireframe";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawAabb"] = 2] = "DBG_DrawAabb";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawFeaturesText"] = 4] = "DBG_DrawFeaturesText";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawContactPoints"] = 8] = "DBG_DrawContactPoints";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_NoDeactivation"] = 16] = "DBG_NoDeactivation";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_NoHelpText"] = 32] = "DBG_NoHelpText";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawText"] = 64] = "DBG_DrawText";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_ProfileTimings"] = 128] = "DBG_ProfileTimings";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_EnableSatComparison"] = 256] = "DBG_EnableSatComparison";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DisableBulletLCP"] = 512] = "DBG_DisableBulletLCP";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_EnableCCD"] = 1024] = "DBG_EnableCCD";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawConstraints"] = 2048] = "DBG_DrawConstraints";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawConstraintLimits"] = 4096] = "DBG_DrawConstraintLimits";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_FastWireframe"] = 8192] = "DBG_FastWireframe";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawNormals"] = 16384] = "DBG_DrawNormals";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_DrawFrames"] = 32768] = "DBG_DrawFrames";
        EBulletDebugDrawModes[EBulletDebugDrawModes["DBG_MAX_DEBUG_DRAW_MODE"] = 32769] = "DBG_MAX_DEBUG_DRAW_MODE";
      })(EBulletDebugDrawModes || (EBulletDebugDrawModes = {}));
      let bt = {};
      const btCache = {};
      btCache.BODY_CACHE_NAME = 'body';
      btCache.CCT_CACHE_NAME = 'cct';
      function initWASM(wasmFactory, wasmUrl) {
        return new Promise((resolve, reject) => {
          const errorMessage = err => `[bullet]: bullet wasm lib load failed: ${err}`;
          wasmFactory({
            instantiateWasm(importObject, receiveInstance) {
              instantiateWasm(wasmUrl, importObject).then(result => {
                receiveInstance(result.instance, result.module);
              }).catch(err => reject(errorMessage(err)));
            }
          }).then(instance => {
            log('[bullet]:bullet wasm lib loaded.');
            bt = instance;
          }).then(resolve).catch(err => reject(errorMessage(err)));
        });
      }
      function initASM(asmFactory) {
        if (asmFactory != null) {
          return asmFactory().then(instance => {
            log('[bullet]:bullet asm lib loaded.');
            bt = instance;
          });
        } else {
          return new Promise((resolve, reject) => {
            resolve();
          });
        }
      }
      function shouldUseWasmModule() {
        {
          return true;
        }
      }
      function waitForAmmoInstantiation() {
        const errorReport = msg => {
          error(msg);
        };
        return ensureWasmModuleReady().then(() => {
          if (shouldUseWasmModule()) {
            return Promise.all([module.import('./bullet.release.wasm-1adc856c.js'), module.import('./bullet.release.wasm-e702f478.js')]).then(([{
              default: bulletWasmFactory
            }, {
              default: bulletWasmUrl
            }]) => initWASM(bulletWasmFactory, bulletWasmUrl));
          } else {
            return module.import('./bullet.release.asm-d4a3f7e0.js').then(({
              default: bulletAsmFactory
            }) => initASM(bulletAsmFactory));
          }
        }).catch(errorReport);
      }
      game.onPostInfrastructureInitDelegate.add(waitForAmmoInstantiation);

      const TriggerEventObject = {
        type: 'onTriggerEnter',
        selfCollider: null,
        otherCollider: null,
        impl: null
      };
      const CollisionEventObject = {
        type: 'onCollisionEnter',
        selfCollider: null,
        otherCollider: null,
        contacts: [],
        impl: null
      };
      const CharacterTriggerEventObject = {
        type: 'onControllerTriggerEnter',
        collider: null,
        characterController: null,
        impl: null
      };
      class BulletCache {
        constructor() {
          this.BT_TRANSFORM_0 = bt.Transform_new();
          this.BT_TRANSFORM_1 = bt.Transform_new();
          this.BT_V3_0 = bt.Vec3_new(0, 0, 0);
          this.BT_V3_1 = bt.Vec3_new(0, 0, 0);
          this.BT_V3_2 = bt.Vec3_new(0, 0, 0);
          this.BT_QUAT_0 = bt.Quat_new(0, 0, 0, 1);
        }
        static get instance() {
          if (BulletCache._instance == null) BulletCache._instance = new BulletCache();
          return BulletCache._instance;
        }
        static setWrapper(impl, type, wrap) {
          if (!this.ROOT[type]) this.ROOT[type] = {};
          this.ROOT[type][impl] = wrap;
        }
        static delWrapper(impl, type) {
          delete this.ROOT[type][impl];
        }
        static getWrapper(ptr, type) {
          return this.ROOT[type][ptr];
        }
        static isNotEmptyShape(ptr) {
          return ptr !== bt.EmptyShape_static();
        }
      }
      BulletCache._instance = void 0;
      BulletCache.ROOT = {};
      const CC_V3_0 = new Vec3();
      const CC_V3_1 = new Vec3();
      const CC_V3_2 = new Vec3();
      const CC_QUAT_0 = new Quat();
      const CC_QUAT_1 = new Quat();
      const CC_MAT4_0 = new Mat4();
      new Mat4();
      const CC_COLOR_0 = new Color$1();
      btCache.CACHE = BulletCache;

      function cocos2BulletVec3(out, v) {
        bt.Vec3_set(out, v.x, v.y, v.z);
        return out;
      }
      function bullet2CocosVec3(out, v) {
        const rawVertexBuffer = bt.HEAPF32.subarray(v / 4, v / 4 + 3);
        out.x = rawVertexBuffer[0];
        out.y = rawVertexBuffer[1];
        out.z = rawVertexBuffer[2];
        return out;
      }
      function cocos2BulletQuat(out, q) {
        bt.Quat_set(out, q.x, q.y, q.z, q.w);
        return out;
      }
      function bullet2CocosQuat(out, q) {
        const rawVertexBuffer = bt.HEAPF32.subarray(q / 4, q / 4 + 4);
        out.x = rawVertexBuffer[0];
        out.y = rawVertexBuffer[1];
        out.z = rawVertexBuffer[2];
        out.w = rawVertexBuffer[3];
        return out;
      }
      function cocos2BulletTriMesh(out, mesh) {
        const len = mesh.renderingSubMeshes.length;
        for (let i = 0; i < len; i++) {
          const subMesh = mesh.renderingSubMeshes[i];
          const geoInfo = subMesh.geometricInfo;
          if (geoInfo) {
            const primitiveMode = subMesh.primitiveMode;
            const vb = geoInfo.positions;
            const ib = geoInfo.indices;
            const v0 = BulletCache.instance.BT_V3_0;
            const v1 = BulletCache.instance.BT_V3_1;
            const v2 = BulletCache.instance.BT_V3_2;
            if (primitiveMode === PrimitiveMode.TRIANGLE_LIST) {
              const cnt = ib.length;
              for (let j = 0; j < cnt; j += 3) {
                const i0 = ib[j] * 3;
                const i1 = ib[j + 1] * 3;
                const i2 = ib[j + 2] * 3;
                bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2, false);
              }
            } else if (primitiveMode === PrimitiveMode.TRIANGLE_STRIP) {
              const cnt = ib.length - 2;
              let rev = 0;
              for (let j = 0; j < cnt; j += 1) {
                const i0 = ib[j - rev] * 3;
                const i1 = ib[j + rev + 1] * 3;
                const i2 = ib[j + 2] * 3;
                rev = ~rev;
                bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2, false);
              }
            } else if (primitiveMode === PrimitiveMode.TRIANGLE_FAN) {
              const cnt = ib.length - 1;
              const i0 = ib[0] * 3;
              bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              for (let j = 1; j < cnt; j += 1) {
                const i1 = ib[j] * 3;
                const i2 = ib[j + 1] * 3;
                bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                bt.TriangleMesh_addTriangle(out, v0, v1, v2, false);
              }
            }
          }
        }
        return out;
      }
      function force2Impulse(force, dt) {
        return force * dt;
      }

      var _dec$F, _dec2$B, _dec3$q, _dec4$l, _dec5$j, _class$E, _class2$B, _initializer$A, _initializer2$x, _initializer3$n, _initializer4$h, _class3$h;
      let PhysicsMaterial = (_dec$F = ccclass$6('cc.PhysicsMaterial'), _dec2$B = type$6(CCFloat), _dec3$q = type$6(CCFloat), _dec4$l = type$6(CCFloat), _dec5$j = type$6(CCFloat), _dec$F(_class$E = (_class2$B = (_class3$h = class PhysicsMaterial extends Asset {
        get friction() {
          return this._friction;
        }
        set friction(value) {
          if (!equals$1(this._friction, value)) {
            this._friction = value;
            this.emit(PhysicsMaterial.EVENT_UPDATE);
          }
        }
        get rollingFriction() {
          return this._rollingFriction;
        }
        set rollingFriction(value) {
          if (!equals$1(this._rollingFriction, value)) {
            this._rollingFriction = value;
            this.emit(PhysicsMaterial.EVENT_UPDATE);
          }
        }
        get spinningFriction() {
          return this._spinningFriction;
        }
        set spinningFriction(value) {
          if (!equals$1(this._spinningFriction, value)) {
            this._spinningFriction = value;
            this.emit(PhysicsMaterial.EVENT_UPDATE);
          }
        }
        get restitution() {
          return this._restitution;
        }
        set restitution(value) {
          if (!equals$1(this._restitution, value)) {
            this._restitution = value;
            this.emit(PhysicsMaterial.EVENT_UPDATE);
          }
        }
        constructor() {
          super();
          this.id = void 0;
          this._friction = _initializer$A && _initializer$A();
          this._rollingFriction = _initializer2$x && _initializer2$x();
          this._spinningFriction = _initializer3$n && _initializer3$n();
          this._restitution = _initializer4$h && _initializer4$h();
          PhysicsMaterial.allMaterials.push(this);
          this.id = PhysicsMaterial._idCounter++;
          if (!this._uuid) this._uuid = `pm_${this.id}`;
        }
        clone() {
          const c = new PhysicsMaterial();
          c._friction = this._friction;
          c._restitution = this._restitution;
          c._rollingFriction = this._rollingFriction;
          c._spinningFriction = this._spinningFriction;
          return c;
        }
        destroy() {
          if (super.destroy()) {
            const idx = PhysicsMaterial.allMaterials.indexOf(this);
            if (idx >= 0) {
              PhysicsMaterial.allMaterials.splice(idx, 1);
            }
            return true;
          }
          return false;
        }
        setValues(friction, rollingFriction, spinningFriction, restitution) {
          const emitUpdate = this._friction !== friction || this._rollingFriction !== rollingFriction || this._spinningFriction !== spinningFriction || this._restitution !== restitution;
          this._friction = friction;
          this._rollingFriction = rollingFriction;
          this._spinningFriction = spinningFriction;
          this._restitution = restitution;
          if (emitUpdate) this.emit(PhysicsMaterial.EVENT_UPDATE);
        }
      }, _class3$h.allMaterials = [], _class3$h.EVENT_UPDATE = 'event_update', _class3$h._idCounter = 0, _class3$h), (_applyDecoratedDescriptor(_class2$B.prototype, "friction", [_dec2$B], Object.getOwnPropertyDescriptor(_class2$B.prototype, "friction"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "rollingFriction", [_dec3$q], Object.getOwnPropertyDescriptor(_class2$B.prototype, "rollingFriction"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "spinningFriction", [_dec4$l], Object.getOwnPropertyDescriptor(_class2$B.prototype, "spinningFriction"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "restitution", [_dec5$j], Object.getOwnPropertyDescriptor(_class2$B.prototype, "restitution"), _class2$B.prototype), _initializer$A = applyDecoratedInitializer(_class2$B.prototype, "_friction", [serializable$6], function () {
        return 0.6;
      }), _initializer2$x = applyDecoratedInitializer(_class2$B.prototype, "_rollingFriction", [serializable$6], function () {
        return 0.0;
      }), _initializer3$n = applyDecoratedInitializer(_class2$B.prototype, "_spinningFriction", [serializable$6], function () {
        return 0.0;
      }), _initializer4$h = applyDecoratedInitializer(_class2$B.prototype, "_restitution", [serializable$6], function () {
        return 0.0;
      })), _class2$B)) || _class$E); exports({ PhysicsMaterial: PhysicsMaterial, PhysicMaterial: PhysicsMaterial });

      class PhysicsRayResult {
        constructor() {
          this._hitPoint = new Vec3();
          this._hitNormal = new Vec3();
          this._distance = 0;
          this._collider = null;
        }
        get hitPoint() {
          return this._hitPoint;
        }
        get distance() {
          return this._distance;
        }
        get collider() {
          return this._collider;
        }
        get hitNormal() {
          return this._hitNormal;
        }
        _assign(hitPoint, distance, collider, hitNormal) {
          Vec3.copy(this._hitPoint, hitPoint);
          Vec3.copy(this._hitNormal, hitNormal);
          this._distance = distance;
          this._collider = collider;
        }
        clone() {
          const c = new PhysicsRayResult();
          Vec3.copy(c._hitPoint, this._hitPoint);
          Vec3.copy(c._hitNormal, this._hitNormal);
          c._distance = this._distance;
          c._collider = this._collider;
          return c;
        }
      } exports('PhysicsRayResult', PhysicsRayResult);
      class PhysicsLineStripCastResult extends PhysicsRayResult {
        constructor(...args) {
          super(...args);
          this._id = 0;
        }
        get id() {
          return this._id;
        }
        _assign(hitPoint, distance, collider, hitNormal, id = 0) {
          super._assign(hitPoint, distance, collider, hitNormal);
          this._id = id;
        }
        clone() {
          const c = new PhysicsLineStripCastResult();
          Vec3.copy(c._hitPoint, this._hitPoint);
          Vec3.copy(c._hitNormal, this._hitNormal);
          c._distance = this._distance;
          c._collider = this._collider;
          c._id = this._id;
          return c;
        }
      } exports('PhysicsLineStripCastResult', PhysicsLineStripCastResult);

      class CollisionMatrix {
        constructor(strategy) {
          if (strategy === 1) {
            const self = this;
            for (let i = 0; i < 32; i++) {
              const key = `_${1 << i}`;
              self[key] = 0;
              self.updateArray = [];
              Object.defineProperty(self, 1 << i, {
                get() {
                  return this[key];
                },
                set(v) {
                  if (this[key] !== v) {
                    this[key] = v;
                    if (this.updateArray.indexOf(i) < 0) {
                      this.updateArray.push(i);
                    }
                  }
                }
              });
            }
            this['_1'] = PhysicsGroup.DEFAULT;
          } else {
            for (let i = 0; i < 32; i++) {
              const key = 1 << i;
              this[`${key}`] = 0;
            }
            this['1'] = PhysicsGroup.DEFAULT;
          }
        }
      }

      legacyCC.internal.PhysicsGroup = PhysicsGroup;
      class PhysicsSystem extends System {
        static get PHYSICS_NONE() {
          return !selector.id;
        }
        static get PHYSICS_BUILTIN() {
          return selector.id === 'builtin';
        }
        static get PHYSICS_CANNON() {
          return selector.id === 'cannon.js';
        }
        static get PHYSICS_BULLET() {
          return selector.id === 'bullet';
        }
        static get PHYSICS_PHYSX() {
          return selector.id === 'physx';
        }
        static get PhysicsGroup() {
          return PhysicsGroup;
        }
        static get instance() {
          return PhysicsSystem._instance;
        }
        get enable() {
          return this._enable;
        }
        set enable(value) {
          this._enable = value;
        }
        get allowSleep() {
          return this._allowSleep;
        }
        set allowSleep(v) {
          this._allowSleep = v;
          if (this.physicsWorld) {
            this.physicsWorld.setAllowSleep(v);
          }
        }
        get maxSubSteps() {
          return this._maxSubSteps;
        }
        set maxSubSteps(value) {
          this._maxSubSteps = value;
        }
        get fixedTimeStep() {
          return this._fixedTimeStep;
        }
        set fixedTimeStep(value) {
          this._fixedTimeStep = value;
        }
        get gravity() {
          return this._gravity;
        }
        set gravity(gravity) {
          this._gravity.set(gravity);
          if (this.physicsWorld) {
            this.physicsWorld.setGravity(gravity);
          }
        }
        get sleepThreshold() {
          return this._sleepThreshold;
        }
        set sleepThreshold(v) {
          this._sleepThreshold = v;
        }
        get autoSimulation() {
          return this._autoSimulation;
        }
        set autoSimulation(value) {
          this._autoSimulation = value;
        }
        get defaultMaterial() {
          return this._material;
        }
        setDefaultPhysicsMaterial(material) {
          this._material = material;
          this.physicsWorld.setDefaultMaterial(this._material);
          this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
        }
        initDefaultMaterial() {
          if (this._material != null) return Promise.resolve();
          const builtinMaterial = builtinResMgr.get('default-physics-material');
          if (!builtinMaterial) {
            console.error('PhysicsSystem initDefaultMaterial() Failed to load builtinMaterial');
            return Promise.resolve();
          }
          const userMaterial = settings.querySettings(Settings.Category.PHYSICS, 'defaultMaterial');
          if (!userMaterial) {
            this.setDefaultPhysicsMaterial(builtinMaterial);
            return Promise.resolve();
          } else {
            return new Promise((resolve, reject) => {
              assetManager.loadAny(userMaterial, (err, asset) => err || !(asset instanceof PhysicsMaterial) ? reject(err) : resolve(asset));
            }).then(asset => {
              this.setDefaultPhysicsMaterial(asset);
            }).catch(reason => {
              warn(reason);
              warn(`Failed to load user customized default physics material: ${userMaterial}, will fallback to built-in default physics material`);
              this.setDefaultPhysicsMaterial(builtinMaterial);
            });
          }
        }
        get physicsWorld() {
          return selector.physicsWorld;
        }
        constructor() {
          super();
          this.raycastClosestResult = new PhysicsRayResult();
          this.raycastResults = [];
          this.lineStripCastClosestResult = new PhysicsLineStripCastResult();
          this.lineStripCastResults = [];
          this.sweepCastClosestResult = new PhysicsRayResult();
          this.sweepCastResults = [];
          this.collisionMatrix = new CollisionMatrix(1);
          this.minVolumeSize = 1e-5;
          this.useNodeChains = false;
          this._enable = true;
          this._allowSleep = true;
          this._maxSubSteps = 1;
          this._subStepCount = 0;
          this._fixedTimeStep = 1.0 / 60.0;
          this._autoSimulation = true;
          this._accumulator = 0;
          this._sleepThreshold = 0.1;
          this._gravity = new Vec3(0, -10, 0);
          this._material = void 0;
          this.raycastOptions = {
            group: -1,
            mask: -1,
            queryTrigger: true,
            maxDistance: 10000000
          };
          this.raycastResultPool = new RecyclePool(() => new PhysicsRayResult(), 1);
          this.sweepResultPool = new RecyclePool(() => new PhysicsRayResult(), 1);
        }
        postUpdate(deltaTime) {
          if (!this.physicsWorld) return;
          if (!this._enable) {
            this.physicsWorld.syncSceneToPhysics();
            return;
          }
          if (this._autoSimulation) {
            this._subStepCount = 0;
            this._accumulator += deltaTime;
            director.emit(Director.EVENT_BEFORE_PHYSICS);
            while (this._subStepCount < this._maxSubSteps) {
              if (this._accumulator >= this._fixedTimeStep) {
                this.physicsWorld.syncSceneToPhysics();
                this.physicsWorld.step(this._fixedTimeStep);
                this.physicsWorld.emitEvents();
                this.physicsWorld.syncAfterEvents();
                this._accumulator -= this._fixedTimeStep;
                this._subStepCount++;
              } else {
                this.physicsWorld.syncSceneToPhysics();
                break;
              }
            }
            director.emit(Director.EVENT_AFTER_PHYSICS);
          }
        }
        resetConfiguration(config) {
          const allowSleep = config ? config.allowSleep : settings.querySettings(Settings.Category.PHYSICS, 'allowSleep');
          if (typeof allowSleep === 'boolean') this._allowSleep = allowSleep;
          const fixedTimeStep = config ? config.fixedTimeStep : settings.querySettings(Settings.Category.PHYSICS, 'fixedTimeStep');
          if (typeof fixedTimeStep === 'number') this._fixedTimeStep = fixedTimeStep;
          const maxSubSteps = config ? config.maxSubSteps : settings.querySettings(Settings.Category.PHYSICS, 'maxSubSteps');
          if (typeof maxSubSteps === 'number') this._maxSubSteps = maxSubSteps;
          const sleepThreshold = config ? config.sleepThreshold : settings.querySettings(Settings.Category.PHYSICS, 'sleepThreshold');
          if (typeof sleepThreshold === 'number') this._sleepThreshold = sleepThreshold;
          const autoSimulation = config ? config.autoSimulation : settings.querySettings(Settings.Category.PHYSICS, 'autoSimulation');
          if (typeof autoSimulation === 'boolean') this.autoSimulation = autoSimulation;
          const gravity = config ? config.gravity : settings.querySettings(Settings.Category.PHYSICS, 'gravity');
          if (gravity) Vec3.copy(this._gravity, gravity);
          const collisionMatrix = config ? config.collisionMatrix : settings.querySettings(Settings.Category.PHYSICS, 'collisionMatrix');
          if (collisionMatrix) {
            for (const i in collisionMatrix) {
              this.collisionMatrix[`${1 << parseInt(i)}`] = collisionMatrix[i];
            }
          }
          const collisionGroups = config ? config.collisionGroups : settings.querySettings(Settings.Category.PHYSICS, 'collisionGroups');
          if (collisionGroups) {
            const cg = collisionGroups;
            if (cg instanceof Array) {
              cg.forEach(v => {
                PhysicsGroup[v.name] = 1 << v.index;
              });
              Enum.update(PhysicsGroup);
            }
          }
          if (this.physicsWorld) {
            this.physicsWorld.setGravity(this._gravity);
            this.physicsWorld.setAllowSleep(this._allowSleep);
          }
        }
        resetAccumulator(time = 0) {
          this._accumulator = time;
        }
        step(fixedTimeStep, deltaTime, maxSubSteps) {
          if (this.physicsWorld) this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
        }
        syncSceneToPhysics() {
          if (this.physicsWorld) this.physicsWorld.syncSceneToPhysics();
        }
        emitEvents() {
          if (this.physicsWorld) this.physicsWorld.emitEvents();
        }
        get debugDrawFlags() {
          return this.physicsWorld.debugDrawFlags;
        }
        set debugDrawFlags(v) {
          this.physicsWorld.debugDrawFlags = v;
        }
        get debugDrawConstraintSize() {
          return this.physicsWorld.debugDrawConstraintSize;
        }
        set debugDrawConstraintSize(v) {
          this.physicsWorld.debugDrawConstraintSize = v;
        }
        raycast(worldRay, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.raycastResultPool.reset();
          this.raycastResults.length = 0;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
        }
        raycastClosest(worldRay, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
        }
        lineStripCast(samplePointsWorldSpace, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (samplePointsWorldSpace.length < 2) return false;
          this.lineStripCastResults = [];
          let distance = 0;
          const worldRay = new Ray();
          for (let i = 1; i < samplePointsWorldSpace.length; ++i) {
            if (distance > maxDistance) break;
            const fromPoint = samplePointsWorldSpace[i - 1];
            const toPoint = samplePointsWorldSpace[i];
            const direction = new Vec3();
            Vec3.subtract(direction, toPoint, fromPoint);
            const stepLength = Vec3.len(direction);
            distance += stepLength;
            Vec3.multiplyScalar(direction, direction, 1.0 / stepLength);
            worldRay.d = direction;
            worldRay.o = fromPoint;
            const hit = this.raycast(worldRay, mask, stepLength, queryTrigger);
            if (hit) {
              for (let re = 0; re < this.raycastResults.length; re++) {
                const result = this.raycastResults[re];
                if (re === 0 && Vec3.equals(fromPoint, result.hitPoint)) {
                  continue;
                }
                const copiedResult = new PhysicsLineStripCastResult();
                copiedResult._assign(result.hitPoint, result.distance, result.collider, result.hitNormal, i - 1);
                this.lineStripCastResults.push(copiedResult);
              }
            }
          }
          return this.lineStripCastResults.length > 0;
        }
        lineStripCastClosest(samplePointsWorldSpace, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (samplePointsWorldSpace.length < 2) {
            return false;
          }
          let distance = 0;
          const worldRay = new Ray();
          let hit = false;
          for (let i = 1; i < samplePointsWorldSpace.length; ++i) {
            if (distance > maxDistance) break;
            const fromPoint = samplePointsWorldSpace[i - 1];
            const toPoint = samplePointsWorldSpace[i];
            const direction = new Vec3();
            Vec3.subtract(direction, toPoint, fromPoint);
            const stepLength = Vec3.len(direction);
            distance += stepLength;
            Vec3.multiplyScalar(direction, direction, 1.0 / stepLength);
            worldRay.d = direction;
            worldRay.o = fromPoint;
            hit = this.raycastClosest(worldRay, mask, stepLength, queryTrigger);
            if (hit) {
              const result = this.raycastClosestResult;
              const copiedResult = new PhysicsLineStripCastResult();
              copiedResult._assign(result.hitPoint, result.distance, result.collider, result.hitNormal, i - 1);
              this.lineStripCastClosestResult = copiedResult;
              break;
            }
          }
          return hit;
        }
        sweepBox(worldRay, halfExtent, orientation, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.sweepResultPool.reset();
          this.sweepCastResults.length = 0;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepBox(worldRay, halfExtent, orientation, this.raycastOptions, this.sweepResultPool, this.sweepCastResults);
        }
        sweepBoxClosest(worldRay, halfExtent, orientation, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepBoxClosest(worldRay, halfExtent, orientation, this.raycastOptions, this.sweepCastClosestResult);
        }
        sweepSphere(worldRay, radius, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.sweepResultPool.reset();
          this.sweepCastResults.length = 0;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepSphere(worldRay, radius, this.raycastOptions, this.sweepResultPool, this.sweepCastResults);
        }
        sweepSphereClosest(worldRay, radius, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepSphereClosest(worldRay, radius, this.raycastOptions, this.sweepCastClosestResult);
        }
        sweepCapsule(worldRay, radius, height, orientation, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.sweepResultPool.reset();
          this.sweepCastResults.length = 0;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepCapsule(worldRay, radius, height, orientation, this.raycastOptions, this.sweepResultPool, this.sweepCastResults);
        }
        sweepCapsuleClosest(worldRay, radius, height, orientation, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
          if (!this.physicsWorld) return false;
          this.raycastOptions.mask = mask >>> 0;
          this.raycastOptions.maxDistance = maxDistance;
          this.raycastOptions.queryTrigger = queryTrigger;
          return this.physicsWorld.sweepCapsuleClosest(worldRay, radius, height, orientation, this.raycastOptions, this.sweepCastClosestResult);
        }
        _updateMaterial() {
          if (this.physicsWorld) this.physicsWorld.setDefaultMaterial(this._material);
        }
        static constructAndRegister() {
          var _settings$querySettin;
          const enabled = (_settings$querySettin = settings.querySettings(Settings.Category.PHYSICS, 'enabled')) !== null && _settings$querySettin !== void 0 ? _settings$querySettin : true;
          if (!enabled) {
            return;
          }
          if (!PhysicsSystem._instance) {
            const sys = new PhysicsSystem();
            PhysicsSystem._instance = sys;
            sys.resetConfiguration();
            constructDefaultWorld(sys);
            director.registerSystem(PhysicsSystem.ID, sys, sys.priority);
            game.onPostProjectInitDelegate.add(sys.initDefaultMaterial.bind(sys));
          }
        }
      } exports('PhysicsSystem', PhysicsSystem);
      PhysicsSystem.ID = 'PHYSICS';
      PhysicsSystem._instance = null;
      director.once(Director.EVENT_INIT, () => {
        PhysicsSystem.constructAndRegister();
      });

      var _dec$E, _dec2$A, _dec3$p, _dec4$k, _class$D, _class2$A, _initializer$z, _initializer2$w, _initializer3$m, _initializer4$g, _initializer5$d, _initializer6$a, _initializer7$9, _initializer8$8, _initializer9$8, _class3$g;
      let RigidBody = (_dec$E = ccclass$6('cc.RigidBody'), _dec2$A = executionOrder$1(-1), _dec3$p = type$6(PhysicsSystem.PhysicsGroup), _dec4$k = type$6(ERigidBodyType), _dec$E(_class$D = disallowMultiple$1(_class$D = _dec2$A(_class$D = (_class2$A = (_class3$g = class RigidBody extends Component {
        constructor(...args) {
          super(...args);
          this._body = null;
          this._group = _initializer$z && _initializer$z();
          this._type = _initializer2$w && _initializer2$w();
          this._mass = _initializer3$m && _initializer3$m();
          this._allowSleep = _initializer4$g && _initializer4$g();
          this._linearDamping = _initializer5$d && _initializer5$d();
          this._angularDamping = _initializer6$a && _initializer6$a();
          this._useGravity = _initializer7$9 && _initializer7$9();
          this._linearFactor = _initializer8$8 && _initializer8$8();
          this._angularFactor = _initializer9$8 && _initializer9$8();
        }
        get group() {
          return this._group;
        }
        set group(v) {
          if (!Number.isInteger(Math.log2(v >>> 0))) warn('[Physics]: The group should only have one bit.');
          this._group = v;
          if (this._body) {
            if (this._body.getGroup() !== v) this._body.setGroup(v);
          }
        }
        get type() {
          return this._type;
        }
        set type(v) {
          if (this._type === v) return;
          this._type = v;
          if (this._body) this._body.setType(v);
        }
        get mass() {
          return this._mass;
        }
        set mass(value) {
          if (value <= 0) warn('[Physics]: The mass should be greater than zero.');
          if (this._mass === value) return;
          value = value <= 0 ? 0.0001 : value;
          this._mass = value;
          if (this._body) this._body.setMass(value);
        }
        get allowSleep() {
          return this._allowSleep;
        }
        set allowSleep(v) {
          this._allowSleep = v;
          if (this._body) this._body.setAllowSleep(v);
        }
        get linearDamping() {
          return this._linearDamping;
        }
        set linearDamping(value) {
          if ((value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
          this._linearDamping = value;
          if (this._body) this._body.setLinearDamping(value);
        }
        get angularDamping() {
          return this._angularDamping;
        }
        set angularDamping(value) {
          if ((value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
          this._angularDamping = value;
          if (this._body) this._body.setAngularDamping(value);
        }
        get useGravity() {
          return this._useGravity;
        }
        set useGravity(value) {
          this._useGravity = value;
          if (this._body) this._body.useGravity(value);
        }
        get linearFactor() {
          return this._linearFactor;
        }
        set linearFactor(value) {
          Vec3.copy(this._linearFactor, value);
          if (this._body) {
            this._body.setLinearFactor(this._linearFactor);
          }
        }
        get angularFactor() {
          return this._angularFactor;
        }
        set angularFactor(value) {
          Vec3.copy(this._angularFactor, value);
          if (this._body) {
            this._body.setAngularFactor(this._angularFactor);
          }
        }
        get sleepThreshold() {
          if (this._isInitialized) {
            return this._body.getSleepThreshold();
          }
          return 0.1;
        }
        set sleepThreshold(v) {
          if (this._isInitialized) {
            this._body.setSleepThreshold(v);
          }
        }
        get useCCD() {
          if (this._isInitialized) {
            return this._body.isUsingCCD();
          }
          return false;
        }
        set useCCD(v) {
          if (this._isInitialized) {
            this._body.useCCD(v);
          }
        }
        get isAwake() {
          if (this._isInitialized) return this._body.isAwake;
          return false;
        }
        get isSleepy() {
          if (this._isInitialized) return this._body.isSleepy;
          return false;
        }
        get isSleeping() {
          if (this._isInitialized) return this._body.isSleeping;
          return false;
        }
        get isStatic() {
          return this._type === ERigidBodyType.STATIC;
        }
        set isStatic(v) {
          if (v && this.isStatic || !v && !this.isStatic) return;
          this.type = v ? ERigidBodyType.STATIC : ERigidBodyType.DYNAMIC;
        }
        get isDynamic() {
          return this._type === ERigidBodyType.DYNAMIC;
        }
        set isDynamic(v) {
          if (v && this.isDynamic || !v && !this.isDynamic) return;
          this.type = v ? ERigidBodyType.DYNAMIC : ERigidBodyType.KINEMATIC;
        }
        get isKinematic() {
          return this._type === ERigidBodyType.KINEMATIC;
        }
        set isKinematic(v) {
          if (v && this.isKinematic || !v && !this.isKinematic) return;
          this.type = v ? ERigidBodyType.KINEMATIC : ERigidBodyType.DYNAMIC;
        }
        get body() {
          return this._body;
        }
        get _isInitialized() {
          const r = this._body === null;
          if (r) {
            error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
          }
          return !r;
        }
        onLoad() {
          if (!selector.runInEditor) return;
          this._body = createRigidBody();
          this._body.initialize(this);
        }
        onEnable() {
          if (this._body) this._body.onEnable();
        }
        onDisable() {
          if (this._body) this._body.onDisable();
        }
        onDestroy() {
          if (this._body) this._body.onDestroy();
        }
        applyForce(force, relativePoint) {
          if (this._isInitialized) this._body.applyForce(force, relativePoint);
        }
        applyLocalForce(force, localPoint) {
          if (this._isInitialized) this._body.applyLocalForce(force, localPoint);
        }
        applyImpulse(impulse, relativePoint) {
          if (this._isInitialized) this._body.applyImpulse(impulse, relativePoint);
        }
        applyLocalImpulse(impulse, localPoint) {
          if (this._isInitialized) this._body.applyLocalImpulse(impulse, localPoint);
        }
        applyTorque(torque) {
          if (this._isInitialized) this._body.applyTorque(torque);
        }
        applyLocalTorque(torque) {
          if (this._isInitialized) this._body.applyLocalTorque(torque);
        }
        wakeUp() {
          if (this._isInitialized) this._body.wakeUp();
        }
        sleep() {
          if (this._isInitialized) this._body.sleep();
        }
        clearState() {
          if (this._isInitialized) this._body.clearState();
        }
        clearForces() {
          if (this._isInitialized) this._body.clearForces();
        }
        clearVelocity() {
          if (this._isInitialized) this._body.clearVelocity();
        }
        getLinearVelocity(out) {
          if (this._isInitialized) this._body.getLinearVelocity(out);
        }
        setLinearVelocity(value) {
          if (this._isInitialized) this._body.setLinearVelocity(value);
        }
        getAngularVelocity(out) {
          if (this._isInitialized) this._body.getAngularVelocity(out);
        }
        setAngularVelocity(value) {
          if (this._isInitialized) this._body.setAngularVelocity(value);
        }
        getGroup() {
          if (this._isInitialized) return this._body.getGroup();
          return 0;
        }
        setGroup(v) {
          if (this._isInitialized) this._body.setGroup(v);
        }
        addGroup(v) {
          if (this._isInitialized) this._body.addGroup(v);
        }
        removeGroup(v) {
          if (this._isInitialized) this._body.removeGroup(v);
        }
        getMask() {
          if (this._isInitialized) return this._body.getMask();
          return 0;
        }
        setMask(v) {
          if (this._isInitialized) this._body.setMask(v);
        }
        addMask(v) {
          if (this._isInitialized) this._body.addMask(v);
        }
        removeMask(v) {
          if (this._isInitialized) this._body.removeMask(v);
        }
      }, _class3$g.Type = ERigidBodyType, _class3$g), (_applyDecoratedDescriptor(_class2$A.prototype, "group", [_dec3$p], Object.getOwnPropertyDescriptor(_class2$A.prototype, "group"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "type", [_dec4$k], Object.getOwnPropertyDescriptor(_class2$A.prototype, "type"), _class2$A.prototype), _initializer$z = applyDecoratedInitializer(_class2$A.prototype, "_group", [serializable$6], function () {
        return PhysicsSystem.PhysicsGroup.DEFAULT;
      }), _initializer2$w = applyDecoratedInitializer(_class2$A.prototype, "_type", [serializable$6], function () {
        return ERigidBodyType.DYNAMIC;
      }), _initializer3$m = applyDecoratedInitializer(_class2$A.prototype, "_mass", [serializable$6], function () {
        return 1;
      }), _initializer4$g = applyDecoratedInitializer(_class2$A.prototype, "_allowSleep", [serializable$6], function () {
        return true;
      }), _initializer5$d = applyDecoratedInitializer(_class2$A.prototype, "_linearDamping", [serializable$6], function () {
        return 0.1;
      }), _initializer6$a = applyDecoratedInitializer(_class2$A.prototype, "_angularDamping", [serializable$6], function () {
        return 0.1;
      }), _initializer7$9 = applyDecoratedInitializer(_class2$A.prototype, "_useGravity", [serializable$6], function () {
        return true;
      }), _initializer8$8 = applyDecoratedInitializer(_class2$A.prototype, "_linearFactor", [serializable$6], function () {
        return new Vec3(1, 1, 1);
      }), _initializer9$8 = applyDecoratedInitializer(_class2$A.prototype, "_angularFactor", [serializable$6], function () {
        return new Vec3(1, 1, 1);
      })), _class2$A)) || _class$D) || _class$D) || _class$D); exports({ RigidBody: RigidBody, RigidBodyComponent: RigidBody });
      (function (_RigidBody) {})(RigidBody || ((RigidBody = {}, exports({ RigidBody: RigidBody, RigidBodyComponent: RigidBody }), RigidBody)));

      var _dec$D, _dec2$z, _dec3$o, _dec4$j, _dec5$i, _class$C, _class2$z, _initializer$y, _initializer2$v, _initializer3$l, _class3$f;
      let Collider = (_dec$D = ccclass$6('cc.Collider'), _dec2$z = type$6(RigidBody), _dec3$o = type$6(PhysicsMaterial), _dec4$j = type$6(Vec3), _dec5$i = type$6(PhysicsMaterial), _dec$D(_class$C = (_class2$z = (_class3$f = class Collider extends Eventify(Component) {
        get attachedRigidBody() {
          return findAttachedBody(this.node);
        }
        get sharedMaterial() {
          return this._material;
        }
        set sharedMaterial(value) {
          {
            this.material = value;
          }
        }
        get material() {
          if (this._isSharedMaterial && this._material) {
            this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
            this._material = this._material.clone();
            this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
            this._isSharedMaterial = false;
          }
          return this._material;
        }
        set material(value) {
          if (this._shape) {
            if (value && this._material) {
              if (this._material.id !== value.id) {
                this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                this._isSharedMaterial = false;
                this._material = value;
              }
            } else if (value && !this._material) {
              value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
              this._material = value;
            } else if (!value && this._material) {
              this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
              this._material = value;
            }
            this._updateMaterial();
          } else {
            this._material = value;
          }
        }
        get isTrigger() {
          return this._isTrigger;
        }
        set isTrigger(value) {
          this._isTrigger = value;
          if (this._shape) {
            this._shape.setAsTrigger(this._isTrigger);
          }
        }
        get center() {
          return this._center;
        }
        set center(value) {
          Vec3.copy(this._center, value);
          if (this._shape) {
            this._shape.setCenter(this._center);
          }
        }
        get shape() {
          return this._shape;
        }
        get worldBounds() {
          if (this._aabb == null) this._aabb = new AABB();
          if (this._shape) this._shape.getAABB(this._aabb);
          return this._aabb;
        }
        get boundingSphere() {
          if (this._boundingSphere == null) this._boundingSphere = new Sphere();
          if (this._shape) this._shape.getBoundingSphere(this._boundingSphere);
          return this._boundingSphere;
        }
        get needTriggerEvent() {
          return this._needTriggerEvent;
        }
        get needCollisionEvent() {
          return this._needCollisionEvent;
        }
        get _isInitialized() {
          const r = this._shape === null;
          if (r) {
            error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
          }
          return !r;
        }
        constructor(type) {
          super();
          this.type = void 0;
          this._shape = null;
          this._aabb = null;
          this._boundingSphere = null;
          this._isSharedMaterial = true;
          this._needTriggerEvent = false;
          this._needCollisionEvent = false;
          this._material = _initializer$y && _initializer$y();
          this._isTrigger = _initializer2$v && _initializer2$v();
          this._center = _initializer3$l && _initializer3$l();
          this.type = type;
        }
        on(type, callback, target, once) {
          const ret = super.on(type, callback, target, once);
          this._updateNeedEvent(type);
          return ret;
        }
        off(type, callback, target) {
          super.off(type, callback, target);
          this._updateNeedEvent();
        }
        once(type, callback, target) {
          const ret = super.once(type, callback, target);
          this._updateNeedEvent(type);
          return ret;
        }
        removeAll(typeOrTarget) {
          super.removeAll(typeOrTarget);
          this._updateNeedEvent();
        }
        getGroup() {
          if (this._isInitialized) {
            return this._shape.getGroup();
          }
          return 0;
        }
        setGroup(v) {
          if (this._isInitialized) {
            this._shape.setGroup(v);
          }
        }
        addGroup(v) {
          if (this._isInitialized) {
            this._shape.addGroup(v);
          }
        }
        removeGroup(v) {
          if (this._isInitialized) {
            this._shape.removeGroup(v);
          }
        }
        getMask() {
          if (this._isInitialized) {
            return this._shape.getMask();
          }
          return 0;
        }
        setMask(v) {
          if (this._isInitialized) {
            this._shape.setMask(v);
          }
        }
        addMask(v) {
          if (this._isInitialized) {
            this._shape.addMask(v);
          }
        }
        removeMask(v) {
          if (this._isInitialized) {
            this._shape.removeMask(v);
          }
        }
        onLoad() {
          if (!selector.runInEditor) return;
          this.sharedMaterial = this._material;
          this._shape = createShape(this.type);
          this._shape.initialize(this);
          this._shape.onLoad();
        }
        onEnable() {
          if (this._shape) {
            this._shape.onEnable();
          }
        }
        onDisable() {
          if (this._shape) {
            this._shape.onDisable();
          }
        }
        onDestroy() {
          if (this._shape) {
            this._needTriggerEvent = false;
            this._needCollisionEvent = false;
            this._shape.updateEventListener();
            if (this._material) this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
            this._shape.onDestroy();
          }
          if (this._boundingSphere) this._boundingSphere.destroy();
        }
        _updateMaterial() {
          if (this._shape) this._shape.setMaterial(this._material);
        }
        _updateNeedEvent(type) {
          if (this.isValid) {
            if (type !== undefined) {
              if (type === 'onCollisionEnter' || type === 'onCollisionStay' || type === 'onCollisionExit') {
                this._needCollisionEvent = true;
              }
              if (type === 'onTriggerEnter' || type === 'onTriggerStay' || type === 'onTriggerExit' || type === 'onControllerTriggerEnter' || type === 'onControllerTriggerStay' || type === 'onControllerTriggerExit') {
                this._needTriggerEvent = true;
              }
            } else {
              if (!(this.hasEventListener('onTriggerEnter') || this.hasEventListener('onTriggerStay') || this.hasEventListener('onTriggerExit') || this.hasEventListener('onControllerTriggerEnter') || this.hasEventListener('onControllerTriggerStay') || this.hasEventListener('onControllerTriggerExit'))) {
                this._needTriggerEvent = false;
              }
              if (!(this.hasEventListener('onCollisionEnter') || this.hasEventListener('onCollisionStay') || this.hasEventListener('onCollisionExit'))) {
                this._needCollisionEvent = false;
              }
            }
            if (this._shape) this._shape.updateEventListener();
          }
        }
      }, _class3$f.Type = EColliderType, _class3$f.Axis = EAxisDirection, _class3$f), (_applyDecoratedDescriptor(_class2$z.prototype, "attachedRigidBody", [_dec2$z], Object.getOwnPropertyDescriptor(_class2$z.prototype, "attachedRigidBody"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "sharedMaterial", [_dec3$o], Object.getOwnPropertyDescriptor(_class2$z.prototype, "sharedMaterial"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "center", [_dec4$j], Object.getOwnPropertyDescriptor(_class2$z.prototype, "center"), _class2$z.prototype), _initializer$y = applyDecoratedInitializer(_class2$z.prototype, "_material", [_dec5$i], function () {
        return null;
      }), _initializer2$v = applyDecoratedInitializer(_class2$z.prototype, "_isTrigger", [serializable$6], function () {
        return false;
      }), _initializer3$l = applyDecoratedInitializer(_class2$z.prototype, "_center", [serializable$6], function () {
        return new Vec3();
      })), _class2$z)) || _class$C); exports({ Collider: Collider, ColliderComponent: Collider });
      (function (_Collider) {})(Collider || ((Collider = {}, exports({ Collider: Collider, ColliderComponent: Collider }), Collider)));
      function findAttachedBody(node) {
        const rb = node.getComponent(RigidBody);
        if (rb && rb.isValid) {
          return rb;
        }
        return null;
      }

      var _dec$C, _dec2$y, _class$B, _class2$y, _initializer$x;
      let BoxCollider = (_dec$C = ccclass$6('cc.BoxCollider'), _dec2$y = type$6(Vec3), _dec$C(_class$B = (_class2$y = class BoxCollider extends Collider {
        get size() {
          return this._size;
        }
        set size(value) {
          if (Vec3.strictEquals(this._size, value)) return;
          Vec3.copy(this._size, value);
          absolute(this._size);
          if (this._shape) {
            this.shape.updateSize();
          }
        }
        get shape() {
          return this._shape;
        }
        constructor() {
          super(EColliderType.BOX);
          this._size = _initializer$x && _initializer$x();
        }
      }, (_applyDecoratedDescriptor(_class2$y.prototype, "size", [_dec2$y], Object.getOwnPropertyDescriptor(_class2$y.prototype, "size"), _class2$y.prototype), _initializer$x = applyDecoratedInitializer(_class2$y.prototype, "_size", [serializable$6], function () {
        return new Vec3(1, 1, 1);
      })), _class2$y)) || _class$B); exports({ BoxCollider: BoxCollider, BoxColliderComponent: BoxCollider });

      var _dec$B, _class$A, _class2$x, _initializer$w;
      let SphereCollider = (_dec$B = ccclass$6('cc.SphereCollider'), _dec$B(_class$A = (_class2$x = class SphereCollider extends Collider {
        get radius() {
          return this._radius;
        }
        set radius(value) {
          if (this._radius === value) return;
          this._radius = Math.abs(value);
          if (this._shape) {
            this.shape.updateRadius();
          }
        }
        get shape() {
          return this._shape;
        }
        constructor() {
          super(EColliderType.SPHERE);
          this._radius = _initializer$w && _initializer$w();
        }
      }, (_initializer$w = applyDecoratedInitializer(_class2$x.prototype, "_radius", [serializable$6], function () {
        return 0.5;
      })), _class2$x)) || _class$A); exports({ SphereCollider: SphereCollider, SphereColliderComponent: SphereCollider });

      var _dec$A, _dec2$x, _class$z, _class2$w, _initializer$v, _initializer2$u, _initializer3$k;
      let CapsuleCollider = (_dec$A = ccclass$6('cc.CapsuleCollider'), _dec2$x = type$6(EAxisDirection), _dec$A(_class$z = (_class2$w = class CapsuleCollider extends Collider {
        get radius() {
          return this._radius;
        }
        set radius(value) {
          if (this._radius === value) return;
          this._radius = Math.abs(value);
          if (this._shape) {
            this.shape.setRadius(value);
          }
        }
        get cylinderHeight() {
          return this._cylinderHeight;
        }
        set cylinderHeight(value) {
          if (this._cylinderHeight === value) return;
          this._cylinderHeight = Math.abs(value);
          if (this._shape) {
            this.shape.setCylinderHeight(value);
          }
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          value = Math.floor(value);
          if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
          if (this._direction === value) return;
          this._direction = value;
          if (this._shape) {
            this.shape.setDirection(value);
          }
        }
        get height() {
          return this._radius * 2 + this._cylinderHeight;
        }
        set height(value) {
          let ch = value - this._radius * 2;
          if (ch < 0) ch = 0;
          this.cylinderHeight = ch;
        }
        get worldHeight() {
          return this._radius * 2 * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
        }
        get shape() {
          return this._shape;
        }
        constructor() {
          super(EColliderType.CAPSULE);
          this._radius = _initializer$v && _initializer$v();
          this._cylinderHeight = _initializer2$u && _initializer2$u();
          this._direction = _initializer3$k && _initializer3$k();
        }
        _getRadiusScale() {
          if (this.node == null) return 1;
          const ws = this.node.worldScale;
          if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(absMax(ws.x, ws.z));
          if (this._direction === EAxisDirection.X_AXIS) return Math.abs(absMax(ws.y, ws.z));
          return Math.abs(absMax(ws.x, ws.y));
        }
        _getHeightScale() {
          if (this.node == null) return 1;
          const ws = this.node.worldScale;
          if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(ws.y);
          if (this._direction === EAxisDirection.X_AXIS) return Math.abs(ws.x);
          return Math.abs(ws.z);
        }
      }, (_applyDecoratedDescriptor(_class2$w.prototype, "direction", [_dec2$x], Object.getOwnPropertyDescriptor(_class2$w.prototype, "direction"), _class2$w.prototype), _initializer$v = applyDecoratedInitializer(_class2$w.prototype, "_radius", [serializable$6], function () {
        return 0.5;
      }), _initializer2$u = applyDecoratedInitializer(_class2$w.prototype, "_cylinderHeight", [serializable$6], function () {
        return 1;
      }), _initializer3$k = applyDecoratedInitializer(_class2$w.prototype, "_direction", [serializable$6], function () {
        return EAxisDirection.Y_AXIS;
      })), _class2$w)) || _class$z); exports({ CapsuleCollider: CapsuleCollider, CapsuleColliderComponent: CapsuleCollider });

      var _dec$z, _dec2$w, _class$y, _class2$v, _initializer$u, _initializer2$t, _initializer3$j;
      let CylinderCollider = (_dec$z = ccclass$6('cc.CylinderCollider'), _dec2$w = type$6(EAxisDirection), _dec$z(_class$y = (_class2$v = class CylinderCollider extends Collider {
        get radius() {
          return this._radius;
        }
        set radius(value) {
          if (this._radius === value) return;
          this._radius = Math.abs(value);
          if (this._shape) {
            this.shape.setRadius(value);
          }
        }
        get height() {
          return this._height;
        }
        set height(value) {
          if (this._height === value) return;
          this._height = Math.abs(value);
          if (this._shape) {
            this.shape.setHeight(value);
          }
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) return;
          if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
          this._direction = value;
          if (this._shape) {
            this.shape.setDirection(value);
          }
        }
        get shape() {
          return this._shape;
        }
        constructor() {
          super(EColliderType.CYLINDER);
          this._radius = _initializer$u && _initializer$u();
          this._height = _initializer2$t && _initializer2$t();
          this._direction = _initializer3$j && _initializer3$j();
        }
      }, (_applyDecoratedDescriptor(_class2$v.prototype, "direction", [_dec2$w], Object.getOwnPropertyDescriptor(_class2$v.prototype, "direction"), _class2$v.prototype), _initializer$u = applyDecoratedInitializer(_class2$v.prototype, "_radius", [serializable$6], function () {
        return 0.5;
      }), _initializer2$t = applyDecoratedInitializer(_class2$v.prototype, "_height", [serializable$6], function () {
        return 2;
      }), _initializer3$j = applyDecoratedInitializer(_class2$v.prototype, "_direction", [serializable$6], function () {
        return EAxisDirection.Y_AXIS;
      })), _class2$v)) || _class$y); exports({ CylinderCollider: CylinderCollider, CylinderColliderComponent: CylinderCollider });

      var _dec$y, _dec2$v, _class$x, _class2$u, _initializer$t, _initializer2$s, _initializer3$i;
      let ConeCollider = exports('ConeCollider', (_dec$y = ccclass$6('cc.ConeCollider'), _dec2$v = type$6(EAxisDirection), _dec$y(_class$x = (_class2$u = class ConeCollider extends Collider {
        get radius() {
          return this._radius;
        }
        set radius(value) {
          if (this._radius === value) return;
          this._radius = Math.abs(value);
          if (this._shape) {
            this.shape.setRadius(value);
          }
        }
        get height() {
          return this._height;
        }
        set height(value) {
          if (this._height === value) return;
          if (value < 0) value = 0;
          this._height = value;
          if (this._shape) {
            this.shape.setHeight(value);
          }
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) return;
          if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
          this._direction = value;
          if (this._shape) {
            this.shape.setDirection(value);
          }
        }
        get shape() {
          return this._shape;
        }
        constructor() {
          super(EColliderType.CONE);
          this._radius = _initializer$t && _initializer$t();
          this._height = _initializer2$s && _initializer2$s();
          this._direction = _initializer3$i && _initializer3$i();
        }
      }, (_applyDecoratedDescriptor(_class2$u.prototype, "direction", [_dec2$v], Object.getOwnPropertyDescriptor(_class2$u.prototype, "direction"), _class2$u.prototype), _initializer$t = applyDecoratedInitializer(_class2$u.prototype, "_radius", [serializable$6], function () {
        return 0.5;
      }), _initializer2$s = applyDecoratedInitializer(_class2$u.prototype, "_height", [serializable$6], function () {
        return 1;
      }), _initializer3$i = applyDecoratedInitializer(_class2$u.prototype, "_direction", [serializable$6], function () {
        return EAxisDirection.Y_AXIS;
      })), _class2$u)) || _class$x));

      var _dec$x, _dec2$u, _class$w, _class2$t, _initializer$s, _initializer2$r;
      let MeshCollider = (_dec$x = ccclass$6('cc.MeshCollider'), _dec2$u = type$6(Mesh), _dec$x(_class$w = (_class2$t = class MeshCollider extends Collider {
        get mesh() {
          return this._mesh;
        }
        set mesh(value) {
          if (this._mesh === value) return;
          this._mesh = value;
          if (this._shape) this.shape.setMesh(this._mesh);
        }
        get convex() {
          return this._convex;
        }
        set convex(value) {
          if (this._convex === value) return;
          this._convex = value;
          if (this._shape && this._mesh) this.shape.setMesh(this._mesh);
        }
        get shape() {
          return this._shape;
        }
        onEnable() {
          super.onEnable();
          if (this.node) {
            const body = this.node.getComponent(RigidBody);
            if (body && body.isValid && body.type === ERigidBodyType.DYNAMIC && !this.convex) {
              warnID(9630, this.node.name);
            }
          }
        }
        constructor() {
          super(EColliderType.MESH);
          this._mesh = _initializer$s && _initializer$s();
          this._convex = _initializer2$r && _initializer2$r();
        }
      }, (_applyDecoratedDescriptor(_class2$t.prototype, "mesh", [_dec2$u], Object.getOwnPropertyDescriptor(_class2$t.prototype, "mesh"), _class2$t.prototype), _initializer$s = applyDecoratedInitializer(_class2$t.prototype, "_mesh", [serializable$6], function () {
        return null;
      }), _initializer2$r = applyDecoratedInitializer(_class2$t.prototype, "_convex", [serializable$6], function () {
        return false;
      })), _class2$t)) || _class$w); exports({ MeshCollider: MeshCollider, MeshColliderComponent: MeshCollider });

      var _dec$w, _dec2$t, _class$v, _class2$s, _initializer$r, _initializer2$q, _initializer3$h, _initializer4$f;
      let ConstantForce = exports('ConstantForce', (_dec$w = ccclass$6('cc.ConstantForce'), _dec2$t = requireComponent(RigidBody), _dec$w(_class$v = _dec2$t(_class$v = disallowMultiple$1(_class$v = (_class2$s = class ConstantForce extends Component {
        constructor(...args) {
          super(...args);
          this._rigidBody = null;
          this._force = _initializer$r && _initializer$r();
          this._localForce = _initializer2$q && _initializer2$q();
          this._torque = _initializer3$h && _initializer3$h();
          this._localTorque = _initializer4$f && _initializer4$f();
          this._mask = 0;
        }
        get force() {
          return this._force;
        }
        set force(value) {
          Vec3.copy(this._force, value);
          this._maskUpdate(this._force, 1);
        }
        get localForce() {
          return this._localForce;
        }
        set localForce(value) {
          Vec3.copy(this._localForce, value);
          this._maskUpdate(this.localForce, 2);
        }
        get torque() {
          return this._torque;
        }
        set torque(value) {
          Vec3.copy(this._torque, value);
          this._maskUpdate(this._torque, 4);
        }
        get localTorque() {
          return this._localTorque;
        }
        set localTorque(value) {
          Vec3.copy(this._localTorque, value);
          this._maskUpdate(this._localTorque, 8);
        }
        onLoad() {
          this._rigidBody = this.node.getComponent(RigidBody);
          this._maskUpdate(this._force, 1);
          this._maskUpdate(this._localForce, 2);
          this._maskUpdate(this._torque, 4);
          this._maskUpdate(this._localTorque, 8);
        }
        lateUpdate(dt) {
          {
            if (this._rigidBody != null && this._mask !== 0) {
              if (this._mask & 1) this._rigidBody.applyForce(this._force);
              if (this._mask & 2) this._rigidBody.applyLocalForce(this.localForce);
              if (this._mask & 4) this._rigidBody.applyTorque(this._torque);
              if (this._mask & 8) this._rigidBody.applyLocalTorque(this._localTorque);
            }
          }
        }
        _maskUpdate(t, m) {
          if (t.strictEquals(Vec3.ZERO)) {
            this._mask &= ~m;
          } else {
            this._mask |= m;
          }
        }
      }, (_initializer$r = applyDecoratedInitializer(_class2$s.prototype, "_force", [serializable$6], function () {
        return new Vec3();
      }), _initializer2$q = applyDecoratedInitializer(_class2$s.prototype, "_localForce", [serializable$6], function () {
        return new Vec3();
      }), _initializer3$h = applyDecoratedInitializer(_class2$s.prototype, "_torque", [serializable$6], function () {
        return new Vec3();
      }), _initializer4$f = applyDecoratedInitializer(_class2$s.prototype, "_localTorque", [serializable$6], function () {
        return new Vec3();
      })), _class2$s)) || _class$v) || _class$v) || _class$v));

      var _dec$v, _class2$r, _class3$e, _initializer$q, _initializer2$p, _initializer3$g, _initializer4$e, _initializer5$c, _initializer6$9, _dec2$s, _class5$3, _dec3$n, _class7$2, _class8$2, _initializer7$8;
      const TERRAIN_BLOCK_TILE_COMPLEXITY = 32;
      const TERRAIN_HEIGHT_BASE = 32768;
      const TERRAIN_HEIGHT_FACTORY = 1.0 / 128.0;
      const TERRAIN_HEIGHT_FACTORY_V7 = 1.0 / 512.0;
      const TERRAIN_DATA_VERSION = 0x01010001;
      const TERRAIN_DATA_VERSION2 = 0x01010002;
      const TERRAIN_DATA_VERSION3 = 0x01010003;
      const TERRAIN_DATA_VERSION4 = 0x01010004;
      const TERRAIN_DATA_VERSION5 = 0x01010005;
      const TERRAIN_DATA_VERSION6 = 0x01010006;
      const TERRAIN_DATA_VERSION7 = 0x01010007;
      const TERRAIN_DATA_VERSION8 = 0x01010008;
      const TERRAIN_DATA_VERSION_DEFAULT = 0x01010111;
      class TerrainBuffer {
        constructor() {
          this.length = 0;
          this.buffer = new Uint8Array(2048);
          this._buffView = new DataView(this.buffer.buffer);
          this._seekPos = 0;
        }
        reserve(size) {
          if (this.buffer.byteLength > size) {
            return;
          }
          let capacity = this.buffer.byteLength;
          while (capacity < size) {
            capacity += capacity;
          }
          const temp = new Uint8Array(capacity);
          for (let i = 0; i < this.length; ++i) {
            temp[i] = this.buffer[i];
          }
          this.buffer = temp;
          this._buffView = new DataView(this.buffer.buffer);
        }
        assign(buff) {
          this.buffer = buff;
          this.length = buff.length;
          this._seekPos = buff.byteOffset;
          this._buffView = new DataView(buff.buffer);
        }
        writeInt8(value) {
          this.reserve(this.length + 1);
          this._buffView.setInt8(this.length, value);
          this.length += 1;
        }
        writeInt16(value) {
          this.reserve(this.length + 2);
          this._buffView.setInt16(this.length, value, true);
          this.length += 2;
        }
        writeInt32(value) {
          this.reserve(this.length + 4);
          this._buffView.setInt32(this.length, value, true);
          this.length += 4;
        }
        writeIntArray(value) {
          this.reserve(this.length + 4 * value.length);
          for (let i = 0; i < value.length; ++i) {
            this._buffView.setInt32(this.length + i * 4, value[i], true);
          }
          this.length += 4 * value.length;
        }
        writeFloat(value) {
          this.reserve(this.length + 4);
          this._buffView.setFloat32(this.length, value, true);
          this.length += 4;
        }
        writeFloatArray(value) {
          this.reserve(this.length + 4 * value.length);
          for (let i = 0; i < value.length; ++i) {
            this._buffView.setFloat32(this.length + i * 4, value[i], true);
          }
          this.length += 4 * value.length;
        }
        writeDouble(value) {
          this.reserve(this.length + 8);
          this._buffView.setFloat64(this.length, value, true);
          this.length += 8;
        }
        writeDoubleArray(value) {
          this.reserve(this.length + 8 * value.length);
          for (let i = 0; i < value.length; ++i) {
            this._buffView.setFloat64(this.length + i * 8, value[i], true);
          }
          this.length += 8 * value.length;
        }
        writeString(value) {
          this.reserve(this.length + value.length + 4);
          this._buffView.setInt32(this.length, value.length, true);
          for (let i = 0; i < value.length; ++i) {
            this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
          }
          this.length += value.length + 4;
        }
        readInt8() {
          const value = this._buffView.getInt8(this._seekPos);
          this._seekPos += 1;
          return value;
        }
        readInt16() {
          const value = this._buffView.getInt16(this._seekPos, true);
          this._seekPos += 2;
          return value;
        }
        readInt() {
          const value = this._buffView.getInt32(this._seekPos, true);
          this._seekPos += 4;
          return value;
        }
        readIntArray(value) {
          for (let i = 0; i < value.length; ++i) {
            value[i] = this._buffView.getInt32(this._seekPos + i * 4, true);
          }
          this._seekPos += 4 * value.length;
          return value;
        }
        readFloat() {
          const value = this._buffView.getFloat32(this._seekPos, true);
          this._seekPos += 4;
          return value;
        }
        readFloatArray(value) {
          for (let i = 0; i < value.length; ++i) {
            value[i] = this._buffView.getFloat32(this._seekPos + i * 4, true);
          }
          this._seekPos += 4 * value.length;
          return value;
        }
        readDouble() {
          const value = this._buffView.getFloat64(this._seekPos, true);
          this._seekPos += 8;
          return value;
        }
        readDoubleArray(value) {
          for (let i = 0; i < value.length; ++i) {
            value[i] = this._buffView.getFloat64(this._seekPos + i * 4, true);
          }
          this._seekPos += 8 * value.length;
          return value;
        }
        readString() {
          const length = this.readInt();
          let value = '';
          for (let i = 0; i < length; ++i) {
            value += String.fromCharCode(this.readInt8());
          }
          return value;
        }
      }
      (_dec$v = ccclass$6('cc.TerrainLayerInfo'), _dec$v(_class2$r = (_class3$e = class TerrainLayerInfo {
        constructor() {
          this.slot = _initializer$q && _initializer$q();
          this.tileSize = _initializer2$p && _initializer2$p();
          this.detailMap = _initializer3$g && _initializer3$g();
          this.normalMap = _initializer4$e && _initializer4$e();
          this.roughness = _initializer5$c && _initializer5$c();
          this.metallic = _initializer6$9 && _initializer6$9();
        }
      }, (_initializer$q = applyDecoratedInitializer(_class3$e.prototype, "slot", [serializable$6], function () {
        return 0;
      }), _initializer2$p = applyDecoratedInitializer(_class3$e.prototype, "tileSize", [serializable$6], function () {
        return 1;
      }), _initializer3$g = applyDecoratedInitializer(_class3$e.prototype, "detailMap", [serializable$6], function () {
        return null;
      }), _initializer4$e = applyDecoratedInitializer(_class3$e.prototype, "normalMap", [serializable$6], function () {
        return null;
      }), _initializer5$c = applyDecoratedInitializer(_class3$e.prototype, "roughness", [serializable$6], function () {
        return 1;
      }), _initializer6$9 = applyDecoratedInitializer(_class3$e.prototype, "metallic", [serializable$6], function () {
        return 0;
      })), _class3$e)) || _class2$r);
      let TerrainLayerBinaryInfo = (_dec2$s = ccclass$6('cc.TerrainLayerBinaryInfo'), _dec2$s(_class5$3 = class TerrainLayerBinaryInfo {
        constructor() {
          this.slot = 0;
          this.tileSize = 1;
          this.roughness = 1;
          this.metallic = 0;
          this.detailMapId = '';
          this.normalMapId = '';
        }
      }) || _class5$3);
      let TerrainAsset = (_dec3$n = ccclass$6('cc.TerrainAsset'), _dec3$n(_class7$2 = (_class8$2 = class TerrainAsset extends Asset {
        constructor() {
          super();
          this._version = 0;
          this._data = null;
          this._tileSize = 1;
          this._blockCount = [1, 1];
          this._weightMapSize = 128;
          this._lightMapSize = 128;
          this._heights = new Uint16Array();
          this._normals = new Float32Array();
          this._weights = new Uint8Array();
          this._layerBuffer = [-1, -1, -1, -1];
          this._layerBinaryInfos = [];
          this._layerInfos = _initializer7$8 && _initializer7$8();
        }
        get _nativeAsset() {
          return this._data.buffer;
        }
        set _nativeAsset(value) {
          if (this._data && this._data.byteLength === value.byteLength) {
            this._data.set(new Uint8Array(value));
          } else {
            this._data = new Uint8Array(value);
          }
          this._loadNativeData(this._data);
        }
        get version() {
          return this._version;
        }
        set tileSize(value) {
          this._tileSize = value;
        }
        get tileSize() {
          return this._tileSize;
        }
        set blockCount(value) {
          this._blockCount = value;
        }
        get blockCount() {
          return this._blockCount;
        }
        set lightMapSize(value) {
          this._lightMapSize = value;
        }
        get lightMapSize() {
          return this._lightMapSize;
        }
        set weightMapSize(value) {
          this._weightMapSize = value;
        }
        get weightMapSize() {
          return this._weightMapSize;
        }
        set heights(value) {
          this._heights = value;
        }
        get heights() {
          return this._heights;
        }
        set normals(value) {
          this._normals = value;
        }
        get normals() {
          return this._normals;
        }
        set weights(value) {
          this._weights = value;
        }
        get weights() {
          return this._weights;
        }
        set layerBuffer(value) {
          this._layerBuffer = value;
        }
        get layerBuffer() {
          return this._layerBuffer;
        }
        set layerInfos(value) {
          this._layerInfos = value;
        }
        get layerInfos() {
          return this._layerInfos;
        }
        get layerBinaryInfos() {
          return this._layerBinaryInfos;
        }
        getLayer(xBlock, yBlock, layerId) {
          const blockId = yBlock * this.blockCount[0] + xBlock;
          const index = blockId * 4 + layerId;
          if (xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length) {
            return this._layerBuffer[index];
          }
          return -1;
        }
        getHeight(i, j) {
          const vertexCountX = this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
          return (this._heights[j * vertexCountX + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
        }
        getVertexCountI() {
          if (this._blockCount.length < 1) return 0;
          return this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
        }
        getVertexCountJ() {
          if (this._blockCount.length < 2) return 0;
          return this._blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
        }
        _setNativeData(_nativeData) {
          this._data = _nativeData;
        }
        _loadNativeData(_nativeData) {
          if (!_nativeData || _nativeData.length === 0) {
            return false;
          }
          const stream = new TerrainBuffer();
          stream.assign(_nativeData);
          this._version = stream.readInt();
          if (this._version === TERRAIN_DATA_VERSION_DEFAULT) {
            return true;
          }
          if (this._version !== TERRAIN_DATA_VERSION && this._version !== TERRAIN_DATA_VERSION2 && this._version !== TERRAIN_DATA_VERSION3 && this._version !== TERRAIN_DATA_VERSION4 && this._version !== TERRAIN_DATA_VERSION5 && this._version !== TERRAIN_DATA_VERSION6 && this._version !== TERRAIN_DATA_VERSION7 && this._version !== TERRAIN_DATA_VERSION8) {
            return false;
          }
          if (this._version >= TERRAIN_DATA_VERSION7) {
            this.tileSize = stream.readDouble();
          } else {
            this.tileSize = stream.readFloat();
          }
          this.tileSize = Math.floor(this.tileSize * 100) / 100.0;
          stream.readIntArray(this._blockCount);
          this.weightMapSize = stream.readInt16();
          this.lightMapSize = stream.readInt16();
          const heightBufferSize = stream.readInt();
          this.heights = new Uint16Array(heightBufferSize);
          for (let i = 0; i < this.heights.length; ++i) {
            this.heights[i] = stream.readInt16();
          }
          if (this._version < TERRAIN_DATA_VERSION8) {
            for (let i = 0; i < this.heights.length; ++i) {
              const h = (this._heights[i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY_V7;
              const ch = TERRAIN_HEIGHT_BASE + h / TERRAIN_HEIGHT_FACTORY;
              this.heights[i] = ch;
            }
          }
          if (this._version >= TERRAIN_DATA_VERSION6) {
            const normalBufferSize = stream.readInt();
            this.normals = new Float32Array(normalBufferSize);
            for (let i = 0; i < this.normals.length; ++i) {
              this.normals[i] = stream.readFloat();
            }
          }
          const WeightBufferSize = stream.readInt();
          this.weights = new Uint8Array(WeightBufferSize);
          for (let i = 0; i < this.weights.length; ++i) {
            this.weights[i] = stream.readInt8();
          }
          if (this._version >= TERRAIN_DATA_VERSION2) {
            const layerBufferSize = stream.readInt();
            this.layerBuffer = new Array(layerBufferSize);
            for (let i = 0; i < this.layerBuffer.length; ++i) {
              this.layerBuffer[i] = stream.readInt16();
            }
          }
          if (this._version >= TERRAIN_DATA_VERSION3) {
            const layerInfoSize = stream.readInt();
            this._layerBinaryInfos = new Array(layerInfoSize);
            for (let i = 0; i < this._layerBinaryInfos.length; ++i) {
              this._layerBinaryInfos[i] = new TerrainLayerBinaryInfo();
              this._layerBinaryInfos[i].slot = stream.readInt();
              if (this._version >= TERRAIN_DATA_VERSION7) {
                this._layerBinaryInfos[i].tileSize = stream.readDouble();
              } else {
                this._layerBinaryInfos[i].tileSize = stream.readFloat();
              }
              this._layerBinaryInfos[i].detailMapId = stream.readString();
              if (this._version >= TERRAIN_DATA_VERSION4) {
                this._layerBinaryInfos[i].normalMapId = stream.readString();
                if (this._version >= TERRAIN_DATA_VERSION7) {
                  this._layerBinaryInfos[i].roughness = stream.readDouble();
                  this._layerBinaryInfos[i].metallic = stream.readDouble();
                } else {
                  this._layerBinaryInfos[i].roughness = stream.readFloat();
                  this._layerBinaryInfos[i].metallic = stream.readFloat();
                }
              }
            }
          }
          return true;
        }
        _exportNativeData() {
          const stream = new TerrainBuffer();
          stream.writeInt32(TERRAIN_DATA_VERSION8);
          stream.writeDouble(this.tileSize);
          stream.writeIntArray(this._blockCount);
          stream.writeInt16(this.weightMapSize);
          stream.writeInt16(this.lightMapSize);
          stream.writeInt32(this.heights.length);
          for (let i = 0; i < this.heights.length; ++i) {
            stream.writeInt16(this.heights[i]);
          }
          stream.writeInt32(this.normals.length);
          for (let i = 0; i < this.normals.length; ++i) {
            stream.writeFloat(this.normals[i]);
          }
          stream.writeInt32(this.weights.length);
          for (let i = 0; i < this.weights.length; ++i) {
            stream.writeInt8(this.weights[i]);
          }
          stream.writeInt32(this.layerBuffer.length);
          for (let i = 0; i < this.layerBuffer.length; ++i) {
            stream.writeInt16(this.layerBuffer[i]);
          }
          const layerBinaryInfos = [];
          layerBinaryInfos.length = this.layerInfos.length;
          for (let i = 0; i < layerBinaryInfos.length; ++i) {
            const layer = this.layerInfos[i];
            const binaryLayer = new TerrainLayerBinaryInfo();
            binaryLayer.slot = i;
            binaryLayer.tileSize = layer.tileSize;
            binaryLayer.detailMapId = layer.detailMap ? layer.detailMap._uuid : '';
            binaryLayer.normalMapId = layer.normalMap ? layer.normalMap._uuid : '';
            binaryLayer.metallic = layer.metallic;
            binaryLayer.roughness = layer.roughness;
            layerBinaryInfos[i] = binaryLayer;
          }
          stream.writeInt32(layerBinaryInfos.length);
          for (let i = 0; i < layerBinaryInfos.length; ++i) {
            stream.writeInt32(layerBinaryInfos[i].slot);
            stream.writeDouble(layerBinaryInfos[i].tileSize);
            stream.writeString(layerBinaryInfos[i].detailMapId);
            stream.writeString(layerBinaryInfos[i].normalMapId);
            stream.writeDouble(layerBinaryInfos[i].roughness);
            stream.writeDouble(layerBinaryInfos[i].metallic);
          }
          return stream.buffer;
        }
        _exportDefaultNativeData() {
          const stream = new TerrainBuffer();
          stream.writeInt32(TERRAIN_DATA_VERSION_DEFAULT);
          return stream.buffer;
        }
      }, (_initializer7$8 = applyDecoratedInitializer(_class8$2.prototype, "_layerInfos", [serializable$6], function () {
        return [];
      })), _class8$2)) || _class7$2);

      var _dec$u, _dec2$r, _class$u, _class2$q, _initializer$p;
      let TerrainCollider = exports('TerrainCollider', (_dec$u = ccclass$6('cc.TerrainCollider'), _dec2$r = type$6(TerrainAsset), _dec$u(_class$u = (_class2$q = class TerrainCollider extends Collider {
        get terrain() {
          return this._terrain;
        }
        set terrain(value) {
          this._terrain = value;
          if (this._shape) this.shape.setTerrain(this._terrain);
        }
        get shape() {
          return this._shape;
        }
        onEnable() {
          super.onEnable();
          if (this.node) {
            const body = this.node.getComponent(RigidBody);
            if (body && body.isValid && body.type === ERigidBodyType.DYNAMIC) {
              warnID(9630, this.node.name);
            }
          }
        }
        constructor() {
          super(EColliderType.TERRAIN);
          this._terrain = _initializer$p && _initializer$p();
        }
      }, (_applyDecoratedDescriptor(_class2$q.prototype, "terrain", [_dec2$r], Object.getOwnPropertyDescriptor(_class2$q.prototype, "terrain"), _class2$q.prototype), _initializer$p = applyDecoratedInitializer(_class2$q.prototype, "_terrain", [serializable$6], function () {
        return null;
      })), _class2$q)) || _class$u));

      var _dec$t, _dec2$q, _class$t, _class2$p, _initializer$o, _initializer2$o, _class3$d;
      let SimplexCollider = exports('SimplexCollider', (_dec$t = ccclass$6('cc.SimplexCollider'), _dec2$q = type$6(ESimplexType), _dec$t(_class$t = (_class2$p = (_class3$d = class SimplexCollider extends Collider {
        get shapeType() {
          return this._shapeType;
        }
        set shapeType(v) {
          this._shapeType = v;
          if (this._shape) {
            this.shape.setShapeType(v);
          }
        }
        get vertex0() {
          return this._vertices[0];
        }
        set vertex0(v) {
          Vec3.copy(this._vertices[0], v);
          this.updateVertices();
        }
        get vertex1() {
          return this._vertices[1];
        }
        set vertex1(v) {
          Vec3.copy(this._vertices[1], v);
          this.updateVertices();
        }
        get vertex2() {
          return this._vertices[2];
        }
        set vertex2(v) {
          Vec3.copy(this._vertices[2], v);
          this.updateVertices();
        }
        get vertex3() {
          return this._vertices[3];
        }
        set vertex3(v) {
          Vec3.copy(this._vertices[3], v);
          this.updateVertices();
        }
        get shape() {
          return this._shape;
        }
        get vertices() {
          return this._vertices;
        }
        constructor() {
          super(EColliderType.SIMPLEX);
          this._shapeType = _initializer$o && _initializer$o();
          this._vertices = _initializer2$o && _initializer2$o();
        }
        updateVertices() {
          if (this._shape) {
            this.shape.setVertices(this._vertices);
          }
        }
      }, _class3$d.ESimplexType = ESimplexType, _class3$d), (_applyDecoratedDescriptor(_class2$p.prototype, "shapeType", [_dec2$q], Object.getOwnPropertyDescriptor(_class2$p.prototype, "shapeType"), _class2$p.prototype), _initializer$o = applyDecoratedInitializer(_class2$p.prototype, "_shapeType", [serializable$6], function () {
        return ESimplexType.TETRAHEDRON;
      }), _initializer2$o = applyDecoratedInitializer(_class2$p.prototype, "_vertices", [serializable$6], function () {
        return [new Vec3(0, 0, 0), new Vec3(0, 0, 1), new Vec3(1, 0, 0), new Vec3(0, 1, 0)];
      })), _class2$p)) || _class$t));
      (function (_SimplexCollider) {})(SimplexCollider || (exports('SimplexCollider', SimplexCollider = {})));

      var _dec$s, _dec2$p, _class$s, _class2$o, _initializer$n, _initializer2$n;
      let PlaneCollider = exports('PlaneCollider', (_dec$s = ccclass$6('cc.PlaneCollider'), _dec2$p = type$6(Vec3), _dec$s(_class$s = (_class2$o = class PlaneCollider extends Collider {
        get normal() {
          return this._normal;
        }
        set normal(value) {
          if (Vec3.strictEquals(this._normal, value)) return;
          Vec3.copy(this._normal, value);
          if (this._shape) {
            this.shape.setNormal(this._normal);
          }
        }
        get constant() {
          return this._constant;
        }
        set constant(v) {
          if (this._constant === v) return;
          this._constant = v;
          if (this._shape) {
            this.shape.setConstant(this._constant);
          }
        }
        get shape() {
          return this._shape;
        }
        onEnable() {
          super.onEnable();
          if (this.node) {
            const body = this.node.getComponent(RigidBody);
            if (body && body.isValid && body.type === ERigidBodyType.DYNAMIC) {
              warnID(9630, this.node.name);
            }
          }
        }
        constructor() {
          super(EColliderType.PLANE);
          this._normal = _initializer$n && _initializer$n();
          this._constant = _initializer2$n && _initializer2$n();
        }
      }, (_applyDecoratedDescriptor(_class2$o.prototype, "normal", [_dec2$p], Object.getOwnPropertyDescriptor(_class2$o.prototype, "normal"), _class2$o.prototype), _initializer$n = applyDecoratedInitializer(_class2$o.prototype, "_normal", [serializable$6], function () {
        return new Vec3(0, 1, 0);
      }), _initializer2$n = applyDecoratedInitializer(_class2$o.prototype, "_constant", [serializable$6], function () {
        return 0;
      })), _class2$o)) || _class$s));

      var _dec$r, _dec2$o, _dec3$m, _dec4$i, _dec5$h, _class$r, _class2$n, _initializer$m, _initializer2$m, _class3$c;
      let Constraint$1 = exports('Constraint', (_dec$r = ccclass$6('cc.Constraint'), _dec2$o = requireComponent(RigidBody), _dec3$m = type$6(RigidBody), _dec4$i = type$6(RigidBody), _dec5$h = type$6(RigidBody), _dec$r(_class$r = _dec2$o(_class$r = (_class2$n = (_class3$c = class Constraint extends Eventify(Component) {
        get attachedBody() {
          return this.getComponent(RigidBody);
        }
        get connectedBody() {
          return this._connectedBody;
        }
        set connectedBody(v) {
          this._connectedBody = v;
          {
            if (this._constraint) this._constraint.setConnectedBody(v);
          }
        }
        get enableCollision() {
          return this._enableCollision;
        }
        set enableCollision(v) {
          this._enableCollision = v;
          {
            if (this._constraint) this._constraint.setEnableCollision(v);
          }
        }
        constructor(type) {
          super();
          this.TYPE = void 0;
          this._enableCollision = _initializer$m && _initializer$m();
          this._connectedBody = _initializer2$m && _initializer2$m();
          this._constraint = null;
          this.TYPE = type;
        }
        onLoad() {
          if (!selector.runInEditor) return;
          this._constraint = createConstraint(this.TYPE);
          this._constraint.initialize(this);
        }
        onEnable() {
          if (this._constraint) {
            this._constraint.onEnable();
          }
        }
        onDisable() {
          if (this._constraint) {
            this._constraint.onDisable();
          }
        }
        onDestroy() {
          if (this._constraint) {
            this._constraint.onDestroy();
          }
        }
      }, _class3$c.Type = EConstraintType, _class3$c), (_applyDecoratedDescriptor(_class2$n.prototype, "attachedBody", [_dec3$m], Object.getOwnPropertyDescriptor(_class2$n.prototype, "attachedBody"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "connectedBody", [_dec4$i], Object.getOwnPropertyDescriptor(_class2$n.prototype, "connectedBody"), _class2$n.prototype), _initializer$m = applyDecoratedInitializer(_class2$n.prototype, "_enableCollision", [serializable$6], function () {
        return true;
      }), _initializer2$m = applyDecoratedInitializer(_class2$n.prototype, "_connectedBody", [_dec5$h], function () {
        return null;
      })), _class2$n)) || _class$r) || _class$r));
      (function (_Constraint) {})(Constraint$1 || (exports('Constraint', Constraint$1 = {})));

      var _dec$q, _dec2$n, _dec3$l, _dec4$h, _dec5$g, _dec6$8, _dec7$7, _class$q, _class2$m, _initializer$l, _initializer2$l, _initializer3$f, _dec8$5, _dec9$5, _dec10$3, _dec11$2, _dec12$2, _dec13$2, _dec14$1, _class4$1, _class5$2, _initializer4$d, _initializer5$b, _initializer6$8, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _class7$1, _class8$1, _initializer7$7, _initializer8$7, _initializer9$7, _initializer10$7, _initializer11$7;
      let HingeLimitData = (_dec$q = ccclass$6('cc.HingeLimitData'), _dec2$n = formerlySerializedAs$3('enabled'), _dec3$l = formerlySerializedAs$3('upperLimit'), _dec4$h = formerlySerializedAs$3('lowerLimit'), _dec5$g = type$6(CCBoolean), _dec6$8 = type$6(CCFloat), _dec7$7 = type$6(CCFloat), _dec$q(_class$q = (_class2$m = class HingeLimitData {
        constructor() {
          this._enabled = _initializer$l && _initializer$l();
          this._upperLimit = _initializer2$l && _initializer2$l();
          this._lowerLimit = _initializer3$f && _initializer3$f();
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(v) {
          this._enabled = v;
        }
        get upperLimit() {
          return this._upperLimit;
        }
        set upperLimit(v) {
          this._upperLimit = v;
        }
        get lowerLimit() {
          return this._lowerLimit;
        }
        set lowerLimit(v) {
          this._lowerLimit = v;
        }
      }, (_initializer$l = applyDecoratedInitializer(_class2$m.prototype, "_enabled", [serializable$6, _dec2$n], function () {
        return false;
      }), _initializer2$l = applyDecoratedInitializer(_class2$m.prototype, "_upperLimit", [serializable$6, _dec3$l], function () {
        return Number.MAX_VALUE;
      }), _initializer3$f = applyDecoratedInitializer(_class2$m.prototype, "_lowerLimit", [serializable$6, _dec4$h], function () {
        return -Number.MAX_VALUE;
      }), _applyDecoratedDescriptor(_class2$m.prototype, "enabled", [_dec5$g], Object.getOwnPropertyDescriptor(_class2$m.prototype, "enabled"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "upperLimit", [_dec6$8], Object.getOwnPropertyDescriptor(_class2$m.prototype, "upperLimit"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "lowerLimit", [_dec7$7], Object.getOwnPropertyDescriptor(_class2$m.prototype, "lowerLimit"), _class2$m.prototype)), _class2$m)) || _class$q);
      let HingeMotorData = (_dec8$5 = ccclass$6('cc.HingeMotorData'), _dec9$5 = formerlySerializedAs$3('enabled'), _dec10$3 = formerlySerializedAs$3('motorVelocity'), _dec11$2 = formerlySerializedAs$3('motorForceLimit'), _dec12$2 = type$6(CCBoolean), _dec13$2 = type$6(CCFloat), _dec14$1 = type$6(CCFloat), _dec8$5(_class4$1 = (_class5$2 = class HingeMotorData {
        constructor() {
          this._enabled = _initializer4$d && _initializer4$d();
          this._motorVelocity = _initializer5$b && _initializer5$b();
          this._motorForceLimit = _initializer6$8 && _initializer6$8();
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(v) {
          this._enabled = v;
        }
        get motorVelocity() {
          return this._motorVelocity;
        }
        set motorVelocity(v) {
          this._motorVelocity = v;
        }
        get motorForceLimit() {
          return this._motorForceLimit;
        }
        set motorForceLimit(v) {
          this._motorForceLimit = v;
        }
      }, (_initializer4$d = applyDecoratedInitializer(_class5$2.prototype, "_enabled", [serializable$6, _dec9$5], function () {
        return false;
      }), _initializer5$b = applyDecoratedInitializer(_class5$2.prototype, "_motorVelocity", [serializable$6, _dec10$3], function () {
        return 0;
      }), _initializer6$8 = applyDecoratedInitializer(_class5$2.prototype, "_motorForceLimit", [serializable$6, _dec11$2], function () {
        return 0;
      }), _applyDecoratedDescriptor(_class5$2.prototype, "enabled", [_dec12$2], Object.getOwnPropertyDescriptor(_class5$2.prototype, "enabled"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "motorVelocity", [_dec13$2], Object.getOwnPropertyDescriptor(_class5$2.prototype, "motorVelocity"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "motorForceLimit", [_dec14$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "motorForceLimit"), _class5$2.prototype)), _class5$2)) || _class4$1);
      let HingeConstraint = exports('HingeConstraint', (_dec15$1 = ccclass$6('cc.HingeConstraint'), _dec16$1 = type$6(Vec3), _dec17$1 = type$6(Vec3), _dec18$1 = type$6(Vec3), _dec19$1 = type$6(CCBoolean), _dec20$1 = type$6(CCFloat), _dec21$1 = type$6(CCFloat), _dec22$1 = type$6(CCBoolean), _dec23$1 = type$6(CCFloat), _dec24$1 = type$6(CCFloat), _dec25$1 = formerlySerializedAs$3('axisA'), _dec26$1 = formerlySerializedAs$3('pivotA'), _dec27$1 = formerlySerializedAs$3('pivotB'), _dec28$1 = formerlySerializedAs$3('limitData'), _dec29$1 = formerlySerializedAs$3('motorData'), _dec15$1(_class7$1 = (_class8$1 = class HingeConstraint extends Constraint$1 {
        get pivotA() {
          return this._pivotA;
        }
        set pivotA(v) {
          Vec3.copy(this._pivotA, v);
          {
            this.constraint.setPivotA(this._pivotA);
          }
        }
        get pivotB() {
          return this._pivotB;
        }
        set pivotB(v) {
          Vec3.copy(this._pivotB, v);
          {
            this.constraint.setPivotB(this._pivotB);
          }
        }
        get axis() {
          return this._axis;
        }
        set axis(v) {
          Vec3.copy(this._axis, v);
          {
            this.constraint.setAxis(this._axis);
          }
        }
        get limitEnabled() {
          return this._limitData.enabled;
        }
        set limitEnabled(v) {
          this._limitData.enabled = v;
          {
            this.constraint.setLimitEnabled(v);
          }
        }
        get upperLimit() {
          return this._limitData.upperLimit;
        }
        set upperLimit(v) {
          this._limitData.upperLimit = v;
          {
            this.constraint.setUpperLimit(v);
          }
        }
        get lowerLimit() {
          return this._limitData.lowerLimit;
        }
        set lowerLimit(v) {
          this._limitData.lowerLimit = v;
          {
            this.constraint.setLowerLimit(v);
          }
        }
        get motorEnabled() {
          return this._motorData.enabled;
        }
        set motorEnabled(v) {
          this._motorData.enabled = v;
          {
            this.constraint.setMotorEnabled(v);
          }
        }
        get motorVelocity() {
          return this._motorData.motorVelocity;
        }
        set motorVelocity(v) {
          this._motorData.motorVelocity = v;
          {
            this.constraint.setMotorVelocity(v);
          }
        }
        get motorForceLimit() {
          return this._motorData.motorForceLimit;
        }
        set motorForceLimit(v) {
          this._motorData.motorForceLimit = v;
          {
            this.constraint.setMotorForceLimit(v);
          }
        }
        get constraint() {
          return this._constraint;
        }
        constructor() {
          super(EConstraintType.HINGE);
          this._axis = _initializer7$7 && _initializer7$7();
          this._pivotA = _initializer8$7 && _initializer8$7();
          this._pivotB = _initializer9$7 && _initializer9$7();
          this._limitData = _initializer10$7 && _initializer10$7();
          this._motorData = _initializer11$7 && _initializer11$7();
        }
      }, (_applyDecoratedDescriptor(_class8$1.prototype, "pivotA", [_dec16$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "pivotA"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "pivotB", [_dec17$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "pivotB"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "axis", [_dec18$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "axis"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "limitEnabled", [_dec19$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "limitEnabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "upperLimit", [_dec20$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "upperLimit"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "lowerLimit", [_dec21$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "lowerLimit"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "motorEnabled", [_dec22$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "motorEnabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "motorVelocity", [_dec23$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "motorVelocity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "motorForceLimit", [_dec24$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "motorForceLimit"), _class8$1.prototype), _initializer7$7 = applyDecoratedInitializer(_class8$1.prototype, "_axis", [serializable$6, _dec25$1], function () {
        return new Vec3();
      }), _initializer8$7 = applyDecoratedInitializer(_class8$1.prototype, "_pivotA", [serializable$6, _dec26$1], function () {
        return new Vec3();
      }), _initializer9$7 = applyDecoratedInitializer(_class8$1.prototype, "_pivotB", [serializable$6, _dec27$1], function () {
        return new Vec3();
      }), _initializer10$7 = applyDecoratedInitializer(_class8$1.prototype, "_limitData", [serializable$6, _dec28$1], function () {
        return new HingeLimitData();
      }), _initializer11$7 = applyDecoratedInitializer(_class8$1.prototype, "_motorData", [serializable$6, _dec29$1], function () {
        return new HingeMotorData();
      })), _class8$1)) || _class7$1));

      var _dec$p, _dec2$m, _dec3$k, _dec4$g, _dec5$f, _class$p, _class2$l, _initializer$k, _initializer2$k;
      let FixedConstraint = exports('FixedConstraint', (_dec$p = ccclass$6('cc.FixedConstraint'), _dec2$m = type$6(CCFloat), _dec3$k = type$6(CCFloat), _dec4$g = formerlySerializedAs$3('breakForce'), _dec5$f = formerlySerializedAs$3('breakTorque'), _dec$p(_class$p = (_class2$l = class FixedConstraint extends Constraint$1 {
        get breakForce() {
          return this._breakForce;
        }
        set breakForce(v) {
          this._breakForce = v;
          {
            this.constraint.setBreakForce(v);
          }
        }
        get breakTorque() {
          return this._breakTorque;
        }
        set breakTorque(v) {
          this._breakTorque = v;
          {
            this.constraint.setBreakTorque(v);
          }
        }
        get constraint() {
          return this._constraint;
        }
        constructor() {
          super(EConstraintType.FIXED);
          this._breakForce = _initializer$k && _initializer$k();
          this._breakTorque = _initializer2$k && _initializer2$k();
        }
      }, (_applyDecoratedDescriptor(_class2$l.prototype, "breakForce", [_dec2$m], Object.getOwnPropertyDescriptor(_class2$l.prototype, "breakForce"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "breakTorque", [_dec3$k], Object.getOwnPropertyDescriptor(_class2$l.prototype, "breakTorque"), _class2$l.prototype), _initializer$k = applyDecoratedInitializer(_class2$l.prototype, "_breakForce", [serializable$6, _dec4$g], function () {
        return 1e8;
      }), _initializer2$k = applyDecoratedInitializer(_class2$l.prototype, "_breakTorque", [serializable$6, _dec5$f], function () {
        return 1e8;
      })), _class2$l)) || _class$p));

      var _dec$o, _dec2$l, _dec3$j, _dec4$f, _dec5$e, _dec6$7, _dec7$6, _dec8$4, _dec9$4, _dec10$2, _class$o, _class2$k, _initializer$j, _initializer2$j, _initializer3$e, _initializer4$c, _initializer5$a, _initializer6$7, _initializer7$6, _initializer8$6, _initializer9$6, _dec11$1, _dec12$1, _dec13$1, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _class4, _class5$1, _initializer10$6, _initializer11$6, _initializer12$5, _initializer13$4, _initializer14$3, _initializer15$2, _initializer16$2, _initializer17$1, _initializer18$1, _initializer19, _initializer20, _initializer21, _initializer22, _initializer23, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class7, _class8, _initializer24, _initializer25, _initializer26, _initializer27, _initializer28, _initializer29, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _class10, _class11, _initializer30, _initializer31, _initializer32, _initializer33, _initializer34, _initializer35, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _class13, _class14, _initializer36, _initializer37, _initializer38, _initializer39, _initializer40, _initializer41, _initializer42, _initializer43, _initializer44, _initializer45, _initializer46;
      let LinearLimitSettings = (_dec$o = ccclass$6('cc.LinearLimitSettings'), _dec2$l = type$6(EConstraintMode), _dec3$j = type$6(EConstraintMode), _dec4$f = type$6(EConstraintMode), _dec5$e = type$6(Vec3), _dec6$7 = type$6(Vec3), _dec7$6 = type$6(CCFloat), _dec8$4 = type$6(CCBoolean), _dec9$4 = type$6(CCFloat), _dec10$2 = type$6(CCFloat), _dec$o(_class$o = (_class2$k = class LinearLimitSettings {
        get xMotion() {
          return this._xMotion;
        }
        set xMotion(v) {
          this._xMotion = v;
          {
            this._impl.setConstraintMode(0, v);
          }
        }
        get yMotion() {
          return this._yMotion;
        }
        set yMotion(v) {
          this._yMotion = v;
          {
            this._impl.setConstraintMode(1, v);
          }
        }
        get zMotion() {
          return this._zMotion;
        }
        set zMotion(v) {
          this._zMotion = v;
          {
            this._impl.setConstraintMode(2, v);
          }
        }
        get upper() {
          return this._upper;
        }
        set upper(v) {
          Vec3.copy(this._upper, v);
          {
            const lower = this.lower;
            this._impl.setLinearLimit(0, lower.x, v.x);
            this._impl.setLinearLimit(1, lower.y, v.y);
            this._impl.setLinearLimit(2, lower.z, v.z);
          }
        }
        get lower() {
          return this._lower;
        }
        set lower(v) {
          Vec3.copy(this._lower, v);
          {
            const upper = this.upper;
            this._impl.setLinearLimit(0, v.x, upper.x);
            this._impl.setLinearLimit(1, v.y, upper.y);
            this._impl.setLinearLimit(2, v.z, upper.z);
          }
        }
        get restitution() {
          return this._bounciness;
        }
        set restitution(v) {
          this._bounciness = v;
          {
            this._impl.setLinearRestitution(v);
          }
        }
        get enableSoftConstraint() {
          return this._enableSoftConstraint;
        }
        set enableSoftConstraint(v) {
          this._enableSoftConstraint = v;
          {
            this._impl.setLinearSoftConstraint(v);
          }
        }
        get stiffness() {
          return this._stiffness;
        }
        set stiffness(v) {
          this._stiffness = v;
          {
            this._impl.setLinearStiffness(v);
          }
        }
        get damping() {
          return this._damping;
        }
        set damping(v) {
          this._damping = v;
          {
            this._impl.setLinearDamping(v);
          }
        }
        set impl(v) {
          this._impl = v;
        }
        constructor(configurableConstraint) {
          this._xMotion = _initializer$j && _initializer$j();
          this._yMotion = _initializer2$j && _initializer2$j();
          this._zMotion = _initializer3$e && _initializer3$e();
          this._upper = _initializer4$c && _initializer4$c();
          this._lower = _initializer5$a && _initializer5$a();
          this._enableSoftConstraint = _initializer6$7 && _initializer6$7();
          this._bounciness = _initializer7$6 && _initializer7$6();
          this._stiffness = _initializer8$6 && _initializer8$6();
          this._damping = _initializer9$6 && _initializer9$6();
          this._impl = void 0;
          this._impl = configurableConstraint;
        }
      }, (_applyDecoratedDescriptor(_class2$k.prototype, "xMotion", [_dec2$l], Object.getOwnPropertyDescriptor(_class2$k.prototype, "xMotion"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "yMotion", [_dec3$j], Object.getOwnPropertyDescriptor(_class2$k.prototype, "yMotion"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "zMotion", [_dec4$f], Object.getOwnPropertyDescriptor(_class2$k.prototype, "zMotion"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "upper", [_dec5$e], Object.getOwnPropertyDescriptor(_class2$k.prototype, "upper"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "lower", [_dec6$7], Object.getOwnPropertyDescriptor(_class2$k.prototype, "lower"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "restitution", [_dec7$6], Object.getOwnPropertyDescriptor(_class2$k.prototype, "restitution"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "enableSoftConstraint", [_dec8$4], Object.getOwnPropertyDescriptor(_class2$k.prototype, "enableSoftConstraint"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "stiffness", [_dec9$4], Object.getOwnPropertyDescriptor(_class2$k.prototype, "stiffness"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "damping", [_dec10$2], Object.getOwnPropertyDescriptor(_class2$k.prototype, "damping"), _class2$k.prototype), _initializer$j = applyDecoratedInitializer(_class2$k.prototype, "_xMotion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer2$j = applyDecoratedInitializer(_class2$k.prototype, "_yMotion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer3$e = applyDecoratedInitializer(_class2$k.prototype, "_zMotion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer4$c = applyDecoratedInitializer(_class2$k.prototype, "_upper", [serializable$6], function () {
        return new Vec3();
      }), _initializer5$a = applyDecoratedInitializer(_class2$k.prototype, "_lower", [serializable$6], function () {
        return new Vec3();
      }), _initializer6$7 = applyDecoratedInitializer(_class2$k.prototype, "_enableSoftConstraint", [serializable$6], function () {
        return false;
      }), _initializer7$6 = applyDecoratedInitializer(_class2$k.prototype, "_bounciness", [serializable$6], function () {
        return 0;
      }), _initializer8$6 = applyDecoratedInitializer(_class2$k.prototype, "_stiffness", [serializable$6], function () {
        return 0;
      }), _initializer9$6 = applyDecoratedInitializer(_class2$k.prototype, "_damping", [serializable$6], function () {
        return 0;
      })), _class2$k)) || _class$o);
      let AngularLimitSettings = (_dec11$1 = ccclass$6('cc.AngularLimitSettings'), _dec12$1 = type$6(EConstraintMode), _dec13$1 = type$6(EConstraintMode), _dec14 = type$6(EConstraintMode), _dec15 = type$6(CCFloat), _dec16 = type$6(CCFloat), _dec17 = type$6(CCFloat), _dec18 = type$6(CCFloat), _dec19 = type$6(CCFloat), _dec20 = type$6(CCBoolean), _dec21 = type$6(CCFloat), _dec22 = type$6(CCFloat), _dec23 = type$6(CCBoolean), _dec24 = type$6(CCFloat), _dec25 = type$6(CCFloat), _dec11$1(_class4 = (_class5$1 = class AngularLimitSettings {
        get twistMotion() {
          return this._twistMotion;
        }
        set twistMotion(v) {
          this._twistMotion = v;
          {
            this._impl.setConstraintMode(3, v);
          }
        }
        get swingMotion1() {
          return this._swing1Motion;
        }
        set swingMotion1(v) {
          this._swing1Motion = v;
          {
            this._impl.setConstraintMode(4, v);
          }
        }
        get swingMotion2() {
          return this._swing2Motion;
        }
        set swingMotion2(v) {
          this._swing2Motion = v;
          {
            this._impl.setConstraintMode(5, v);
          }
        }
        get twistExtent() {
          return this._twistExtent;
        }
        set twistExtent(v) {
          this._twistExtent = v;
          {
            this._impl.setAngularExtent(v, this.swingExtent1, this.swingExtent2);
          }
        }
        get swingExtent1() {
          return this._swingExtent1;
        }
        set swingExtent1(v) {
          this._swingExtent1 = v;
          {
            this._impl.setAngularExtent(this.twistExtent, v, this.swingExtent2);
          }
        }
        get swingExtent2() {
          return this._swingExtent2;
        }
        set swingExtent2(v) {
          this._swingExtent2 = v;
          {
            this._impl.setAngularExtent(this.twistExtent, this.swingExtent1, v);
          }
        }
        get twistRestitution() {
          return this._twistBounciness;
        }
        set twistRestitution(v) {
          this._twistBounciness = v;
          {
            this._impl.setTwistRestitution(v);
          }
        }
        get swingRestitution() {
          return this._swingBounciness;
        }
        set swingRestitution(v) {
          this._swingBounciness = v;
          {
            this._impl.setSwingRestitution(v);
          }
        }
        get enableSoftConstraintTwist() {
          return this._enableSoftConstraintTwist;
        }
        set enableSoftConstraintTwist(v) {
          this._enableSoftConstraintTwist = v;
          {
            this._impl.setTwistSoftConstraint(v);
          }
        }
        get twistStiffness() {
          return this._twistStiffness;
        }
        set twistStiffness(v) {
          this._twistStiffness = v;
          {
            this._impl.setTwistStiffness(v);
          }
        }
        get twistDamping() {
          return this._twistDamping;
        }
        set twistDamping(v) {
          this._twistDamping = v;
          {
            this._impl.setTwistDamping(v);
          }
        }
        get enableSoftConstraintSwing() {
          return this._enableSoftConstraintSwing;
        }
        set enableSoftConstraintSwing(v) {
          this._enableSoftConstraintSwing = v;
          {
            this._impl.setSwingSoftConstraint(v);
          }
        }
        get swingStiffness() {
          return this._swingStiffness;
        }
        set swingStiffness(v) {
          this._swingStiffness = v;
          {
            this._impl.setSwingStiffness(v);
          }
        }
        get swingDamping() {
          return this._swingDamping;
        }
        set swingDamping(v) {
          this._swingDamping = v;
          {
            this._impl.setSwingDamping(v);
          }
        }
        set impl(v) {
          this._impl = v;
        }
        constructor(configurableConstraint) {
          this._swing1Motion = _initializer10$6 && _initializer10$6();
          this._swing2Motion = _initializer11$6 && _initializer11$6();
          this._twistMotion = _initializer12$5 && _initializer12$5();
          this._twistExtent = _initializer13$4 && _initializer13$4();
          this._swingExtent1 = _initializer14$3 && _initializer14$3();
          this._swingExtent2 = _initializer15$2 && _initializer15$2();
          this._enableSoftConstraintSwing = _initializer16$2 && _initializer16$2();
          this._swingBounciness = _initializer17$1 && _initializer17$1();
          this._swingStiffness = _initializer18$1 && _initializer18$1();
          this._swingDamping = _initializer19 && _initializer19();
          this._enableSoftConstraintTwist = _initializer20 && _initializer20();
          this._twistBounciness = _initializer21 && _initializer21();
          this._twistStiffness = _initializer22 && _initializer22();
          this._twistDamping = _initializer23 && _initializer23();
          this._impl = void 0;
          this._impl = configurableConstraint;
        }
      }, (_applyDecoratedDescriptor(_class5$1.prototype, "twistMotion", [_dec12$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "twistMotion"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingMotion1", [_dec13$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingMotion1"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingMotion2", [_dec14], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingMotion2"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "twistExtent", [_dec15], Object.getOwnPropertyDescriptor(_class5$1.prototype, "twistExtent"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingExtent1", [_dec16], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingExtent1"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingExtent2", [_dec17], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingExtent2"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "twistRestitution", [_dec18], Object.getOwnPropertyDescriptor(_class5$1.prototype, "twistRestitution"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingRestitution", [_dec19], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingRestitution"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "enableSoftConstraintTwist", [_dec20], Object.getOwnPropertyDescriptor(_class5$1.prototype, "enableSoftConstraintTwist"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "twistStiffness", [_dec21], Object.getOwnPropertyDescriptor(_class5$1.prototype, "twistStiffness"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "twistDamping", [_dec22], Object.getOwnPropertyDescriptor(_class5$1.prototype, "twistDamping"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "enableSoftConstraintSwing", [_dec23], Object.getOwnPropertyDescriptor(_class5$1.prototype, "enableSoftConstraintSwing"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingStiffness", [_dec24], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingStiffness"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "swingDamping", [_dec25], Object.getOwnPropertyDescriptor(_class5$1.prototype, "swingDamping"), _class5$1.prototype), _initializer10$6 = applyDecoratedInitializer(_class5$1.prototype, "_swing1Motion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer11$6 = applyDecoratedInitializer(_class5$1.prototype, "_swing2Motion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer12$5 = applyDecoratedInitializer(_class5$1.prototype, "_twistMotion", [serializable$6], function () {
        return EConstraintMode.FREE;
      }), _initializer13$4 = applyDecoratedInitializer(_class5$1.prototype, "_twistExtent", [serializable$6], function () {
        return 0;
      }), _initializer14$3 = applyDecoratedInitializer(_class5$1.prototype, "_swingExtent1", [serializable$6], function () {
        return 0;
      }), _initializer15$2 = applyDecoratedInitializer(_class5$1.prototype, "_swingExtent2", [serializable$6], function () {
        return 0;
      }), _initializer16$2 = applyDecoratedInitializer(_class5$1.prototype, "_enableSoftConstraintSwing", [serializable$6], function () {
        return false;
      }), _initializer17$1 = applyDecoratedInitializer(_class5$1.prototype, "_swingBounciness", [serializable$6], function () {
        return 0;
      }), _initializer18$1 = applyDecoratedInitializer(_class5$1.prototype, "_swingStiffness", [serializable$6], function () {
        return 0;
      }), _initializer19 = applyDecoratedInitializer(_class5$1.prototype, "_swingDamping", [serializable$6], function () {
        return 0;
      }), _initializer20 = applyDecoratedInitializer(_class5$1.prototype, "_enableSoftConstraintTwist", [serializable$6], function () {
        return false;
      }), _initializer21 = applyDecoratedInitializer(_class5$1.prototype, "_twistBounciness", [serializable$6], function () {
        return 0;
      }), _initializer22 = applyDecoratedInitializer(_class5$1.prototype, "_twistStiffness", [serializable$6], function () {
        return 0;
      }), _initializer23 = applyDecoratedInitializer(_class5$1.prototype, "_twistDamping", [serializable$6], function () {
        return 0;
      })), _class5$1)) || _class4);
      let LinearDriverSettings = (_dec26 = ccclass$6('cc.LinearDriverSettings'), _dec27 = type$6(EDriverMode), _dec28 = type$6(EDriverMode), _dec29 = type$6(EDriverMode), _dec30 = type$6(Vec3), _dec31 = type$6(Vec3), _dec32 = type$6(CCFloat), _dec26(_class7 = (_class8 = class LinearDriverSettings {
        get xDrive() {
          return this._xDrive;
        }
        set xDrive(v) {
          this._xDrive = v;
          {
            this._impl.setDriverMode(0, v);
          }
        }
        get yDrive() {
          return this._yDrive;
        }
        set yDrive(v) {
          this._yDrive = v;
          {
            this._impl.setDriverMode(1, v);
          }
        }
        get zDrive() {
          return this._zDrive;
        }
        set zDrive(v) {
          this._zDrive = v;
          {
            this._impl.setDriverMode(2, v);
          }
        }
        get targetPosition() {
          return this._target;
        }
        set targetPosition(v) {
          Vec3.copy(this._target, v);
          {
            this._impl.setLinearMotorTarget(v);
          }
        }
        get targetVelocity() {
          return this._velocity;
        }
        set targetVelocity(v) {
          Vec3.copy(this._velocity, v);
          {
            this._impl.setLinearMotorVelocity(v);
          }
        }
        get strength() {
          return this._strength;
        }
        set strength(v) {
          this._strength = v;
          {
            this._impl.setLinearMotorForceLimit(v);
          }
        }
        set impl(v) {
          this._impl = v;
        }
        constructor(configurableConstraint) {
          this._target = _initializer24 && _initializer24();
          this._velocity = _initializer25 && _initializer25();
          this._xDrive = _initializer26 && _initializer26();
          this._yDrive = _initializer27 && _initializer27();
          this._zDrive = _initializer28 && _initializer28();
          this._strength = _initializer29 && _initializer29();
          this._impl = void 0;
          this._impl = configurableConstraint;
        }
      }, (_applyDecoratedDescriptor(_class8.prototype, "xDrive", [_dec27], Object.getOwnPropertyDescriptor(_class8.prototype, "xDrive"), _class8.prototype), _applyDecoratedDescriptor(_class8.prototype, "yDrive", [_dec28], Object.getOwnPropertyDescriptor(_class8.prototype, "yDrive"), _class8.prototype), _applyDecoratedDescriptor(_class8.prototype, "zDrive", [_dec29], Object.getOwnPropertyDescriptor(_class8.prototype, "zDrive"), _class8.prototype), _applyDecoratedDescriptor(_class8.prototype, "targetPosition", [_dec30], Object.getOwnPropertyDescriptor(_class8.prototype, "targetPosition"), _class8.prototype), _applyDecoratedDescriptor(_class8.prototype, "targetVelocity", [_dec31], Object.getOwnPropertyDescriptor(_class8.prototype, "targetVelocity"), _class8.prototype), _applyDecoratedDescriptor(_class8.prototype, "strength", [_dec32], Object.getOwnPropertyDescriptor(_class8.prototype, "strength"), _class8.prototype), _initializer24 = applyDecoratedInitializer(_class8.prototype, "_target", [serializable$6], function () {
        return new Vec3();
      }), _initializer25 = applyDecoratedInitializer(_class8.prototype, "_velocity", [serializable$6], function () {
        return new Vec3();
      }), _initializer26 = applyDecoratedInitializer(_class8.prototype, "_xDrive", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer27 = applyDecoratedInitializer(_class8.prototype, "_yDrive", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer28 = applyDecoratedInitializer(_class8.prototype, "_zDrive", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer29 = applyDecoratedInitializer(_class8.prototype, "_strength", [serializable$6], function () {
        return 0;
      })), _class8)) || _class7);
      let AngularDriverSettings = (_dec33 = ccclass$6('cc.AngularDriverSettings'), _dec34 = type$6(EDriverMode), _dec35 = type$6(EDriverMode), _dec36 = type$6(EDriverMode), _dec37 = type$6(Vec3), _dec38 = type$6(Vec3), _dec39 = type$6(CCFloat), _dec33(_class10 = (_class11 = class AngularDriverSettings {
        get twistDrive() {
          return this._twistDrive;
        }
        set twistDrive(v) {
          this._twistDrive = v;
          {
            this._impl.setDriverMode(3, v);
          }
        }
        get swingDrive1() {
          return this._swingDrive1;
        }
        set swingDrive1(v) {
          this._swingDrive1 = v;
          {
            this._impl.setDriverMode(4, v);
          }
        }
        get swingDrive2() {
          return this._swingDrive2;
        }
        set swingDrive2(v) {
          this._swingDrive2 = v;
          {
            this._impl.setDriverMode(5, v);
          }
        }
        get targetOrientation() {
          return this._targetOrientation;
        }
        set targetOrientation(v) {
          Vec3.copy(this._targetOrientation, v);
          {
            this._impl.setAngularMotorTarget(v);
          }
        }
        get targetVelocity() {
          return this._targetVelocity;
        }
        set targetVelocity(v) {
          Vec3.copy(this._targetVelocity, v);
          {
            this._impl.setAngularMotorVelocity(v);
          }
        }
        get strength() {
          return this._strength;
        }
        set strength(v) {
          this._strength = v;
          {
            this._impl.setAngularMotorForceLimit(v);
          }
        }
        set impl(v) {
          this._impl = v;
        }
        constructor(configurableConstraint) {
          this._swingDrive1 = _initializer30 && _initializer30();
          this._swingDrive2 = _initializer31 && _initializer31();
          this._twistDrive = _initializer32 && _initializer32();
          this._targetOrientation = _initializer33 && _initializer33();
          this._targetVelocity = _initializer34 && _initializer34();
          this._strength = _initializer35 && _initializer35();
          this._impl = void 0;
          this._impl = configurableConstraint;
        }
      }, (_applyDecoratedDescriptor(_class11.prototype, "twistDrive", [_dec34], Object.getOwnPropertyDescriptor(_class11.prototype, "twistDrive"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "swingDrive1", [_dec35], Object.getOwnPropertyDescriptor(_class11.prototype, "swingDrive1"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "swingDrive2", [_dec36], Object.getOwnPropertyDescriptor(_class11.prototype, "swingDrive2"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "targetOrientation", [_dec37], Object.getOwnPropertyDescriptor(_class11.prototype, "targetOrientation"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "targetVelocity", [_dec38], Object.getOwnPropertyDescriptor(_class11.prototype, "targetVelocity"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "strength", [_dec39], Object.getOwnPropertyDescriptor(_class11.prototype, "strength"), _class11.prototype), _initializer30 = applyDecoratedInitializer(_class11.prototype, "_swingDrive1", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer31 = applyDecoratedInitializer(_class11.prototype, "_swingDrive2", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer32 = applyDecoratedInitializer(_class11.prototype, "_twistDrive", [serializable$6], function () {
        return EDriverMode.DISABLED;
      }), _initializer33 = applyDecoratedInitializer(_class11.prototype, "_targetOrientation", [serializable$6], function () {
        return new Vec3();
      }), _initializer34 = applyDecoratedInitializer(_class11.prototype, "_targetVelocity", [serializable$6], function () {
        return new Vec3();
      }), _initializer35 = applyDecoratedInitializer(_class11.prototype, "_strength", [serializable$6], function () {
        return 0;
      })), _class11)) || _class10);
      let ConfigurableConstraint = exports('ConfigurableConstraint', (_dec40 = ccclass$6('cc.ConfigurableConstraint'), _dec41 = type$6(Vec3), _dec42 = type$6(Vec3), _dec43 = type$6(Vec3), _dec44 = type$6(Vec3), _dec45 = type$6(CCBoolean), _dec46 = type$6(CCFloat), _dec47 = type$6(CCFloat), _dec48 = type$6(LinearLimitSettings), _dec49 = type$6(AngularLimitSettings), _dec50 = type$6(LinearDriverSettings), _dec51 = type$6(AngularDriverSettings), _dec52 = formerlySerializedAs$3('linearLimitSettings'), _dec53 = formerlySerializedAs$3('angularLimitSettings'), _dec54 = formerlySerializedAs$3('linearDriverSettings'), _dec55 = formerlySerializedAs$3('angularDriverSettings'), _dec40(_class13 = (_class14 = class ConfigurableConstraint extends Constraint$1 {
        get axis() {
          return this._axis;
        }
        set axis(v) {
          Vec3.copy(this._axis, v);
          {
            this.constraint.setAxis(this._axis);
          }
        }
        get secondaryAxis() {
          return this._secondaryAxis;
        }
        set secondaryAxis(v) {
          Vec3.copy(this._secondaryAxis, v);
          {
            this.constraint.setSecondaryAxis(this._secondaryAxis);
          }
        }
        get pivotA() {
          return this._pivotA;
        }
        set pivotA(v) {
          Vec3.copy(this._pivotA, v);
          {
            this.constraint.setPivotA(this._pivotA);
          }
        }
        get pivotB() {
          return this._pivotB;
        }
        set pivotB(v) {
          Vec3.copy(this._pivotB, v);
          {
            this.constraint.setPivotB(this._pivotB);
          }
        }
        get autoPivotB() {
          return this._autoPivotB;
        }
        set autoPivotB(v) {
          this._autoPivotB = v;
          {
            this.constraint.setAutoPivotB(this._autoPivotB);
          }
        }
        get breakForce() {
          return this._breakForce;
        }
        set breakForce(v) {
          this._breakForce = v;
          {
            this.constraint.setBreakForce(v);
          }
        }
        get breakTorque() {
          return this._breakTorque;
        }
        set breakTorque(v) {
          this._breakTorque = v;
          {
            this.constraint.setBreakTorque(v);
          }
        }
        get linearLimitSettings() {
          return this._linearLimitSettings;
        }
        set linearLimitSettings(v) {
          this._linearLimitSettings = v;
          {
            const constraint = this.constraint;
            constraint.setConstraintMode(0, v.xMotion);
            constraint.setConstraintMode(1, v.yMotion);
            constraint.setConstraintMode(2, v.zMotion);
            const upper = v.upper;
            const lower = v.lower;
            constraint.setLinearLimit(0, lower.x, upper.x);
            constraint.setLinearLimit(1, lower.y, upper.y);
            constraint.setLinearLimit(2, lower.z, upper.z);
            constraint.setLinearSoftConstraint(v.enableSoftConstraint);
            constraint.setLinearDamping(v.damping);
            constraint.setLinearStiffness(v.stiffness);
            constraint.setLinearRestitution(v.restitution);
          }
        }
        get angularLimitSettings() {
          return this._angularLimitSettings;
        }
        set angularLimitSettings(v) {
          this._angularLimitSettings = v;
          {
            const constraint = this.constraint;
            constraint.setConstraintMode(3, v.twistMotion);
            constraint.setConstraintMode(4, v.swingMotion1);
            constraint.setConstraintMode(5, v.swingMotion2);
            constraint.setAngularExtent(v.twistExtent, v.swingExtent1, v.swingExtent2);
            constraint.setTwistRestitution(v.twistRestitution);
            constraint.setSwingRestitution(v.swingRestitution);
            constraint.setTwistSoftConstraint(v.enableSoftConstraintTwist);
            constraint.setSwingSoftConstraint(v.enableSoftConstraintSwing);
            constraint.setTwistDamping(v.twistDamping);
            constraint.setSwingDamping(v.swingDamping);
            constraint.setTwistStiffness(v.twistStiffness);
            constraint.setSwingStiffness(v.swingStiffness);
          }
        }
        get linearDriverSettings() {
          return this._linearDriverSettings;
        }
        set linearDriverSettings(v) {
          this._linearDriverSettings = v;
          {
            const constraint = this.constraint;
            constraint.setDriverMode(0, v.xDrive);
            constraint.setDriverMode(1, v.yDrive);
            constraint.setDriverMode(2, v.zDrive);
            constraint.setLinearMotorTarget(v.targetPosition);
            constraint.setLinearMotorVelocity(v.targetVelocity);
            constraint.setLinearMotorForceLimit(v.strength);
          }
        }
        get angularDriverSettings() {
          return this._angularDriverSettings;
        }
        set angularDriverSettings(v) {
          this._angularDriverSettings = v;
          {
            const constraint = this.constraint;
            constraint.setDriverMode(3, v.twistDrive);
            constraint.setDriverMode(4, v.swingDrive1);
            constraint.setDriverMode(5, v.swingDrive2);
            constraint.setAngularMotorTarget(v.targetOrientation);
            constraint.setAngularMotorVelocity(v.targetVelocity);
            constraint.setAngularMotorForceLimit(v.strength);
          }
        }
        get constraint() {
          return this._constraint;
        }
        constructor() {
          super(EConstraintType.CONFIGURABLE);
          this._breakForce = _initializer36 && _initializer36();
          this._breakTorque = _initializer37 && _initializer37();
          this._linearLimitSettings = _initializer38 && _initializer38();
          this._angularLimitSettings = _initializer39 && _initializer39();
          this._linearDriverSettings = _initializer40 && _initializer40();
          this._angularDriverSettings = _initializer41 && _initializer41();
          this._pivotA = _initializer42 && _initializer42();
          this._pivotB = _initializer43 && _initializer43();
          this._autoPivotB = _initializer44 && _initializer44();
          this._axis = _initializer45 && _initializer45();
          this._secondaryAxis = _initializer46 && _initializer46();
          this._linearLimitSettings = new LinearLimitSettings(this.constraint);
          this._angularLimitSettings = new AngularLimitSettings(this.constraint);
          this._linearDriverSettings = new LinearDriverSettings(this.constraint);
          this._angularDriverSettings = new AngularDriverSettings(this.constraint);
        }
        onLoad() {
          super.onLoad();
          {
            this.linearLimitSettings.impl = this.constraint;
            this.angularLimitSettings.impl = this.constraint;
            this.linearDriverSettings.impl = this.constraint;
            this.angularDriverSettings.impl = this.constraint;
          }
        }
      }, (_applyDecoratedDescriptor(_class14.prototype, "axis", [_dec41], Object.getOwnPropertyDescriptor(_class14.prototype, "axis"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "secondaryAxis", [_dec42], Object.getOwnPropertyDescriptor(_class14.prototype, "secondaryAxis"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "pivotA", [_dec43], Object.getOwnPropertyDescriptor(_class14.prototype, "pivotA"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "pivotB", [_dec44], Object.getOwnPropertyDescriptor(_class14.prototype, "pivotB"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "autoPivotB", [_dec45], Object.getOwnPropertyDescriptor(_class14.prototype, "autoPivotB"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "breakForce", [_dec46], Object.getOwnPropertyDescriptor(_class14.prototype, "breakForce"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "breakTorque", [_dec47], Object.getOwnPropertyDescriptor(_class14.prototype, "breakTorque"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "linearLimitSettings", [_dec48], Object.getOwnPropertyDescriptor(_class14.prototype, "linearLimitSettings"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "angularLimitSettings", [_dec49], Object.getOwnPropertyDescriptor(_class14.prototype, "angularLimitSettings"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "linearDriverSettings", [_dec50], Object.getOwnPropertyDescriptor(_class14.prototype, "linearDriverSettings"), _class14.prototype), _applyDecoratedDescriptor(_class14.prototype, "angularDriverSettings", [_dec51], Object.getOwnPropertyDescriptor(_class14.prototype, "angularDriverSettings"), _class14.prototype), _initializer36 = applyDecoratedInitializer(_class14.prototype, "_breakForce", [serializable$6], function () {
        return 1e8;
      }), _initializer37 = applyDecoratedInitializer(_class14.prototype, "_breakTorque", [serializable$6], function () {
        return 1e8;
      }), _initializer38 = applyDecoratedInitializer(_class14.prototype, "_linearLimitSettings", [serializable$6, _dec52], null), _initializer39 = applyDecoratedInitializer(_class14.prototype, "_angularLimitSettings", [serializable$6, _dec53], null), _initializer40 = applyDecoratedInitializer(_class14.prototype, "_linearDriverSettings", [serializable$6, _dec54], null), _initializer41 = applyDecoratedInitializer(_class14.prototype, "_angularDriverSettings", [serializable$6, _dec55], null), _initializer42 = applyDecoratedInitializer(_class14.prototype, "_pivotA", [serializable$6], function () {
        return new Vec3();
      }), _initializer43 = applyDecoratedInitializer(_class14.prototype, "_pivotB", [serializable$6], function () {
        return new Vec3();
      }), _initializer44 = applyDecoratedInitializer(_class14.prototype, "_autoPivotB", [serializable$6], function () {
        return false;
      }), _initializer45 = applyDecoratedInitializer(_class14.prototype, "_axis", [serializable$6], function () {
        return new Vec3(0, 1, 0);
      }), _initializer46 = applyDecoratedInitializer(_class14.prototype, "_secondaryAxis", [serializable$6], function () {
        return new Vec3(1, 0, 0);
      })), _class14)) || _class13));

      var _dec$n, _dec2$k, _dec3$i, _class$n, _class2$j, _initializer$i, _initializer2$i;
      let PointToPointConstraint = exports('PointToPointConstraint', (_dec$n = ccclass$6('cc.PointToPointConstraint'), _dec2$k = type$6(Vec3), _dec3$i = type$6(Vec3), _dec$n(_class$n = (_class2$j = class PointToPointConstraint extends Constraint$1 {
        get pivotA() {
          return this._pivotA;
        }
        set pivotA(v) {
          Vec3.copy(this._pivotA, v);
          {
            this.constraint.setPivotA(this._pivotA);
          }
        }
        get pivotB() {
          return this._pivotB;
        }
        set pivotB(v) {
          Vec3.copy(this._pivotB, v);
          {
            this.constraint.setPivotB(this._pivotB);
          }
        }
        get constraint() {
          return this._constraint;
        }
        constructor() {
          super(EConstraintType.POINT_TO_POINT);
          this._pivotA = _initializer$i && _initializer$i();
          this._pivotB = _initializer2$i && _initializer2$i();
        }
      }, (_applyDecoratedDescriptor(_class2$j.prototype, "pivotA", [_dec2$k], Object.getOwnPropertyDescriptor(_class2$j.prototype, "pivotA"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "pivotB", [_dec3$i], Object.getOwnPropertyDescriptor(_class2$j.prototype, "pivotB"), _class2$j.prototype), _initializer$i = applyDecoratedInitializer(_class2$j.prototype, "_pivotA", [serializable$6], function () {
        return new Vec3();
      }), _initializer2$i = applyDecoratedInitializer(_class2$j.prototype, "_pivotB", [serializable$6], function () {
        return new Vec3();
      })), _class2$j)) || _class$n));

      var _dec$m, _dec2$j, _dec3$h, _dec4$e, _dec5$d, _dec6$6, _dec7$5, _class$m, _class2$i, _initializer$h, _initializer2$h, _initializer3$d, _initializer4$b, _initializer5$9, _initializer6$6;
      new Vec3(0, 0, 0);
      new Vec3(0, 0, 0);
      let CharacterController = exports('CharacterController', (_dec$m = ccclass$6('cc.CharacterController'), _dec2$j = type$6(PhysicsSystem.PhysicsGroup), _dec3$h = type$6(CCFloat), _dec4$e = type$6(CCFloat), _dec5$d = type$6(CCFloat), _dec6$6 = type$6(CCFloat), _dec7$5 = type$6(Vec3), _dec$m(_class$m = disallowMultiple$1(_class$m = (_class2$i = class CharacterController extends Eventify(Component) {
        get group() {
          return this._group;
        }
        set group(v) {
          if (!Number.isInteger(Math.log2(v >>> 0))) {
            warn('[Physics]: The group should only have one bit.');
          }
          this._group = v;
          if (this._cct) {
            if (this._cct.getGroup() !== v) this._cct.setGroup(v);
          }
        }
        get minMoveDistance() {
          return this._minMoveDistance;
        }
        set minMoveDistance(value) {
          if (this._minMoveDistance === value) return;
          this._minMoveDistance = Math.abs(value);
        }
        get stepOffset() {
          return this._stepOffset;
        }
        set stepOffset(value) {
          if (this._stepOffset === value) return;
          this._stepOffset = Math.abs(value);
          if (this._cct) {
            this._cct.setStepOffset(value);
          }
        }
        get slopeLimit() {
          return this._slopeLimit;
        }
        set slopeLimit(value) {
          if (this._slopeLimit === value) return;
          this._slopeLimit = Math.abs(value);
          if (this._cct) {
            this._cct.setSlopeLimit(value);
          }
        }
        get skinWidth() {
          return this._skinWidth;
        }
        set skinWidth(value) {
          if (this._skinWidth === value) return;
          this._skinWidth = Math.abs(value);
          if (this._cct) {
            this._cct.setContactOffset(Math.max(0.0001, value));
          }
        }
        get center() {
          return this._center;
        }
        set center(value) {
          if (Vec3.equals(this._center, value)) return;
          Vec3.copy(this._center, value);
        }
        constructor(type) {
          super();
          this.type = void 0;
          this._cct = null;
          this._group = _initializer$h && _initializer$h();
          this._minMoveDistance = _initializer2$h && _initializer2$h();
          this._stepOffset = _initializer3$d && _initializer3$d();
          this._slopeLimit = _initializer4$b && _initializer4$b();
          this._skinWidth = _initializer5$9 && _initializer5$9();
          this._center = _initializer6$6 && _initializer6$6();
          this._initialized = false;
          this._prevPos = new Vec3();
          this._currentPos = new Vec3();
          this._velocity = new Vec3();
          this._centerWorldPosition = new Vec3();
          this._needCollisionEvent = false;
          this._needTriggerEvent = false;
          this.type = type;
        }
        get _isInitialized() {
          if (this._cct === null || !this._initialized) {
            return false;
          } else {
            return true;
          }
        }
        onLoad() {
          if (!selector.runInEditor) return;
          this._cct = createCharacterController(this.type);
          this._initialized = this._cct.initialize(this);
          this._cct.onLoad();
        }
        onEnable() {
          if (this._cct) {
            this._cct.onEnable();
          }
        }
        onDisable() {
          if (this._cct) {
            this._cct.onDisable();
          }
        }
        onDestroy() {
          if (this._cct) {
            this._needCollisionEvent = false;
            this._needTriggerEvent = false;
            this._cct.updateEventListener();
            this._cct.onDestroy();
            this._cct = null;
          }
        }
        get centerWorldPosition() {
          if (this._isInitialized) this._cct.getPosition(this._centerWorldPosition);
          return this._centerWorldPosition;
        }
        set centerWorldPosition(value) {
          if (this._isInitialized) this._cct.setPosition(value);
        }
        get velocity() {
          return this._velocity;
        }
        get isGrounded() {
          return this._cct.onGround();
        }
        move(movement) {
          if (!this._isInitialized) {
            return;
          }
          this._prevPos.set(this.centerWorldPosition);
          const elapsedTime = PhysicsSystem.instance.fixedTimeStep;
          this._cct.move(movement, this._minMoveDistance, elapsedTime);
          this._currentPos.set(this.centerWorldPosition);
          this._velocity = this._currentPos.subtract(this._prevPos).multiplyScalar(1.0 / elapsedTime);
          this._cct.syncPhysicsToScene();
        }
        on(type, callback, target, once) {
          const ret = super.on(type, callback, target, once);
          this._updateNeedEvent(type);
          return ret;
        }
        off(type, callback, target) {
          super.off(type, callback, target);
          this._updateNeedEvent();
        }
        once(type, callback, target) {
          const ret = super.once(type, callback, target);
          this._updateNeedEvent(type);
          return ret;
        }
        getGroup() {
          if (this._isInitialized) return this._cct.getGroup();
          return 0;
        }
        setGroup(v) {
          if (this._isInitialized) this._cct.setGroup(v);
        }
        addGroup(v) {
          if (this._isInitialized) this._cct.addGroup(v);
        }
        removeGroup(v) {
          if (this._isInitialized) this._cct.removeGroup(v);
        }
        getMask() {
          if (this._isInitialized) return this._cct.getMask();
          return 0;
        }
        setMask(v) {
          if (this._isInitialized) this._cct.setMask(v);
        }
        addMask(v) {
          if (this._isInitialized) this._cct.addMask(v);
        }
        removeMask(v) {
          if (this._isInitialized) this._cct.removeMask(v);
        }
        get needCollisionEvent() {
          return this._needCollisionEvent;
        }
        get needTriggerEvent() {
          return this._needTriggerEvent;
        }
        _updateNeedEvent(type) {
          if (this.isValid) {
            if (type !== undefined) {
              if (type === 'onControllerColliderHit') {
                this._needCollisionEvent = true;
              }
              if (type === 'onControllerTriggerEnter' || type === 'onControllerTriggerStay' || type === 'onControllerTriggerExit') {
                this._needTriggerEvent = true;
              }
            } else {
              if (!this.hasEventListener('onControllerColliderHit')) {
                this._needCollisionEvent = false;
              }
              if (!(this.hasEventListener('onControllerTriggerEnter') || this.hasEventListener('onControllerTriggerStay') || this.hasEventListener('onControllerTriggerExit'))) {
                this._needTriggerEvent = false;
              }
            }
            if (this._cct) this._cct.updateEventListener();
          }
        }
      }, (_applyDecoratedDescriptor(_class2$i.prototype, "group", [_dec2$j], Object.getOwnPropertyDescriptor(_class2$i.prototype, "group"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "minMoveDistance", [_dec3$h], Object.getOwnPropertyDescriptor(_class2$i.prototype, "minMoveDistance"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "stepOffset", [_dec4$e], Object.getOwnPropertyDescriptor(_class2$i.prototype, "stepOffset"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "slopeLimit", [_dec5$d], Object.getOwnPropertyDescriptor(_class2$i.prototype, "slopeLimit"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "skinWidth", [_dec6$6], Object.getOwnPropertyDescriptor(_class2$i.prototype, "skinWidth"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "center", [_dec7$5], Object.getOwnPropertyDescriptor(_class2$i.prototype, "center"), _class2$i.prototype), _initializer$h = applyDecoratedInitializer(_class2$i.prototype, "_group", [serializable$6], function () {
        return PhysicsSystem.PhysicsGroup.DEFAULT;
      }), _initializer2$h = applyDecoratedInitializer(_class2$i.prototype, "_minMoveDistance", [serializable$6], function () {
        return 0.001;
      }), _initializer3$d = applyDecoratedInitializer(_class2$i.prototype, "_stepOffset", [serializable$6], function () {
        return 0.5;
      }), _initializer4$b = applyDecoratedInitializer(_class2$i.prototype, "_slopeLimit", [serializable$6], function () {
        return 45.0;
      }), _initializer5$9 = applyDecoratedInitializer(_class2$i.prototype, "_skinWidth", [serializable$6], function () {
        return 0.01;
      }), _initializer6$6 = applyDecoratedInitializer(_class2$i.prototype, "_center", [serializable$6], function () {
        return new Vec3();
      })), _class2$i)) || _class$m) || _class$m));

      var _dec$l, _dec2$i, _dec3$g, _dec4$d, _dec5$c, _class$l, _class2$h, _initializer$g, _initializer2$g, _initializer3$c;
      new Vec3(0, 0, 0);
      let BoxCharacterController = exports('BoxCharacterController', (_dec$l = ccclass$6('cc.BoxCharacterController'), _dec2$i = executionOrder$1(-1), _dec3$g = type$6(CCFloat), _dec4$d = type$6(CCFloat), _dec5$c = type$6(CCFloat), _dec$l(_class$l = _dec2$i(_class$l = (_class2$h = class BoxCharacterController extends CharacterController {
        constructor() {
          super(ECharacterControllerType.BOX);
          this._halfHeight = _initializer$g && _initializer$g();
          this._halfSideExtent = _initializer2$g && _initializer2$g();
          this._halfForwardExtent = _initializer3$c && _initializer3$c();
        }
        get halfHeight() {
          return this._halfHeight;
        }
        set halfHeight(value) {
          if (this._halfHeight === value) return;
          this._halfHeight = Math.abs(value);
          if (this._cct) {
            this._cct.setHalfHeight(value);
          }
        }
        get halfSideExtent() {
          return this._halfSideExtent;
        }
        set halfSideExtent(value) {
          if (this._halfSideExtent === value) return;
          this._halfSideExtent = Math.abs(value);
          if (this._cct) {
            this._cct.setHalfSideExtent(value);
          }
        }
        get halfForwardExtent() {
          return this._halfForwardExtent;
        }
        set halfForwardExtent(value) {
          if (this._halfForwardExtent === value) return;
          this._halfForwardExtent = Math.abs(value);
          if (this._cct) {
            this._cct.setHalfForwardExtent(value);
          }
        }
      }, (_applyDecoratedDescriptor(_class2$h.prototype, "halfHeight", [_dec3$g], Object.getOwnPropertyDescriptor(_class2$h.prototype, "halfHeight"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "halfSideExtent", [_dec4$d], Object.getOwnPropertyDescriptor(_class2$h.prototype, "halfSideExtent"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "halfForwardExtent", [_dec5$c], Object.getOwnPropertyDescriptor(_class2$h.prototype, "halfForwardExtent"), _class2$h.prototype), _initializer$g = applyDecoratedInitializer(_class2$h.prototype, "_halfHeight", [serializable$6], function () {
        return 0.5;
      }), _initializer2$g = applyDecoratedInitializer(_class2$h.prototype, "_halfSideExtent", [serializable$6], function () {
        return 0.5;
      }), _initializer3$c = applyDecoratedInitializer(_class2$h.prototype, "_halfForwardExtent", [serializable$6], function () {
        return 0.5;
      })), _class2$h)) || _class$l) || _class$l));

      var _dec$k, _dec2$h, _dec3$f, _dec4$c, _class$k, _class2$g, _initializer$f, _initializer2$f;
      new Vec3(0, 0, 0);
      let CapsuleCharacterController = exports('CapsuleCharacterController', (_dec$k = ccclass$6('cc.CapsuleCharacterController'), _dec2$h = executionOrder$1(-1), _dec3$f = type$6(CCFloat), _dec4$c = type$6(CCFloat), _dec$k(_class$k = _dec2$h(_class$k = (_class2$g = class CapsuleCharacterController extends CharacterController {
        constructor() {
          super(ECharacterControllerType.CAPSULE);
          this._radius = _initializer$f && _initializer$f();
          this._height = _initializer2$f && _initializer2$f();
        }
        get radius() {
          return this._radius;
        }
        set radius(value) {
          if (this._radius === value) return;
          this._radius = Math.abs(value);
          if (this._cct) {
            this._cct.setRadius(value);
          }
        }
        get height() {
          return this._height;
        }
        set height(value) {
          if (this._height === value) return;
          this._height = Math.abs(value);
          if (this._cct) {
            this._cct.setHeight(value);
          }
        }
      }, (_applyDecoratedDescriptor(_class2$g.prototype, "radius", [_dec3$f], Object.getOwnPropertyDescriptor(_class2$g.prototype, "radius"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "height", [_dec4$c], Object.getOwnPropertyDescriptor(_class2$g.prototype, "height"), _class2$g.prototype), _initializer$f = applyDecoratedInitializer(_class2$g.prototype, "_radius", [serializable$6], function () {
        return 0.5;
      }), _initializer2$f = applyDecoratedInitializer(_class2$g.prototype, "_height", [serializable$6], function () {
        return 1.0;
      })), _class2$g)) || _class$k) || _class$k));

      class CharacterControllerContact {
        constructor() {
          this.worldPosition = new Vec3();
          this.worldNormal = new Vec3();
          this.motionDirection = new Vec3();
          this.motionLength = 0;
        }
      }

      legacyCC.PhysicsSystem = PhysicsSystem;
      legacyCC.PhysicsMaterial = PhysicsMaterial;
      legacyCC.PhysicsRayResult = PhysicsRayResult;
      legacyCC.ConstantForce = ConstantForce;

      var physics = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PhysicsSystem: PhysicsSystem,
        PhysicsRayResult: PhysicsRayResult,
        PhysicsLineStripCastResult: PhysicsLineStripCastResult,
        get Collider () { return Collider; },
        BoxCollider: BoxCollider,
        SphereCollider: SphereCollider,
        CapsuleCollider: CapsuleCollider,
        MeshCollider: MeshCollider,
        CylinderCollider: CylinderCollider,
        ConeCollider: ConeCollider,
        TerrainCollider: TerrainCollider,
        get SimplexCollider () { return SimplexCollider; },
        PlaneCollider: PlaneCollider,
        get Constraint () { return Constraint$1; },
        HingeConstraint: HingeConstraint,
        FixedConstraint: FixedConstraint,
        PointToPointConstraint: PointToPointConstraint,
        ConfigurableConstraint: ConfigurableConstraint,
        get RigidBody () { return RigidBody; },
        PhysicsMaterial: PhysicsMaterial,
        ConstantForce: ConstantForce,
        CharacterController: CharacterController,
        BoxCharacterController: BoxCharacterController,
        CapsuleCharacterController: CapsuleCharacterController,
        selector: selector,
        utils: util,
        CharacterControllerContact: CharacterControllerContact,
        get ERigidBodyType () { return ERigidBodyType; },
        get EAxisDirection () { return EAxisDirection; },
        get ED6Axis () { return ED6Axis; },
        get ESimplexType () { return ESimplexType; },
        get EColliderType () { return EColliderType; },
        get EConstraintType () { return EConstraintType; },
        get EConstraintMode () { return EConstraintMode; },
        get EDriverMode () { return EDriverMode; },
        get ECharacterControllerType () { return ECharacterControllerType; },
        get PhysicsGroup () { return PhysicsGroup; },
        get EPhysicsDrawFlags () { return EPhysicsDrawFlags; }
      });
      exports('physics', physics);

      replaceProperty(PhysicsSystem, 'PhysicsSystem', [{
        name: 'ins',
        newName: 'instance'
      }, {
        name: 'PHYSICS_AMMO',
        newName: 'PHYSICS_BULLET'
      }]);
      replaceProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
        name: 'deltaTime',
        newName: 'fixedTimeStep'
      }, {
        name: 'maxSubStep',
        newName: 'maxSubSteps'
      }]);
      removeProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
        name: 'useFixedTime'
      }, {
        name: 'useCollisionMatrix'
      }, {
        name: 'updateCollisionMatrix'
      }, {
        name: 'resetCollisionMatrix'
      }, {
        name: 'isCollisionGroup'
      }, {
        name: 'setCollisionGroup'
      }]);
      replaceProperty(Collider.prototype, 'Collider.prototype', [{
        name: 'attachedRigidbody',
        newName: 'attachedRigidBody'
      }, {
        name: 'TYPE',
        newName: 'type'
      }]);
      replaceProperty(Collider, 'Collider', [{
        name: 'EColliderType',
        newName: 'Type'
      }, {
        name: 'EAxisDirection',
        newName: 'Axis'
      }]);
      replaceProperty(Constraint$1, 'Constraint', [{
        name: 'EConstraintType',
        newName: 'Type'
      }]);
      replaceProperty(BoxCollider.prototype, 'BoxCollider.prototype', [{
        name: 'boxShape',
        newName: 'shape'
      }]);
      replaceProperty(SphereCollider.prototype, 'SphereCollider.prototype', [{
        name: 'sphereShape',
        newName: 'shape'
      }]);
      replaceProperty(CapsuleCollider.prototype, 'CapsuleCollider.prototype', [{
        name: 'capsuleShape',
        newName: 'shape'
      }]);
      replaceProperty(RigidBody.prototype, 'RigidBody.prototype', [{
        name: 'rigidBody',
        newName: 'body'
      }]);
      replaceProperty(RigidBody, 'RigidBody', [{
        name: 'ERigidBodyType',
        newName: 'Type'
      }]);
      removeProperty(RigidBody.prototype, 'RigidBody.prototype', [{
        name: 'fixedRotation'
      }]);
      legacyCC.RigidBodyComponent = RigidBody;
      setClassAlias(RigidBody, 'cc.RigidBodyComponent');
      legacyCC.ColliderComponent = Collider;
      setClassAlias(Collider, 'cc.ColliderComponent');
      legacyCC.BoxColliderComponent = BoxCollider;
      setClassAlias(BoxCollider, 'cc.BoxColliderComponent');
      legacyCC.SphereColliderComponent = SphereCollider;
      setClassAlias(SphereCollider, 'cc.SphereColliderComponent');
      setClassAlias(CapsuleCollider, 'cc.CapsuleColliderComponent');
      setClassAlias(MeshCollider, 'cc.MeshColliderComponent');
      setClassAlias(CylinderCollider, 'cc.CylinderColliderComponent');
      legacyCC.PhysicMaterial = PhysicsMaterial;
      setClassAlias(PhysicsMaterial, 'cc.PhysicMaterial');

      legacyCC.physics = physics;

      let EBtSharedBodyDirty;
      (function (EBtSharedBodyDirty) {
        EBtSharedBodyDirty[EBtSharedBodyDirty["BODY_RE_ADD"] = 1] = "BODY_RE_ADD";
        EBtSharedBodyDirty[EBtSharedBodyDirty["GHOST_RE_ADD"] = 2] = "GHOST_RE_ADD";
      })(EBtSharedBodyDirty || (EBtSharedBodyDirty = {}));
      let btCollisionFlags;
      (function (btCollisionFlags) {
        btCollisionFlags[btCollisionFlags["CF_STATIC_OBJECT"] = 1] = "CF_STATIC_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_KINEMATIC_OBJECT"] = 2] = "CF_KINEMATIC_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_NO_CONTACT_RESPONSE"] = 4] = "CF_NO_CONTACT_RESPONSE";
        btCollisionFlags[btCollisionFlags["CF_CUSTOM_MATERIAL_CALLBACK"] = 8] = "CF_CUSTOM_MATERIAL_CALLBACK";
        btCollisionFlags[btCollisionFlags["CF_CHARACTER_OBJECT"] = 16] = "CF_CHARACTER_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_DISABLE_VISUALIZE_OBJECT"] = 32] = "CF_DISABLE_VISUALIZE_OBJECT";
        btCollisionFlags[btCollisionFlags["CF_DISABLE_SPU_COLLISION_PROCESSING"] = 64] = "CF_DISABLE_SPU_COLLISION_PROCESSING";
      })(btCollisionFlags || (btCollisionFlags = {}));
      let btCollisionObjectTypes;
      (function (btCollisionObjectTypes) {
        btCollisionObjectTypes[btCollisionObjectTypes["CO_COLLISION_OBJECT"] = 1] = "CO_COLLISION_OBJECT";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_RIGID_BODY"] = 2] = "CO_RIGID_BODY";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_GHOST_OBJECT"] = 4] = "CO_GHOST_OBJECT";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_SOFT_BODY"] = 8] = "CO_SOFT_BODY";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_HF_FLUID"] = 16] = "CO_HF_FLUID";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_USER_TYPE"] = 32] = "CO_USER_TYPE";
        btCollisionObjectTypes[btCollisionObjectTypes["CO_FEATHERSTONE_LINK"] = 64] = "CO_FEATHERSTONE_LINK";
      })(btCollisionObjectTypes || (btCollisionObjectTypes = {}));
      let btCollisionObjectStates;
      (function (btCollisionObjectStates) {
        btCollisionObjectStates[btCollisionObjectStates["ACTIVE_TAG"] = 1] = "ACTIVE_TAG";
        btCollisionObjectStates[btCollisionObjectStates["ISLAND_SLEEPING"] = 2] = "ISLAND_SLEEPING";
        btCollisionObjectStates[btCollisionObjectStates["WANTS_DEACTIVATION"] = 3] = "WANTS_DEACTIVATION";
        btCollisionObjectStates[btCollisionObjectStates["DISABLE_DEACTIVATION"] = 4] = "DISABLE_DEACTIVATION";
        btCollisionObjectStates[btCollisionObjectStates["DISABLE_SIMULATION"] = 5] = "DISABLE_SIMULATION";
      })(btCollisionObjectStates || (btCollisionObjectStates = {}));
      let btRigidBodyFlags;
      (function (btRigidBodyFlags) {
        btRigidBodyFlags[btRigidBodyFlags["BT_DISABLE_WORLD_GRAVITY"] = 1] = "BT_DISABLE_WORLD_GRAVITY";
        btRigidBodyFlags[btRigidBodyFlags["BT_ENABLE_GYROPSCOPIC_FORCE"] = 2] = "BT_ENABLE_GYROPSCOPIC_FORCE";
      })(btRigidBodyFlags || (btRigidBodyFlags = {}));

      const v3_0$6 = CC_V3_0;
      const v3_1$2 = CC_V3_1;
      class BulletRigidBody {
        get isAwake() {
          const state = bt.CollisionObject_getActivationState(this.impl);
          return state === btCollisionObjectStates.ACTIVE_TAG || state === btCollisionObjectStates.DISABLE_DEACTIVATION;
        }
        get isSleepy() {
          const state = bt.CollisionObject_getActivationState(this.impl);
          return state === btCollisionObjectStates.WANTS_DEACTIVATION;
        }
        get isSleeping() {
          const state = bt.CollisionObject_getActivationState(this.impl);
          return state === btCollisionObjectStates.ISLAND_SLEEPING;
        }
        setMass(value) {
          if (!this._rigidBody.isDynamic) return;
          bt.RigidBody_setMass(this.impl, value);
          this._wakeUpIfSleep();
          this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
        }
        setType(v) {
          this._sharedBody.setType(v);
        }
        setLinearDamping(value) {
          bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
        }
        setAngularDamping(value) {
          bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
        }
        useGravity(value) {
          if (!this._rigidBody.isDynamic) return;
          let m_rigidBodyFlag = bt.RigidBody_getFlags(this.impl);
          if (value) {
            m_rigidBodyFlag &= ~btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
          } else {
            bt.RigidBody_setGravity(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, Vec3.ZERO));
            m_rigidBodyFlag |= btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
          }
          bt.RigidBody_setFlags(this.impl, m_rigidBodyFlag);
          this._wakeUpIfSleep();
          this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
        }
        useCCD(value) {
          bt.CollisionObject_setCcdMotionThreshold(this.impl, value ? 0.01 : 0);
          bt.CollisionObject_setCcdSweptSphereRadius(this.impl, value ? 0.1 : 0);
          this._isUsingCCD = value;
        }
        isUsingCCD() {
          return this._isUsingCCD;
        }
        setLinearFactor(v) {
          bt.RigidBody_setLinearFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));
          this._wakeUpIfSleep();
        }
        setAngularFactor(v) {
          bt.RigidBody_setAngularFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));
          this._wakeUpIfSleep();
        }
        setAllowSleep(v) {
          if (!this._rigidBody.isDynamic) return;
          if (v) {
            bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ACTIVE_TAG);
          } else {
            bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.DISABLE_DEACTIVATION);
          }
          this._wakeUpIfSleep();
        }
        get impl() {
          return this._sharedBody.body;
        }
        get rigidBody() {
          return this._rigidBody;
        }
        get sharedBody() {
          return this._sharedBody;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        constructor() {
          this.id = void 0;
          this._isEnabled = false;
          this._isUsingCCD = false;
          this._sharedBody = void 0;
          this._rigidBody = void 0;
          this.id = BulletRigidBody.idCounter++;
        }
        clearState() {
          bt.RigidBody_clearState(this.impl);
        }
        clearVelocity() {
          this.setLinearVelocity(Vec3.ZERO);
          this.setAngularVelocity(Vec3.ZERO);
        }
        clearForces() {
          bt.RigidBody_clearForces(this.impl);
        }
        initialize(com) {
          this._rigidBody = com;
          this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node, this);
          this._sharedBody.reference = true;
        }
        onEnable() {
          this._isEnabled = true;
          this.setMass(this._rigidBody.mass);
          this.setAllowSleep(this._rigidBody.allowSleep);
          this.setLinearDamping(this._rigidBody.linearDamping);
          this.setAngularDamping(this._rigidBody.angularDamping);
          this.setLinearFactor(this._rigidBody.linearFactor);
          this.setAngularFactor(this._rigidBody.angularFactor);
          this.useGravity(this._rigidBody.useGravity);
          this._sharedBody.bodyEnabled = true;
        }
        onDisable() {
          this._isEnabled = false;
          this._sharedBody.bodyEnabled = false;
        }
        onDestroy() {
          this._sharedBody.reference = false;
          this._rigidBody = null;
          this._sharedBody = null;
        }
        wakeUp(force = true) {
          bt.CollisionObject_activate(this.impl, force);
        }
        sleep() {
          const state = bt.CollisionObject_getActivationState(this.impl);
          if (state !== btCollisionObjectStates.DISABLE_DEACTIVATION && state !== btCollisionObjectStates.DISABLE_SIMULATION) {
            bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ISLAND_SLEEPING);
          }
        }
        setSleepThreshold(v) {
          this._wakeUpIfSleep();
          bt.RigidBody_setSleepingThresholds(this.impl, v, v);
        }
        getSleepThreshold() {
          return bt.RigidBody_getLinearSleepingThreshold(this.impl);
        }
        getLinearVelocity(out) {
          return bullet2CocosVec3(out, bt.RigidBody_getLinearVelocity(this.impl));
        }
        setLinearVelocity(value) {
          this._wakeUpIfSleep();
          cocos2BulletVec3(bt.RigidBody_getLinearVelocity(this.impl), value);
        }
        getAngularVelocity(out) {
          return bullet2CocosVec3(out, bt.RigidBody_getAngularVelocity(this.impl));
        }
        setAngularVelocity(value) {
          this._wakeUpIfSleep();
          cocos2BulletVec3(bt.RigidBody_getAngularVelocity(this.impl), value);
        }
        applyLocalForce(force, rel_pos) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          const quat = this._sharedBody.node.worldRotation;
          const v = Vec3.transformQuat(v3_0$6, force, quat);
          const rp = rel_pos ? Vec3.transformQuat(v3_1$2, rel_pos, quat) : Vec3.ZERO;
          bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        }
        applyLocalTorque(torque) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          Vec3.transformQuat(v3_0$6, torque, this._sharedBody.node.worldRotation);
          bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$6));
        }
        applyLocalImpulse(impulse, rel_pos) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          const quat = this._sharedBody.node.worldRotation;
          const v = Vec3.transformQuat(v3_0$6, impulse, quat);
          const rp = rel_pos ? Vec3.transformQuat(v3_1$2, rel_pos, quat) : Vec3.ZERO;
          bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        }
        applyForce(force, rel_pos) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          const rp = rel_pos || Vec3.ZERO;
          bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, force), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        }
        applyTorque(torque) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, torque));
        }
        applyImpulse(impulse, rel_pos) {
          this._sharedBody.syncSceneToPhysics();
          this._wakeUpIfSleep();
          const rp = rel_pos || Vec3.ZERO;
          bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, impulse), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
        }
        getGroup() {
          return this._sharedBody.collisionFilterGroup;
        }
        setGroup(v) {
          this._sharedBody.collisionFilterGroup = v;
        }
        addGroup(v) {
          this._sharedBody.collisionFilterGroup |= v;
        }
        removeGroup(v) {
          this._sharedBody.collisionFilterGroup &= ~v;
        }
        getMask() {
          return this._sharedBody.collisionFilterMask;
        }
        setMask(v) {
          this._sharedBody.collisionFilterMask = v;
        }
        addMask(v) {
          this._sharedBody.collisionFilterMask |= v;
        }
        removeMask(v) {
          this._sharedBody.collisionFilterMask &= ~v;
        }
        _wakeUpIfSleep() {
          if (!this.isAwake) {
            bt.CollisionObject_activate(this.impl, true);
          }
        }
      }
      BulletRigidBody.idCounter = 0;

      const importFunc = {
        syncPhysicsToGraphics(id) {
          const body = btCache.CACHE.getWrapper(id, btCache.BODY_CACHE_NAME);
          body.syncPhysicsToGraphics();
        },
        onShapeHitExt(hit, controller) {
          const cct = btCache.CACHE.getWrapper(controller, btCache.CCT_CACHE_NAME);
          cct.onShapeHitExt(hit);
        },
        onDebugDrawLine(from, to, color) {
          const world = btCache.CACHE.world;
          if (world) {
            world.onDebugDrawLine(from, to, color);
          }
        },
        clearLines() {
          const world = btCache.CACHE.world;
          if (world) {
            world.onClearLines();
          }
        },
        flushLines() {}
      };

      const v3_0$5 = CC_V3_0;
      const quat_0 = CC_QUAT_0;
      let IDCounter = 0;
      class BulletSharedBody {
        static getSharedBody(node, wrappedWorld, wrappedBody) {
          const key = node.uuid;
          let newSB;
          if (BulletSharedBody.sharedBodesMap.has(key)) {
            newSB = BulletSharedBody.sharedBodesMap.get(key);
          } else {
            newSB = new BulletSharedBody(node, wrappedWorld);
            const g = PhysicsGroup.DEFAULT;
            const m = PhysicsSystem.instance.collisionMatrix[g];
            newSB._collisionFilterGroup = g;
            newSB._collisionFilterMask = m;
            BulletSharedBody.sharedBodesMap.set(node.uuid, newSB);
          }
          if (wrappedBody) {
            newSB._wrappedBody = wrappedBody;
            const g = wrappedBody.rigidBody.group;
            const m = PhysicsSystem.instance.collisionMatrix[g];
            newSB._collisionFilterGroup = g;
            newSB._collisionFilterMask = m;
          }
          return newSB;
        }
        get wrappedBody() {
          return this._wrappedBody;
        }
        get bodyCompoundShape() {
          return this.bodyStruct.compound;
        }
        get ghostCompoundShape() {
          return this.ghostStruct.compound;
        }
        get body() {
          return this.bodyStruct.body;
        }
        get ghost() {
          return this.ghostStruct.ghost;
        }
        get collisionFilterGroup() {
          return this._collisionFilterGroup;
        }
        set collisionFilterGroup(v) {
          if (v !== this._collisionFilterGroup) {
            this._collisionFilterGroup = v;
            this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
            this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
          }
        }
        get collisionFilterMask() {
          return this._collisionFilterMask;
        }
        set collisionFilterMask(v) {
          if (v !== this._collisionFilterMask) {
            this._collisionFilterMask = v;
            this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
            this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
          }
        }
        get bodyStruct() {
          this._instantiateBodyStruct();
          return this._bodyStruct;
        }
        get ghostStruct() {
          this._instantiateGhostStruct();
          return this._ghostStruct;
        }
        set bodyEnabled(v) {
          if (v) {
            if (this.bodyIndex < 0) {
              if (this.bodyStruct.wrappedShapes.length === 0) {
                if (!this.wrappedBody) return;
                if (!this.wrappedBody.rigidBody.isDynamic) return;
              }
              this.bodyIndex = this.wrappedWorld.bodies.length;
              this.wrappedWorld.addSharedBody(this);
              this.syncInitialBody();
            }
          } else if (this.bodyIndex >= 0) {
            const isRemoveBody = this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody == null || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.isEnabled || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.rigidBody.enabledInHierarchy;
            if (isRemoveBody) {
              bt.RigidBody_clearState(this.body);
              this.bodyIndex = -1;
              this.wrappedWorld.removeSharedBody(this);
            }
          }
        }
        set ghostEnabled(v) {
          if (v) {
            if (this.ghostIndex < 0 && this.ghostStruct.wrappedShapes.length > 0) {
              this.ghostIndex = 1;
              this.wrappedWorld.addGhostObject(this);
              this.syncInitialGhost();
            }
          } else if (this.ghostIndex >= 0) {
            const isRemoveGhost = this.ghostStruct.wrappedShapes.length === 0 && this.ghost;
            if (isRemoveGhost) {
              this.ghostIndex = -1;
              this.wrappedWorld.removeGhostObject(this);
            }
          }
        }
        set reference(v) {
          v ? this.ref++ : this.ref--;
          if (this.ref === 0) {
            this.destroy();
          }
        }
        constructor(node, wrappedWorld) {
          this.id = void 0;
          this.node = void 0;
          this.wrappedWorld = void 0;
          this.wrappedJoints0 = [];
          this.wrappedJoints1 = [];
          this.dirty = 0;
          this._collisionFilterGroup = PhysicsSystem.PhysicsGroup.DEFAULT;
          this._collisionFilterMask = -1;
          this.ref = 0;
          this.bodyIndex = -1;
          this.ghostIndex = -1;
          this._bodyStruct = void 0;
          this._ghostStruct = void 0;
          this._wrappedBody = null;
          this.id = BulletSharedBody.idCounter++;
          this.wrappedWorld = wrappedWorld;
          this.node = node;
        }
        _instantiateBodyStruct() {
          if (this._bodyStruct) return;
          let mass = 0;
          if (this._wrappedBody && this._wrappedBody.rigidBody.enabled && this._wrappedBody.rigidBody.isDynamic) {
            mass = this._wrappedBody.rigidBody.mass;
          }
          const trans = BulletCache.instance.BT_TRANSFORM_0;
          const quat = BulletCache.instance.BT_QUAT_0;
          cocos2BulletVec3(bt.Transform_getOrigin(trans), this.node.worldPosition);
          cocos2BulletQuat(quat, this.node.worldRotation);
          bt.Transform_setRotation(trans, quat);
          const motionState = bt.MotionState.implement(importFunc).$$.ptr;
          bt.ccMotionState_setup(motionState, this.id, trans);
          const body = bt.RigidBody_new(mass, motionState);
          const sleepTd = PhysicsSystem.instance.sleepThreshold;
          bt.RigidBody_setSleepingThresholds(body, sleepTd, sleepTd);
          this._bodyStruct = {
            id: IDCounter++,
            body,
            motionState,
            compound: bt.ccCompoundShape_new(),
            wrappedShapes: [],
            useCompound: false
          };
          BulletCache.setWrapper(this.id, btCache.BODY_CACHE_NAME, this);
          if (this._ghostStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.ghost, this.body, true);
          if (this._wrappedBody) this.setBodyType(this._wrappedBody.rigidBody.type);
        }
        _instantiateGhostStruct() {
          if (this._ghostStruct) return;
          const ghost = bt.CollisionObject_new();
          const ghostShape = bt.ccCompoundShape_new();
          bt.CollisionObject_setCollisionShape(ghost, ghostShape);
          bt.CollisionObject_setCollisionFlags(ghost, btCollisionFlags.CF_STATIC_OBJECT | btCollisionFlags.CF_NO_CONTACT_RESPONSE);
          this._ghostStruct = {
            id: IDCounter++,
            ghost,
            compound: ghostShape,
            wrappedShapes: []
          };
          if (this._bodyStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.body, this.ghost, true);
          if (this._wrappedBody) this.setGhostType(this._wrappedBody.rigidBody.type);
        }
        setType(v) {
          this.setBodyType(v);
          this.setGhostType(v);
        }
        setBodyType(v) {
          if (this._bodyStruct && this._wrappedBody) {
            const body = this._bodyStruct.body;
            const wrap = this._wrappedBody;
            const com = wrap.rigidBody;
            let m_bcf = bt.CollisionObject_getCollisionFlags(body);
            const localInertia = BulletCache.instance.BT_V3_0;
            switch (v) {
              case ERigidBodyType.DYNAMIC:
                m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                wrap.setMass(com.mass);
                wrap.useGravity(com.useGravity);
                wrap.setAllowSleep(com.allowSleep);
                break;
              case ERigidBodyType.KINEMATIC:
                bt.Vec3_set(localInertia, 0, 0, 0);
                bt.RigidBody_setMassProps(body, 0, localInertia);
                m_bcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.DISABLE_DEACTIVATION);
                break;
              case ERigidBodyType.STATIC:
              default:
                bt.Vec3_set(localInertia, 0, 0, 0);
                bt.RigidBody_setMassProps(body, 0, localInertia);
                m_bcf |= btCollisionFlags.CF_STATIC_OBJECT;
                m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(body, m_bcf);
                bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.ISLAND_SLEEPING);
                break;
            }
            this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
          }
        }
        setGhostType(v) {
          if (this._ghostStruct) {
            const ghost = this._ghostStruct.ghost;
            let m_gcf = bt.CollisionObject_getCollisionFlags(ghost);
            switch (v) {
              case ERigidBodyType.DYNAMIC:
              case ERigidBodyType.KINEMATIC:
                m_gcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                m_gcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.DISABLE_DEACTIVATION);
                break;
              case ERigidBodyType.STATIC:
              default:
                m_gcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                m_gcf |= btCollisionFlags.CF_STATIC_OBJECT;
                bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.ISLAND_SLEEPING);
                break;
            }
            this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
          }
        }
        addShape(v, isTrigger) {
          function switchShape(that, shape) {
            bt.CollisionObject_setCollisionShape(that.body, shape);
            that.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
            if (that._wrappedBody && that._wrappedBody.isEnabled) {
              that._wrappedBody.setMass(that._wrappedBody.rigidBody.mass);
            }
          }
          if (isTrigger) {
            const index = this.ghostStruct.wrappedShapes.indexOf(v);
            if (index < 0) {
              this.ghostStruct.wrappedShapes.push(v);
              v.setCompound(this.ghostCompoundShape);
              this.ghostEnabled = true;
            }
          } else {
            const index = this.bodyStruct.wrappedShapes.indexOf(v);
            if (index < 0) {
              this.bodyStruct.wrappedShapes.push(v);
              if (this.bodyStruct.useCompound) {
                v.setCompound(this.bodyCompoundShape);
              } else {
                const l = this.bodyStruct.wrappedShapes.length;
                if (l === 1 && !v.needCompound()) {
                  switchShape(this, v.impl);
                } else {
                  this.bodyStruct.useCompound = true;
                  for (let i = 0; i < l; i++) {
                    const childShape = this.bodyStruct.wrappedShapes[i];
                    childShape.setCompound(this.bodyCompoundShape);
                  }
                  switchShape(this, this.bodyStruct.compound);
                }
              }
              this.bodyEnabled = true;
            }
          }
        }
        removeShape(v, isTrigger) {
          if (isTrigger) {
            const index = this.ghostStruct.wrappedShapes.indexOf(v);
            if (index >= 0) {
              fastRemoveAt$2(this.ghostStruct.wrappedShapes, index);
              v.setCompound(0);
              this.ghostEnabled = false;
            }
          } else {
            const index = this.bodyStruct.wrappedShapes.indexOf(v);
            if (index >= 0) {
              if (this.bodyStruct.useCompound) {
                v.setCompound(0);
              } else {
                bt.CollisionObject_setCollisionShape(this.body, bt.EmptyShape_static());
              }
              bt.CollisionObject_activate(this.body, true);
              this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              fastRemoveAt$2(this.bodyStruct.wrappedShapes, index);
              this.bodyEnabled = false;
            }
          }
        }
        addJoint(v, type) {
          if (type) {
            const i = this.wrappedJoints1.indexOf(v);
            if (i < 0) this.wrappedJoints1.push(v);
          } else {
            const i = this.wrappedJoints0.indexOf(v);
            if (i < 0) this.wrappedJoints0.push(v);
          }
        }
        removeJoint(v, type) {
          if (type) {
            const i = this.wrappedJoints1.indexOf(v);
            if (i >= 0) fastRemoveAt$2(this.wrappedJoints1, i);
          } else {
            const i = this.wrappedJoints0.indexOf(v);
            if (i >= 0) fastRemoveAt$2(this.wrappedJoints0, i);
          }
        }
        updateDirty() {
          if (this.dirty) {
            if (this.bodyIndex >= 0 && this.dirty & EBtSharedBodyDirty.BODY_RE_ADD) this.updateBodyByReAdd();
            if (this.ghostIndex >= 0 && this.dirty & EBtSharedBodyDirty.GHOST_RE_ADD) this.updateGhostByReAdd();
            this.dirty = 0;
          }
        }
        syncSceneToPhysics() {
          if (this.node.hasChangedFlags) {
            const bt_quat = BulletCache.instance.BT_QUAT_0;
            const bt_transform = bt.CollisionObject_getWorldTransform(this.body);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
            bt.Transform_setRotation(bt_transform, bt_quat);
            if (this.node.hasChangedFlags & TransformBit.SCALE) {
              this.syncBodyScale();
            }
            if (bt.CollisionObject_isKinematicObject(this.body)) {
              const ms = bt.RigidBody_getMotionState(this.body);
              if (ms) bt.MotionState_setWorldTransform(ms, bt_transform);
            } else if (this.isBodySleeping()) bt.CollisionObject_activate(this.body, false);
          }
        }
        syncPhysicsToScene() {
          if (bt.CollisionObject_isStaticOrKinematicObject(this.body)) return;
          this.syncPhysicsToGraphics();
        }
        syncPhysicsToGraphics() {
          if (this.isBodySleeping()) return;
          const bt_quat = BulletCache.instance.BT_QUAT_0;
          const bt_transform = BulletCache.instance.BT_TRANSFORM_0;
          bt.RigidBody_getWorldTransform(this.body, bt_transform);
          const originPosPtr = bt.Transform_getRotationAndOrigin(bt_transform, bt_quat);
          this.node.worldRotation = bullet2CocosQuat(quat_0, bt_quat);
          this.node.worldPosition = bullet2CocosVec3(v3_0$5, originPosPtr);
          if (this._ghostStruct) {
            const bt_transform1 = bt.CollisionObject_getWorldTransform(this.ghost);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform1), this.node.worldPosition);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            bt.Transform_setRotation(bt_transform1, bt_quat);
          }
        }
        syncSceneToGhost() {
          if (this.node.hasChangedFlags) {
            const bt_quat = BulletCache.instance.BT_QUAT_0;
            const bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
            cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
            cocos2BulletQuat(bt_quat, this.node.worldRotation);
            bt.Transform_setRotation(bt_transform, bt_quat);
            if (this.node.hasChangedFlags & TransformBit.SCALE) this.syncGhostScale();
            bt.CollisionObject_activate(this.ghost, false);
          }
        }
        syncInitialBody() {
          const bt_quat = BulletCache.instance.BT_QUAT_0;
          const bt_transform = bt.CollisionObject_getWorldTransform(this.body);
          cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
          cocos2BulletQuat(bt_quat, this.node.worldRotation);
          bt.Transform_setRotation(bt_transform, bt_quat);
          this.syncBodyScale();
          bt.CollisionObject_activate(this.body, false);
        }
        syncInitialGhost() {
          const bt_quat = BulletCache.instance.BT_QUAT_0;
          const bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
          cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
          cocos2BulletQuat(bt_quat, this.node.worldRotation);
          bt.Transform_setRotation(bt_transform, bt_quat);
          this.syncGhostScale();
          bt.CollisionObject_activate(this.body, false);
        }
        syncBodyScale() {
          for (let i = 0; i < this.bodyStruct.wrappedShapes.length; i++) {
            this.bodyStruct.wrappedShapes[i].updateScale();
          }
          for (let i = 0; i < this.wrappedJoints0.length; i++) {
            this.wrappedJoints0[i].updateScale0();
          }
          for (let i = 0; i < this.wrappedJoints1.length; i++) {
            this.wrappedJoints1[i].updateScale1();
          }
        }
        syncGhostScale() {
          for (let i = 0; i < this.ghostStruct.wrappedShapes.length; i++) {
            this.ghostStruct.wrappedShapes[i].updateScale();
          }
        }
        updateBodyByReAdd() {
          if (this.bodyIndex >= 0) {
            this.wrappedWorld.removeSharedBody(this);
            this.bodyIndex = this.wrappedWorld.bodies.length;
            this.wrappedWorld.addSharedBody(this);
          }
        }
        updateGhostByReAdd() {
          if (this.ghostIndex >= 0) {
            this.wrappedWorld.removeGhostObject(this);
            this.ghostIndex = this.wrappedWorld.ghosts.length;
            this.wrappedWorld.addGhostObject(this);
          }
        }
        destroy() {
          BulletSharedBody.sharedBodesMap.delete(this.node.uuid);
          this.node = null;
          this.wrappedWorld = null;
          if (this._bodyStruct) {
            const bodyStruct = this._bodyStruct;
            BulletCache.delWrapper(bodyStruct.body, btCache.BODY_CACHE_NAME);
            bt._safe_delete(bodyStruct.motionState, EBulletType.EBulletTypeMotionState);
            bt._safe_delete(bodyStruct.compound, EBulletType.EBulletTypeCollisionShape);
            bt._safe_delete(bodyStruct.body, EBulletType.EBulletTypeCollisionObject);
            this._bodyStruct = null;
          }
          if (this._ghostStruct) {
            const ghostStruct = this._ghostStruct;
            bt._safe_delete(ghostStruct.compound, EBulletType.EBulletTypeCollisionShape);
            bt._safe_delete(ghostStruct.ghost, EBulletType.EBulletTypeCollisionObject);
            this._ghostStruct = null;
          }
        }
        isBodySleeping() {
          return bt.CollisionObject_isSleeping(this.body);
        }
      }
      BulletSharedBody.idCounter = 0;
      BulletSharedBody.sharedBodesMap = new Map();

      const v3_0$4 = CC_V3_0;
      const ccMaterialBooks = {};
      class BulletShape {
        constructor() {
          this.id = BulletShape.idCounter++;
          this._isEnabled = false;
          this._isTrigger = false;
          this._isInitialized = false;
          this._impl = 0;
          this._compound = 0;
          this.quat = bt.Quat_new(0, 0, 0, 1);
          this.transform = bt.Transform_new();
          this._collider = void 0;
          this._sharedBody = void 0;
        }
        updateEventListener() {
          this._sharedBody.wrappedWorld.updateNeedEmitEvents(this.collider.needCollisionEvent || this.collider.needTriggerEvent);
        }
        setMaterial(v) {
          const v1 = v == null ? PhysicsSystem.instance.defaultMaterial : v;
          if (!this._isTrigger && this._isEnabled) {
            if (this._compound) {
              if (!ccMaterialBooks[v1._uuid]) ccMaterialBooks[v1._uuid] = bt.ccMaterial_new();
              const mat = ccMaterialBooks[v1._uuid];
              bt.ccMaterial_set(mat, v1.restitution, v1.friction, v1.rollingFriction, v1.spinningFriction);
              bt.CollisionShape_setMaterial(this._impl, mat);
            } else {
              bt.CollisionObject_setMaterial(this._sharedBody.body, v1.restitution, v1.friction, v1.rollingFriction, v1.spinningFriction);
            }
          }
        }
        setCenter(v) {
          Vec3.copy(v3_0$4, v);
          v3_0$4.multiply(this._collider.node.worldScale);
          cocos2BulletVec3(bt.Transform_getOrigin(this.transform), v3_0$4);
          this.updateCompoundTransform();
        }
        setAsTrigger(v) {
          if (this._isTrigger === v) return;
          if (this._isEnabled) {
            this._sharedBody.removeShape(this, !v);
            this._sharedBody.addShape(this, v);
          }
          this._isTrigger = v;
        }
        get attachedRigidBody() {
          if (this._sharedBody.wrappedBody) return this._sharedBody.wrappedBody.rigidBody;
          return null;
        }
        get impl() {
          return this._impl;
        }
        get collider() {
          return this._collider;
        }
        get sharedBody() {
          return this._sharedBody;
        }
        getAABB(v) {
          const bt_transform = BulletCache.instance.BT_TRANSFORM_0;
          bt.Transform_setIdentity(bt_transform);
          bt.Transform_setRotation(bt_transform, cocos2BulletQuat(BulletCache.instance.BT_QUAT_0, this._collider.node.worldRotation));
          const MIN = BulletCache.instance.BT_V3_0;
          const MAX = BulletCache.instance.BT_V3_1;
          bt.CollisionShape_getAabb(this._impl, bt_transform, MIN, MAX);
          v.halfExtents.x = (bt.Vec3_x(MAX) - bt.Vec3_x(MIN)) / 2;
          v.halfExtents.y = (bt.Vec3_y(MAX) - bt.Vec3_y(MIN)) / 2;
          v.halfExtents.z = (bt.Vec3_z(MAX) - bt.Vec3_z(MIN)) / 2;
          Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
        }
        getBoundingSphere(v) {
          v.radius = bt.CollisionShape_getLocalBoundingSphere(this._impl);
          Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
        }
        initialize(com) {
          this._collider = com;
          this._isInitialized = true;
          this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node);
          this._sharedBody.reference = true;
          this.onComponentSet();
          this.setWrapper();
        }
        setWrapper() {
          if (BulletCache.isNotEmptyShape(this._impl)) {
            bt.CollisionShape_setUserPointer(this._impl, this._impl);
            BulletCache.setWrapper(this._impl, BulletShape.TYPE, this);
          }
        }
        onLoad() {
          this.setCenter(this._collider.center);
          this.setAsTrigger(this._collider.isTrigger);
        }
        onEnable() {
          this._isEnabled = true;
          this._sharedBody.addShape(this, this._isTrigger);
          this.setMaterial(this.collider.sharedMaterial);
        }
        onDisable() {
          this._isEnabled = false;
          this._sharedBody.removeShape(this, this._isTrigger);
        }
        onDestroy() {
          this._sharedBody.reference = false;
          this._collider = null;
          bt._safe_delete(this.quat, EBulletType.EBulletTypeQuat);
          bt._safe_delete(this.transform, EBulletType.EBulletTypeTransform);
          if (this._compound) bt._safe_delete(this._compound, EBulletType.EBulletTypeCollisionShape);
          if (BulletCache.isNotEmptyShape(this._impl)) {
            bt._safe_delete(this._impl, EBulletType.EBulletTypeCollisionShape);
            BulletCache.delWrapper(this._impl, BulletShape.TYPE);
          }
        }
        updateByReAdd() {
          if (this._isEnabled) {
            this._sharedBody.removeShape(this, this._isTrigger);
            this._sharedBody.addShape(this, this._isTrigger);
          }
        }
        getGroup() {
          return this._sharedBody.collisionFilterGroup;
        }
        setGroup(v) {
          this._sharedBody.collisionFilterGroup = v;
        }
        addGroup(v) {
          this._sharedBody.collisionFilterGroup |= v;
        }
        removeGroup(v) {
          this._sharedBody.collisionFilterGroup &= ~v;
        }
        getMask() {
          return this._sharedBody.collisionFilterMask;
        }
        setMask(v) {
          this._sharedBody.collisionFilterMask = v;
        }
        addMask(v) {
          this._sharedBody.collisionFilterMask |= v;
        }
        removeMask(v) {
          this._sharedBody.collisionFilterMask &= ~v;
        }
        setCompound(compound) {
          if (this._compound) bt.CompoundShape_removeChildShape(this._compound, this._impl);
          if (compound) bt.CompoundShape_addChildShape(compound, this.transform, this._impl);
          this._compound = compound;
        }
        updateScale() {
          this.setCenter(this._collider.center);
        }
        updateCompoundTransform() {
          if (this._compound) {
            bt.CompoundShape_updateChildTransform(this._compound, this._impl, this.transform, true);
          } else if (this._isEnabled && !this._isTrigger) {
            if (this._sharedBody && !this._sharedBody.bodyStruct.useCompound) {
              this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
            }
          }
        }
        needCompound() {
          if (this._collider.type === EColliderType.TERRAIN) {
            return true;
          }
          if (this._collider.center.equals(Vec3.ZERO)) {
            return false;
          }
          return true;
        }
      }
      BulletShape.TYPE = 'shape';
      BulletShape.idCounter = 0;

      class ArrayCollisionMatrix {
        constructor() {
          this.matrix = [];
        }
        get(i, j) {
          if (j > i) {
            const temp = j;
            j = i;
            i = temp;
          }
          return this.matrix[(i * (i + 1) >> 1) + j - 1];
        }
        set(i, j, value) {
          if (j > i) {
            const temp = j;
            j = i;
            i = temp;
          }
          this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
        }
        reset() {
          this.matrix.length = 0;
        }
        setNumObjects(n) {
          this.matrix.length = n * (n - 1) >> 1;
        }
      }

      class TupleDictionary {
        constructor() {
          this.data = void 0;
          this.data = {
            keys: []
          };
        }
        get(i, j) {
          if (i > j) {
            const temp = j;
            j = i;
            i = temp;
          }
          return this.data[`${i}-${j}`];
        }
        set(i, j, value) {
          if (i > j) {
            const temp = j;
            j = i;
            i = temp;
          }
          const key = `${i}-${j}`;
          if (value == null) {
            const idx = this.data.keys.indexOf(key);
            if (idx !== -1) {
              this.data.keys.splice(idx, 1);
              delete this.data[key];
              return value;
            }
          }
          if (!this.get(i, j)) {
            this.data.keys.push(key);
          }
          this.data[key] = value;
          return this.data[key];
        }
        reset() {
          this.data = {
            keys: []
          };
        }
        getLength() {
          return this.data.keys.length;
        }
        getKeyByIndex(index) {
          return this.data.keys[index];
        }
        getDataByKey(Key) {
          return this.data[Key];
        }
      }

      class BulletContactData {
        get isBodyA() {
          const sb = this.event.selfCollider.shape.sharedBody.body;
          return sb === bt.PersistentManifold_getBody0(this.event.impl);
        }
        constructor(event) {
          this.impl = 0;
          this.event = void 0;
          this.event = event;
        }
        getLocalPointOnA(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointA(this.impl));
        }
        getLocalPointOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointB(this.impl));
        }
        getWorldPointOnA(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnA(this.impl));
        }
        getWorldPointOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnB(this.impl));
        }
        getLocalNormalOnA(out) {
          if (this.impl) {
            const bt_rot = BulletCache.instance.BT_QUAT_0;
            const body = bt.PersistentManifold_getBody0(this.event.impl);
            const trans = bt.CollisionObject_getWorldTransform(body);
            bt.Transform_getRotation(trans, bt_rot);
            const inv_rot = CC_QUAT_0;
            bullet2CocosQuat(inv_rot, bt_rot);
            Quat.conjugate(inv_rot, inv_rot);
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            if (!this.isBodyA) Vec3.negate(out, out);
            Vec3.transformQuat(out, out, inv_rot);
          }
        }
        getLocalNormalOnB(out) {
          if (this.impl) {
            const bt_rot = BulletCache.instance.BT_QUAT_0;
            const body = bt.PersistentManifold_getBody1(this.event.impl);
            const trans = bt.CollisionObject_getWorldTransform(body);
            bt.Transform_getRotation(trans, bt_rot);
            const inv_rot = CC_QUAT_0;
            bullet2CocosQuat(inv_rot, bt_rot);
            Quat.conjugate(inv_rot, inv_rot);
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            Vec3.transformQuat(out, out, inv_rot);
          }
        }
        getWorldNormalOnA(out) {
          if (this.impl) {
            bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
            if (!this.isBodyA) Vec3.negate(out, out);
          }
        }
        getWorldNormalOnB(out) {
          if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
        }
      }

      const contactsPool = [];
      const v3_0$3 = CC_V3_0;
      const v3_1$1 = CC_V3_1;
      const v3_2 = CC_V3_2;
      const c_0 = CC_COLOR_0;
      const emitHit = new CharacterControllerContact();
      class BulletWorld {
        setDefaultMaterial(v) {}
        setAllowSleep(v) {
          bt.ccDiscreteDynamicsWorld_setAllowSleep(this._world, v);
        }
        setGravity(gravity) {
          bt.DynamicsWorld_setGravity(this._world, cocos2BulletVec3(BulletCache.instance.BT_V3_0, gravity));
        }
        updateNeedEmitEvents(v) {
          if (!this.ghosts) return;
          if (v) {
            this._needEmitEvents = true;
          } else {
            this._needEmitEvents = false;
            for (let i = 0; i < this.ghosts.length; i++) {
              const ghost = this.ghosts[i];
              const shapes = ghost.ghostStruct.wrappedShapes;
              for (let j = 0; j < shapes.length; j++) {
                const collider = shapes[j].collider;
                if (collider.needCollisionEvent || collider.needTriggerEvent) {
                  this._needEmitEvents = true;
                  return;
                }
              }
            }
            for (let i = 0; i < this.bodies.length; i++) {
              const body = this.bodies[i];
              const shapes = body.bodyStruct.wrappedShapes;
              for (let j = 0; j < shapes.length; j++) {
                const collider = shapes[j].collider;
                if (collider.needCollisionEvent || collider.needTriggerEvent) {
                  this._needEmitEvents = true;
                  return;
                }
              }
            }
          }
        }
        updateNeedEmitCCTEvents(force) {
          if (!this.ccts) return;
          if (force) {
            this._needEmitCCTEvents = true;
          } else {
            this._needEmitCCTEvents = false;
            const ccts = this.ccts;
            const length = ccts.length;
            for (let i = 0; i < length; i++) {
              const cctCom = ccts[i].characterController;
              if (cctCom.needCollisionEvent) {
                this._needEmitCCTEvents = true;
                return;
              }
            }
          }
        }
        get impl() {
          return this._world;
        }
        constructor() {
          this._world = void 0;
          this._broadphase = void 0;
          this._solver = void 0;
          this._dispatcher = void 0;
          this._debugDraw = void 0;
          this._debugLineCount = 0;
          this._MAX_DEBUG_LINE_COUNT = 16384;
          this._debugDrawFlags = EPhysicsDrawFlags.NONE;
          this._debugConstraintSize = 0.3;
          this._needEmitEvents = false;
          this._needSyncAfterEvents = false;
          this._needEmitCCTEvents = false;
          this.bodies = [];
          this.ghosts = [];
          this.ccts = [];
          this.constraints = [];
          this.triggerArrayMat = new ArrayCollisionMatrix();
          this.collisionArrayMat = new ArrayCollisionMatrix();
          this.contactsDic = new TupleDictionary();
          this.oldContactsDic = new TupleDictionary();
          this.cctShapeEventDic = new TupleDictionary();
          this.cctContactsDic = new TupleDictionary();
          this.cctOldContactsDic = new TupleDictionary();
          btCache.CACHE.world = this;
          this._broadphase = bt.DbvtBroadphase_new();
          this._dispatcher = bt.CollisionDispatcher_new();
          this._solver = bt.SequentialImpulseConstraintSolver_new();
          this._world = bt.ccDiscreteDynamicsWorld_new(this._dispatcher, this._broadphase, this._solver);
          const debugDraw = bt.DebugDraw.implement(importFunc);
          this._debugDraw = debugDraw.$$.ptr;
          bt.CollisionWorld_setDebugDrawer(this._world, this._debugDraw);
          bt.DebugDraw_setDebugMode(this._debugDraw, EBulletDebugDrawModes.DBG_NoDebug);
          bt.DebugDraw_setAABBColor(this._debugDraw, 0, 1, 1);
          bt.DebugDraw_setActiveObjectColor(this._debugDraw, 1, 0, 1);
          bt.DebugDraw_setDeactiveObjectColor(this._debugDraw, 1, 0, 1);
          bt.DebugDraw_setWantsDeactivationObjectColor(this._debugDraw, 1, 0, 1);
          bt.DebugDraw_setDisabledDeactivationObjectColor(this._debugDraw, 1, 0, 1);
          bt.DebugDraw_setDisabledSimulationObjectColor(this._debugDraw, 1, 0, 1);
          bt.DebugDraw_setConstraintLimitColor(this._debugDraw, 0.5, 0.5, 0.5);
        }
        destroy() {
          if (this.constraints.length || this.bodies.length || this.ccts.length) error('You should destroy all physics component first.');
          bt._safe_delete(this._world, EBulletType.EBulletTypeCollisionWorld);
          bt._safe_delete(this._broadphase, EBulletType.EBulletTypeDbvtBroadPhase);
          bt._safe_delete(this._dispatcher, EBulletType.EBulletTypeCollisionDispatcher);
          bt._safe_delete(this._solver, EBulletType.EBulletTypeSequentialImpulseConstraintSolver);
          bt._safe_delete(this._debugDraw, EBulletType.EBulletTypeDebugDraw);
          this.bodies = null;
          this.ghosts = null;
          this.ccts = null;
          this.constraints = null;
          this.triggerArrayMat = null;
          this.collisionArrayMat = null;
          this.contactsDic = null;
          this.oldContactsDic = null;
          this.cctShapeEventDic = null;
          this.cctShapeEventPool = null;
          contactsPool.length = 0;
        }
        step(deltaTime, timeSinceLastCalled, maxSubStep = 0) {
          if (!this.bodies.length && !this.ghosts.length) return;
          if (timeSinceLastCalled === undefined) timeSinceLastCalled = deltaTime;
          bt.DynamicsWorld_stepSimulation(this._world, timeSinceLastCalled, maxSubStep, deltaTime);
          bt.CollisionWorld_debugDrawWorld(this._world);
        }
        syncSceneToPhysics() {
          for (let i = this.ghosts.length - 1; i >= 0; i--) {
            const ghost = this.ghosts[i];
            ghost.updateDirty();
            ghost.syncSceneToGhost();
          }
          for (let i = this.bodies.length - 1; i >= 0; i--) {
            const body = this.bodies[i];
            body.updateDirty();
            body.syncSceneToPhysics();
          }
          const ccts = this.ccts;
          const length = ccts.length;
          for (let i = length - 1; i >= 0; i--) {
            const cct = ccts[i];
            cct.updateDirty();
            cct.syncSceneToPhysics();
          }
        }
        syncAfterEvents() {
          if (!this._needSyncAfterEvents) return;
          this.syncSceneToPhysics();
        }
        raycast(worldRay, options, pool, results) {
          worldRay.computeHit(v3_0$3, options.maxDistance);
          const to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
          const from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
          const allHitsCB = bt.ccAllRayCallback_static();
          bt.ccAllRayCallback_reset(allHitsCB, from, to, options.mask >>> 0, options.queryTrigger);
          bt.ccAllRayCallback_setFlags(allHitsCB, EBulletTriangleRaycastFlag.UseSubSimplexConvexCastRaytest);
          bt.CollisionWorld_rayTest(this._world, from, to, allHitsCB);
          if (bt.RayCallback_hasHit(allHitsCB)) {
            const posArray = bt.ccAllRayCallback_getHitPointWorld(allHitsCB);
            const normalArray = bt.ccAllRayCallback_getHitNormalWorld(allHitsCB);
            const ptrArray = bt.ccAllRayCallback_getCollisionShapePtrs(allHitsCB);
            for (let i = 0, n = bt.int_array_size(ptrArray); i < n; i++) {
              bullet2CocosVec3(v3_0$3, bt.Vec3_array_at(posArray, i));
              bullet2CocosVec3(v3_1$1, bt.Vec3_array_at(normalArray, i));
              const shape = BulletCache.getWrapper(bt.int_array_at(ptrArray, i), BulletShape.TYPE);
              const r = pool.add();
              results.push(r);
              r._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$1);
            }
            return true;
          }
          return false;
        }
        raycastClosest(worldRay, options, result) {
          worldRay.computeHit(v3_0$3, options.maxDistance);
          const to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
          const from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
          const closeHitCB = bt.ccClosestRayCallback_static();
          bt.ccClosestRayCallback_reset(closeHitCB, from, to, options.mask >>> 0, options.queryTrigger);
          bt.ccClosestRayCallback_setFlags(closeHitCB, EBulletTriangleRaycastFlag.UseSubSimplexConvexCastRaytest);
          bt.CollisionWorld_rayTest(this._world, from, to, closeHitCB);
          if (bt.RayCallback_hasHit(closeHitCB)) {
            bullet2CocosVec3(v3_0$3, bt.ccClosestRayCallback_getHitPointWorld(closeHitCB));
            bullet2CocosVec3(v3_1$1, bt.ccClosestRayCallback_getHitNormalWorld(closeHitCB));
            const shape = BulletCache.getWrapper(bt.ccClosestRayCallback_getCollisionShapePtr(closeHitCB), BulletShape.TYPE);
            result._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$1);
            return true;
          }
          return false;
        }
        sweepBox(worldRay, halfExtent, orientation, options, pool, results) {
          const hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, halfExtent);
          if (!BulletWorld._sweepBoxGeometry) {
            BulletWorld._sweepBoxGeometry = bt.BoxShape_new(hf);
          }
          bt.BoxShape_setUnscaledHalfExtents(BulletWorld._sweepBoxGeometry, hf);
          return this.sweep(worldRay, BulletWorld._sweepBoxGeometry, orientation, options, pool, results);
        }
        sweepBoxClosest(worldRay, halfExtent, orientation, options, result) {
          const hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, halfExtent);
          if (!BulletWorld._sweepBoxGeometry) {
            BulletWorld._sweepBoxGeometry = bt.BoxShape_new(hf);
          }
          bt.BoxShape_setUnscaledHalfExtents(BulletWorld._sweepBoxGeometry, hf);
          return this.sweepClosest(worldRay, BulletWorld._sweepBoxGeometry, orientation, options, result);
        }
        sweepSphere(worldRay, radius, options, pool, results) {
          if (!BulletWorld._sweepSphereGeometry) {
            BulletWorld._sweepSphereGeometry = bt.SphereShape_new(radius);
          }
          bt.SphereShape_setUnscaledRadius(BulletWorld._sweepSphereGeometry, radius);
          return this.sweep(worldRay, BulletWorld._sweepSphereGeometry, Quat.IDENTITY, options, pool, results);
        }
        sweepSphereClosest(worldRay, radius, options, result) {
          if (!BulletWorld._sweepSphereGeometry) {
            BulletWorld._sweepSphereGeometry = bt.SphereShape_new(radius);
          }
          bt.SphereShape_setUnscaledRadius(BulletWorld._sweepSphereGeometry, radius);
          return this.sweepClosest(worldRay, BulletWorld._sweepSphereGeometry, Quat.IDENTITY, options, result);
        }
        sweepCapsule(worldRay, radius, height, orientation, options, pool, results) {
          if (!BulletWorld._sweepCapsuleGeometry) {
            BulletWorld._sweepCapsuleGeometry = bt.CapsuleShape_new(radius, height);
          }
          bt.CapsuleShape_updateProp(BulletWorld._sweepCapsuleGeometry, radius, height * 0.5, 1);
          return this.sweep(worldRay, BulletWorld._sweepCapsuleGeometry, orientation, options, pool, results);
        }
        sweepCapsuleClosest(worldRay, radius, height, orientation, options, result) {
          if (!BulletWorld._sweepCapsuleGeometry) {
            BulletWorld._sweepCapsuleGeometry = bt.CapsuleShape_new(radius, height);
          }
          bt.CapsuleShape_updateProp(BulletWorld._sweepCapsuleGeometry, radius, height * 0.5, 1);
          return this.sweepClosest(worldRay, BulletWorld._sweepCapsuleGeometry, orientation, options, result);
        }
        sweep(worldRay, btShapePtr, orientation, options, pool, results) {
          const BT_fromTransform = BulletCache.instance.BT_TRANSFORM_0;
          const BT_toTransform = BulletCache.instance.BT_TRANSFORM_1;
          const BT_orientation = BulletCache.instance.BT_QUAT_0;
          cocos2BulletVec3(bt.Transform_getOrigin(BT_fromTransform), worldRay.o);
          cocos2BulletQuat(BT_orientation, orientation);
          bt.Transform_setRotation(BT_fromTransform, BT_orientation);
          worldRay.computeHit(v3_0$3, options.maxDistance);
          cocos2BulletVec3(bt.Transform_getOrigin(BT_toTransform), v3_0$3);
          cocos2BulletQuat(BT_orientation, orientation);
          bt.Transform_setRotation(BT_toTransform, BT_orientation);
          const allHitsCB = bt.ccAllConvexCallback_static();
          bt.ccAllConvexCallback_reset(allHitsCB, BT_fromTransform, BT_toTransform, options.mask >>> 0, options.queryTrigger);
          bt.CollisionWorld_convexSweepTest(this._world, btShapePtr, BT_fromTransform, BT_toTransform, allHitsCB, 0);
          if (bt.ConvexCallback_hasHit(allHitsCB)) {
            const posArray = bt.ccAllConvexCallback_getHitPointWorld(allHitsCB);
            const normalArray = bt.ccAllConvexCallback_getHitNormalWorld(allHitsCB);
            const ptrArray = bt.ccAllConvexCallback_getCollisionShapePtrs(allHitsCB);
            for (let i = 0, n = bt.int_array_size(ptrArray); i < n; i++) {
              bullet2CocosVec3(v3_0$3, bt.Vec3_array_at(posArray, i));
              bullet2CocosVec3(v3_1$1, bt.Vec3_array_at(normalArray, i));
              const shape = BulletCache.getWrapper(bt.int_array_at(ptrArray, i), BulletShape.TYPE);
              const r = pool.add();
              results.push(r);
              r._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$1);
            }
            return true;
          }
          return false;
        }
        sweepClosest(worldRay, btShapePtr, orientation, options, result) {
          const BT_fromTransform = BulletCache.instance.BT_TRANSFORM_0;
          const BT_toTransform = BulletCache.instance.BT_TRANSFORM_1;
          const BT_orientation = BulletCache.instance.BT_QUAT_0;
          cocos2BulletVec3(bt.Transform_getOrigin(BT_fromTransform), worldRay.o);
          cocos2BulletQuat(BT_orientation, orientation);
          bt.Transform_setRotation(BT_fromTransform, BT_orientation);
          worldRay.computeHit(v3_0$3, options.maxDistance);
          cocos2BulletVec3(bt.Transform_getOrigin(BT_toTransform), v3_0$3);
          cocos2BulletQuat(BT_orientation, orientation);
          bt.Transform_setRotation(BT_toTransform, BT_orientation);
          const closeHitCB = bt.ccClosestConvexCallback_static();
          bt.ccClosestConvexCallback_reset(closeHitCB, BT_fromTransform, BT_toTransform, options.mask >>> 0, options.queryTrigger);
          bt.CollisionWorld_convexSweepTest(this._world, btShapePtr, BT_fromTransform, BT_toTransform, closeHitCB, 0);
          if (bt.ConvexCallback_hasHit(closeHitCB)) {
            bullet2CocosVec3(v3_0$3, bt.ccClosestConvexCallback_getHitPointWorld(closeHitCB));
            bullet2CocosVec3(v3_1$1, bt.ccClosestConvexCallback_getHitNormalWorld(closeHitCB));
            const shape = BulletCache.getWrapper(bt.ccClosestConvexCallback_getCollisionShapePtr(closeHitCB), BulletShape.TYPE);
            result._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$1);
            return true;
          }
          return false;
        }
        getSharedBody(node, wrappedBody) {
          return BulletSharedBody.getSharedBody(node, this, wrappedBody);
        }
        addSharedBody(sharedBody) {
          const i = this.bodies.indexOf(sharedBody);
          if (i < 0) {
            this.bodies.push(sharedBody);
            const group = sharedBody.collisionFilterGroup;
            const mask = sharedBody.collisionFilterMask;
            bt.DynamicsWorld_addRigidBody(this._world, sharedBody.body, group >>> 0, mask >>> 0);
          }
        }
        removeSharedBody(sharedBody) {
          const i = this.bodies.indexOf(sharedBody);
          if (i >= 0) {
            fastRemoveAt$2(this.bodies, i);
            bt.DynamicsWorld_removeRigidBody(this._world, sharedBody.body);
          }
        }
        addGhostObject(sharedBody) {
          const i = this.ghosts.indexOf(sharedBody);
          if (i < 0) {
            this.ghosts.push(sharedBody);
            const group = sharedBody.collisionFilterGroup;
            const mask = sharedBody.collisionFilterMask;
            bt.CollisionWorld_addCollisionObject(this._world, sharedBody.ghost, group >>> 0, mask >>> 0);
          }
        }
        removeGhostObject(sharedBody) {
          const i = this.ghosts.indexOf(sharedBody);
          if (i >= 0) {
            fastRemoveAt$2(this.ghosts, i);
            bt.CollisionWorld_removeCollisionObject(this._world, sharedBody.ghost);
          }
        }
        addCCT(cct) {
          const index = this.ccts.indexOf(cct);
          if (index < 0) {
            this.ccts.push(cct);
            const cctGhost = bt.CharacterController_getGhostObject(cct.impl);
            const group = cct.getGroup();
            const mask = cct.getMask();
            bt.CollisionWorld_addCollisionObject(this._world, cctGhost, group >>> 0, mask >>> 0);
            bt.DynamicsWorld_addAction(this._world, cct.impl);
          }
        }
        removeCCT(cct) {
          const index = this.ccts.indexOf(cct);
          if (index >= 0) {
            fastRemoveAt$2(this.ccts, index);
            const cctGhost = bt.CharacterController_getGhostObject(cct.impl);
            bt.CollisionWorld_removeCollisionObject(this._world, cctGhost);
            bt.DynamicsWorld_removeAction(this._world, cct.impl);
          }
        }
        addConstraint(constraint) {
          const i = this.constraints.indexOf(constraint);
          if (i < 0) {
            this.constraints.push(constraint);
            bt.DynamicsWorld_addConstraint(this.impl, constraint.impl, !constraint.constraint.enableCollision);
            constraint.index = i;
          }
        }
        removeConstraint(constraint) {
          const i = this.constraints.indexOf(constraint);
          if (i >= 0) {
            this.constraints.splice(i, 1);
            bt.DynamicsWorld_removeConstraint(this.impl, constraint.impl);
            constraint.index = -1;
          }
        }
        emitEvents() {
          this._needSyncAfterEvents = false;
          if (this._needEmitEvents) {
            this.gatherConatactData();
            this.emitCollisionAndTriggerEvent();
            this.emitCCTTriggerEvent();
          }
          if (this._needEmitCCTEvents) {
            this.emitCCTCollisionEvent();
          }
        }
        emitCollisionAndTriggerEvent() {
          let dicL = this.contactsDic.getLength();
          while (dicL--) {
            contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
            CollisionEventObject.contacts.length = 0;
            const key = this.contactsDic.getKeyByIndex(dicL);
            const data = this.contactsDic.getDataByKey(key);
            const shape0 = data.shape0;
            const shape1 = data.shape1;
            this.oldContactsDic.set(shape0.id, shape1.id, data);
            const collider0 = shape0.collider;
            const collider1 = shape1.collider;
            if (collider0 && collider1) {
              const isTrigger = collider0.isTrigger || collider1.isTrigger;
              if (isTrigger) {
                if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                  TriggerEventObject.type = 'onTriggerStay';
                } else {
                  TriggerEventObject.type = 'onTriggerEnter';
                  this.triggerArrayMat.set(shape0.id, shape1.id, true);
                }
                TriggerEventObject.impl = data.impl;
                TriggerEventObject.selfCollider = collider0;
                TriggerEventObject.otherCollider = collider1;
                collider0.emit(TriggerEventObject.type, TriggerEventObject);
                TriggerEventObject.selfCollider = collider1;
                TriggerEventObject.otherCollider = collider0;
                collider1.emit(TriggerEventObject.type, TriggerEventObject);
                this._needSyncAfterEvents = true;
              } else {
                const body0 = collider0.attachedRigidBody;
                const body1 = collider1.attachedRigidBody;
                if (body0 && body1) {
                  if (body0.isSleeping && body1.isSleeping) continue;
                } else if (!body0 && body1) {
                  if (body1.isSleeping) continue;
                } else if (!body1 && body0) {
                  if (body0.isSleeping) continue;
                }
                if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                  CollisionEventObject.type = 'onCollisionStay';
                } else {
                  CollisionEventObject.type = 'onCollisionEnter';
                  this.collisionArrayMat.set(shape0.id, shape1.id, true);
                }
                for (let i = 0; i < data.contacts.length; i++) {
                  const cq = data.contacts[i];
                  if (contactsPool.length > 0) {
                    const c = contactsPool.pop();
                    c.impl = cq;
                    CollisionEventObject.contacts.push(c);
                  } else {
                    const c = new BulletContactData(CollisionEventObject);
                    c.impl = cq;
                    CollisionEventObject.contacts.push(c);
                  }
                }
                CollisionEventObject.impl = data.impl;
                CollisionEventObject.selfCollider = collider0;
                CollisionEventObject.otherCollider = collider1;
                collider0.emit(CollisionEventObject.type, CollisionEventObject);
                CollisionEventObject.selfCollider = collider1;
                CollisionEventObject.otherCollider = collider0;
                collider1.emit(CollisionEventObject.type, CollisionEventObject);
                this._needSyncAfterEvents = true;
              }
              if (this.oldContactsDic.get(shape0.id, shape1.id) == null) {
                this.oldContactsDic.set(shape0.id, shape1.id, data);
              }
            }
          }
          let oldDicL = this.oldContactsDic.getLength();
          while (oldDicL--) {
            const key = this.oldContactsDic.getKeyByIndex(oldDicL);
            const data = this.oldContactsDic.getDataByKey(key);
            const shape0 = data.shape0;
            const shape1 = data.shape1;
            const collider0 = shape0.collider;
            const collider1 = shape1.collider;
            if (collider0 && collider1) {
              const isTrigger = collider0.isTrigger || collider1.isTrigger;
              if (this.contactsDic.getDataByKey(key) == null) {
                if (isTrigger) {
                  if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                    TriggerEventObject.type = 'onTriggerExit';
                    TriggerEventObject.selfCollider = collider0;
                    TriggerEventObject.otherCollider = collider1;
                    collider0.emit(TriggerEventObject.type, TriggerEventObject);
                    TriggerEventObject.selfCollider = collider1;
                    TriggerEventObject.otherCollider = collider0;
                    collider1.emit(TriggerEventObject.type, TriggerEventObject);
                    this.triggerArrayMat.set(shape0.id, shape1.id, false);
                    this.oldContactsDic.set(shape0.id, shape1.id, null);
                    this._needSyncAfterEvents = true;
                  }
                } else if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                  contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                  CollisionEventObject.contacts.length = 0;
                  CollisionEventObject.type = 'onCollisionExit';
                  CollisionEventObject.selfCollider = collider0;
                  CollisionEventObject.otherCollider = collider1;
                  collider0.emit(CollisionEventObject.type, CollisionEventObject);
                  CollisionEventObject.selfCollider = collider1;
                  CollisionEventObject.otherCollider = collider0;
                  collider1.emit(CollisionEventObject.type, CollisionEventObject);
                  this.collisionArrayMat.set(shape0.id, shape1.id, false);
                  this.oldContactsDic.set(shape0.id, shape1.id, null);
                  this._needSyncAfterEvents = true;
                }
              }
            }
          }
          this.contactsDic.reset();
        }
        emitCCTTriggerEvent() {
          let dicL = this.cctContactsDic.getLength();
          while (dicL--) {
            const key = this.cctContactsDic.getKeyByIndex(dicL);
            const data = this.cctContactsDic.getDataByKey(key);
            const shape = data.shape;
            const cct = data.cct;
            this.cctOldContactsDic.set(shape.id, cct.id, data);
            const collider = shape.collider;
            const characterController = cct.characterController;
            if (collider && characterController) {
              const isTrigger = collider.isTrigger;
              if (isTrigger) {
                if (this.triggerArrayMat.get(shape.id, cct.id)) {
                  CharacterTriggerEventObject.type = 'onControllerTriggerStay';
                } else {
                  CharacterTriggerEventObject.type = 'onControllerTriggerEnter';
                  this.triggerArrayMat.set(shape.id, cct.id, true);
                }
                CharacterTriggerEventObject.impl = data.impl;
                CharacterTriggerEventObject.collider = collider;
                CharacterTriggerEventObject.characterController = characterController;
                collider.emit(CharacterTriggerEventObject.type, CharacterTriggerEventObject);
                CharacterTriggerEventObject.collider = collider;
                CharacterTriggerEventObject.characterController = characterController;
                characterController.emit(CharacterTriggerEventObject.type, CharacterTriggerEventObject);
                this._needSyncAfterEvents = true;
              }
              if (this.cctOldContactsDic.get(shape.id, cct.id) == null) {
                this.cctOldContactsDic.set(shape.id, cct.id, data);
              }
            }
          }
          let oldDicL = this.cctOldContactsDic.getLength();
          while (oldDicL--) {
            const key = this.cctOldContactsDic.getKeyByIndex(oldDicL);
            const data = this.cctOldContactsDic.getDataByKey(key);
            const shape = data.shape;
            const cct = data.cct;
            const collider = shape.collider;
            const characterController = cct.characterController;
            if (collider && characterController) {
              const isTrigger = collider.isTrigger;
              if (this.cctContactsDic.getDataByKey(key) == null) {
                if (isTrigger) {
                  if (this.triggerArrayMat.get(shape.id, cct.id)) {
                    CharacterTriggerEventObject.type = 'onControllerTriggerExit';
                    CharacterTriggerEventObject.collider = collider;
                    CharacterTriggerEventObject.characterController = characterController;
                    collider.emit(CharacterTriggerEventObject.type, CharacterTriggerEventObject);
                    CharacterTriggerEventObject.collider = collider;
                    CharacterTriggerEventObject.characterController = characterController;
                    characterController.emit(CharacterTriggerEventObject.type, CharacterTriggerEventObject);
                    this.triggerArrayMat.set(shape.id, cct.id, false);
                    this.cctOldContactsDic.set(shape.id, cct.id, null);
                    this._needSyncAfterEvents = true;
                  }
                }
              }
            }
          }
          this.cctContactsDic.reset();
        }
        emitCCTCollisionEvent() {
          let dicL = this.cctShapeEventDic.getLength();
          while (dicL--) {
            var _emitHit$controller;
            const key = this.cctShapeEventDic.getKeyByIndex(dicL);
            const data = this.cctShapeEventDic.getDataByKey(key);
            const cct = data.BulletCharacterController;
            const shape = data.BulletShape;
            const worldPos = data.worldPos;
            const worldNormal = data.worldNormal;
            const motionDir = data.motionDir;
            const motionLength = data.motionLength;
            emitHit.controller = cct.characterController;
            emitHit.collider = shape.collider;
            emitHit.worldPosition.set(worldPos.x, worldPos.y, worldPos.z);
            emitHit.worldNormal.set(worldNormal.x, worldNormal.y, worldNormal.z);
            emitHit.motionDirection.set(motionDir.x, motionDir.y, motionDir.z);
            emitHit.motionLength = motionLength;
            (_emitHit$controller = emitHit.controller) === null || _emitHit$controller === void 0 ? void 0 : _emitHit$controller.emit('onControllerColliderHit', emitHit);
            this._needSyncAfterEvents = true;
          }
          this.cctShapeEventDic.reset();
        }
        gatherConatactData() {
          const numManifolds = bt.Dispatcher_getNumManifolds(this._dispatcher);
          for (let i = 0; i < numManifolds; i++) {
            const manifold = bt.Dispatcher_getManifoldByIndexInternal(this._dispatcher, i);
            const numContacts = bt.PersistentManifold_getNumContacts(manifold);
            for (let j = 0; j < numContacts; j++) {
              const manifoldPoint = bt.PersistentManifold_getContactPoint(manifold, j);
              const s0 = bt.ManifoldPoint_getShape0(manifoldPoint);
              const s1 = bt.ManifoldPoint_getShape1(manifoldPoint);
              let processed = false;
              if (!processed) {
                const shape0 = BulletCache.getWrapper(s0, BulletShape.TYPE);
                const shape1 = BulletCache.getWrapper(s1, BulletShape.TYPE);
                if (shape0 && shape1) {
                  processed = true;
                  if (shape0.collider.needTriggerEvent || shape1.collider.needTriggerEvent || shape0.collider.needCollisionEvent || shape1.collider.needCollisionEvent) {
                    let item = this.contactsDic.get(shape0.id, shape1.id);
                    if (!item) {
                      item = this.contactsDic.set(shape0.id, shape1.id, {
                        shape0,
                        shape1,
                        contacts: [],
                        impl: manifold
                      });
                    }
                    item.contacts.push(manifoldPoint);
                  }
                }
              }
              if (!processed) {
                const shape = BulletCache.getWrapper(s0, BulletShape.TYPE);
                const cct = BulletCache.getWrapper(s1, btCache.CCT_CACHE_NAME);
                if (shape && cct) {
                  processed = true;
                  if (shape.collider.needTriggerEvent) {
                    let item = this.cctContactsDic.get(shape.id, cct.id);
                    if (!item) {
                      item = this.cctContactsDic.set(shape.id, cct.id, {
                        shape,
                        cct,
                        contacts: [],
                        impl: manifold
                      });
                    }
                    item.contacts.push(manifoldPoint);
                    processed = true;
                  }
                }
              }
              if (!processed) {
                const cct = BulletCache.getWrapper(s0, btCache.CCT_CACHE_NAME);
                const shape = BulletCache.getWrapper(s1, BulletShape.TYPE);
                if (shape && cct) {
                  processed = true;
                  if (shape.collider.needTriggerEvent) {
                    let item = this.cctContactsDic.get(shape.id, cct.id);
                    if (!item) {
                      item = this.cctContactsDic.set(shape.id, cct.id, {
                        shape,
                        cct,
                        contacts: [],
                        impl: manifold
                      });
                    }
                    item.contacts.push(manifoldPoint);
                    processed = true;
                  }
                }
              }
            }
          }
        }
        get debugDrawFlags() {
          return this._debugDrawFlags;
        }
        set debugDrawFlags(v) {
          this._debugDrawFlags = v;
          if (this._debugDraw) {
            this._setDebugDrawMode();
          }
        }
        get debugDrawConstraintSize() {
          return this._debugConstraintSize;
        }
        set debugDrawConstraintSize(v) {
          this._debugConstraintSize = v;
          for (let i = 0; i < this.constraints.length; i++) {
            this.constraints[i].updateDebugDrawSize();
          }
        }
        _setDebugDrawMode() {
          let btDrawMode = 0;
          if (this._debugDrawFlags & EPhysicsDrawFlags.WIRE_FRAME) {
            btDrawMode |= EBulletDebugDrawModes.DBG_DrawWireframe;
          }
          if (this._debugDrawFlags & EPhysicsDrawFlags.CONSTRAINT) {
            btDrawMode |= EBulletDebugDrawModes.DBG_DrawConstraints;
            btDrawMode |= EBulletDebugDrawModes.DBG_DrawConstraintLimits;
          }
          if (this._debugDrawFlags & EPhysicsDrawFlags.AABB) {
            btDrawMode |= EBulletDebugDrawModes.DBG_DrawAabb;
          }
          bt.DebugDraw_setDebugMode(this._debugDraw, btDrawMode);
        }
        _getDebugRenderer() {
          var _mainWindow;
          const cameras = (_mainWindow = director.root.mainWindow) === null || _mainWindow === void 0 ? void 0 : _mainWindow.cameras;
          if (!cameras) return null;
          if (cameras.length === 0) return null;
          if (!cameras[0]) return null;
          cameras[0].initGeometryRenderer();
          return cameras[0].geometryRenderer;
        }
        onDebugDrawLine(from, to, color) {
          const debugRenderer = this._getDebugRenderer();
          if (debugRenderer && this._debugLineCount < this._MAX_DEBUG_LINE_COUNT) {
            this._debugLineCount++;
            bullet2CocosVec3(v3_0$3, from);
            bullet2CocosVec3(v3_1$1, to);
            bullet2CocosVec3(v3_2, color);
            c_0.set(v3_2.x * 255, v3_2.y * 255, v3_2.z * 255, 255);
            debugRenderer.addLine(v3_0$3, v3_1$1, c_0);
          }
        }
        onClearLines() {
          this._debugLineCount = 0;
        }
      }
      BulletWorld._sweepBoxGeometry = void 0;
      BulletWorld._sweepSphereGeometry = void 0;
      BulletWorld._sweepCapsuleGeometry = void 0;

      class BulletBoxShape extends BulletShape {
        updateSize() {
          const hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
          bt.BoxShape_setUnscaledHalfExtents(this.impl, hf);
          this.updateCompoundTransform();
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          const hf = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
          this._impl = bt.BoxShape_new(hf);
          this.updateScale();
        }
        updateScale() {
          super.updateScale();
          const bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this.getMinScale(VEC3_0)));
          this.updateCompoundTransform();
        }
        getMinUnscaledHalfExtents(out) {
          const size = this.collider.size;
          const ws = absolute(VEC3_0.set(this._collider.node.worldScale));
          const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          const halfSizeX = size.x / 2;
          const halfSizeY = size.y / 2;
          const halfSizeZ = size.z / 2;
          const halfX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / ws.x : halfSizeX;
          const halfY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / ws.y : halfSizeY;
          const halfZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / ws.z : halfSizeZ;
          out.set(halfX, halfY, halfZ);
          return out;
        }
        getMinScale(out) {
          const size = this.collider.size;
          const ws = absolute(VEC3_0.set(this._collider.node.worldScale));
          const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          const halfSizeX = size.x / 2;
          const halfSizeY = size.y / 2;
          const halfSizeZ = size.z / 2;
          const scaleX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / halfSizeX : ws.x;
          const scaleY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / halfSizeY : ws.y;
          const scaleZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / halfSizeZ : ws.z;
          out.set(scaleX, scaleY, scaleZ);
          return out;
        }
      }

      class BulletSphereShape extends BulletShape {
        updateRadius() {
          bt.SphereShape_setUnscaledRadius(this.impl, this.getMinUnscaledRadius());
          this.updateCompoundTransform();
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          this._impl = bt.SphereShape_new(this.getMinUnscaledRadius());
          this.updateScale();
        }
        updateScale() {
          super.updateScale();
          const scale = this.getMinScale();
          CC_V3_0.set(scale, scale, scale);
          const bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, CC_V3_0));
          this.updateCompoundTransform();
        }
        getMinUnscaledRadius() {
          const radius = this.collider.radius;
          const ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
          const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          return ws * radius < minVolumeSize ? minVolumeSize / ws : radius;
        }
        getMinScale() {
          const radius = this.collider.radius;
          const ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
          const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
          return ws * radius < minVolumeSize ? minVolumeSize / radius : ws;
        }
      }

      class BulletCapsuleShape extends BulletShape {
        setCylinderHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        }
        setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        }
        setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          this._impl = bt.CapsuleShape_new(0.5, 1);
          this.setRadius(this.collider.radius);
        }
        updateScale() {
          super.updateScale();
          this.setRadius(this.collider.radius);
        }
        updateProperties(radius, height, direction, scale) {
          const ws = scale;
          const upAxis = direction;
          let wr;
          let halfH;
          if (upAxis === 1) {
            wr = radius * Math.abs(absMax(ws.x, ws.z));
            halfH = height / 2 * Math.abs(ws.y);
          } else if (upAxis === 0) {
            wr = radius * Math.abs(absMax(ws.y, ws.z));
            halfH = height / 2 * Math.abs(ws.x);
          } else {
            wr = radius * Math.abs(absMax(ws.x, ws.y));
            halfH = height / 2 * Math.abs(ws.z);
          }
          bt.CapsuleShape_updateProp(this._impl, wr, halfH, upAxis);
          this.updateCompoundTransform();
        }
      }

      class BulletBvhTriangleMeshShape {
        static getBulletBvhTriangleMeshShape(key, mesh) {
          let newBulletBvhTriangleMeshShape;
          if (BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.has(key)) {
            newBulletBvhTriangleMeshShape = BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.get(key);
            newBulletBvhTriangleMeshShape.reference = true;
          } else {
            newBulletBvhTriangleMeshShape = new BulletBvhTriangleMeshShape(key, mesh);
            BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.set(key, newBulletBvhTriangleMeshShape);
          }
          return newBulletBvhTriangleMeshShape;
        }
        set reference(v) {
          v ? this.ref++ : this.ref--;
          if (this.ref === 0) {
            this.destroy();
          }
        }
        constructor(key, mesh) {
          this.key = void 0;
          this.ref = 0;
          this.bulletBvhTriangleMeshShapePtr = void 0;
          this.btTriangleMeshPtr = 0;
          this.reference = true;
          this.key = key;
          this.btTriangleMeshPtr = bt.TriangleMesh_new();
          cocos2BulletTriMesh(this.btTriangleMeshPtr, mesh);
          this.bulletBvhTriangleMeshShapePtr = bt.BvhTriangleMeshShape_new(this.btTriangleMeshPtr, true, true);
        }
        destroy() {
          if (this.bulletBvhTriangleMeshShapePtr) {
            bt._safe_delete(EBulletType.EBulletTypeCollisionShape, this.bulletBvhTriangleMeshShapePtr);
          }
          if (this.btTriangleMeshPtr) {
            bt._safe_delete(EBulletType.EBulletTypeTriangleMesh, this.btTriangleMeshPtr);
          }
          BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap.delete(this.key);
        }
      }
      BulletBvhTriangleMeshShape.BulletBvhTriangleMeshShapeMap = new Map();

      class BulletTrimeshShape extends BulletShape {
        constructor(...args) {
          super(...args);
          this.btBVHMeshShape = void 0;
          this.refBtTriangleMesh = 0;
        }
        get collider() {
          return this._collider;
        }
        setMesh(v) {
          if (!this._isInitialized) return;
          if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
            if (this._compound) {
              bt.CompoundShape_removeChildShape(this._compound, this._impl);
            }
            bt._safe_delete(this._impl, EBulletType.EBulletTypeCollisionShape);
            BulletCache.delWrapper(this._impl, BulletShape.TYPE);
            this._impl = 0;
          }
          const mesh = v;
          if (mesh && mesh.renderingSubMeshes.length > 0) {
            if (this.collider.convex) {
              const btTriangleMesh = this._getBtTriangleMesh(mesh);
              this._impl = bt.ConvexTriangleMeshShape_new(btTriangleMesh);
            } else {
              this.btBVHMeshShape = BulletBvhTriangleMeshShape.getBulletBvhTriangleMeshShape(mesh.hash, mesh);
              this._impl = bt.ScaledBvhTriangleMeshShape_new(this.btBVHMeshShape.bulletBvhTriangleMeshShapePtr, 1, 1, 1);
            }
            const bt_v3 = BulletCache.instance.BT_V3_0;
            cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
            bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
            bt.CollisionShape_setMargin(this._impl, 0.01);
            this.setCompound(this._compound);
            this.updateByReAdd();
            this.setWrapper();
          } else {
            this._impl = bt.EmptyShape_static();
          }
        }
        onComponentSet() {
          this.setMesh(this.collider.mesh);
        }
        onDestroy() {
          if (this.collider.convex) {
            if (this.refBtTriangleMesh) {
              bt._safe_delete(this.refBtTriangleMesh, EBulletType.EBulletTypeTriangleMesh);
            }
          } else if (this.btBVHMeshShape) {
            this.btBVHMeshShape.reference = false;
          }
          super.onDestroy();
        }
        updateScale() {
          super.updateScale();
          const bt_v3 = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        }
        _getBtTriangleMesh(mesh) {
          this.refBtTriangleMesh = bt.TriangleMesh_new();
          cocos2BulletTriMesh(this.refBtTriangleMesh, mesh);
          return this.refBtTriangleMesh;
        }
      }

      class BulletCylinderShape extends BulletShape {
        setHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          const bt_v3 = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(bt_v3, 0.5, 1, 0.5);
          this._impl = bt.CylinderShape_new(bt_v3);
          this.setRadius(this.collider.radius);
        }
        updateScale() {
          super.updateScale();
          this.setRadius(this.collider.radius);
        }
        updateProperties(radius, height, direction, scale) {
          const ws = scale;
          const upAxis = direction;
          let wr;
          let wh;
          if (upAxis === 1) {
            wh = height * Math.abs(ws.y);
            wr = radius * Math.abs(absMax(ws.x, ws.z));
          } else if (upAxis === 0) {
            wh = height * Math.abs(ws.x);
            wr = radius * Math.abs(absMax(ws.y, ws.z));
          } else {
            wh = height * Math.abs(ws.z);
            wr = radius * Math.abs(absMax(ws.x, ws.y));
          }
          bt.CylinderShape_updateProp(this._impl, wr, wh / 2, upAxis);
          this.updateCompoundTransform();
        }
      }

      class BulletConeShape extends BulletShape {
        setHeight(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        setDirection(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        setRadius(v) {
          this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
        }
        get impl() {
          return this._impl;
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          this._impl = bt.ConeShape_new(0.5, 1);
          this.setRadius(this.collider.radius);
        }
        updateScale() {
          super.updateScale();
          this.setRadius(this.collider.radius);
        }
        updateProperties(radius, height, direction, scale) {
          const ws = scale;
          const upAxis = direction;
          let wr;
          let wh;
          if (upAxis === 1) {
            wh = height * Math.abs(ws.y);
            wr = radius * Math.abs(absMax(ws.x, ws.z));
          } else if (upAxis === 0) {
            wh = height * Math.abs(ws.x);
            wr = radius * Math.abs(absMax(ws.y, ws.z));
          } else {
            wh = height * Math.abs(ws.z);
            wr = radius * Math.abs(absMax(ws.x, ws.y));
          }
          bt.ConeShape_setRadius(this._impl, wr);
          bt.ConeShape_setHeight(this._impl, wh);
          bt.ConeShape_setConeUpIndex(this._impl, upAxis);
          const bt_v3 = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(bt_v3, 1, 1, 1);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        }
      }

      class BulletTerrainShape extends BulletShape {
        constructor(...args) {
          super(...args);
          this._bufPtr = 0;
          this._tileSize = 0;
          this._localOffset = new Vec3();
        }
        get collider() {
          return this._collider;
        }
        setTerrain(v) {
          if (!this._isInitialized) return;
          if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
            warn('[Physics][Bullet]: change the terrain asset after initialization is not support.');
          } else {
            const terrain = v;
            if (terrain) {
              this._tileSize = terrain.tileSize;
              const sizeI = terrain.getVertexCountI();
              const sizeJ = terrain.getVertexCountJ();
              this._bufPtr = bt._malloc(4 * sizeI * sizeJ);
              let offset = 0;
              let min = Number.MAX_SAFE_INTEGER;
              let max = Number.MIN_SAFE_INTEGER;
              for (let j = 0; j < sizeJ; j++) {
                for (let i = 0; i < sizeI; i++) {
                  const v = terrain.getHeight(i, j);
                  bt._write_f32(this._bufPtr + offset, v);
                  if (min > v) min = v;
                  if (v > max) max = v;
                  offset += 4;
                }
              }
              max += 0.01;
              min -= 0.01;
              this._localOffset.set((sizeI - 1) / 2 * this._tileSize, (max + min) / 2, (sizeJ - 1) / 2 * this._tileSize);
              this._impl = bt.TerrainShape_new(sizeI, sizeJ, this._bufPtr, 1, min, max);
              const bt_v3 = BulletCache.instance.BT_V3_0;
              bt.Vec3_set(bt_v3, this._tileSize, 1, this._tileSize);
              bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
              this.setCompound(this._compound);
              this.updateByReAdd();
              this.setWrapper();
            } else {
              this._impl = bt.EmptyShape_static();
            }
          }
        }
        onComponentSet() {
          this.setTerrain(this.collider.terrain);
        }
        onDestroy() {
          if (this._bufPtr) bt._free(this._bufPtr);
          super.onDestroy();
        }
        setCenter(v) {
          Vec3.copy(CC_V3_0, v);
          CC_V3_0.add(this._localOffset);
          cocos2BulletVec3(bt.Transform_getOrigin(this.transform), CC_V3_0);
          this.updateCompoundTransform();
        }
      }

      class BulletSimplexShape extends BulletShape {
        setShapeType(v) {}
        setVertices(v) {}
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          this._impl = bt.SimplexShape_new();
          const length = this.collider.shapeType;
          const vertices = this.collider.vertices;
          const bt_v3 = BulletCache.instance.BT_V3_0;
          for (let i = 0; i < length; i++) {
            bt.SimplexShape_addVertex(this._impl, cocos2BulletVec3(bt_v3, vertices[i]));
          }
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
        }
        onLoad() {
          super.onLoad();
          this.collider.updateVertices();
        }
        updateScale() {
          super.updateScale();
          const bt_v3 = BulletCache.instance.BT_V3_0;
          bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
        }
      }

      class BulletPlaneShape extends BulletShape {
        setNormal(v) {
          cocos2BulletVec3(bt.StaticPlaneShape_getPlaneNormal(this.impl), v);
          this.updateCompoundTransform();
        }
        setConstant(v) {
          bt.StaticPlaneShape_setPlaneConstant(this.impl, v);
          this.updateCompoundTransform();
        }
        updateScale() {
          super.updateScale();
          const bt_v3 = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
          bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
          this.updateCompoundTransform();
        }
        get collider() {
          return this._collider;
        }
        onComponentSet() {
          const normal = BulletCache.instance.BT_V3_0;
          cocos2BulletVec3(normal, this.collider.normal);
          this._impl = bt.StaticPlaneShape_new(normal, this.collider.constant);
          this.updateScale();
        }
      }

      class BulletConstraint {
        constructor() {
          this.dirty = 0;
          this.index = -1;
          this._impl = 0;
          this._com = void 0;
          this._rigidBody = void 0;
          this._connectedBody = null;
          this._collided = false;
        }
        setConnectedBody(v) {
          if (this._connectedBody === v) return;
          const oldBody2 = this._connectedBody;
          if (oldBody2) {
            const oldSB2 = oldBody2.body.sharedBody;
            oldSB2.removeJoint(this, 1);
          }
          const sb = this._rigidBody.body.sharedBody;
          sb.removeJoint(this, 0);
          if (this._impl) {
            sb.wrappedWorld.removeConstraint(this);
            bt._safe_delete(this._impl, EBulletType.EBulletTypeTypedConstraint);
          }
          this._connectedBody = v;
          const connect = this._connectedBody;
          this.onComponentSet();
          this.setEnableCollision(this._collided);
          sb.wrappedWorld.addConstraint(this);
          sb.addJoint(this, 0);
          if (connect) {
            const sb2 = connect.body.sharedBody;
            sb2.addJoint(this, 1);
          }
        }
        setEnableCollision(v) {
          if (this._collided !== v) {
            this._collided = v;
            this.updateByReAdd();
          }
        }
        get impl() {
          return this._impl;
        }
        get constraint() {
          return this._com;
        }
        updateByReAdd() {
          if (this._rigidBody && this.index >= 0) {
            const sb = this._rigidBody.body.sharedBody;
            sb.wrappedWorld.removeConstraint(this);
            sb.wrappedWorld.addConstraint(this);
          }
        }
        initialize(v) {
          this._com = v;
          this._rigidBody = v.attachedBody;
          this._connectedBody = v.connectedBody;
          this._collided = v.enableCollision;
          this.onComponentSet();
          this.setEnableCollision(this._collided);
        }
        updateDebugDrawSize() {
          if (this.impl) {
            const size = PhysicsSystem.instance.physicsWorld.debugDrawConstraintSize;
            bt.TypedConstraint_setDbgDrawSize(this.impl, size);
          }
        }
        onEnable() {
          const sb = this._rigidBody.body.sharedBody;
          sb.wrappedWorld.addConstraint(this);
          sb.addJoint(this, 0);
          const connect = this._connectedBody;
          if (connect) {
            const sb2 = connect.body.sharedBody;
            sb2.addJoint(this, 1);
          }
        }
        onDisable() {
          const sb = this._rigidBody.body.sharedBody;
          sb.wrappedWorld.removeConstraint(this);
          sb.removeJoint(this, 0);
          const connect = this._connectedBody;
          if (connect) {
            const sb2 = connect.body.sharedBody;
            sb2.removeJoint(this, 1);
          }
        }
        onDestroy() {
          bt._safe_delete(this._impl, EBulletType.EBulletTypeTypedConstraint);
          this._com = null;
          this._rigidBody = null;
          this._connectedBody = null;
        }
      }

      class BulletP2PConstraint extends BulletConstraint {
        setPivotA(v) {
          const cs = this.constraint;
          const pivotA = BulletCache.instance.BT_V3_0;
          Vec3.multiply(CC_V3_0, cs.node.worldScale, cs.pivotA);
          cocos2BulletVec3(pivotA, CC_V3_0);
          bt.P2PConstraint_setPivotA(this._impl, pivotA);
          if (!cs.connectedBody) this.setPivotB(cs.pivotB);
        }
        setPivotB(v) {
          const cs = this.constraint;
          const node = this._rigidBody.node;
          const pivotB = BulletCache.instance.BT_V3_0;
          const cb = cs.connectedBody;
          if (cb) {
            Vec3.multiply(CC_V3_0, cb.node.worldScale, cs.pivotB);
            cocos2BulletVec3(pivotB, CC_V3_0);
          } else {
            Vec3.multiply(CC_V3_0, node.worldScale, cs.pivotA);
            Vec3.transformQuat(CC_V3_0, CC_V3_0, node.worldRotation);
            Vec3.add(CC_V3_0, CC_V3_0, node.worldPosition);
            cocos2BulletVec3(pivotB, CC_V3_0);
          }
          bt.P2PConstraint_setPivotB(this._impl, pivotB);
        }
        get constraint() {
          return this._com;
        }
        onComponentSet() {
          const cb = this.constraint.connectedBody;
          const bodyA = this._rigidBody.body.impl;
          const bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
          const pivotA = BulletCache.instance.BT_V3_0;
          const pivotB = BulletCache.instance.BT_V3_1;
          this._impl = bt.P2PConstraint_new(bodyA, bodyB, pivotA, pivotB);
          this.setPivotA(this.constraint.pivotA);
          this.setPivotB(this.constraint.pivotB);
          this.updateDebugDrawSize();
        }
        updateScale0() {
          this.setPivotA(this.constraint.pivotA);
        }
        updateScale1() {
          this.setPivotB(this.constraint.pivotB);
        }
      }

      class BulletFixedConstraint extends BulletConstraint {
        setBreakForce(v) {
          bt.TypedConstraint_setMaxImpulseThreshold(this._impl, v);
        }
        setBreakTorque(v) {}
        get constraint() {
          return this._com;
        }
        onComponentSet() {
          const cb = this.constraint.connectedBody;
          const bodyA = this._rigidBody.body.impl;
          const bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          this._impl = bt.FixedConstraint_new(bodyA, bodyB, trans0, trans1);
          this.setBreakForce(this.constraint.breakForce);
          this.setBreakTorque(this.constraint.breakTorque);
          this.updateFrames();
          this.updateDebugDrawSize();
        }
        updateFrames() {
          const cb = this.constraint.connectedBody;
          const bodyA = this._rigidBody.body.sharedBody;
          const pos = CC_V3_0;
          const rot = CC_QUAT_0;
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          const quat = BulletCache.instance.BT_QUAT_0;
          const trans = CC_MAT4_0;
          Mat4.fromRT(trans, bodyA.node.worldRotation, bodyA.node.worldPosition);
          Mat4.invert(trans, trans);
          Mat4.getRotation(rot, trans);
          Mat4.getTranslation(pos, trans);
          cocos2BulletVec3(bt.Transform_getOrigin(trans0), pos);
          cocos2BulletQuat(quat, rot);
          bt.Transform_setRotation(trans0, quat);
          if (cb) {
            const bodyB = cb.body.sharedBody;
            Mat4.fromRT(trans, bodyB.node.worldRotation, bodyB.node.worldPosition);
            Mat4.invert(trans, trans);
            Mat4.getRotation(rot, trans);
            Mat4.getTranslation(pos, trans);
            cocos2BulletVec3(bt.Transform_getOrigin(trans1), pos);
            cocos2BulletQuat(quat, rot);
            bt.Transform_setRotation(trans1, quat);
          } else {
            bt.Transform_setIdentity(trans1);
          }
          bt.FixedConstraint_setFrames(this._impl, trans0, trans1);
        }
        updateScale0() {
          this.updateFrames();
        }
        updateScale1() {
          this.updateFrames();
        }
      }

      class BulletHingeConstraint extends BulletConstraint {
        setPivotA(v) {
          this.updateFrames();
        }
        setPivotB(v) {
          this.updateFrames();
        }
        setAxis(v) {
          this.updateFrames();
        }
        setLimitEnabled(v) {
          if (this.constraint.limitEnabled) {
            bt.HingeConstraint_setLimit(this._impl, toRadian(this.constraint.lowerLimit), toRadian(this.constraint.upperLimit), 0.9, 0.3, 1.0);
          } else {
            bt.HingeConstraint_setLimit(this._impl, 1, 0, 0.9, 0.3, 1.0);
          }
        }
        setLowerLimit(min) {
          if (this.constraint.limitEnabled) {
            bt.HingeConstraint_setLimit(this._impl, toRadian(this.constraint.lowerLimit), toRadian(this.constraint.upperLimit), 0.9, 0.3, 1.0);
          }
        }
        setUpperLimit(max) {
          if (this.constraint.limitEnabled) {
            bt.HingeConstraint_setLimit(this._impl, toRadian(this.constraint.lowerLimit), toRadian(this.constraint.upperLimit), 0.9, 0.3, 1.0);
          }
        }
        setMotorEnabled(v) {
          bt.HingeConstraint_enableMotor(this._impl, v);
          const velocity = -this.constraint.motorVelocity / 60.0;
          const impulse = force2Impulse(this.constraint.motorForceLimit, PhysicsSystem.instance.fixedTimeStep);
          bt.HingeConstraint_setMotorVelocity(this._impl, velocity);
          bt.HingeConstraint_setMaxMotorImpulse(this._impl, impulse);
        }
        setMotorVelocity(v) {
          if (this.constraint.motorEnabled) {
            const velocity = -v / 60.0;
            bt.HingeConstraint_setMotorVelocity(this._impl, velocity);
          }
        }
        setMotorForceLimit(v) {
          if (this.constraint.motorEnabled) {
            const impulse = force2Impulse(v, PhysicsSystem.instance.fixedTimeStep);
            bt.HingeConstraint_setMaxMotorImpulse(this._impl, impulse);
          }
        }
        get constraint() {
          return this._com;
        }
        onComponentSet() {
          const cb = this.constraint.connectedBody;
          const bodyA = this._rigidBody.body.impl;
          const bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          this._impl = bt.HingeConstraint_new(bodyA, bodyB, trans0, trans1);
          this.setLimitEnabled(this.constraint.limitEnabled);
          this.setLowerLimit(this.constraint.lowerLimit);
          this.setUpperLimit(this.constraint.upperLimit);
          this.setMotorEnabled(this.constraint.motorEnabled);
          this.setMotorVelocity(this.constraint.motorVelocity);
          this.setMotorForceLimit(this.constraint.motorForceLimit);
          this.updateFrames();
          this.updateDebugDrawSize();
        }
        updateFrames() {
          const cs = this.constraint;
          const node = cs.node;
          const v3_0 = CC_V3_0;
          const rot_0 = CC_QUAT_0;
          const rot_1 = CC_QUAT_1;
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
          cocos2BulletVec3(bt.Transform_getOrigin(trans0), v3_0);
          const quat = BulletCache.instance.BT_QUAT_0;
          Vec3.normalize(v3_0, cs.axis);
          Quat.rotationTo(rot_1, Vec3.UNIT_Z, v3_0);
          cocos2BulletQuat(quat, rot_1);
          bt.Transform_setRotation(trans0, quat);
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          const cb = this.constraint.connectedBody;
          if (cb) {
            Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
            Quat.multiply(rot_1, node.worldRotation, rot_1);
            Quat.invert(rot_0, cb.node.worldRotation);
            Quat.multiply(rot_1, rot_0, rot_1);
          } else {
            Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
            Vec3.transformQuat(v3_0, v3_0, node.worldRotation);
            Vec3.add(v3_0, v3_0, node.worldPosition);
            Quat.multiply(rot_1, node.worldRotation, rot_1);
          }
          cocos2BulletVec3(bt.Transform_getOrigin(trans1), v3_0);
          cocos2BulletQuat(quat, rot_1);
          bt.Transform_setRotation(trans1, quat);
          bt.HingeConstraint_setFrames(this._impl, trans0, trans1);
        }
        updateScale0() {
          this.updateFrames();
        }
        updateScale1() {
          this.updateFrames();
        }
      }

      var RotateOrder;
      (function (RotateOrder) {
        RotateOrder[RotateOrder["RO_XYZ"] = 0] = "RO_XYZ";
        RotateOrder[RotateOrder["RO_XZY"] = 1] = "RO_XZY";
        RotateOrder[RotateOrder["RO_YXZ"] = 2] = "RO_YXZ";
        RotateOrder[RotateOrder["RO_YZX"] = 3] = "RO_YZX";
        RotateOrder[RotateOrder["RO_ZXY"] = 4] = "RO_ZXY";
        RotateOrder[RotateOrder["RO_ZYX"] = 5] = "RO_ZYX";
      })(RotateOrder || (RotateOrder = {}));
      var BulletDofAxis;
      (function (BulletDofAxis) {
        BulletDofAxis[BulletDofAxis["X"] = 0] = "X";
        BulletDofAxis[BulletDofAxis["Y"] = 1] = "Y";
        BulletDofAxis[BulletDofAxis["Z"] = 2] = "Z";
        BulletDofAxis[BulletDofAxis["TWIST"] = 3] = "TWIST";
        BulletDofAxis[BulletDofAxis["SWING1"] = 4] = "SWING1";
        BulletDofAxis[BulletDofAxis["SWING2"] = 5] = "SWING2";
      })(BulletDofAxis || (BulletDofAxis = {}));
      class BulletConfigurableConstraint extends BulletConstraint {
        _setLimit(v, axis, lower, upper) {
          switch (v) {
            case EConstraintMode.LOCKED:
              bt.Generic6DofSpring2Constraint_setLimit(this._impl, axis, 0, 0);
              break;
            case EConstraintMode.LIMITED:
              bt.Generic6DofSpring2Constraint_setLimit(this._impl, axis, lower, upper);
              break;
            case EConstraintMode.FREE:
              bt.Generic6DofSpring2Constraint_setLimit(this._impl, axis, 1, 0);
              break;
          }
        }
        setConstraintMode(idx, v) {
          const ll = this.constraint.linearLimitSettings;
          const al = this.constraint.angularLimitSettings;
          const lowers = [0, 0, 0];
          const uppers = [0, 0, 0];
          let upper = 0;
          let lower = 0;
          switch (idx) {
            case 0:
            case 1:
            case 2:
              Vec3.toArray(lowers, ll.lower);
              Vec3.toArray(uppers, ll.upper);
              lower = lowers[idx];
              upper = uppers[idx];
              break;
            case 3:
              upper = toRadian(al.twistExtent) * 0.5;
              lower = -upper;
              break;
            case 4:
              upper = toRadian(al.swingExtent1) * 0.5;
              lower = -upper;
              break;
            case 5:
              upper = toRadian(al.swingExtent2) * 0.5;
              lower = -upper;
              break;
            default:
              error(`idx should be in [0, 5], but give ${idx}`);
              break;
          }
          this._setLimit(v, idx, lower, upper);
        }
        setLinearLimit(idx, lower, upper) {
          let cm = 0;
          const ll = this.constraint.linearLimitSettings;
          switch (idx) {
            case 0:
              cm = ll.xMotion;
              break;
            case 1:
              cm = ll.yMotion;
              break;
            case 2:
              cm = ll.zMotion;
              break;
          }
          this._setLimit(cm, idx, lower, upper);
        }
        setAngularExtent(twist, swing1, swing2) {
          const al = this.constraint.angularLimitSettings;
          this._setLimit(al.twistMotion, BulletDofAxis.TWIST, -toRadian(twist) * 0.5, toRadian(twist) * 0.5);
          this._setLimit(al.swingMotion1, BulletDofAxis.SWING1, -toRadian(swing1) * 0.5, toRadian(swing1) * 0.5);
          this._setLimit(al.swingMotion2, BulletDofAxis.SWING2, -toRadian(swing2) * 0.5, toRadian(swing2) * 0.5);
        }
        setSwingSoftConstraint(v) {
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.SWING1, v);
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.SWING2, v);
        }
        setTwistSoftConstraint(v) {
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.TWIST, v);
        }
        setLinearSoftConstraint(v) {
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.X, v);
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.Y, v);
          bt.Generic6DofSpring2Constraint_enableSpring(this._impl, BulletDofAxis.Z, v);
        }
        setLinearStiffness(v) {
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.X, v);
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.Y, v);
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.Z, v);
        }
        setLinearDamping(v) {
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.X, v);
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.Y, v);
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.Z, v);
        }
        setLinearRestitution(v) {
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.X, v);
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.Y, v);
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.Z, v);
        }
        setSwingStiffness(v) {
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.SWING1, v);
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.SWING2, v);
        }
        setSwingDamping(v) {
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.SWING1, v);
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.SWING2, v);
        }
        setSwingRestitution(v) {
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.SWING1, v);
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.SWING2, v);
        }
        setTwistStiffness(v) {
          bt.Generic6DofSpring2Constraint_setStiffness(this._impl, BulletDofAxis.TWIST, v);
        }
        setTwistDamping(v) {
          bt.Generic6DofSpring2Constraint_setDamping(this._impl, BulletDofAxis.TWIST, v);
        }
        setTwistRestitution(v) {
          bt.Generic6DofSpring2Constraint_setBounce(this._impl, BulletDofAxis.TWIST, v);
        }
        setDriverMode(idx, v) {
          if (v === EDriverMode.DISABLED) {
            bt.Generic6DofSpring2Constraint_enableMotor(this._impl, idx, false);
          } else if (v === EDriverMode.SERVO) {
            bt.Generic6DofSpring2Constraint_enableMotor(this._impl, idx, true);
            bt.Generic6DofSpring2Constraint_setServo(this._impl, idx, true);
          } else if (v === EDriverMode.INDUCTION) {
            bt.Generic6DofSpring2Constraint_enableMotor(this._impl, idx, true);
            bt.Generic6DofSpring2Constraint_setServo(this._impl, idx, false);
          }
        }
        _updateMotorTargetAndVelocity(index) {
          let mode = EDriverMode.DISABLED;
          let axis = 0;
          let target = 0;
          let velocity = 0;
          const ld = this.constraint.linearDriverSettings;
          const ad = this.constraint.angularDriverSettings;
          switch (index) {
            case 0:
              axis = BulletDofAxis.X;
              mode = ld.xDrive;
              target = ld.targetPosition.x;
              velocity = -ld.targetVelocity.x;
              break;
            case 1:
              axis = BulletDofAxis.Y;
              mode = ld.yDrive;
              target = ld.targetPosition.y;
              velocity = -ld.targetVelocity.y;
              break;
            case 2:
              axis = BulletDofAxis.Z;
              mode = ld.zDrive;
              target = ld.targetPosition.z;
              velocity = -ld.targetVelocity.z;
              break;
            case 3:
              axis = BulletDofAxis.TWIST;
              mode = ad.twistDrive;
              target = -toRadian(ad.targetOrientation.x);
              velocity = -toRadian(ad.targetVelocity.x);
              break;
            case 4:
              axis = BulletDofAxis.SWING1;
              mode = ad.swingDrive1;
              target = -toRadian(ad.targetOrientation.y);
              velocity = -toRadian(ad.targetVelocity.y);
              break;
            case 5:
              axis = BulletDofAxis.SWING2;
              mode = ad.swingDrive2;
              target = -toRadian(ad.targetOrientation.z);
              velocity = -toRadian(ad.targetVelocity.z);
              break;
          }
          const strength = index > 2 ? ad.strength : ld.strength;
          bt.Generic6DofSpring2Constraint_setServoTarget(this._impl, axis, target);
          if (mode === EDriverMode.SERVO) {
            if (index > 2) {
              bt.Generic6DofSpring2Constraint_setTargetVelocity(this._impl, axis, -target * strength * 0.1);
            } else {
              bt.Generic6DofSpring2Constraint_setTargetVelocity(this._impl, axis, target * strength * 0.1);
            }
          } else if (mode === EDriverMode.INDUCTION) {
            bt.Generic6DofSpring2Constraint_setTargetVelocity(this._impl, axis, velocity);
          }
        }
        setLinearMotorTarget(v) {
          this._updateMotorTargetAndVelocity(0);
          this._updateMotorTargetAndVelocity(1);
          this._updateMotorTargetAndVelocity(2);
        }
        setLinearMotorVelocity(v) {
          this._updateMotorTargetAndVelocity(0);
          this._updateMotorTargetAndVelocity(1);
          this._updateMotorTargetAndVelocity(2);
        }
        setLinearMotorForceLimit(v) {
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.X, v);
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.Y, v);
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.Z, v);
        }
        setAngularMotorTarget(v) {
          this._updateMotorTargetAndVelocity(3);
          this._updateMotorTargetAndVelocity(4);
          this._updateMotorTargetAndVelocity(5);
        }
        setAngularMotorVelocity(v) {
          this._updateMotorTargetAndVelocity(3);
          this._updateMotorTargetAndVelocity(4);
          this._updateMotorTargetAndVelocity(5);
        }
        setAngularMotorForceLimit(v) {
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.TWIST, v);
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.SWING1, v);
          bt.Generic6DofSpring2Constraint_setMaxMotorForce(this._impl, BulletDofAxis.SWING2, v);
        }
        setPivotA(v) {
          this.updateFrames();
        }
        setPivotB(v) {
          this.updateFrames();
        }
        setAutoPivotB(v) {
          this.updateFrames();
        }
        setAxis(v) {
          this.updateFrames();
        }
        setSecondaryAxis(v) {
          this.updateFrames();
        }
        setBreakForce(v) {
          const maxForce = Math.max(this.constraint.breakForce, this.constraint.breakTorque);
          const impulse = force2Impulse(maxForce, PhysicsSystem.instance.fixedTimeStep);
          bt.TypedConstraint_setMaxImpulseThreshold(this._impl, impulse);
        }
        setBreakTorque(v) {
          const maxForce = Math.max(this.constraint.breakForce, this.constraint.breakTorque);
          const impulse = force2Impulse(maxForce, PhysicsSystem.instance.fixedTimeStep);
          bt.TypedConstraint_setMaxImpulseThreshold(this._impl, impulse);
        }
        get constraint() {
          return this._com;
        }
        onComponentSet() {
          const cb = this.constraint.connectedBody;
          const bodyA = this._rigidBody.body.impl;
          const bodyB = cb && cb.body.impl || bt.TypedConstraint_getFixedBody();
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          this._impl = bt.Generic6DofSpring2Constraint_new(bodyA, bodyB, trans0, trans1, RotateOrder.RO_YZX);
          const linearLimit = this.constraint.linearLimitSettings;
          const angularLimit = this.constraint.angularLimitSettings;
          this.setConstraintMode(0, linearLimit.xMotion);
          this.setConstraintMode(1, linearLimit.yMotion);
          this.setConstraintMode(2, linearLimit.zMotion);
          this.setConstraintMode(3, angularLimit.twistMotion);
          this.setConstraintMode(4, angularLimit.swingMotion1);
          this.setConstraintMode(5, angularLimit.swingMotion2);
          this.setLinearSoftConstraint(linearLimit.enableSoftConstraint);
          this.setLinearStiffness(linearLimit.stiffness);
          this.setLinearDamping(linearLimit.damping);
          this.setLinearRestitution(linearLimit.restitution);
          this.setSwingSoftConstraint(angularLimit.enableSoftConstraintSwing);
          this.setSwingRestitution(angularLimit.swingRestitution);
          this.setSwingStiffness(angularLimit.swingStiffness);
          this.setSwingDamping(angularLimit.swingDamping);
          this.setTwistSoftConstraint(angularLimit.enableSoftConstraintTwist);
          this.setTwistRestitution(angularLimit.twistRestitution);
          this.setTwistStiffness(angularLimit.twistStiffness);
          this.setTwistDamping(angularLimit.twistDamping);
          const linearMotor = this.constraint.linearDriverSettings;
          const angularMotor = this.constraint.angularDriverSettings;
          this.setDriverMode(0, linearMotor.xDrive);
          this.setDriverMode(1, linearMotor.yDrive);
          this.setDriverMode(2, linearMotor.zDrive);
          this.setDriverMode(3, angularMotor.twistDrive);
          this.setDriverMode(4, angularMotor.swingDrive1);
          this.setDriverMode(5, angularMotor.swingDrive2);
          this.setLinearMotorTarget(linearMotor.targetPosition);
          this.setLinearMotorVelocity(linearMotor.targetVelocity);
          this.setLinearMotorForceLimit(linearMotor.strength);
          this.setAngularMotorTarget(angularMotor.targetOrientation);
          this.setAngularMotorVelocity(angularMotor.targetVelocity);
          this.setAngularMotorForceLimit(angularMotor.strength);
          this.setBreakForce(this.constraint.breakForce);
          this.setBreakTorque(this.constraint.breakTorque);
          this.updateFrames();
          this.updateDebugDrawSize();
        }
        updateFrames() {
          const cs = this.constraint;
          const node = cs.node;
          const v3_0 = CC_V3_0;
          const rot_0 = CC_QUAT_0;
          const rot_1 = CC_QUAT_1;
          const trans0 = BulletCache.instance.BT_TRANSFORM_0;
          Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
          cocos2BulletVec3(bt.Transform_getOrigin(trans0), v3_0);
          const quat = BulletCache.instance.BT_QUAT_0;
          const axisX = cs.axis;
          const axisY = cs.secondaryAxis;
          const axisZ = Vec3.cross(CC_V3_1, axisX, axisY);
          const mat = Mat4.set(CC_MAT4_0, axisX.x, axisX.y, axisX.z, 0, axisY.x, axisY.y, axisY.z, 0, axisZ.x, axisZ.y, axisZ.z, 0, 0, 0, 0, 1);
          mat.getRotation(rot_0);
          cocos2BulletQuat(quat, rot_0);
          bt.Transform_setRotation(trans0, quat);
          const trans1 = BulletCache.instance.BT_TRANSFORM_1;
          const cb = this.constraint.connectedBody;
          if (cb) {
            Quat.multiply(rot_0, node.worldRotation, rot_0);
            Quat.invert(rot_1, cb.node.worldRotation);
            Quat.multiply(rot_0, rot_1, rot_0);
            if (cs.autoPivotB) {
              Vec3.multiply(v3_0, cs.node.worldScale, cs.pivotA);
              Vec3.transformQuat(v3_0, v3_0, node.worldRotation);
              Vec3.add(v3_0, v3_0, cs.node.worldPosition);
              Vec3.subtract(v3_0, v3_0, cb.node.worldPosition);
              Vec3.transformQuat(v3_0, v3_0, rot_1);
            } else {
              Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
            }
          } else {
            Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
            Vec3.transformQuat(v3_0, v3_0, node.worldRotation);
            Vec3.add(v3_0, v3_0, node.worldPosition);
            Quat.multiply(rot_0, node.worldRotation, rot_0);
          }
          cocos2BulletVec3(bt.Transform_getOrigin(trans1), v3_0);
          cocos2BulletQuat(quat, rot_0);
          bt.Transform_setRotation(trans1, quat);
          bt.Generic6DofSpring2Constraint_setFrames(this._impl, trans0, trans1);
        }
        updateScale0() {
          this.updateFrames();
        }
        updateScale1() {
          this.updateFrames();
        }
      }

      const v3_0$2 = new Vec3(0, 0, 0);
      const v3_1 = new Vec3(0, 0, 0);
      new Vec3(0, 0, 0);
      class BulletCharacterController {
        get isEnabled() {
          return this._isEnabled;
        }
        get impl() {
          return this._impl;
        }
        get characterController() {
          return this._comp;
        }
        constructor() {
          this.wrappedWorld = void 0;
          this._isEnabled = false;
          this._impl = 0;
          this._comp = null;
          this._btCollisionFlags = 0;
          this._word3 = 0;
          this._dirty = false;
          this._collisionFilterGroup = PhysicsGroup.DEFAULT;
          this._collisionFilterMask = -1;
          this.id = BulletCharacterController.idCounter++;
          this.wrappedWorld = PhysicsSystem.instance.physicsWorld;
        }
        onComponentSet() {}
        updateScale() {}
        initialize(comp) {
          this._comp = comp;
          const group = this._comp.group;
          const mask = PhysicsSystem.instance.collisionMatrix[group];
          this._collisionFilterGroup = group;
          this._collisionFilterMask = mask;
          this.onComponentSet();
          if (this._impl === 0) {
            error('[Physics]: Initialize BulletCharacterController failed');
            return false;
          } else {
            return true;
          }
        }
        setWrapper() {
          BulletCache.setWrapper(this._impl, btCache.CCT_CACHE_NAME, this);
          const cctCollisionShapeImpl = bt.CharacterController_getCollisionShape(this.impl);
          BulletCache.setWrapper(cctCollisionShapeImpl, btCache.CCT_CACHE_NAME, this);
        }
        onEnable() {
          this._isEnabled = true;
          if (!this._impl) {
            this.onComponentSet();
          }
          this.setDetectCollisions(false);
          this.setOverlapRecovery(true);
          PhysicsSystem.instance.physicsWorld.addCCT(this);
          this.setWrapper();
        }
        onDisable() {
          this._isEnabled = false;
          this.wrappedWorld.removeCCT(this);
          this.onDestroy();
        }
        onDestroy() {
          bt._safe_delete(this._impl, EBulletType.EBulletTypeCharacterController);
          BulletCache.delWrapper(this._impl, btCache.CCT_CACHE_NAME);
          this._impl = 0;
        }
        onLoad() {}
        getPosition(out) {
          if (!this._impl) return;
          bullet2CocosVec3(out, bt.CharacterController_getPosition(this.impl));
        }
        setPosition(value) {
          if (!this._impl) return;
          cocos2BulletVec3(bt.CharacterController_getPosition(this.impl), value);
          this.syncPhysicsToScene();
        }
        setContactOffset(value) {
          if (!this._impl) return;
          bt.CharacterController_setContactOffset(this._impl, value);
        }
        setStepOffset(value) {
          if (!this._impl) return;
          bt.CharacterController_setStepOffset(this._impl, value);
        }
        setSlopeLimit(value) {
          if (!this._impl) return;
          bt.CharacterController_setSlopeLimit(this._impl, degreesToRadians(value));
        }
        setDetectCollisions(value) {
          if (!this._impl) return;
          bt.CharacterController_setCollision(this.impl, value);
        }
        setOverlapRecovery(value) {
          if (!this._impl) return;
          bt.CharacterController_setOverlapRecovery(this.impl, value);
        }
        onGround() {
          return (this._btCollisionFlags & 1 << 2) > 0;
        }
        syncSceneToPhysics() {
          const node = this.characterController.node;
          if (node.hasChangedFlags) {
            if (node.hasChangedFlags & TransformBit.SCALE) this.syncScale();
            if (node.hasChangedFlags & TransformBit.POSITION) {
              Vec3.add(v3_0$2, node.worldPosition, this.scaledCenter);
              this.setPosition(v3_0$2);
            }
          }
        }
        syncPhysicsToScene() {
          this.getPosition(v3_0$2);
          v3_0$2.subtract(this.scaledCenter);
          this._comp.node.setWorldPosition(v3_0$2);
        }
        syncScale() {
          this.updateScale();
        }
        get scaledCenter() {
          Vec3.multiply(v3_1, this._comp.center, this._comp.node.worldScale);
          return v3_1;
        }
        move(movement, minDist, elapsedTime) {
          if (!this._isEnabled) {
            return;
          }
          const movementBT = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(movementBT, movement.x, movement.y, movement.z);
          this._btCollisionFlags = bt.CharacterController_move(this.impl, movementBT, minDist, elapsedTime);
        }
        setGroup(v) {
          if (v !== this._collisionFilterGroup) {
            this._collisionFilterGroup = v;
            this._dirty = true;
          }
        }
        getGroup() {
          return this._collisionFilterGroup;
        }
        addGroup(v) {
          this._collisionFilterGroup |= v;
          this._dirty = true;
        }
        removeGroup(v) {
          this._collisionFilterGroup &= ~v;
          this._dirty = true;
        }
        setMask(v) {
          if (v !== this._collisionFilterMask) {
            this._collisionFilterMask = v;
            this._dirty = true;
          }
        }
        getMask() {
          return this._collisionFilterMask;
        }
        addMask(v) {
          this._collisionFilterMask |= v;
          this._dirty = true;
        }
        removeMask(v) {
          this._collisionFilterMask &= ~v;
          this._dirty = true;
        }
        updateEventListener() {
          this.wrappedWorld.updateNeedEmitCCTEvents(this.characterController.needCollisionEvent);
        }
        updateDirty() {
          if (this._dirty) {
            PhysicsSystem.instance.physicsWorld.removeCCT(this);
            PhysicsSystem.instance.physicsWorld.addCCT(this);
            this._dirty = false;
          }
        }
        onShapeHitExt(hit) {
          const shapePtr = bt.ControllerShapeHit_getHitShape(hit);
          const bulletWorld = PhysicsSystem.instance.physicsWorld;
          bulletWorld.cctShapeEventDic.get(this.impl, shapePtr);
          const worldPos = new Vec3();
          bullet2CocosVec3(worldPos, bt.ControllerHit_getHitWorldPos(hit));
          const worldNormal = new Vec3();
          bullet2CocosVec3(worldNormal, bt.ControllerHit_getHitWorldNormal(hit));
          const motionDir = new Vec3();
          bullet2CocosVec3(motionDir, bt.ControllerHit_getHitMotionDir(hit));
          const motionLength = bt.ControllerHit_getHitMotionLength(hit);
          const s = BulletCache.getWrapper(shapePtr, BulletShape.TYPE);
          if (s) {
            bulletWorld.cctShapeEventDic.set(this.impl, shapePtr, {
              BulletCharacterController: this,
              BulletShape: s,
              worldPos,
              worldNormal,
              motionDir,
              motionLength
            });
          }
        }
      }
      BulletCharacterController.idCounter = 0;

      const v3_0$1 = new Vec3(0, 0, 0);
      class BulletCapsuleCharacterController extends BulletCharacterController {
        get component() {
          return this._comp;
        }
        onComponentSet() {
          this.component.node.getWorldPosition(v3_0$1);
          v3_0$1.add(this.scaledCenter);
          const pos = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(pos, v3_0$1.x, v3_0$1.y, v3_0$1.z);
          const upDir = Vec3.UNIT_Y;
          const up = BulletCache.instance.BT_V3_1;
          bt.Vec3_set(up, upDir.x, upDir.y, upDir.z);
          const report = bt.ControllerHitReport.implement(importFunc).$$.ptr;
          const bulletWorld = PhysicsSystem.instance.physicsWorld;
          const controllerDesc = bt.CapsuleCharacterControllerDesc_new(degreesToRadians(this.component.slopeLimit), this.component.stepOffset, this.component.skinWidth, up, pos, report, this.component.radius, this.component.height);
          this._impl = bt.CapsuleCharacterController_new(bulletWorld.impl, controllerDesc, 0);
          this.updateScale();
        }
        setRadius(value) {
          this.updateScale();
        }
        setHeight(value) {
          this.updateScale();
        }
        updateScale() {
          this.updateGeometry();
        }
        updateGeometry() {
          const ws = this.component.node.worldScale;
          const r = this.component.radius * absMax(ws.x, ws.z);
          const h = this.component.height * Math.abs(ws.y);
          bt.CapsuleCharacterController_setRadius(this.impl, r);
          bt.CapsuleCharacterController_setHeight(this.impl, h);
          this._dirty = true;
        }
      }

      const v3_0 = new Vec3(0, 0, 0);
      class BulletBoxCharacterController extends BulletCharacterController {
        get component() {
          return this._comp;
        }
        onComponentSet() {
          this.component.node.getWorldPosition(v3_0);
          v3_0.add(this.scaledCenter);
          const pos = BulletCache.instance.BT_V3_0;
          bt.Vec3_set(pos, v3_0.x, v3_0.y, v3_0.z);
          const upDir = Vec3.UNIT_Y;
          const up = BulletCache.instance.BT_V3_1;
          bt.Vec3_set(up, upDir.x, upDir.y, upDir.z);
          const report = bt.ControllerHitReport.implement(importFunc).$$.ptr;
          const bulletWorld = PhysicsSystem.instance.physicsWorld;
          const controllerDesc = bt.BoxCharacterControllerDesc_new(degreesToRadians(this.component.slopeLimit), this.component.stepOffset, this.component.skinWidth, up, pos, report, this.component.halfHeight, this.component.halfSideExtent, this.component.halfForwardExtent);
          this._impl = bt.BoxCharacterController_new(bulletWorld.impl, controllerDesc, 0);
          this.updateScale();
        }
        setHalfHeight(value) {
          this.updateScale();
        }
        setHalfSideExtent(value) {
          this.updateScale();
        }
        setHalfForwardExtent(value) {
          this.updateScale();
        }
        updateScale() {
          this.updateGeometry();
        }
        updateGeometry() {
          const ws = this.component.node.worldScale;
          bt.BoxCharacterController_setHalfSideExtent(this.impl, this.component.halfSideExtent * ws.x);
          bt.BoxCharacterController_setHalfHeight(this.impl, this.component.halfHeight * ws.y);
          bt.BoxCharacterController_setHalfForwardExtent(this.impl, this.component.halfForwardExtent * ws.z);
          this._dirty = true;
        }
      }

      game.once(Game.EVENT_PRE_SUBSYSTEM_INIT, () => {
        selector.register('bullet', {
          PhysicsWorld: BulletWorld,
          RigidBody: BulletRigidBody,
          BoxShape: BulletBoxShape,
          SphereShape: BulletSphereShape,
          CapsuleShape: BulletCapsuleShape,
          TrimeshShape: BulletTrimeshShape,
          CylinderShape: BulletCylinderShape,
          ConeShape: BulletConeShape,
          TerrainShape: BulletTerrainShape,
          SimplexShape: BulletSimplexShape,
          PlaneShape: BulletPlaneShape,
          PointToPointConstraint: BulletP2PConstraint,
          HingeConstraint: BulletHingeConstraint,
          FixedConstraint: BulletFixedConstraint,
          ConfigurableConstraint: BulletConfigurableConstraint,
          BoxCharacterController: BulletBoxCharacterController,
          CapsuleCharacterController: BulletCapsuleCharacterController
        });
      });

      var _dec$j, _dec2$g, _class$j, _class2$f, _initializer$e, _initializer2$e, _class3$b;
      var PrimitiveType;
      (function (PrimitiveType) {
        PrimitiveType[PrimitiveType["BOX"] = 0] = "BOX";
        PrimitiveType[PrimitiveType["SPHERE"] = 1] = "SPHERE";
        PrimitiveType[PrimitiveType["CYLINDER"] = 2] = "CYLINDER";
        PrimitiveType[PrimitiveType["CONE"] = 3] = "CONE";
        PrimitiveType[PrimitiveType["CAPSULE"] = 4] = "CAPSULE";
        PrimitiveType[PrimitiveType["TORUS"] = 5] = "TORUS";
        PrimitiveType[PrimitiveType["PLANE"] = 6] = "PLANE";
        PrimitiveType[PrimitiveType["QUAD"] = 7] = "QUAD";
      })(PrimitiveType || (PrimitiveType = {}));
      ccenum(PrimitiveType);
      let Primitive = exports('Primitive', (_dec$j = ccclass$6('cc.Primitive'), _dec2$g = type$6(PrimitiveType), _dec$j(_class$j = (_class2$f = (_class3$b = class Primitive extends Mesh {
        constructor(type = PrimitiveType.BOX) {
          super();
          this.type = _initializer$e && _initializer$e();
          this.info = _initializer2$e && _initializer2$e();
          this.type = type;
        }
        onLoaded() {
          createMesh(primitives[PrimitiveType[this.type].toLowerCase()](this.info), this);
        }
      }, _class3$b.PrimitiveType = PrimitiveType, _class3$b), (_initializer$e = applyDecoratedInitializer(_class2$f.prototype, "type", [_dec2$g], function () {
        return PrimitiveType.BOX;
      }), _initializer2$e = applyDecoratedInitializer(_class2$f.prototype, "info", [serializable$6], function () {
        return {};
      })), _class2$f)) || _class$j));
      legacyCC.Primitive = Primitive;

      legacyCC.primitives = primitives;

      class Counter {
        get value() {
          return this._value;
        }
        set value(val) {
          this._value = val;
        }
        constructor(id, opts, now) {
          this._opts = void 0;
          this._total = 0;
          this._value = 0;
          this._averageValue = 0;
          this._accumValue = 0;
          this._accumSamples = 0;
          this._id = id;
          this._opts = opts;
          this._accumStart = now;
        }
        sample(now) {
          this._average(this._value, now);
        }
        human() {
          const {
            average,
            isInteger
          } = this._opts;
          const v = average ? this._averageValue : this._value;
          return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
        }
        alarm() {
          if (this._opts.below !== undefined && this._value < this._opts.below) {
            return true;
          }
          if (this._opts.over !== undefined && this._value > this._opts.over) {
            return true;
          }
          return false;
        }
        _average(v, now = 0) {
          if (this._opts.average) {
            this._accumValue += v;
            ++this._accumSamples;
            const t = now;
            if (t - this._accumStart >= this._opts.average) {
              this._averageValue = this._accumValue / this._accumSamples;
              this._accumValue = 0;
              this._accumStart = t;
              this._accumSamples = 0;
            }
          }
        }
      }

      var _dec$i, _class$i;
      let PerfCounter = (_dec$i = ccclass$6('cc.PerfCounter'), _dec$i(_class$i = class PerfCounter extends Counter {
        constructor(id, opts, now) {
          super(id, opts, now);
          this._time = now;
        }
        start(now = 0) {
          this._time = now;
        }
        end(now = 0) {
          this._value = now - this._time;
          this._average(this._value);
        }
        tick() {
          this.end();
          this.start();
        }
        frame(now) {
          const t = now;
          const e = t - this._time;
          this._total++;
          const avg = this._opts.average || 1000;
          if (e > avg) {
            this._value = this._total * 1000 / e;
            this._total = 0;
            this._time = t;
            this._average(this._value);
          }
        }
      }) || _class$i);

      const _characters = '0123456789. ';
      const _average = 500;
      const _string2offset = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        '.': 10
      };
      const _profileInfo = {
        fps: {
          desc: `Framerate (FPS)`,
          below: 30,
          average: _average,
          isInteger: true
        },
        draws: {
          desc: 'Draw call',
          isInteger: true
        },
        frame: {
          desc: 'Frame time (ms)',
          min: 0,
          max: 50,
          average: _average
        },
        instances: {
          desc: 'Instance Count',
          isInteger: true
        },
        tricount: {
          desc: 'Triangle',
          isInteger: true
        },
        logic: {
          desc: 'Game Logic (ms)',
          min: 0,
          max: 50,
          average: _average,
          color: '#080'
        },
        physics: {
          desc: 'Physics (ms)',
          min: 0,
          max: 50,
          average: _average
        },
        render: {
          desc: 'Renderer (ms)',
          min: 0,
          max: 50,
          average: _average,
          color: '#f90'
        },
        present: {
          desc: 'Present (ms)',
          min: 0,
          max: 50,
          average: _average,
          color: '#f90'
        },
        textureMemory: {
          desc: 'GFX Texture Mem(M)'
        },
        bufferMemory: {
          desc: 'GFX Buffer Mem(M)'
        }
      };
      const _constants = {
        fontSize: 23,
        quadHeight: 0.4,
        segmentsPerLine: 8,
        textureWidth: 280,
        textureHeight: 280
      };
      class Profiler extends System {
        constructor() {
          super();
          this._profilerStats = null;
          this._showFPS = false;
          this._rootNode = null;
          this._device = null;
          this._swapchain = null;
          this._meshRenderer = null;
          this._canvas = null;
          this._ctx = null;
          this._texture = null;
          this._region = new BufferTextureCopy();
          this._canvasArr = [];
          this._regionArr = [this._region];
          this.digitsData = null;
          this.offsetData = null;
          this.pass = null;
          this._canvasDone = false;
          this._statsDone = false;
          this._inited = false;
          this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
          this._wordHeight = 0;
          this._eachNumWidth = 0;
          this._totalLines = 0;
          this.lastTime = 0;
          {
            this._canvas = ccwindow$1.document.createElement('canvas');
            this._ctx = this._canvas.getContext('2d');
            this._canvasArr.push(this._canvas);
          }
        }
        init() {
          const showFPS = !!settings.querySettings(Settings.Category.PROFILING, 'showFPS');
          if (showFPS) {
            this.showStats();
          } else {
            this.hideStats();
          }
        }
        get _stats() {
          warn('Profiler._stats is deprecated, please use Profiler.stats instead.');
          return this._profilerStats;
        }
        get stats() {
          return this._profilerStats;
        }
        isShowingStats() {
          return this._showFPS;
        }
        hideStats() {
          if (this._showFPS) {
            if (this._rootNode) {
              this._rootNode.active = false;
            }
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
            legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_RENDER, this.afterRender, this);
            legacyCC.director.off(legacyCC.Director.EVENT_AFTER_DRAW, this.afterPresent, this);
            this._showFPS = false;
            director.root.pipeline.profiler = null;
            legacyCC.game.config.showFPS = false;
          }
        }
        showStats() {
          if (!this._showFPS) {
            if (!this._device) {
              const root = legacyCC.director.root;
              this._device = deviceManager.gfxDevice;
              this._swapchain = root.mainWindow.swapchain;
            }
            this.generateCanvas();
            this.generateStats();
            legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.generateNode, this);
            legacyCC.game.on(legacyCC.Game.EVENT_RESTART, this.generateNode, this);
            if (this._rootNode) {
              this._rootNode.active = true;
            }
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
            legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_RENDER, this.afterRender, this);
            legacyCC.director.on(legacyCC.Director.EVENT_AFTER_DRAW, this.afterPresent, this);
            this._showFPS = true;
            this._canvasDone = true;
            this._statsDone = true;
            legacyCC.game.config.showFPS = true;
          }
        }
        generateCanvas() {
          if (this._canvasDone) {
            return;
          }
          const {
            textureWidth,
            textureHeight
          } = _constants;
          if (!this._ctx || !this._canvas) {
            return;
          }
          this._canvas.width = textureWidth;
          this._canvas.height = textureHeight;
          this._canvas.style.width = `${this._canvas.width}`;
          this._canvas.style.height = `${this._canvas.height}`;
          this._ctx.font = `${_constants.fontSize}px Arial`;
          this._ctx.textBaseline = 'top';
          this._ctx.fillStyle = '#fff';
          this._texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, textureWidth, textureHeight));
          this._region.texExtent.width = textureWidth;
          this._region.texExtent.height = textureHeight;
        }
        generateStats() {
          if (this._statsDone || !this._ctx || !this._canvas) {
            return;
          }
          this._profilerStats = null;
          const now = performance.now();
          this._ctx.textAlign = 'left';
          let i = 0;
          for (const id in _profileInfo) {
            const element = _profileInfo[id];
            this._ctx.fillText(element.desc, 0, i * this._lineHeight);
            element.counter = new PerfCounter(id, element, now);
            i++;
          }
          this._totalLines = i;
          this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;
          for (let j = 0; j < _characters.length; ++j) {
            const offset = this._ctx.measureText(_characters[j]).width;
            this._eachNumWidth = Math.max(this._eachNumWidth, offset);
          }
          for (let j = 0; j < _characters.length; ++j) {
            this._ctx.fillText(_characters[j], j * this._eachNumWidth, this._totalLines * this._lineHeight);
          }
          this._eachNumWidth /= this._canvas.width;
          this._profilerStats = _profileInfo;
          this._canvasArr[0] = this._canvas;
          this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
        }
        generateNode() {
          if (this._rootNode && this._rootNode.isValid) {
            return;
          }
          this._rootNode = new Node$1('PROFILER_NODE');
          this._rootNode._objFlags = legacyCC.Object.Flags.DontSave | legacyCC.Object.Flags.HideInHierarchy;
          legacyCC.game.addPersistRootNode(this._rootNode);
          const managerNode = new Node$1('Profiler_Root');
          managerNode.parent = this._rootNode;
          const height = _constants.quadHeight;
          const rowHeight = height / this._totalLines;
          const lWidth = height / this._wordHeight;
          const scale = rowHeight / _constants.fontSize;
          const columnWidth = this._eachNumWidth * this._canvas.width * scale;
          const vertexPos = [0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0];
          const vertexindices = [0, 2, 1, 0, 3, 2];
          const vertexUV = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0];
          let offset = 0;
          for (let i = 0; i < this._totalLines; i++) {
            for (let j = 0; j < _constants.segmentsPerLine; j++) {
              vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
              vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
              vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
              vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
              offset = (i * _constants.segmentsPerLine + j + 1) * 4;
              vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
              const idx = i * _constants.segmentsPerLine + j;
              const z = Math.floor(idx / 4);
              const w = idx - z * 4;
              vertexUV.push(0, this._wordHeight, z, w);
              vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
              vertexUV.push(this._eachNumWidth, 1, z, w);
              vertexUV.push(0, 1, z, w);
            }
          }
          this._meshRenderer = managerNode.addComponent(MeshRenderer);
          this._meshRenderer.mesh = createMesh({
            positions: vertexPos,
            indices: vertexindices,
            colors: vertexUV
          });
          const _material = new Material();
          _material.initialize({
            effectName: 'util/profiler'
          });
          const pass = this.pass = _material.passes[0];
          const hTexture = pass.getBinding('mainTexture');
          const bDigits = pass.getBinding('digits');
          const bOffset = pass.getBinding('offset');
          pass.bindTexture(hTexture, this._texture);
          this.digitsData = pass.blocks[bDigits];
          this.offsetData = pass.blocks[bOffset];
          this.offsetData[3] = -1;
          this._meshRenderer.material = _material;
          this._meshRenderer.node.layer = Layers.Enum.PROFILER;
          this._inited = true;
        }
        beforeUpdate() {
          if (!this._profilerStats) {
            return;
          }
          const now = performance.now();
          this._profilerStats.frame.counter.start(now);
          this._profilerStats.logic.counter.start(now);
        }
        afterUpdate() {
          if (!this._profilerStats) {
            return;
          }
          const now = performance.now();
          if (legacyCC.director.isPaused()) {
            this._profilerStats.frame.counter.start(now);
          } else {
            this._profilerStats.logic.counter.end(now);
          }
        }
        beforePhysics() {
          if (!this._profilerStats) {
            return;
          }
          const now = performance.now();
          this._profilerStats.physics.counter.start(now);
        }
        afterPhysics() {
          if (!this._profilerStats) {
            return;
          }
          const now = performance.now();
          this._profilerStats.physics.counter.end(now);
        }
        beforeDraw() {
          if (!this._profilerStats || !this._inited) {
            return;
          }
          const surfaceTransform = this._swapchain.surfaceTransform;
          const clipSpaceSignY = this._device.capabilities.clipSpaceSignY;
          if (surfaceTransform !== this.offsetData[3]) {
            const preTransform = preTransforms[surfaceTransform];
            let x = -0.9;
            let y = -0.9 * clipSpaceSignY;
            if (sys.isXR) {
              x = -0.5;
              y = -0.5 * clipSpaceSignY;
            }
            this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
            this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
            this.offsetData[2] = this._eachNumWidth;
            this.offsetData[3] = surfaceTransform;
          }
          this.pass.setRootBufferDirty(true);
          if (this._meshRenderer.model) {
            director.root.pipeline.profiler = this._meshRenderer.model;
          } else {
            director.root.pipeline.profiler = null;
          }
          const now = performance.now();
          this._profilerStats.render.counter.start(now);
        }
        afterRender() {
          if (!this._profilerStats || !this._inited) {
            return;
          }
          const now = performance.now();
          this._profilerStats.render.counter.end(now);
          this._profilerStats.present.counter.start(now);
        }
        afterPresent() {
          if (!this._profilerStats || !this._inited) {
            return;
          }
          const now = performance.now();
          this._profilerStats.frame.counter.end(now);
          this._profilerStats.fps.counter.frame(now);
          this._profilerStats.present.counter.end(now);
          if (now - this.lastTime < _average) {
            return;
          }
          this.lastTime = now;
          const device = this._device;
          this._profilerStats.draws.counter.value = device.numDrawCalls;
          this._profilerStats.instances.counter.value = device.numInstances;
          this._profilerStats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
          this._profilerStats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
          this._profilerStats.tricount.counter.value = device.numTris;
          let i = 0;
          const view = this.digitsData;
          for (const id in this._profilerStats) {
            const stat = this._profilerStats[id];
            stat.counter.sample(now);
            const result = stat.counter.human().toString();
            for (let j = _constants.segmentsPerLine - 1; j >= 0; j--) {
              const index = i * _constants.segmentsPerLine + j;
              const character = result[result.length - (_constants.segmentsPerLine - j)];
              let offset = _string2offset[character];
              if (offset === undefined) {
                offset = 11;
              }
              view[index] = offset;
            }
            i++;
          }
        }
      } exports('Profiler', Profiler);
      const profiler = exports('profiler', new Profiler());
      director.registerSystem('profiler', profiler, 0);
      legacyCC.profiler = profiler;

      class Action {
        constructor() {
          this.originalTarget = null;
          this.target = null;
          this.tag = Action.TAG_INVALID;
        }
        clone() {
          const action = new Action();
          action.originalTarget = null;
          action.target = null;
          action.tag = this.tag;
          return action;
        }
        isDone() {
          return true;
        }
        startWithTarget(target) {
          this.originalTarget = target;
          this.target = target;
        }
        stop() {
          this.target = null;
        }
        step(dt) {
          logID(1006);
        }
        update(dt) {
          logID(1007);
        }
        getTarget() {
          return this.target;
        }
        setTarget(target) {
          this.target = target;
        }
        getOriginalTarget() {
          return this.originalTarget;
        }
        setOriginalTarget(originalTarget) {
          this.originalTarget = originalTarget;
        }
        getTag() {
          return this.tag;
        }
        setTag(tag) {
          this.tag = tag;
        }
        reverse() {
          logID(1008);
          return null;
        }
        retain() {}
        release() {}
      }
      Action.TAG_INVALID = -1;
      class FiniteTimeAction extends Action {
        constructor(...args) {
          super(...args);
          this._duration = 0;
          this._timesForRepeat = 1;
        }
        getDuration() {
          return this._duration * (this._timesForRepeat || 1);
        }
        setDuration(duration) {
          this._duration = duration;
        }
        clone() {
          return new FiniteTimeAction();
        }
      }

      let ID_COUNTER = 0;
      class HashElement {
        constructor() {
          this.actions = [];
          this.target = null;
          this.actionIndex = 0;
          this.currentAction = null;
          this.paused = false;
          this.lock = false;
        }
      }
      class ActionManager {
        constructor() {
          this._hashTargets = new Map();
          this._arrayTargets = [];
          this._currentTarget = void 0;
          this._elementPool = [];
        }
        _searchElementByTarget(arr, target) {
          for (let k = 0; k < arr.length; k++) {
            if (target === arr[k].target) return arr[k];
          }
          return null;
        }
        _getElement(target, paused) {
          let element = this._elementPool.pop();
          if (!element) {
            element = new HashElement();
          }
          element.target = target;
          element.paused = !!paused;
          return element;
        }
        _putElement(element) {
          element.actions.length = 0;
          element.actionIndex = 0;
          element.currentAction = null;
          element.paused = false;
          element.target = null;
          element.lock = false;
          this._elementPool.push(element);
        }
        addAction(action, target, paused) {
          if (!action || !target) {
            errorID(1000);
            return;
          }
          if (target.uuid == null) {
            target.uuid = `_TWEEN_UUID_${ID_COUNTER++}`;
          }
          let element = this._hashTargets.get(target);
          if (!element) {
            element = this._getElement(target, paused);
            this._hashTargets.set(target, element);
            this._arrayTargets.push(element);
          } else if (!element.actions) {
            element.actions = [];
          }
          element.target = target;
          element.actions.push(action);
          action.startWithTarget(target);
        }
        removeAllActions() {
          const locTargets = this._arrayTargets;
          for (let i = 0; i < locTargets.length; i++) {
            const element = locTargets[i];
            if (element) this._putElement(element);
          }
          this._arrayTargets.length = 0;
          this._hashTargets = new Map();
        }
        removeAllActionsFromTarget(target) {
          if (target == null) return;
          const element = this._hashTargets.get(target);
          if (element) {
            element.actions.length = 0;
            this._deleteHashElement(element);
          }
        }
        removeAction(action) {
          if (action == null) return;
          const target = action.getOriginalTarget();
          const element = this._hashTargets.get(target);
          if (element) {
            for (let i = 0; i < element.actions.length; i++) {
              if (element.actions[i] === action) {
                element.actions.splice(i, 1);
                if (element.actionIndex >= i) element.actionIndex--;
                break;
              }
            }
          }
        }
        _removeActionByTag(tag, element, target) {
          for (let i = 0, l = element.actions.length; i < l; ++i) {
            const action = element.actions[i];
            if (action && action.getTag() === tag) {
              if (target && action.getOriginalTarget() !== target) {
                continue;
              }
              this._removeActionAtIndex(i, element);
              break;
            }
          }
        }
        _removeAllActionsByTag(tag, element, target) {
          for (let i = element.actions.length - 1; i >= 0; --i) {
            const action = element.actions[i];
            if (action && action.getTag() === tag) {
              if (target && action.getOriginalTarget() !== target) {
                continue;
              }
              this._removeActionAtIndex(i, element);
            }
          }
        }
        removeActionByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1002);
          const hashTargets = this._hashTargets;
          if (target) {
            const element = hashTargets.get(target);
            if (element) {
              this._removeActionByTag(tag, element, target);
            }
          } else {
            hashTargets.forEach(element => {
              this._removeActionByTag(tag, element);
            });
          }
        }
        removeAllActionsByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1002);
          const hashTargets = this._hashTargets;
          if (target) {
            const element = hashTargets.get(target);
            if (element) {
              this._removeAllActionsByTag(tag, element, target);
            }
          } else {
            hashTargets.forEach(element => {
              this._removeAllActionsByTag(tag, element);
            });
          }
        }
        getActionByTag(tag, target) {
          if (tag === Action.TAG_INVALID) logID(1004);
          const element = this._hashTargets.get(target);
          if (element) {
            if (element.actions != null) {
              for (let i = 0; i < element.actions.length; ++i) {
                const action = element.actions[i];
                if (action && action.getTag() === tag) {
                  return action;
                }
              }
            }
            logID(1005, tag);
          }
          return null;
        }
        getNumberOfRunningActionsInTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) {
            return element.actions ? element.actions.length : 0;
          }
          return 0;
        }
        pauseTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) element.paused = true;
        }
        resumeTarget(target) {
          const element = this._hashTargets.get(target);
          if (element) element.paused = false;
        }
        pauseAllRunningActions() {
          const idsWithActions = [];
          const locTargets = this._arrayTargets;
          for (let i = 0; i < locTargets.length; i++) {
            const element = locTargets[i];
            if (element && !element.paused) {
              element.paused = true;
              idsWithActions.push(element.target);
            }
          }
          return idsWithActions;
        }
        resumeTargets(targetsToResume) {
          if (!targetsToResume) return;
          for (let i = 0; i < targetsToResume.length; i++) {
            if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
          }
        }
        pauseTargets(targetsToPause) {
          if (!targetsToPause) return;
          for (let i = 0; i < targetsToPause.length; i++) {
            if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
          }
        }
        purgeSharedManager() {
          legacyCC.director.getScheduler().unscheduleUpdate(this);
        }
        _removeActionAtIndex(index, element) {
          element.actions[index];
          element.actions.splice(index, 1);
          if (element.actionIndex >= index) element.actionIndex--;
          if (element.actions.length === 0) {
            this._deleteHashElement(element);
          }
        }
        _deleteHashElement(element) {
          let ret = false;
          if (element && !element.lock) {
            if (this._hashTargets.get(element.target)) {
              this._hashTargets.delete(element.target);
              const targets = this._arrayTargets;
              for (let i = 0, l = targets.length; i < l; i++) {
                if (targets[i] === element) {
                  targets.splice(i, 1);
                  break;
                }
              }
              this._putElement(element);
              ret = true;
            }
          }
          return ret;
        }
        update(dt) {
          const locTargets = this._arrayTargets;
          let locCurrTarget;
          for (let elt = 0; elt < locTargets.length; elt++) {
            this._currentTarget = locTargets[elt];
            locCurrTarget = this._currentTarget;
            const target = locCurrTarget.target;
            if (isCCObject(target) && !target.isValid) {
              this.removeAllActionsFromTarget(target);
              elt--;
              continue;
            }
            if (!locCurrTarget.paused && locCurrTarget.actions) {
              locCurrTarget.lock = true;
              for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                if (!locCurrTarget.currentAction) continue;
                locCurrTarget.currentAction.step(dt * (this._isActionInternal(locCurrTarget.currentAction) ? locCurrTarget.currentAction.getSpeed() : 1));
                if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                  locCurrTarget.currentAction.stop();
                  const action = locCurrTarget.currentAction;
                  locCurrTarget.currentAction = null;
                  this.removeAction(action);
                }
                locCurrTarget.currentAction = null;
              }
              locCurrTarget.lock = false;
            }
            if (locCurrTarget.actions.length === 0) {
              if (this._deleteHashElement(locCurrTarget)) {
                elt--;
              }
            }
          }
        }
        _isActionInternal(action) {
          return typeof action._speedMethod !== 'undefined';
        }
      }

      class TweenSystem extends System {
        constructor(...args) {
          super(...args);
          this.actionMgr = new ActionManager();
        }
        get ActionManager() {
          return this.actionMgr;
        }
        update(dt) {
          {
            this.actionMgr.update(dt);
          }
        }
      } exports('TweenSystem', TweenSystem);
      TweenSystem.ID = 'TWEEN';
      TweenSystem.instance = void 0;
      director.on(Director.EVENT_INIT, () => {
        const sys = new TweenSystem();
        TweenSystem.instance = sys;
        director.registerSystem(TweenSystem.ID, sys, System.Priority.MEDIUM);
      });

      class ActionInstant extends FiniteTimeAction {
        isDone() {
          return true;
        }
        step(dt) {
          this.update(1);
        }
        update(dt) {}
        reverse() {
          return this.clone();
        }
        clone() {
          return new ActionInstant();
        }
      }
      class Show extends ActionInstant {
        update(dt) {
          const _renderComps = this.target.getComponentsInChildren(Renderer);
          for (let i = 0; i < _renderComps.length; ++i) {
            const render = _renderComps[i];
            render.enabled = true;
          }
        }
        reverse() {
          return new Hide();
        }
        clone() {
          return new Show();
        }
      }
      function show() {
        return new Show();
      }
      class Hide extends ActionInstant {
        update(dt) {
          const _renderComps = this.target.getComponentsInChildren(Renderer);
          for (let i = 0; i < _renderComps.length; ++i) {
            const render = _renderComps[i];
            render.enabled = false;
          }
        }
        reverse() {
          return new Show();
        }
        clone() {
          return new Hide();
        }
      }
      function hide() {
        return new Hide();
      }
      class RemoveSelf extends ActionInstant {
        constructor(isNeedCleanUp) {
          super();
          this._isNeedCleanUp = true;
          isNeedCleanUp !== undefined && this.init(isNeedCleanUp);
        }
        update(dt) {
          this.target.removeFromParent();
          if (this._isNeedCleanUp) {
            this.target.destroy();
          }
        }
        init(isNeedCleanUp) {
          this._isNeedCleanUp = isNeedCleanUp;
          return true;
        }
        reverse() {
          return new RemoveSelf(this._isNeedCleanUp);
        }
        clone() {
          return new RemoveSelf(this._isNeedCleanUp);
        }
      }
      function removeSelf(isNeedCleanUp) {
        return new RemoveSelf(isNeedCleanUp);
      }
      class CallFunc extends ActionInstant {
        constructor(selector, selectorTarget, data) {
          super();
          this._selectorTarget = null;
          this._function = null;
          this._data = null;
          this.initWithFunction(selector, selectorTarget, data);
        }
        initWithFunction(selector, selectorTarget, data) {
          if (selector) {
            this._function = selector;
          }
          if (selectorTarget) {
            this._selectorTarget = selectorTarget;
          }
          if (data !== undefined) {
            this._data = data;
          }
          return true;
        }
        execute() {
          if (this._function) {
            this._function.call(this._selectorTarget, this.target, this._data);
          }
        }
        update(dt) {
          this.execute();
        }
        getTargetCallback() {
          return this._selectorTarget;
        }
        setTargetCallback(sel) {
          if (sel !== this._selectorTarget) {
            if (this._selectorTarget) {
              this._selectorTarget = null;
            }
            this._selectorTarget = sel;
          }
        }
        clone() {
          const action = new CallFunc();
          action.initWithFunction(this._function, this._selectorTarget, this._data);
          return action;
        }
      }
      function callFunc(selector, selectorTarget, data) {
        return new CallFunc(selector, selectorTarget, data);
      }

      var _class2$e, _class5;
      class ActionInterval extends FiniteTimeAction {
        constructor(d) {
          super();
          this.MAX_VALUE = 2;
          this._elapsed = 0;
          this._firstTick = false;
          this._easeList = [];
          this._speed = 1;
          this._repeatForever = false;
          this._repeatMethod = false;
          this._speedMethod = false;
          if (d !== undefined && !Number.isNaN(d)) {
            this.initWithDuration(d);
          }
        }
        getElapsed() {
          return this._elapsed;
        }
        initWithDuration(d) {
          this._duration = d === 0 ? macro.FLT_EPSILON : d;
          this._elapsed = 0;
          this._firstTick = true;
          return true;
        }
        isDone() {
          return this._elapsed >= this._duration;
        }
        _cloneDecoration(action) {
          action._repeatForever = this._repeatForever;
          action._speed = this._speed;
          action._timesForRepeat = this._timesForRepeat;
          action._easeList = this._easeList;
          action._speedMethod = this._speedMethod;
          action._repeatMethod = this._repeatMethod;
        }
        _reverseEaseList(action) {
          if (this._easeList) {
            action._easeList = [];
            for (let i = 0; i < this._easeList.length; i++) {
              action._easeList.push(this._easeList[i]);
            }
          }
        }
        clone() {
          const action = new ActionInterval(this._duration);
          this._cloneDecoration(action);
          return action;
        }
        easing(easeObj) {
          if (this._easeList) this._easeList.length = 0;else this._easeList = [];
          for (let i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
          return this;
        }
        _computeEaseTime(dt) {
          return dt;
        }
        step(dt) {
          if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
          } else this._elapsed += dt;
          let t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
          t = t < 1 ? t : 1;
          this.update(t > 0 ? t : 0);
          if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
            if (!this._repeatForever) {
              this._timesForRepeat--;
            }
            this.startWithTarget(this.target);
            this.step(this._elapsed - this._duration);
          }
        }
        startWithTarget(target) {
          Action.prototype.startWithTarget.call(this, target);
          this._elapsed = 0;
          this._firstTick = true;
        }
        reverse() {
          logID(1010);
          return this;
        }
        setAmplitudeRate(amp) {
          logID(1011);
        }
        getAmplitudeRate() {
          logID(1012);
          return 0;
        }
        speed(speed) {
          if (speed <= 0) {
            logID(1013);
            return this;
          }
          this._speedMethod = true;
          this._speed *= speed;
          return this;
        }
        getSpeed() {
          return this._speed;
        }
        setSpeed(speed) {
          this._speed = speed;
          return this;
        }
        repeat(times) {
          times = Math.round(times);
          if (Number.isNaN(times) || times < 1) {
            logID(1014);
            return this;
          }
          this._repeatMethod = true;
          this._timesForRepeat *= times;
          return this;
        }
        repeatForever() {
          this._repeatMethod = true;
          this._timesForRepeat = this.MAX_VALUE;
          this._repeatForever = true;
          return this;
        }
      }
      class Sequence extends ActionInterval {
        constructor(tempArray) {
          super();
          this._actions = [];
          this._split = 0;
          this._last = 0;
          this._reversed = false;
          const paramArray = tempArray instanceof Array ? tempArray : arguments;
          if (paramArray.length === 1) {
            errorID(1019);
            return;
          }
          const last = paramArray.length - 1;
          if (last >= 0 && paramArray[last] == null) logID(1015);
          if (last >= 0) {
            let prev = paramArray[0];
            let action1;
            for (let i = 1; i < last; i++) {
              if (paramArray[i]) {
                action1 = prev;
                prev = Sequence._actionOneTwo(action1, paramArray[i]);
              }
            }
            this.initWithTwoActions(prev, paramArray[last]);
          }
        }
        initWithTwoActions(actionOne, actionTwo) {
          if (!actionOne || !actionTwo) {
            errorID(1025);
            return false;
          }
          let durationOne = actionOne._duration;
          let durationTwo = actionTwo._duration;
          durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
          durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
          const d = durationOne + durationTwo;
          this.initWithDuration(d);
          this._actions[0] = actionOne;
          this._actions[1] = actionTwo;
          return true;
        }
        clone() {
          const action = new Sequence();
          this._cloneDecoration(action);
          action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._split = this._actions[0]._duration / this._duration;
          this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
          this._last = -1;
        }
        stop() {
          if (this._last !== -1) this._actions[this._last].stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          let new_t;
          let found = 0;
          const locSplit = this._split;
          const locActions = this._actions;
          const locLast = this._last;
          let actionFound;
          dt = this._computeEaseTime(dt);
          if (dt < locSplit) {
            new_t = locSplit !== 0 ? dt / locSplit : 1;
            if (found === 0 && locLast === 1 && this._reversed) {
              locActions[1].update(0);
              locActions[1].stop();
            }
          } else {
            found = 1;
            new_t = locSplit === 1 ? 1 : (dt - locSplit) / (1 - locSplit);
            if (locLast === -1) {
              locActions[0].startWithTarget(this.target);
              locActions[0].update(1);
              locActions[0].stop();
            }
            if (locLast === 0) {
              locActions[0].update(1);
              locActions[0].stop();
            }
          }
          actionFound = locActions[found];
          if (locLast === found && actionFound.isDone()) return;
          if (locLast !== found) actionFound.startWithTarget(this.target);
          new_t *= actionFound._timesForRepeat;
          actionFound.update(new_t > 1 ? new_t % 1 : new_t);
          this._last = found;
        }
        reverse() {
          const action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          action._reversed = true;
          return action;
        }
      }
      _class2$e = Sequence;
      Sequence._actionOneTwo = function (actionOne, actionTwo) {
        const sequence = new _class2$e();
        sequence.initWithTwoActions(actionOne, actionTwo);
        return sequence;
      };
      function sequence(tempArray) {
        const paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (paramArray.length === 1) {
          return paramArray[0];
        }
        const last = paramArray.length - 1;
        if (last >= 0 && paramArray[last] == null) logID(1015);
        let result = null;
        if (last >= 0) {
          result = paramArray[0];
          for (let i = 1; i <= last; i++) {
            if (paramArray[i]) {
              result = Sequence._actionOneTwo(result, paramArray[i]);
            }
          }
        }
        return result;
      }
      class Repeat extends ActionInterval {
        constructor(action, times) {
          super();
          this._times = 0;
          this._total = 0;
          this._nextDt = 0;
          this._actionInstant = false;
          this._innerAction = null;
          times !== undefined && this.initWithAction(action, times);
        }
        initWithAction(action, times) {
          const duration = action._duration * times;
          if (this.initWithDuration(duration)) {
            this._times = times;
            this._innerAction = action;
            if (action instanceof ActionInstant) {
              this._actionInstant = true;
              this._times -= 1;
            }
            this._total = 0;
            return true;
          }
          return false;
        }
        clone() {
          const action = new Repeat();
          this._cloneDecoration(action);
          action.initWithAction(this._innerAction.clone(), this._times);
          return action;
        }
        startWithTarget(target) {
          this._total = 0;
          this._nextDt = this._innerAction._duration / this._duration;
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._innerAction.startWithTarget(target);
        }
        stop() {
          this._innerAction.stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          const locInnerAction = this._innerAction;
          const locDuration = this._duration;
          const locTimes = this._times;
          let locNextDt = this._nextDt;
          if (dt >= locNextDt) {
            while (dt > locNextDt && this._total < locTimes) {
              locInnerAction.update(1);
              this._total++;
              locInnerAction.stop();
              locInnerAction.startWithTarget(this.target);
              locNextDt += locInnerAction._duration / locDuration;
              this._nextDt = locNextDt > 1 ? 1 : locNextDt;
            }
            if (dt >= 1.0 && this._total < locTimes) {
              locInnerAction.update(1);
              this._total++;
            }
            if (!this._actionInstant) {
              if (this._total === locTimes) {
                locInnerAction.stop();
              } else {
                locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
              }
            }
          } else {
            locInnerAction.update(dt * locTimes % 1.0);
          }
        }
        isDone() {
          return this._total === this._times;
        }
        reverse() {
          const action = new Repeat(this._innerAction.reverse(), this._times);
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        setInnerAction(action) {
          if (this._innerAction !== action) {
            this._innerAction = action;
          }
        }
        getInnerAction() {
          return this._innerAction;
        }
      }
      function repeat(action, times) {
        return new Repeat(action, times);
      }
      class RepeatForever extends ActionInterval {
        constructor(action) {
          super();
          this._innerAction = null;
          action && this.initWithAction(action);
        }
        initWithAction(action) {
          if (!action) {
            errorID(1026);
            return false;
          }
          this._innerAction = action;
          return true;
        }
        clone() {
          const action = new RepeatForever();
          this._cloneDecoration(action);
          action.initWithAction(this._innerAction.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._innerAction.startWithTarget(target);
        }
        step(dt) {
          const locInnerAction = this._innerAction;
          locInnerAction.step(dt);
          if (locInnerAction.isDone()) {
            locInnerAction.startWithTarget(this.target);
            locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
          }
        }
        isDone() {
          return false;
        }
        reverse() {
          const action = new RepeatForever(this._innerAction.reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        setInnerAction(action) {
          if (this._innerAction !== action) {
            this._innerAction = action;
          }
        }
        getInnerAction() {
          return this._innerAction;
        }
      }
      function repeatForever(action) {
        return new RepeatForever(action);
      }
      class Spawn extends ActionInterval {
        constructor(tempArray) {
          super();
          this._one = null;
          this._two = null;
          const paramArray = tempArray instanceof Array ? tempArray : arguments;
          if (paramArray.length === 1) {
            errorID(1020);
            return;
          }
          const last = paramArray.length - 1;
          if (last >= 0 && paramArray[last] == null) logID(1015);
          if (last >= 0) {
            let prev = paramArray[0];
            let action1;
            for (let i = 1; i < last; i++) {
              if (paramArray[i]) {
                action1 = prev;
                prev = Spawn._actionOneTwo(action1, paramArray[i]);
              }
            }
            this.initWithTwoActions(prev, paramArray[last]);
          }
        }
        initWithTwoActions(action1, action2) {
          if (!action1 || !action2) {
            errorID(1027);
            return false;
          }
          let ret = false;
          const d1 = action1._duration;
          const d2 = action2._duration;
          if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;
            if (d1 > d2) {
              this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2));
            } else if (d1 < d2) {
              this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1));
            }
            ret = true;
          }
          return ret;
        }
        clone() {
          const action = new Spawn();
          this._cloneDecoration(action);
          action.initWithTwoActions(this._one.clone(), this._two.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._one.startWithTarget(target);
          this._two.startWithTarget(target);
        }
        stop() {
          this._one.stop();
          this._two.stop();
          Action.prototype.stop.call(this);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          if (this._one) this._one.update(dt);
          if (this._two) this._two.update(dt);
        }
        reverse() {
          const action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
      }
      _class5 = Spawn;
      Spawn._actionOneTwo = function (action1, action2) {
        const pSpawn = new _class5();
        pSpawn.initWithTwoActions(action1, action2);
        return pSpawn;
      };
      function spawn(tempArray) {
        const paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (paramArray.length === 1) {
          errorID(1020);
          return null;
        }
        if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null) logID(1015);
        let prev = paramArray[0];
        for (let i = 1; i < paramArray.length; i++) {
          if (paramArray[i] != null) prev = Spawn._actionOneTwo(prev, paramArray[i]);
        }
        return prev;
      }
      class DelayTime extends ActionInterval {
        update(dt) {}
        reverse() {
          const action = new DelayTime(this._duration);
          this._cloneDecoration(action);
          this._reverseEaseList(action);
          return action;
        }
        clone() {
          const action = new DelayTime();
          this._cloneDecoration(action);
          action.initWithDuration(this._duration);
          return action;
        }
      }
      function delayTime(d) {
        return new DelayTime(d);
      }
      class ReverseTime extends ActionInterval {
        constructor(action) {
          super();
          this._other = null;
          action && this.initWithAction(action);
        }
        initWithAction(action) {
          if (!action) {
            errorID(1028);
            return false;
          }
          if (action === this._other) {
            errorID(1029);
            return false;
          }
          if (ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
            this._other = action;
            return true;
          }
          return false;
        }
        clone() {
          const action = new ReverseTime();
          this._cloneDecoration(action);
          action.initWithAction(this._other.clone());
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          this._other.startWithTarget(target);
        }
        update(dt) {
          dt = this._computeEaseTime(dt);
          if (this._other) this._other.update(1 - dt);
        }
        reverse() {
          return this._other.clone();
        }
        stop() {
          this._other.stop();
          Action.prototype.stop.call(this);
        }
      }
      function reverseTime(action) {
        return new ReverseTime(action);
      }

      function TweenEasingAdapter(easingName) {
        const initialChar = easingName.charAt(0);
        if (/[A-Z]/.test(initialChar)) {
          easingName = easingName.replace(initialChar, initialChar.toLowerCase());
          const arr = easingName.split('-');
          if (arr.length === 2) {
            const str0 = arr[0];
            if (str0 === 'linear') {
              easingName = 'linear';
            } else {
              const str1 = arr[1];
              switch (str0) {
                case 'quadratic':
                  easingName = `quad${str1}`;
                  break;
                case 'quartic':
                  easingName = `quart${str1}`;
                  break;
                case 'quintic':
                  easingName = `quint${str1}`;
                  break;
                case 'sinusoidal':
                  easingName = `sine${str1}`;
                  break;
                case 'exponential':
                  easingName = `expo${str1}`;
                  break;
                case 'circular':
                  easingName = `circ${str1}`;
                  break;
                default:
                  easingName = str0 + str1;
                  break;
              }
            }
          }
        }
        return easingName;
      }
      function TweenOptionChecker(opts) {
        const header = ' [Tween:] ';
        const message = ` option is not support in v + ${engineVersion}`;
        const _opts = opts;
        if (_opts.delay) {
          warn(`${header}delay${message}`);
        }
        if (_opts.repeat) {
          warn(`${header}repeat${message}`);
        }
        if (_opts.repeatDelay) {
          warn(`${header}repeatDelay${message}`);
        }
        if (_opts.interpolation) {
          warn(`${header}interpolation${message}`);
        }
        if (_opts.onStop) {
          warn(`${header}onStop${message}`);
        }
      }
      class TweenAction extends ActionInterval {
        constructor(duration, props, opts) {
          super();
          this._opts = void 0;
          this._props = void 0;
          this._originProps = void 0;
          if (opts == null) {
            opts = Object.create(null);
          } else {
            TweenOptionChecker(opts);
            if (opts.easing && typeof opts.easing === 'string') {
              opts.easing = TweenEasingAdapter(opts.easing);
            }
            if (!opts.progress) {
              opts.progress = this.progress;
            }
            if (opts.easing && typeof opts.easing === 'string') {
              const easingName = opts.easing;
              opts.easing = easing[easingName];
              if (!opts.easing) {
                warnID(1031, easingName);
              }
            }
          }
          this._opts = opts;
          this._props = Object.create(null);
          for (const name in props) {
            if (!props.hasOwnProperty(name)) continue;
            let value = props[name];
            if (typeof value === 'function') {
              value = value();
            }
            if (value == null || typeof value === 'string') continue;
            let customEasing;
            let progress;
            if (value.value !== undefined && (value.easing || value.progress)) {
              if (typeof value.easing === 'string') {
                customEasing = easing[value.easing];
                if (!customEasing) warnID(1031, value.easing);
              } else {
                customEasing = value.easing;
              }
              progress = value.progress;
              value = value.value;
            }
            const prop = Object.create(null);
            prop.value = value;
            prop.easing = customEasing;
            prop.progress = progress;
            this._props[name] = prop;
          }
          this._originProps = props;
          this.initWithDuration(duration);
        }
        clone() {
          const action = new TweenAction(this._duration, this._originProps, this._opts);
          this._cloneDecoration(action);
          return action;
        }
        startWithTarget(target) {
          ActionInterval.prototype.startWithTarget.call(this, target);
          const relative = !!this._opts.relative;
          const props = this._props;
          for (const property in props) {
            const _t = target[property];
            if (_t === undefined) {
              continue;
            }
            const prop = props[property];
            const value = prop.value;
            if (typeof _t === 'number') {
              prop.start = _t;
              prop.current = _t;
              prop.end = relative ? _t + value : value;
            } else if (typeof _t === 'object') {
              if (prop.start == null) {
                prop.start = {};
                prop.current = {};
                prop.end = {};
              }
              for (const k in value) {
                if (isNaN(_t[k])) continue;
                prop.start[k] = _t[k];
                prop.current[k] = _t[k];
                prop.end[k] = relative ? _t[k] + value[k] : value[k];
              }
            }
          }
          if (this._opts.onStart) {
            this._opts.onStart(this.target);
          }
        }
        update(t) {
          const target = this.target;
          if (!target) return;
          const props = this._props;
          const opts = this._opts;
          let easingTime = t;
          if (opts.easing) easingTime = opts.easing(t);
          const progress = opts.progress;
          for (const name in props) {
            const prop = props[name];
            const time = prop.easing ? prop.easing(t) : easingTime;
            const interpolation = prop.progress ? prop.progress : progress;
            const start = prop.start;
            const end = prop.end;
            if (typeof start === 'number') {
              prop.current = interpolation(start, end, prop.current, time);
            } else if (typeof start === 'object') {
              for (const k in start) {
                prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
              }
            }
            target[name] = prop.current;
          }
          if (opts.onUpdate) {
            opts.onUpdate(this.target, t);
          }
          if (t === 1 && opts.onComplete) {
            opts.onComplete(this.target);
          }
        }
        progress(start, end, current, t) {
          return start + (end - start) * t;
        }
      } exports('TweenAction', TweenAction);

      class SetAction extends ActionInstant {
        constructor(props) {
          super();
          this._props = void 0;
          this._props = {};
          props !== undefined && this.init(props);
        }
        init(props) {
          for (const name in props) {
            this._props[name] = props[name];
          }
          return true;
        }
        update() {
          const props = this._props;
          const target = this.target;
          for (const name in props) {
            target[name] = props[name];
          }
        }
        clone() {
          const action = new SetAction();
          action.init(this._props);
          return action;
        }
      }

      class Tween {
        constructor(target) {
          this._actions = [];
          this._finalAction = null;
          this._target = null;
          this._tag = Action.TAG_INVALID;
          this._target = target === undefined ? null : target;
        }
        tag(tag) {
          this._tag = tag;
          return this;
        }
        then(other) {
          if (other instanceof Action) {
            this._actions.push(other.clone());
          } else {
            this._actions.push(other._union());
          }
          return this;
        }
        target(target) {
          this._target = target;
          return this;
        }
        start() {
          if (!this._target) {
            warn('Please set target to tween first');
            return this;
          }
          if (this._finalAction) {
            TweenSystem.instance.ActionManager.removeAction(this._finalAction);
          }
          this._finalAction = this._union();
          this._finalAction.setTag(this._tag);
          TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, false);
          return this;
        }
        stop() {
          if (this._finalAction) {
            TweenSystem.instance.ActionManager.removeAction(this._finalAction);
          }
          return this;
        }
        clone(target) {
          const action = this._union();
          return tween(target).then(action.clone());
        }
        union() {
          const action = this._union();
          this._actions.length = 0;
          this._actions.push(action);
          return this;
        }
        to(duration, props, opts) {
          opts = opts || Object.create(null);
          opts.relative = false;
          const action = new TweenAction(duration, props, opts);
          this._actions.push(action);
          return this;
        }
        by(duration, props, opts) {
          opts = opts || Object.create(null);
          opts.relative = true;
          const action = new TweenAction(duration, props, opts);
          this._actions.push(action);
          return this;
        }
        set(props) {
          const action = new SetAction(props);
          this._actions.push(action);
          return this;
        }
        delay(duration) {
          const action = delayTime(duration);
          this._actions.push(action);
          return this;
        }
        call(callback) {
          const action = callFunc(callback);
          this._actions.push(action);
          return this;
        }
        sequence(...args) {
          const action = Tween._wrappedSequence(...args);
          this._actions.push(action);
          return this;
        }
        parallel(...args) {
          const action = Tween._wrappedParallel(...args);
          this._actions.push(action);
          return this;
        }
        repeat(repeatTimes, embedTween) {
          if (repeatTimes === Infinity) {
            return this.repeatForever(embedTween);
          }
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(repeat(action, repeatTimes));
          return this;
        }
        repeatForever(embedTween) {
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(repeatForever(action));
          return this;
        }
        reverseTime(embedTween) {
          const actions = this._actions;
          let action;
          if (embedTween instanceof Tween) {
            action = embedTween._union();
          } else {
            action = actions.pop();
          }
          actions.push(reverseTime(action));
          return this;
        }
        hide() {
          const action = hide();
          this._actions.push(action);
          return this;
        }
        show() {
          const action = show();
          this._actions.push(action);
          return this;
        }
        removeSelf() {
          const action = removeSelf(false);
          this._actions.push(action);
          return this;
        }
        destroySelf() {
          const action = removeSelf(true);
          this._actions.push(action);
          return this;
        }
        static stopAll() {
          TweenSystem.instance.ActionManager.removeAllActions();
        }
        static stopAllByTag(tag, target) {
          TweenSystem.instance.ActionManager.removeAllActionsByTag(tag, target);
        }
        static stopAllByTarget(target) {
          TweenSystem.instance.ActionManager.removeAllActionsFromTarget(target);
        }
        _union() {
          const actions = this._actions;
          let action;
          if (actions.length === 1) {
            action = actions[0];
          } else {
            action = sequence(actions);
          }
          return action;
        }
        _destroy() {
          this.stop();
        }
        static _wrappedSequence(...args) {
          const tmp_args = Tween._tmp_args;
          tmp_args.length = 0;
          for (let l = args.length, i = 0; i < l; i++) {
            const arg = tmp_args[i] = args[i];
            if (arg instanceof Tween) {
              tmp_args[i] = arg._union();
            }
          }
          return sequence.apply(sequence, tmp_args);
        }
        static _wrappedParallel(...args) {
          const tmp_args = Tween._tmp_args;
          tmp_args.length = 0;
          for (let l = args.length, i = 0; i < l; i++) {
            const arg = tmp_args[i] = args[i];
            if (arg instanceof Tween) {
              tmp_args[i] = arg._union();
            }
          }
          return spawn.apply(spawn, tmp_args);
        }
      } exports('Tween', Tween);
      Tween._tmp_args = [];
      legacyCC.Tween = Tween;
      function tween(target) {
        return new Tween(target);
      }
      legacyCC.tween = tween;
      function tweenUtil(target) {
        warn('tweenUtil\' is deprecated, please use \'tween\' instead ');
        return new Tween(target);
      }
      legacyCC.tweenUtil = tweenUtil;

      let DeviceType;
      (function (DeviceType) {
        DeviceType[DeviceType["Other"] = 0] = "Other";
        DeviceType[DeviceType["Left"] = 1] = "Left";
        DeviceType[DeviceType["Right"] = 2] = "Right";
      })(DeviceType || (DeviceType = {}));
      let XrUIPressEventType;
      (function (XrUIPressEventType) {
        XrUIPressEventType["XRUI_HOVER_ENTERED"] = "xrui-hover-entered";
        XrUIPressEventType["XRUI_HOVER_EXITED"] = "xrui-hover-exited";
        XrUIPressEventType["XRUI_HOVER_STAY"] = "xrui-hover-stay";
        XrUIPressEventType["XRUI_CLICK"] = "xrui-click";
        XrUIPressEventType["XRUI_UNCLICK"] = "xrui-unclick";
      })(XrUIPressEventType || (XrUIPressEventType = {}));
      let XrKeyboardEventType;
      (function (XrKeyboardEventType) {
        XrKeyboardEventType["XR_CAPS_LOCK"] = "xr-caps-lock";
        XrKeyboardEventType["XR_KEYBOARD_INIT"] = "xr-keyboard-init";
        XrKeyboardEventType["XR_KEYBOARD_INPUT"] = "xr-keyboard-input";
        XrKeyboardEventType["TO_LATIN"] = "to-latin";
        XrKeyboardEventType["TO_SYMBOL"] = "to-symbol";
        XrKeyboardEventType["TO_MATH_SYMBOL"] = "to-math-symbol";
      })(XrKeyboardEventType || (XrKeyboardEventType = {}));

      var _dec$h, _dec2$f, _dec3$e, _dec4$b, _dec5$b, _dec6$5, _dec7$4, _dec8$3, _dec9$3, _dec10$1, _class$h, _class2$d, _initializer$d, _initializer2$d, _initializer3$b, _initializer4$a, _initializer5$8, _initializer6$5, _initializer7$5, _initializer8$5, _initializer9$5, _initializer10$5, _initializer11$5, _initializer12$4, _initializer13$3, _initializer14$2, _class3$a;
      const _tempColor$1 = new Color$1();
      var Transition;
      (function (Transition) {
        Transition[Transition["NONE"] = 0] = "NONE";
        Transition[Transition["COLOR"] = 1] = "COLOR";
        Transition[Transition["SPRITE"] = 2] = "SPRITE";
        Transition[Transition["SCALE"] = 3] = "SCALE";
      })(Transition || (Transition = {}));
      ccenum(Transition);
      var State;
      (function (State) {
        State["NORMAL"] = "normal";
        State["HOVER"] = "hover";
        State["PRESSED"] = "pressed";
        State["DISABLED"] = "disabled";
      })(State || (State = {}));
      let EventType$4;
      (function (EventType) {
        EventType["CLICK"] = "click";
      })(EventType$4 || (EventType$4 = {}));
      let Button = (_dec$h = ccclass$6('cc.Button'), _dec2$f = executionOrder$1(110), _dec3$e = requireComponent(UITransform), _dec4$b = type$6(Node$1), _dec5$b = type$6(Transition), _dec6$5 = type$6(SpriteFrame), _dec7$4 = type$6(SpriteFrame), _dec8$3 = type$6(SpriteFrame), _dec9$3 = type$6(SpriteFrame), _dec10$1 = type$6([EventHandler]), _dec$h(_class$h = _dec2$f(_class$h = _dec3$e(_class$h = (_class2$d = (_class3$a = class Button extends Component {
        constructor(...args) {
          super(...args);
          this.clickEvents = _initializer$d && _initializer$d();
          this._interactable = _initializer2$d && _initializer2$d();
          this._transition = _initializer3$b && _initializer3$b();
          this._normalColor = _initializer4$a && _initializer4$a();
          this._hoverColor = _initializer5$8 && _initializer5$8();
          this._pressedColor = _initializer6$5 && _initializer6$5();
          this._disabledColor = _initializer7$5 && _initializer7$5();
          this._normalSprite = _initializer8$5 && _initializer8$5();
          this._hoverSprite = _initializer9$5 && _initializer9$5();
          this._pressedSprite = _initializer10$5 && _initializer10$5();
          this._disabledSprite = _initializer11$5 && _initializer11$5();
          this._duration = _initializer12$4 && _initializer12$4();
          this._zoomScale = _initializer13$3 && _initializer13$3();
          this._target = _initializer14$2 && _initializer14$2();
          this._pressed = false;
          this._hovered = false;
          this._fromColor = new Color$1();
          this._toColor = new Color$1();
          this._time = 0;
          this._transitionFinished = true;
          this._fromScale = new Vec3();
          this._toScale = new Vec3();
          this._originalScale = null;
          this._sprite = null;
          this._targetScale = new Vec3();
        }
        get target() {
          return this._target || this.node;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          if (this._target) {
            this._unregisterTargetEvent(this._target);
          }
          this._target = value;
          this._applyTarget();
        }
        get interactable() {
          return this._interactable;
        }
        set interactable(value) {
          if (this._interactable === value) {
            return;
          }
          this._interactable = value;
          this._updateState();
          if (!this._interactable) {
            this._resetState();
          }
        }
        set _resizeToTarget(value) {
          if (value) {
            this._resizeNodeToTargetNode();
          }
        }
        get transition() {
          return this._transition;
        }
        set transition(value) {
          if (this._transition === value) {
            return;
          }
          if (this._transition === Transition.COLOR) {
            this._updateColorTransition(State.NORMAL);
          } else if (this._transition === Transition.SPRITE) {
            this._updateSpriteTransition(State.NORMAL);
          }
          this._transition = value;
          this._updateState();
        }
        get normalColor() {
          return this._normalColor;
        }
        set normalColor(value) {
          if (this._normalColor === value) {
            return;
          }
          this._normalColor.set(value);
          this._updateState();
        }
        get pressedColor() {
          return this._pressedColor;
        }
        set pressedColor(value) {
          if (this._pressedColor === value) {
            return;
          }
          this._pressedColor.set(value);
        }
        get hoverColor() {
          return this._hoverColor;
        }
        set hoverColor(value) {
          if (this._hoverColor === value) {
            return;
          }
          this._hoverColor.set(value);
        }
        get disabledColor() {
          return this._disabledColor;
        }
        set disabledColor(value) {
          if (this._disabledColor === value) {
            return;
          }
          this._disabledColor.set(value);
          this._updateState();
        }
        get duration() {
          return this._duration;
        }
        set duration(value) {
          if (this._duration === value) {
            return;
          }
          this._duration = value;
        }
        get zoomScale() {
          return this._zoomScale;
        }
        set zoomScale(value) {
          if (this._zoomScale === value) {
            return;
          }
          this._zoomScale = value;
        }
        get normalSprite() {
          return this._normalSprite;
        }
        set normalSprite(value) {
          if (this._normalSprite === value) {
            return;
          }
          this._normalSprite = value;
          const sprite = this.node.getComponent(Sprite);
          if (sprite) {
            sprite.spriteFrame = value;
          }
          this._updateState();
        }
        get pressedSprite() {
          return this._pressedSprite;
        }
        set pressedSprite(value) {
          if (this._pressedSprite === value) {
            return;
          }
          this._pressedSprite = value;
          this._updateState();
        }
        get hoverSprite() {
          return this._hoverSprite;
        }
        set hoverSprite(value) {
          if (this._hoverSprite === value) {
            return;
          }
          this._hoverSprite = value;
          this._updateState();
        }
        get disabledSprite() {
          return this._disabledSprite;
        }
        set disabledSprite(value) {
          if (this._disabledSprite === value) {
            return;
          }
          this._disabledSprite = value;
          this._updateState();
        }
        __preload() {
          if (!this.target) {
            this.target = this.node;
          }
          this._applyTarget();
          this._resetState();
        }
        onEnable() {
          {
            this._registerNodeEvent();
          }
        }
        onDisable() {
          this._resetState();
          {
            this._unregisterNodeEvent();
          }
        }
        onDestroy() {
          if (this.target.isValid) {
            this._unregisterTargetEvent(this.target);
          }
        }
        update(dt) {
          const target = this.target;
          if (this._transitionFinished || !target) {
            return;
          }
          if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
            return;
          }
          this._time += dt;
          let ratio = 1.0;
          if (this._duration > 0) {
            ratio = this._time / this._duration;
          }
          if (ratio >= 1) {
            ratio = 1;
          }
          if (this._transition === Transition.COLOR) {
            const renderComp = target._uiProps.uiComp;
            Color$1.lerp(_tempColor$1, this._fromColor, this._toColor, ratio);
            if (renderComp) {
              renderComp.color = _tempColor$1;
            }
          } else if (this.transition === Transition.SCALE) {
            target.getScale(this._targetScale);
            this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
            this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
            target.setScale(this._targetScale);
          }
          if (ratio === 1) {
            this._transitionFinished = true;
          }
        }
        _resizeNodeToTargetNode() {
          if (!this.target) {
            return;
          }
          this.target._uiProps.uiTransformComp;
        }
        _resetState() {
          this._pressed = false;
          this._hovered = false;
          const target = this.target;
          if (!target) {
            return;
          }
          const transition = this._transition;
          if (transition === Transition.COLOR && this._interactable) {
            const renderComp = target.getComponent(UIRenderer);
            if (renderComp) {
              renderComp.color = this._normalColor;
            }
          } else if (transition === Transition.SCALE && this._originalScale) {
            target.setScale(this._originalScale);
          }
          this._transitionFinished = true;
        }
        _registerNodeEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        }
        _registerTargetEvent(target) {
          target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
        }
        _unregisterNodeEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
        }
        _unregisterTargetEvent(target) {
          target.off(NodeEventType.TRANSFORM_CHANGED);
        }
        _getTargetSprite(target) {
          let sprite = null;
          if (target) {
            sprite = target.getComponent(Sprite);
          }
          return sprite;
        }
        _applyTarget() {
          if (this.target) {
            this._sprite = this._getTargetSprite(this.target);
            if (!this._originalScale) {
              this._originalScale = new Vec3();
            }
            Vec3.copy(this._originalScale, this.target.getScale());
            this._registerTargetEvent(this.target);
          }
        }
        _onTargetSpriteFrameChanged(comp) {
          if (this._transition === Transition.SPRITE) {
            this._setCurrentStateSpriteFrame(comp.spriteFrame);
          }
        }
        _setCurrentStateSpriteFrame(spriteFrame) {
          if (!spriteFrame) {
            return;
          }
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalSprite = spriteFrame;
              break;
            case State.HOVER:
              this._hoverSprite = spriteFrame;
              break;
            case State.PRESSED:
              this._pressedSprite = spriteFrame;
              break;
            case State.DISABLED:
              this._disabledSprite = spriteFrame;
              break;
          }
        }
        _onTargetColorChanged(color) {
          if (this._transition === Transition.COLOR) {
            this._setCurrentStateColor(color);
          }
        }
        _setCurrentStateColor(color) {
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalColor = color;
              break;
            case State.HOVER:
              this._hoverColor = color;
              break;
            case State.PRESSED:
              this._pressedColor = color;
              break;
            case State.DISABLED:
              this._disabledColor = color;
              break;
          }
        }
        _onTargetTransformChanged(transformBit) {
          if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
            Vec3.copy(this._originalScale, this.target.getScale());
          }
        }
        _onTouchBegan(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = true;
          this._updateState();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchMove(event) {
          if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
            return;
          }
          if (!event) {
            return;
          }
          const touch = event.touch;
          if (!touch) {
            return;
          }
          const hit = this.node._uiProps.uiTransformComp.hitTest(touch.getLocation(), event.windowId);
          if (this._transition === Transition.SCALE && this.target && this._originalScale) {
            if (hit) {
              Vec3.copy(this._fromScale, this._originalScale);
              Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
              this._transitionFinished = false;
            } else {
              this._time = 0;
              this._transitionFinished = true;
              this.target.setScale(this._originalScale);
            }
          } else {
            let state;
            if (hit) {
              state = State.PRESSED;
            } else {
              state = State.NORMAL;
            }
            this._applyTransition(state);
          }
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchEnded(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, event);
            this.node.emit(EventType$4.CLICK, this);
          }
          this._pressed = false;
          this._updateState();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchCancel(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = false;
          this._updateState();
        }
        _onMouseMoveIn(event) {
          if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._transition === Transition.SPRITE && !this._hoverSprite) {
            return;
          }
          if (!this._hovered) {
            this._hovered = true;
            this._updateState();
          }
        }
        _onMouseMoveOut(event) {
          if (this._hovered) {
            this._hovered = false;
            this._updateState();
          }
        }
        _updateState() {
          const state = this._getButtonState();
          this._applyTransition(state);
        }
        _getButtonState() {
          let state = State.NORMAL;
          if (!this._interactable) {
            state = State.DISABLED;
          } else if (this._pressed) {
            state = State.PRESSED;
          } else if (this._hovered) {
            state = State.HOVER;
          }
          return state.toString();
        }
        _updateColorTransition(state) {
          var _this$target;
          const color = this[`${state}Color`];
          const renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(UIRenderer);
          if (!renderComp) {
            return;
          }
          if (state === State.DISABLED.toString()) {
            renderComp.color = color;
          } else {
            this._fromColor = renderComp.color.clone();
            this._toColor = color;
            this._time = 0;
            this._transitionFinished = false;
          }
        }
        _updateSpriteTransition(state) {
          const sprite = this[`${state}Sprite`];
          if (this._sprite && sprite) {
            this._sprite.spriteFrame = sprite;
          }
        }
        _updateScaleTransition(state) {
          if (!this._interactable) {
            return;
          }
          if (state === State.PRESSED.toString()) {
            this._zoomUp();
          } else {
            this._zoomBack();
          }
        }
        _zoomUp() {
          if (!this._originalScale) {
            return;
          }
          Vec3.copy(this._fromScale, this._originalScale);
          Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
          this._time = 0;
          this._transitionFinished = false;
        }
        _zoomBack() {
          if (!this.target || !this._originalScale) {
            return;
          }
          Vec3.copy(this._fromScale, this.target.getScale());
          Vec3.copy(this._toScale, this._originalScale);
          this._time = 0;
          this._transitionFinished = false;
        }
        _applyTransition(state) {
          const transition = this._transition;
          if (transition === Transition.COLOR) {
            this._updateColorTransition(state);
          } else if (transition === Transition.SPRITE) {
            this._updateSpriteTransition(state);
          } else if (transition === Transition.SCALE) {
            this._updateScaleTransition(state);
          }
        }
        _xrHoverEnter() {
          this._onMouseMoveIn();
          this._updateState();
        }
        _xrHoverExit() {
          this._onMouseMoveOut();
          if (this._pressed) {
            this._pressed = false;
            this._updateState();
          }
        }
        _xrClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          this._pressed = true;
          this._updateState();
        }
        _xrUnClick() {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }
          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, this);
            this.node.emit(EventType$4.CLICK, this);
          }
          this._pressed = false;
          this._updateState();
        }
      }, _class3$a.Transition = Transition, _class3$a.EventType = EventType$4, _class3$a), (_applyDecoratedDescriptor(_class2$d.prototype, "target", [_dec4$b], Object.getOwnPropertyDescriptor(_class2$d.prototype, "target"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "transition", [_dec5$b], Object.getOwnPropertyDescriptor(_class2$d.prototype, "transition"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "normalSprite", [_dec6$5], Object.getOwnPropertyDescriptor(_class2$d.prototype, "normalSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "pressedSprite", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$d.prototype, "pressedSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "hoverSprite", [_dec8$3], Object.getOwnPropertyDescriptor(_class2$d.prototype, "hoverSprite"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "disabledSprite", [_dec9$3], Object.getOwnPropertyDescriptor(_class2$d.prototype, "disabledSprite"), _class2$d.prototype), _initializer$d = applyDecoratedInitializer(_class2$d.prototype, "clickEvents", [_dec10$1, serializable$6], function () {
        return [];
      }), _initializer2$d = applyDecoratedInitializer(_class2$d.prototype, "_interactable", [serializable$6], function () {
        return true;
      }), _initializer3$b = applyDecoratedInitializer(_class2$d.prototype, "_transition", [serializable$6], function () {
        return Transition.NONE;
      }), _initializer4$a = applyDecoratedInitializer(_class2$d.prototype, "_normalColor", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer5$8 = applyDecoratedInitializer(_class2$d.prototype, "_hoverColor", [serializable$6], function () {
        return new Color$1(211, 211, 211, 255);
      }), _initializer6$5 = applyDecoratedInitializer(_class2$d.prototype, "_pressedColor", [serializable$6], function () {
        return Color$1.WHITE.clone();
      }), _initializer7$5 = applyDecoratedInitializer(_class2$d.prototype, "_disabledColor", [serializable$6], function () {
        return new Color$1(124, 124, 124, 255);
      }), _initializer8$5 = applyDecoratedInitializer(_class2$d.prototype, "_normalSprite", [serializable$6], function () {
        return null;
      }), _initializer9$5 = applyDecoratedInitializer(_class2$d.prototype, "_hoverSprite", [serializable$6], function () {
        return null;
      }), _initializer10$5 = applyDecoratedInitializer(_class2$d.prototype, "_pressedSprite", [serializable$6], function () {
        return null;
      }), _initializer11$5 = applyDecoratedInitializer(_class2$d.prototype, "_disabledSprite", [serializable$6], function () {
        return null;
      }), _initializer12$4 = applyDecoratedInitializer(_class2$d.prototype, "_duration", [serializable$6], function () {
        return 0.1;
      }), _initializer13$3 = applyDecoratedInitializer(_class2$d.prototype, "_zoomScale", [serializable$6], function () {
        return 1.2;
      }), _initializer14$2 = applyDecoratedInitializer(_class2$d.prototype, "_target", [serializable$6], function () {
        return null;
      })), _class2$d)) || _class$h) || _class$h) || _class$h); exports({ Button: Button, ButtonComponent: Button });
      legacyCC.Button = Button;

      class tabIndexUtil {
        static add(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          if (index === -1) {
            list.push(editBoxImpl);
          }
        }
        static remove(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          if (index !== -1) {
            list.splice(index, 1);
          }
        }
        static resort() {
          this._tabIndexList.sort((a, b) => a._delegate.tabIndex - b._delegate.tabIndex);
        }
        static next(editBoxImpl) {
          const list = this._tabIndexList;
          const index = list.indexOf(editBoxImpl);
          editBoxImpl.setFocus(false);
          if (index !== -1) {
            const nextImpl = list[index + 1];
            if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
              nextImpl.setFocus(true);
            }
          }
        }
      }
      tabIndexUtil._tabIndexList = [];

      let KeyboardReturnType;
      (function (KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
        KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
        KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
        KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
        KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
        KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
      })(KeyboardReturnType || (KeyboardReturnType = {}));
      Enum(KeyboardReturnType);
      let InputMode;
      (function (InputMode) {
        InputMode[InputMode["ANY"] = 0] = "ANY";
        InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
        InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
        InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
        InputMode[InputMode["URL"] = 4] = "URL";
        InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
        InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
      })(InputMode || (InputMode = {}));
      Enum(InputMode);
      let InputFlag;
      (function (InputFlag) {
        InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
        InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
        InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
        InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
        InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
        InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
      })(InputFlag || (InputFlag = {}));
      Enum(InputFlag);

      class EditBoxImplBase {
        constructor() {
          this._editing = false;
          this._delegate = null;
        }
        init(delegate) {}
        onEnable() {}
        beforeDraw() {}
        onDisable() {
          if (this._editing) {
            this.endEditing();
          }
        }
        clear() {
          this._delegate = null;
        }
        setTabIndex(index) {}
        setSize(width, height) {}
        setFocus(value) {
          if (value) {
            this.beginEditing();
          } else {
            this.endEditing();
          }
        }
        isFocused() {
          return this._editing;
        }
        beginEditing() {}
        endEditing() {}
      }

      const ccdocument = ccwindow$1.document;
      const SCROLLY = 40;
      const LEFT_PADDING$1 = 2;
      const DELAY_TIME = 400;
      const _matrix = new Mat4();
      const _matrix_temp = new Mat4();
      const _vec3 = new Vec3();
      let _currentEditBoxImpl = null;
      let _domCount = 0;
      class EditBoxImpl extends EditBoxImplBase {
        constructor(...args) {
          super(...args);
          this._delegate = null;
          this._inputMode = -1;
          this._inputFlag = -1;
          this._returnType = -1;
          this.__eventListeners = {};
          this.__autoResize = false;
          this.__orientationChanged = void 0;
          this._edTxt = null;
          this._isTextArea = false;
          this._textLabelFont = null;
          this._textLabelFontSize = null;
          this._textLabelFontColor = null;
          this._textLabelAlign = null;
          this._placeholderLabelFont = null;
          this._placeholderLabelFontSize = null;
          this._placeholderLabelFontColor = null;
          this._placeholderLabelAlign = null;
          this._placeholderLineHeight = null;
          this._placeholderStyleSheet = null;
          this._domId = `EditBoxId_${++_domCount}`;
          this._forceUpdate = false;
        }
        init(delegate) {
          if (!delegate) {
            return;
          }
          this._delegate = delegate;
          if (delegate.inputMode === InputMode.ANY) {
            this._createTextArea();
          } else {
            this._createInput();
          }
          tabIndexUtil.add(this);
          this.setTabIndex(delegate.tabIndex);
          this._initStyleSheet();
          this._registerEventListeners();
          this._addDomToGameContainer();
          View.instance.on('canvas-resize', this._resize, this);
          screenAdapter.on('window-resize', this._resize, this);
        }
        clear() {
          View.instance.off('canvas-resize', this._resize, this);
          screenAdapter.off('window-resize', this._resize, this);
          this._removeEventListeners();
          this._removeDomFromGameContainer();
          tabIndexUtil.remove(this);
          if (_currentEditBoxImpl === this) {
            _currentEditBoxImpl = null;
          }
          this._delegate = null;
        }
        _resize() {
          this._forceUpdate = true;
        }
        beforeDraw() {
          const node = this._delegate.node;
          if (!node.hasChangedFlags && !this._forceUpdate) {
            return;
          }
          this._forceUpdate = false;
          this._updateMatrix();
        }
        setTabIndex(index) {
          this._edTxt.tabIndex = index;
          tabIndexUtil.resort();
        }
        setSize(width, height) {
          const elem = this._edTxt;
          if (elem) {
            elem.style.width = `${width}px`;
            elem.style.height = `${height}px`;
          }
        }
        beginEditing() {
          if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
            _currentEditBoxImpl.setFocus(false);
          }
          this._editing = true;
          _currentEditBoxImpl = this;
          this._delegate._editBoxEditingDidBegan();
          this._showDom();
          this._edTxt.focus();
        }
        endEditing() {
          this._edTxt.blur();
        }
        _createInput() {
          this._isTextArea = false;
          this._edTxt = ccdocument.createElement('input');
        }
        _createTextArea() {
          this._isTextArea = true;
          this._edTxt = ccdocument.createElement('textarea');
        }
        _addDomToGameContainer() {
          if (game.container && this._edTxt) {
            game.container.appendChild(this._edTxt);
            ccdocument.head.appendChild(this._placeholderStyleSheet);
          }
        }
        _removeDomFromGameContainer() {
          const hasElem = contains$1(game.container, this._edTxt);
          if (hasElem && this._edTxt) {
            game.container.removeChild(this._edTxt);
          }
          const hasStyleSheet = contains$1(ccdocument.head, this._placeholderStyleSheet);
          if (hasStyleSheet) {
            ccdocument.head.removeChild(this._placeholderStyleSheet);
          }
          this._edTxt = null;
          this._placeholderStyleSheet = null;
        }
        _showDom() {
          this._updateMaxLength();
          this._updateInputType();
          this._updateStyleSheet();
          if (this._edTxt && this._delegate) {
            this._edTxt.style.display = '';
            this._delegate._hideLabels();
          }
          if (sys.isMobile) {
            this._showDomOnMobile();
          }
        }
        _hideDom() {
          const elem = this._edTxt;
          if (elem && this._delegate) {
            elem.style.display = 'none';
            this._delegate._showLabels();
          }
          if (sys.isMobile) {
            this._hideDomOnMobile();
          }
        }
        _showDomOnMobile() {
          if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
            return;
          }
          screenAdapter.handleResizeEvent = false;
          this._adjustWindowScroll();
        }
        _hideDomOnMobile() {
          if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
            screenAdapter.handleResizeEvent = true;
          }
          this._scrollBackWindow();
        }
        _isElementInViewport() {
          if (this._edTxt) {
            const rect = this._edTxt.getBoundingClientRect();
            return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (ccwindow$1.innerHeight || ccdocument.documentElement.clientHeight) && rect.right <= (ccwindow$1.innerWidth || ccdocument.documentElement.clientWidth);
          }
          return false;
        }
        _adjustWindowScroll() {
          setTimeout(() => {
            if (ccwindow$1.scrollY < SCROLLY && !this._isElementInViewport()) {
              this._edTxt.scrollIntoView({
                block: 'start',
                inline: 'nearest',
                behavior: 'smooth'
              });
            }
          }, DELAY_TIME);
        }
        _scrollBackWindow() {
          setTimeout(() => {
            if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
              if (ccwindow$1.top) {
                ccwindow$1.top.scrollTo(0, 0);
              }
              return;
            }
            ccwindow$1.scrollTo(0, 0);
          }, DELAY_TIME);
        }
        _updateMatrix() {
          if (!this._edTxt) {
            return;
          }
          const node = this._delegate.node;
          let scaleX = view.getScaleX();
          let scaleY = view.getScaleY();
          const viewport = view.getViewportRect();
          const dpr = screenAdapter.devicePixelRatio;
          node.getWorldMatrix(_matrix);
          const transform = node._uiProps.uiTransformComp;
          if (transform) {
            Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
            Mat4.transform(_matrix, _matrix, _vec3);
          }
          if (!node._uiProps.uiTransformComp) {
            return;
          }
          const camera = director.root.batcher2D.getFirstRenderCamera(node);
          if (!camera) return;
          camera.node.getWorldRT(_matrix_temp);
          const m12 = _matrix_temp.m12;
          const m13 = _matrix_temp.m13;
          const center = visibleRect.center;
          _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
          _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
          scaleX /= dpr;
          scaleY /= dpr;
          Vec3.set(_vec3, scaleX, scaleY, 1);
          Mat4.scale(_matrix_temp, _matrix_temp, _vec3);
          const container = game.container;
          let offsetX = parseInt(container && container.style.paddingLeft || '0');
          offsetX += viewport.x / dpr;
          let offsetY = parseInt(container && container.style.paddingBottom || '0');
          offsetY += viewport.y / dpr;
          _matrix_temp.m12 += offsetX;
          _matrix_temp.m13 += offsetY;
          Mat4.multiply(_matrix_temp, _matrix_temp, _matrix);
          const a = _matrix_temp.m00;
          const b = _matrix_temp.m01;
          const c = _matrix_temp.m04;
          const d = _matrix_temp.m05;
          const tx = _matrix_temp.m12;
          const ty = _matrix_temp.m13;
          const matrix = `matrix(${a},${-b},${-c},${d},${tx},${-ty})`;
          this._edTxt.style.transform = matrix;
          this._edTxt.style['-webkit-transform'] = matrix;
          this._edTxt.style['transform-origin'] = '0px 100% 0px';
          this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
        }
        _updateInputType() {
          const delegate = this._delegate;
          const inputMode = delegate.inputMode;
          const inputFlag = delegate.inputFlag;
          const returnType = delegate.returnType;
          let elem = this._edTxt;
          if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
            return;
          }
          this._inputMode = inputMode;
          this._inputFlag = inputFlag;
          this._returnType = returnType;
          if (this._isTextArea) {
            let transform = 'none';
            if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
              transform = 'uppercase';
            } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
              transform = 'capitalize';
            }
            elem.style.textTransform = transform;
            return;
          }
          elem = elem;
          if (inputFlag === InputFlag.PASSWORD) {
            elem.type = 'password';
            elem.style.textTransform = 'none';
            return;
          }
          let type = elem.type;
          if (inputMode === InputMode.EMAIL_ADDR) {
            type = 'email';
          } else if (inputMode === InputMode.NUMERIC) {
            type = 'number';
          } else if (inputMode === InputMode.DECIMAL) {
            type = 'digit';
          } else if (inputMode === InputMode.PHONE_NUMBER) {
            type = 'tel';
            elem.addEventListener('wheel', () => false);
          } else if (inputMode === InputMode.URL) {
            type = 'url';
          } else {
            type = 'text';
            if (returnType === KeyboardReturnType.SEARCH) {
              type = 'search';
            }
          }
          elem.type = type;
          let textTransform = 'none';
          if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            textTransform = 'uppercase';
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            textTransform = 'capitalize';
          }
          elem.style.textTransform = textTransform;
        }
        _updateMaxLength() {
          let maxLength = this._delegate.maxLength;
          if (maxLength < 0) {
            maxLength = 65535;
          }
          this._edTxt.maxLength = maxLength;
        }
        _initStyleSheet() {
          if (!this._edTxt) {
            return;
          }
          let elem = this._edTxt;
          elem.style.color = '#000000';
          elem.style.border = '0px';
          elem.style.background = 'transparent';
          elem.style.width = '100%';
          elem.style.height = '100%';
          elem.style.outline = 'medium';
          elem.style.padding = '0';
          elem.style.textTransform = 'none';
          elem.style.display = 'none';
          elem.style.position = 'absolute';
          elem.style.bottom = '0px';
          elem.style.left = `${LEFT_PADDING$1}px`;
          elem.className = 'cocosEditBox';
          elem.style.fontFamily = 'Arial';
          elem.id = this._domId;
          if (!this._isTextArea) {
            elem = elem;
            elem.type = 'text';
            elem.style['-moz-appearance'] = 'textfield';
          } else {
            elem.style.resize = 'none';
            elem.style.overflowY = 'scroll';
          }
          this._placeholderStyleSheet = ccdocument.createElement('style');
        }
        _updateStyleSheet() {
          const delegate = this._delegate;
          const elem = this._edTxt;
          if (elem && delegate) {
            elem.value = delegate.string;
            this._updateTextLabel(delegate.textLabel);
          }
        }
        _updateTextLabel(textLabel) {
          if (!textLabel) {
            return;
          }
          let font = textLabel.font;
          if (font && !(font instanceof BitmapFont)) {
            font = font._fontFamily;
          } else {
            font = textLabel.fontFamily;
          }
          const fontSize = textLabel.fontSize * textLabel.node.scale.y;
          if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
            return;
          }
          this._textLabelFont = font;
          this._textLabelFontSize = fontSize;
          this._textLabelFontColor = textLabel.fontColor;
          this._textLabelAlign = textLabel.horizontalAlign;
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          elem.style.fontSize = `${fontSize}px`;
          elem.style.color = textLabel.color.toCSS();
          elem.style.fontFamily = font;
          switch (textLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              elem.style.textAlign = 'left';
              break;
            case Label.HorizontalAlign.CENTER:
              elem.style.textAlign = 'center';
              break;
            case Label.HorizontalAlign.RIGHT:
              elem.style.textAlign = 'right';
              break;
          }
        }
        _updatePlaceholderLabel(placeholderLabel) {
          if (!placeholderLabel) {
            return;
          }
          let font = placeholderLabel.font;
          if (font && !(font instanceof BitmapFont)) {
            font = placeholderLabel.font._fontFamily;
          } else {
            font = placeholderLabel.fontFamily;
          }
          const fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;
          if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
            return;
          }
          this._placeholderLabelFont = font;
          this._placeholderLabelFontSize = fontSize;
          this._placeholderLabelFontColor = placeholderLabel.fontColor;
          this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
          this._placeholderLineHeight = placeholderLabel.fontSize;
          const styleEl = this._placeholderStyleSheet;
          const fontColor = placeholderLabel.color.toCSS();
          const lineHeight = placeholderLabel.fontSize;
          let horizontalAlign = '';
          switch (placeholderLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              horizontalAlign = 'left';
              break;
            case Label.HorizontalAlign.CENTER:
              horizontalAlign = 'center';
              break;
            case Label.HorizontalAlign.RIGHT:
              horizontalAlign = 'right';
              break;
          }
          styleEl.innerHTML = `#${this._domId}::-webkit-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-moz-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-ms-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}`;
          if (sys.browserType === BrowserType.EDGE) {
            styleEl.innerHTML += `#${this._domId}::-ms-clear{display: none;}`;
          }
        }
        _registerEventListeners() {
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          let inputLock = false;
          const cbs = this.__eventListeners;
          cbs.compositionStart = () => {
            inputLock = true;
          };
          cbs.compositionEnd = () => {
            inputLock = false;
            this._delegate._editBoxTextChanged(elem.value);
          };
          cbs.onInput = () => {
            if (inputLock) {
              return;
            }
            const delegate = this._delegate;
            const maxLength = delegate.maxLength;
            if (maxLength >= 0) {
              elem.value = elem.value.slice(0, maxLength);
            }
            delegate._editBoxTextChanged(elem.value);
          };
          cbs.onClick = () => {
            if (this._editing) {
              if (sys.isMobile) {
                this._adjustWindowScroll();
              }
            }
          };
          cbs.onKeydown = e => {
            if (e.keyCode === KeyCode.ENTER) {
              e.propagationStopped = true;
              this._delegate._editBoxEditingReturn();
              if (!this._isTextArea) {
                elem.blur();
              }
            } else if (e.keyCode === KeyCode.TAB) {
              e.propagationStopped = true;
              e.preventDefault();
              tabIndexUtil.next(this);
            }
          };
          cbs.onBlur = () => {
            if (sys.isMobile && inputLock) {
              cbs.compositionEnd();
            }
            this._editing = false;
            _currentEditBoxImpl = null;
            this._hideDom();
            this._delegate._editBoxEditingDidEnded();
          };
          elem.addEventListener('compositionstart', cbs.compositionStart);
          elem.addEventListener('compositionend', cbs.compositionEnd);
          elem.addEventListener('input', cbs.onInput);
          elem.addEventListener('keydown', cbs.onKeydown);
          elem.addEventListener('blur', cbs.onBlur);
          elem.addEventListener('touchstart', cbs.onClick);
        }
        _removeEventListeners() {
          if (!this._edTxt) {
            return;
          }
          const elem = this._edTxt;
          const cbs = this.__eventListeners;
          elem.removeEventListener('compositionstart', cbs.compositionStart);
          elem.removeEventListener('compositionend', cbs.compositionEnd);
          elem.removeEventListener('input', cbs.onInput);
          elem.removeEventListener('keydown', cbs.onKeydown);
          elem.removeEventListener('blur', cbs.onBlur);
          elem.removeEventListener('touchstart', cbs.onClick);
          cbs.compositionStart = null;
          cbs.compositionEnd = null;
          cbs.onInput = null;
          cbs.onKeydown = null;
          cbs.onBlur = null;
          cbs.onClick = null;
        }
      }

      var _dec$g, _dec2$e, _dec3$d, _dec4$a, _dec5$a, _dec6$4, _dec7$3, _dec8$2, _dec9$2, _dec10, _dec11, _dec12, _dec13, _class$g, _class2$c, _initializer$c, _initializer2$c, _initializer3$a, _initializer4$9, _initializer5$7, _initializer6$4, _initializer7$4, _initializer8$4, _initializer9$4, _initializer10$4, _initializer11$4, _initializer12$3, _initializer13$2, _class3$9;
      const LEFT_PADDING = 2;
      function capitalize(str) {
        return str.replace(/(?:^|\s)\S/g, a => a.toUpperCase());
      }
      function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      var EventType$3;
      (function (EventType) {
        EventType["EDITING_DID_BEGAN"] = "editing-did-began";
        EventType["EDITING_DID_ENDED"] = "editing-did-ended";
        EventType["TEXT_CHANGED"] = "text-changed";
        EventType["EDITING_RETURN"] = "editing-return";
        EventType["XR_EDITING_DID_BEGAN"] = "xr-editing-did-began";
        EventType["XR_EDITING_DID_ENDED"] = "xr-editing-did-ended";
      })(EventType$3 || (EventType$3 = {}));
      let EditBox = (_dec$g = ccclass$6('cc.EditBox'), _dec2$e = executionOrder$1(110), _dec3$d = requireComponent(UITransform), _dec4$a = type$6(Label), _dec5$a = type$6(Label), _dec6$4 = type$6(SpriteFrame), _dec7$3 = type$6(InputFlag), _dec8$2 = type$6(InputMode), _dec9$2 = type$6(KeyboardReturnType), _dec10 = type$6([EventHandler]), _dec11 = type$6([EventHandler]), _dec12 = type$6([EventHandler]), _dec13 = type$6([EventHandler]), _dec$g(_class$g = _dec2$e(_class$g = _dec3$d(_class$g = (_class2$c = (_class3$9 = class EditBox extends Component {
        constructor(...args) {
          super(...args);
          this.editingDidBegan = _initializer$c && _initializer$c();
          this.textChanged = _initializer2$c && _initializer2$c();
          this.editingDidEnded = _initializer3$a && _initializer3$a();
          this.editingReturn = _initializer4$9 && _initializer4$9();
          this._impl = null;
          this._background = null;
          this._textLabel = _initializer5$7 && _initializer5$7();
          this._placeholderLabel = _initializer6$4 && _initializer6$4();
          this._returnType = _initializer7$4 && _initializer7$4();
          this._string = _initializer8$4 && _initializer8$4();
          this._tabIndex = _initializer9$4 && _initializer9$4();
          this._backgroundImage = _initializer10$4 && _initializer10$4();
          this._inputFlag = _initializer11$4 && _initializer11$4();
          this._inputMode = _initializer12$3 && _initializer12$3();
          this._maxLength = _initializer13$2 && _initializer13$2();
          this._isLabelVisible = false;
        }
        get string() {
          return this._string;
        }
        set string(value) {
          if (this._maxLength >= 0 && value.length >= this._maxLength) {
            value = value.slice(0, this._maxLength);
          }
          if (this._string === value) {
            return;
          }
          this._string = value;
          this._updateString(value);
        }
        get placeholder() {
          if (!this._placeholderLabel) {
            return '';
          }
          return this._placeholderLabel.string;
        }
        set placeholder(value) {
          if (this._placeholderLabel) {
            this._placeholderLabel.string = value;
          }
        }
        get textLabel() {
          return this._textLabel;
        }
        set textLabel(oldValue) {
          if (this._textLabel !== oldValue) {
            this._textLabel = oldValue;
            if (this._textLabel) {
              this._updateTextLabel();
              this._updateLabels();
            }
          }
        }
        get placeholderLabel() {
          return this._placeholderLabel;
        }
        set placeholderLabel(oldValue) {
          if (this._placeholderLabel !== oldValue) {
            this._placeholderLabel = oldValue;
            if (this._placeholderLabel) {
              this._updatePlaceholderLabel();
              this._updateLabels();
            }
          }
        }
        get backgroundImage() {
          return this._backgroundImage;
        }
        set backgroundImage(value) {
          if (this._backgroundImage === value) {
            return;
          }
          this._backgroundImage = value;
          this._ensureBackgroundSprite();
          this._background.spriteFrame = value;
        }
        get inputFlag() {
          return this._inputFlag;
        }
        set inputFlag(value) {
          if (this._inputFlag === value) {
            return;
          }
          this._inputFlag = value;
          this._updateString(this._string);
        }
        get inputMode() {
          return this._inputMode;
        }
        set inputMode(oldValue) {
          if (this._inputMode !== oldValue) {
            this._inputMode = oldValue;
            this._updateTextLabel();
            this._updatePlaceholderLabel();
          }
        }
        get returnType() {
          return this._returnType;
        }
        set returnType(value) {
          this._returnType = value;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(value) {
          this._maxLength = value;
        }
        get tabIndex() {
          return this._tabIndex;
        }
        set tabIndex(value) {
          if (this._tabIndex !== value) {
            this._tabIndex = value;
            if (this._impl) {
              this._impl.setTabIndex(value);
            }
          }
        }
        __preload() {
          this._init();
        }
        onEnable() {
          {
            this._registerEvent();
          }
          this._ensureBackgroundSprite();
          if (this._impl) {
            this._impl.onEnable();
          }
        }
        _beforeDraw() {
          if (this._impl) {
            this._impl.beforeDraw();
          }
        }
        onDisable() {
          {
            this._unregisterEvent();
          }
          this._unregisterBackgroundEvent();
          if (this._impl) {
            this._impl.onDisable();
          }
        }
        onDestroy() {
          director.off(Director.EVENT_BEFORE_DRAW, this._beforeDraw, this);
          if (this._impl) {
            this._impl.clear();
          }
        }
        setFocus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        }
        focus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        }
        blur() {
          if (this._impl) {
            this._impl.setFocus(false);
          }
        }
        isFocused() {
          if (this._impl) {
            return this._impl.isFocused();
          }
          return false;
        }
        _editBoxEditingDidBegan() {
          EventHandler.emitEvents(this.editingDidBegan, this);
          this.node.emit(EventType$3.EDITING_DID_BEGAN, this);
        }
        _editBoxEditingDidEnded(text) {
          EventHandler.emitEvents(this.editingDidEnded, this);
          this.node.emit(EventType$3.EDITING_DID_ENDED, this, text);
        }
        _editBoxTextChanged(text) {
          text = this._updateLabelStringStyle(text, true);
          this.string = text;
          EventHandler.emitEvents(this.textChanged, text, this);
          this.node.emit(EventType$3.TEXT_CHANGED, this);
        }
        _editBoxEditingReturn(text) {
          EventHandler.emitEvents(this.editingReturn, this);
          this.node.emit(EventType$3.EDITING_RETURN, this, text);
        }
        _showLabels() {
          this._isLabelVisible = true;
          this._updateLabels();
        }
        _hideLabels() {
          this._isLabelVisible = false;
          if (this._textLabel) {
            this._textLabel.node.active = false;
          }
          if (this._placeholderLabel) {
            this._placeholderLabel.node.active = false;
          }
        }
        _onTouchBegan(event) {
          event.propagationStopped = true;
        }
        _onTouchCancel(event) {
          event.propagationStopped = true;
        }
        _onTouchEnded(event) {
          if (this._impl) {
            this._impl.beginEditing();
          }
          event.propagationStopped = true;
        }
        _init() {
          this._updatePlaceholderLabel();
          this._updateTextLabel();
          this._isLabelVisible = true;
          this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
          director.on(Director.EVENT_BEFORE_DRAW, this._beforeDraw, this);
          const impl = this._impl = new EditBox._EditBoxImpl();
          impl.init(this);
          this._updateString(this._string);
          this._syncSize();
        }
        _ensureBackgroundSprite() {
          if (!this._background) {
            let background = this.node.getComponent(Sprite);
            if (!background) {
              background = this.node.addComponent(Sprite);
            }
            if (background !== this._background) {
              background.type = Sprite.Type.SLICED;
              background.spriteFrame = this._backgroundImage;
              this._background = background;
              this._registerBackgroundEvent();
            }
          }
        }
        _updateTextLabel() {
          let textLabel = this._textLabel;
          if (!textLabel) {
            let node = this.node.getChildByName('TEXT_LABEL');
            if (!node) {
              node = new Node$1('TEXT_LABEL');
              node.layer = this.node.layer;
            }
            textLabel = node.getComponent(Label);
            if (!textLabel) {
              textLabel = node.addComponent(Label);
            }
            node.parent = this.node;
            this._textLabel = textLabel;
          }
          if (this._inputMode === InputMode.ANY) {
            textLabel.verticalAlign = VerticalTextAlignment.TOP;
            textLabel.enableWrapText = true;
          } else {
            textLabel.enableWrapText = false;
          }
          textLabel.string = this._updateLabelStringStyle(this._string);
        }
        _updatePlaceholderLabel() {
          let placeholderLabel = this._placeholderLabel;
          if (!placeholderLabel) {
            let node = this.node.getChildByName('PLACEHOLDER_LABEL');
            if (!node) {
              node = new Node$1('PLACEHOLDER_LABEL');
              node.layer = this.node.layer;
            }
            placeholderLabel = node.getComponent(Label);
            if (!placeholderLabel) {
              placeholderLabel = node.addComponent(Label);
            }
            node.parent = this.node;
            this._placeholderLabel = placeholderLabel;
          }
          if (this._inputMode === InputMode.ANY) {
            placeholderLabel.enableWrapText = true;
          } else {
            placeholderLabel.enableWrapText = false;
          }
          placeholderLabel.string = this.placeholder;
        }
        _syncSize() {
          const trans = this.node._uiProps.uiTransformComp;
          const size = trans.contentSize;
          if (this._background) {
            const bgTrans = this._background.node._uiProps.uiTransformComp;
            bgTrans.anchorPoint = trans.anchorPoint;
            bgTrans.setContentSize(size);
          }
          this._updateLabelPosition(size);
          if (this._impl) {
            this._impl.setSize(size.width, size.height);
          }
        }
        _updateLabels() {
          if (this._isLabelVisible) {
            const content = this._string;
            if (this._textLabel) {
              this._textLabel.node.active = content !== '';
            }
            if (this._placeholderLabel) {
              this._placeholderLabel.node.active = content === '';
            }
          }
        }
        _updateString(text) {
          const textLabel = this._textLabel;
          if (!textLabel) {
            return;
          }
          let displayText = text;
          if (displayText) {
            displayText = this._updateLabelStringStyle(displayText);
          }
          textLabel.string = displayText;
          this._updateLabels();
        }
        _updateLabelStringStyle(text, ignorePassword = false) {
          const inputFlag = this._inputFlag;
          if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
            let passwordString = '';
            const len = text.length;
            for (let i = 0; i < len; ++i) {
              passwordString += '\u25CF';
            }
            text = passwordString;
          } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            text = text.toUpperCase();
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            text = capitalize(text);
          } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
            text = capitalizeFirstLetter(text);
          }
          return text;
        }
        _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.on(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        }
        _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          this.node.off(XrKeyboardEventType.XR_KEYBOARD_INPUT, this._xrKeyBoardInput, this);
        }
        _onBackgroundSpriteFrameChanged() {
          if (!this._background) {
            return;
          }
          this.backgroundImage = this._background.spriteFrame;
        }
        _registerBackgroundEvent() {
          const node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }
        _unregisterBackgroundEvent() {
          const node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }
        _updateLabelPosition(size) {
          const trans = this.node._uiProps.uiTransformComp;
          const offX = -trans.anchorX * trans.width;
          const offY = -trans.anchorY * trans.height;
          const placeholderLabel = this._placeholderLabel;
          const textLabel = this._textLabel;
          if (textLabel) {
            textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING, size.height);
            textLabel.node.setPosition(offX + LEFT_PADDING, offY + size.height, textLabel.node.position.z);
            if (this._inputMode === InputMode.ANY) {
              textLabel.verticalAlign = VerticalTextAlignment.TOP;
            }
            textLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
          if (placeholderLabel) {
            placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING, size.height);
            placeholderLabel.node.setPosition(offX + LEFT_PADDING, offY + size.height, placeholderLabel.node.position.z);
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
        }
        _resizeChildNodes() {
          const trans = this.node._uiProps.uiTransformComp;
          const textLabelNode = this._textLabel && this._textLabel.node;
          if (textLabelNode) {
            textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);
            textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          const placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
          if (placeholderLabelNode) {
            placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);
            placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          const backgroundNode = this._background && this._background.node;
          if (backgroundNode) {
            backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }
          this._syncSize();
        }
        _xrUnClick() {
          this.node.emit(EventType$3.XR_EDITING_DID_BEGAN, this._maxLength, this.string);
        }
        _xrKeyBoardInput(str) {
          this.string = str;
        }
      }, _class3$9._EditBoxImpl = EditBoxImplBase, _class3$9.KeyboardReturnType = KeyboardReturnType, _class3$9.InputFlag = InputFlag, _class3$9.InputMode = InputMode, _class3$9.EventType = EventType$3, _class3$9), (_applyDecoratedDescriptor(_class2$c.prototype, "textLabel", [_dec4$a], Object.getOwnPropertyDescriptor(_class2$c.prototype, "textLabel"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "placeholderLabel", [_dec5$a], Object.getOwnPropertyDescriptor(_class2$c.prototype, "placeholderLabel"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "backgroundImage", [_dec6$4], Object.getOwnPropertyDescriptor(_class2$c.prototype, "backgroundImage"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "inputFlag", [_dec7$3], Object.getOwnPropertyDescriptor(_class2$c.prototype, "inputFlag"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "inputMode", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$c.prototype, "inputMode"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "returnType", [_dec9$2], Object.getOwnPropertyDescriptor(_class2$c.prototype, "returnType"), _class2$c.prototype), _initializer$c = applyDecoratedInitializer(_class2$c.prototype, "editingDidBegan", [_dec10, serializable$6], function () {
        return [];
      }), _initializer2$c = applyDecoratedInitializer(_class2$c.prototype, "textChanged", [_dec11, serializable$6], function () {
        return [];
      }), _initializer3$a = applyDecoratedInitializer(_class2$c.prototype, "editingDidEnded", [_dec12, serializable$6], function () {
        return [];
      }), _initializer4$9 = applyDecoratedInitializer(_class2$c.prototype, "editingReturn", [_dec13, serializable$6], function () {
        return [];
      }), _initializer5$7 = applyDecoratedInitializer(_class2$c.prototype, "_textLabel", [serializable$6], function () {
        return null;
      }), _initializer6$4 = applyDecoratedInitializer(_class2$c.prototype, "_placeholderLabel", [serializable$6], function () {
        return null;
      }), _initializer7$4 = applyDecoratedInitializer(_class2$c.prototype, "_returnType", [serializable$6], function () {
        return KeyboardReturnType.DEFAULT;
      }), _initializer8$4 = applyDecoratedInitializer(_class2$c.prototype, "_string", [serializable$6], function () {
        return '';
      }), _initializer9$4 = applyDecoratedInitializer(_class2$c.prototype, "_tabIndex", [serializable$6], function () {
        return 0;
      }), _initializer10$4 = applyDecoratedInitializer(_class2$c.prototype, "_backgroundImage", [serializable$6], function () {
        return null;
      }), _initializer11$4 = applyDecoratedInitializer(_class2$c.prototype, "_inputFlag", [serializable$6], function () {
        return InputFlag.DEFAULT;
      }), _initializer12$3 = applyDecoratedInitializer(_class2$c.prototype, "_inputMode", [serializable$6], function () {
        return InputMode.ANY;
      }), _initializer13$2 = applyDecoratedInitializer(_class2$c.prototype, "_maxLength", [serializable$6], function () {
        return 20;
      })), _class2$c)) || _class$g) || _class$g) || _class$g); exports({ EditBox: EditBox, EditBoxComponent: EditBox });
      if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
        EditBox._EditBoxImpl = EditBoxImpl;
      }
      legacyCC.internal.EditBox = EditBox;

      var _dec$f, _dec2$d, _dec3$c, _dec4$9, _dec5$9, _dec6$3, _dec7$2, _dec8$1, _dec9$1, _class$f, _class2$b, _initializer$b, _initializer2$b, _initializer3$9, _initializer4$8, _initializer5$6, _initializer6$3, _initializer7$3, _initializer8$3, _initializer9$3, _initializer10$3, _initializer11$3, _initializer12$2, _initializer13$1, _initializer14$1, _initializer15$1, _initializer16$1, _class3$8;
      var Type;
      (function (Type) {
        Type[Type["NONE"] = 0] = "NONE";
        Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
        Type[Type["VERTICAL"] = 2] = "VERTICAL";
        Type[Type["GRID"] = 3] = "GRID";
      })(Type || (Type = {}));
      ccenum(Type);
      var ResizeMode;
      (function (ResizeMode) {
        ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
        ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
        ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
      })(ResizeMode || (ResizeMode = {}));
      ccenum(ResizeMode);
      var AxisDirection;
      (function (AxisDirection) {
        AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
        AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
      })(AxisDirection || (AxisDirection = {}));
      ccenum(AxisDirection);
      var VerticalDirection;
      (function (VerticalDirection) {
        VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
        VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
      })(VerticalDirection || (VerticalDirection = {}));
      ccenum(VerticalDirection);
      var HorizontalDirection;
      (function (HorizontalDirection) {
        HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
      })(HorizontalDirection || (HorizontalDirection = {}));
      ccenum(HorizontalDirection);
      var Constraint;
      (function (Constraint) {
        Constraint[Constraint["NONE"] = 0] = "NONE";
        Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
        Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
      })(Constraint || (Constraint = {}));
      ccenum(Constraint);
      const _tempVec3$2 = new Vec3();
      let Layout = (_dec$f = ccclass$6('cc.Layout'), _dec2$d = executionOrder$1(110), _dec3$c = requireComponent(UITransform), _dec4$9 = type$6(Type), _dec5$9 = type$6(ResizeMode), _dec6$3 = type$6(AxisDirection), _dec7$2 = type$6(VerticalDirection), _dec8$1 = type$6(HorizontalDirection), _dec9$1 = type$6(Constraint), _dec$f(_class$f = _dec2$d(_class$f = _dec3$c(_class$f = (_class2$b = (_class3$8 = class Layout extends Component {
        constructor(...args) {
          super(...args);
          this._resizeMode = _initializer$b && _initializer$b();
          this._layoutType = _initializer2$b && _initializer2$b();
          this._cellSize = _initializer3$9 && _initializer3$9();
          this._startAxis = _initializer4$8 && _initializer4$8();
          this._paddingLeft = _initializer5$6 && _initializer5$6();
          this._paddingRight = _initializer6$3 && _initializer6$3();
          this._paddingTop = _initializer7$3 && _initializer7$3();
          this._paddingBottom = _initializer8$3 && _initializer8$3();
          this._spacingX = _initializer9$3 && _initializer9$3();
          this._spacingY = _initializer10$3 && _initializer10$3();
          this._verticalDirection = _initializer11$3 && _initializer11$3();
          this._horizontalDirection = _initializer12$2 && _initializer12$2();
          this._constraint = _initializer13$1 && _initializer13$1();
          this._constraintNum = _initializer14$1 && _initializer14$1();
          this._affectedByScale = _initializer15$1 && _initializer15$1();
          this._isAlign = _initializer16$1 && _initializer16$1();
          this._layoutSize = new Size$1(300, 200);
          this._layoutDirty = true;
          this._childrenDirty = false;
          this._usefulLayoutObj = [];
          this._init = false;
        }
        get alignHorizontal() {
          return this._isAlign;
        }
        set alignHorizontal(value) {
          if (this._layoutType !== Type.HORIZONTAL) {
            return;
          }
          this._isAlign = value;
          this._doLayoutDirty();
        }
        get alignVertical() {
          return this._isAlign;
        }
        set alignVertical(value) {
          if (this._layoutType !== Type.VERTICAL) {
            return;
          }
          this._isAlign = value;
          this._doLayoutDirty();
        }
        get type() {
          return this._layoutType;
        }
        set type(value) {
          this._layoutType = value;
          this._doLayoutDirty();
        }
        get resizeMode() {
          return this._resizeMode;
        }
        set resizeMode(value) {
          if (this._layoutType === Type.NONE) {
            return;
          }
          this._resizeMode = value;
          this._doLayoutDirty();
        }
        get cellSize() {
          return this._cellSize;
        }
        set cellSize(value) {
          if (this._cellSize === value) {
            return;
          }
          this._cellSize.set(value);
          this._doLayoutDirty();
        }
        get startAxis() {
          return this._startAxis;
        }
        set startAxis(value) {
          if (this._startAxis === value) {
            return;
          }
          this._startAxis = value;
          this._doLayoutDirty();
        }
        get paddingLeft() {
          return this._paddingLeft;
        }
        set paddingLeft(value) {
          if (this._paddingLeft === value) {
            return;
          }
          this._paddingLeft = value;
          this._doLayoutDirty();
        }
        get paddingRight() {
          return this._paddingRight;
        }
        set paddingRight(value) {
          if (this._paddingRight === value) {
            return;
          }
          this._paddingRight = value;
          this._doLayoutDirty();
        }
        get paddingTop() {
          return this._paddingTop;
        }
        set paddingTop(value) {
          if (this._paddingTop === value) {
            return;
          }
          this._paddingTop = value;
          this._doLayoutDirty();
        }
        get paddingBottom() {
          return this._paddingBottom;
        }
        set paddingBottom(value) {
          if (this._paddingBottom === value) {
            return;
          }
          this._paddingBottom = value;
          this._doLayoutDirty();
        }
        get spacingX() {
          return this._spacingX;
        }
        set spacingX(value) {
          if (this._spacingX === value) {
            return;
          }
          this._spacingX = value;
          this._doLayoutDirty();
        }
        get spacingY() {
          return this._spacingY;
        }
        set spacingY(value) {
          if (this._spacingY === value) {
            return;
          }
          this._spacingY = value;
          this._doLayoutDirty();
        }
        get verticalDirection() {
          return this._verticalDirection;
        }
        set verticalDirection(value) {
          if (this._verticalDirection === value) {
            return;
          }
          this._verticalDirection = value;
          this._doLayoutDirty();
        }
        get horizontalDirection() {
          return this._horizontalDirection;
        }
        set horizontalDirection(value) {
          if (this._horizontalDirection === value) {
            return;
          }
          this._horizontalDirection = value;
          this._doLayoutDirty();
        }
        get padding() {
          return this._paddingLeft;
        }
        set padding(value) {
          if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
            this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;
            this._doLayoutDirty();
          }
        }
        get constraint() {
          return this._constraint;
        }
        set constraint(value) {
          if (this._layoutType === Type.NONE || this._constraint === value) {
            return;
          }
          this._constraint = value;
          this._doLayoutDirty();
        }
        get constraintNum() {
          return this._constraintNum;
        }
        set constraintNum(value) {
          if (this._constraint === Constraint.NONE || this._constraintNum === value) {
            return;
          }
          if (value <= 0) {
            warn('Limit values to be greater than 0');
          }
          this._constraintNum = value;
          this._doLayoutDirty();
        }
        get affectedByScale() {
          return this._affectedByScale;
        }
        set affectedByScale(value) {
          this._affectedByScale = value;
          this._doLayoutDirty();
        }
        updateLayout(force = false) {
          if (this._layoutDirty || force) {
            this._doLayout();
            this._layoutDirty = false;
          }
        }
        onEnable() {
          this._addEventListeners();
          const trans = this.node._uiProps.uiTransformComp;
          if (trans.contentSize.equals(Size$1.ZERO)) {
            trans.setContentSize(this._layoutSize);
          }
          this._childrenChanged();
        }
        onDisable() {
          this._usefulLayoutObj.length = 0;
          this._removeEventListeners();
        }
        _checkUsefulObj() {
          this._usefulLayoutObj.length = 0;
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            const uiTrans = child._uiProps.uiTransformComp;
            if (child.activeInHierarchy && uiTrans) {
              this._usefulLayoutObj.push(uiTrans);
            }
          }
        }
        _addEventListeners() {
          director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.on(NodeEventType.CHILDREN_ORDER_CHANGED, this._childrenChanged, this);
          this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);
          this._addChildrenEventListeners();
        }
        _removeEventListeners() {
          director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.off(NodeEventType.CHILDREN_ORDER_CHANGED, this._childrenChanged, this);
          this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);
          this._removeChildrenEventListeners();
        }
        _addChildrenEventListeners() {
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }
        _removeChildrenEventListeners() {
          const children = this.node.children;
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }
        _childAdded(child) {
          child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          this._childrenChanged();
        }
        _childRemoved(child) {
          child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          this._childrenChanged();
        }
        _resized() {
          this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);
          this._doLayoutDirty();
        }
        _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const limit = this._getFixedBreakingNum();
          let sign = 1;
          let paddingX = this._paddingLeft;
          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            paddingX = this._paddingRight;
          }
          const startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
          let nextX = startPos - sign * this._spacingX;
          let totalHeight = 0;
          let rowMaxHeight = 0;
          let tempMaxHeight = 0;
          let maxHeight = 0;
          let isBreak = false;
          const activeChildCount = this._usefulLayoutObj.length;
          let newChildWidth = this._cellSize.width;
          const paddingH = this._getPaddingH();
          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
          }
          const children = this._usefulLayoutObj;
          for (let i = 0; i < children.length; ++i) {
            const childTrans = children[i];
            const child = childTrans.node;
            const scale = child.scale;
            const childScaleX = this._getUsedScaleValue(scale.x);
            const childScaleY = this._getUsedScaleValue(scale.y);
            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.width = newChildWidth / childScaleX;
              if (this._layoutType === Type.GRID) {
                childTrans.height = this._cellSize.height / childScaleY;
              }
            }
            const anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
            const childBoundingBoxWidth = childTrans.width * childScaleX;
            const childBoundingBoxHeight = childTrans.height * childScaleY;
            if (childBoundingBoxHeight > tempMaxHeight) {
              maxHeight = Math.max(tempMaxHeight, maxHeight);
              rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
              tempMaxHeight = childBoundingBoxHeight;
            }
            nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
            const rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
            if (rowBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;
                if (isBreak) {
                  rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                }
              } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                  isBreak = true;
                }
              } else {
                const boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                const rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
              }
              if (isBreak) {
                nextX = startPos + sign * (anchorX * childBoundingBoxWidth);
                if (childBoundingBoxHeight !== tempMaxHeight) {
                  rowMaxHeight = tempMaxHeight;
                }
                totalHeight += rowMaxHeight + this._spacingY;
                rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
              }
            }
            const finalPositionY = fnPositionY(child, childTrans, totalHeight);
            if (applyChildren) {
              child.setPosition(nextX, finalPositionY);
            }
            nextX += rightBoundaryOfChild;
          }
          rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);
          const containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();
          return containerResizeBoundary;
        }
        _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const limit = this._getFixedBreakingNum();
          let sign = 1;
          let paddingY = this._paddingBottom;
          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            paddingY = this._paddingTop;
          }
          const startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
          let nextY = startPos - sign * this._spacingY;
          let tempMaxWidth = 0;
          let maxWidth = 0;
          let colMaxWidth = 0;
          let totalWidth = 0;
          let isBreak = false;
          const activeChildCount = this._usefulLayoutObj.length;
          let newChildHeight = this._cellSize.height;
          const paddingV = this._getPaddingV();
          if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
          }
          const children = this._usefulLayoutObj;
          for (let i = 0; i < children.length; ++i) {
            const childTrans = children[i];
            const child = childTrans.node;
            const scale = child.scale;
            const childScaleX = this._getUsedScaleValue(scale.x);
            const childScaleY = this._getUsedScaleValue(scale.y);
            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.height = newChildHeight / childScaleY;
              if (this._layoutType === Type.GRID) {
                childTrans.width = this._cellSize.width / childScaleX;
              }
            }
            const anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
            const childBoundingBoxWidth = childTrans.width * childScaleX;
            const childBoundingBoxHeight = childTrans.height * childScaleY;
            if (childBoundingBoxWidth > tempMaxWidth) {
              maxWidth = Math.max(tempMaxWidth, maxWidth);
              colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
              tempMaxWidth = childBoundingBoxWidth;
            }
            nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
            const topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
            if (columnBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;
                if (isBreak) {
                  colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                }
              } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                  isBreak = true;
                }
              } else {
                const boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                const columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
              }
              if (isBreak) {
                nextY = startPos + sign * (anchorY * childBoundingBoxHeight);
                if (childBoundingBoxWidth !== tempMaxWidth) {
                  colMaxWidth = tempMaxWidth;
                }
                totalWidth += colMaxWidth + this._spacingX;
                colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
              }
            }
            const finalPositionX = fnPositionX(child, childTrans, totalWidth);
            if (applyChildren) {
              child.getPosition(_tempVec3$2);
              child.setPosition(finalPositionX, nextY, _tempVec3$2.z);
            }
            nextY += topBoundaryOfChild;
          }
          colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);
          const containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();
          return containerResizeBoundary;
        }
        _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
          const baseWidth = layoutSize.width;
          let sign = 1;
          let bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
          let paddingY = this._paddingBottom;
          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
            paddingY = this._paddingTop;
          }
          const fnPositionY = (child, childTrans, topOffset) => bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * this._getUsedScaleValue(child.scale.y) + paddingY);
          let newHeight = 0;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
            bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
            if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
              sign = -1;
              bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
            }
          }
          this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
          }
        }
        _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
          const baseHeight = layoutSize.height;
          let sign = 1;
          let leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
          let paddingX = this._paddingLeft;
          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
            paddingX = this._paddingRight;
          }
          const fnPositionX = (child, childTrans, leftOffset) => leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * this._getUsedScaleValue(child.scale.x) + paddingX);
          let newWidth = 0;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
            leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
            if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
              sign = -1;
              leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
            }
          }
          this._doLayoutVertically(baseHeight, true, fnPositionX, true);
          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
          }
        }
        _doLayoutGrid() {
          const trans = this.node._uiProps.uiTransformComp;
          const layoutAnchor = trans.anchorPoint;
          const layoutSize = trans.contentSize;
          if (this.startAxis === AxisDirection.HORIZONTAL) {
            this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
          } else if (this.startAxis === AxisDirection.VERTICAL) {
            this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
          }
        }
        _getHorizontalBaseWidth(horizontal = true) {
          const children = this._usefulLayoutObj;
          let baseSize = 0;
          const activeChildCount = children.length;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (let i = 0; i < children.length; ++i) {
              const childTrans = children[i];
              const child = childTrans.node;
              const scale = child.scale;
              baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
            }
            baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.width;
          }
          return baseSize;
        }
        _getVerticalBaseHeight() {
          const children = this._usefulLayoutObj;
          let baseSize = 0;
          const activeChildCount = children.length;
          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (let i = 0; i < children.length; ++i) {
              const childTrans = children[i];
              const child = childTrans.node;
              const scale = child.scale;
              baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
            }
            baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.height;
          }
          return baseSize;
        }
        _doLayout() {
          if (!this._init || this._childrenDirty) {
            this._checkUsefulObj();
            this._init = true;
            this._childrenDirty = false;
          }
          if (this._layoutType === Type.HORIZONTAL) {
            const newWidth = this._getHorizontalBaseWidth();
            const fnPositionY = child => {
              const pos = this._isAlign ? Vec3.ZERO : child.position;
              return pos.y;
            };
            this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
            this.node._uiProps.uiTransformComp.width = newWidth;
          } else if (this._layoutType === Type.VERTICAL) {
            const newHeight = this._getVerticalBaseHeight();
            const fnPositionX = child => {
              const pos = this._isAlign ? Vec3.ZERO : child.position;
              return pos.x;
            };
            this._doLayoutVertically(newHeight, false, fnPositionX, true);
            this.node._uiProps.uiTransformComp.height = newHeight;
          } else if (this._layoutType === Type.GRID) {
            this._doLayoutGrid();
          }
        }
        _getUsedScaleValue(value) {
          return this._affectedByScale ? Math.abs(value) : 1;
        }
        _transformDirty(type) {
          if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
            return;
          }
          this._doLayoutDirty();
        }
        _doLayoutDirty() {
          this._layoutDirty = true;
        }
        _childrenChanged() {
          this._childrenDirty = true;
          this._doLayoutDirty();
        }
        _getPaddingH() {
          return this._paddingLeft + this._paddingRight;
        }
        _getPaddingV() {
          return this._paddingTop + this._paddingBottom;
        }
        _getFixedBreakingNum() {
          if (this._layoutType !== Type.GRID || this._constraint === Constraint.NONE || this._constraintNum <= 0) {
            return 0;
          }
          let num = this._constraint === Constraint.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          if (this._startAxis === AxisDirection.VERTICAL) {
            num = this._constraint === Constraint.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          }
          return num;
        }
      }, _class3$8.Type = Type, _class3$8.VerticalDirection = VerticalDirection, _class3$8.HorizontalDirection = HorizontalDirection, _class3$8.ResizeMode = ResizeMode, _class3$8.AxisDirection = AxisDirection, _class3$8.Constraint = Constraint, _class3$8), (_applyDecoratedDescriptor(_class2$b.prototype, "type", [_dec4$9], Object.getOwnPropertyDescriptor(_class2$b.prototype, "type"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "resizeMode", [_dec5$9], Object.getOwnPropertyDescriptor(_class2$b.prototype, "resizeMode"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "startAxis", [_dec6$3], Object.getOwnPropertyDescriptor(_class2$b.prototype, "startAxis"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "verticalDirection", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$b.prototype, "verticalDirection"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "horizontalDirection", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$b.prototype, "horizontalDirection"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "constraint", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$b.prototype, "constraint"), _class2$b.prototype), _initializer$b = applyDecoratedInitializer(_class2$b.prototype, "_resizeMode", [serializable$6], function () {
        return ResizeMode.NONE;
      }), _initializer2$b = applyDecoratedInitializer(_class2$b.prototype, "_layoutType", [serializable$6], function () {
        return Type.NONE;
      }), _initializer3$9 = applyDecoratedInitializer(_class2$b.prototype, "_cellSize", [serializable$6], function () {
        return new Size$1(40, 40);
      }), _initializer4$8 = applyDecoratedInitializer(_class2$b.prototype, "_startAxis", [serializable$6], function () {
        return AxisDirection.HORIZONTAL;
      }), _initializer5$6 = applyDecoratedInitializer(_class2$b.prototype, "_paddingLeft", [serializable$6], function () {
        return 0;
      }), _initializer6$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingRight", [serializable$6], function () {
        return 0;
      }), _initializer7$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingTop", [serializable$6], function () {
        return 0;
      }), _initializer8$3 = applyDecoratedInitializer(_class2$b.prototype, "_paddingBottom", [serializable$6], function () {
        return 0;
      }), _initializer9$3 = applyDecoratedInitializer(_class2$b.prototype, "_spacingX", [serializable$6], function () {
        return 0;
      }), _initializer10$3 = applyDecoratedInitializer(_class2$b.prototype, "_spacingY", [serializable$6], function () {
        return 0;
      }), _initializer11$3 = applyDecoratedInitializer(_class2$b.prototype, "_verticalDirection", [serializable$6], function () {
        return VerticalDirection.TOP_TO_BOTTOM;
      }), _initializer12$2 = applyDecoratedInitializer(_class2$b.prototype, "_horizontalDirection", [serializable$6], function () {
        return HorizontalDirection.LEFT_TO_RIGHT;
      }), _initializer13$1 = applyDecoratedInitializer(_class2$b.prototype, "_constraint", [serializable$6], function () {
        return Constraint.NONE;
      }), _initializer14$1 = applyDecoratedInitializer(_class2$b.prototype, "_constraintNum", [serializable$6], function () {
        return 2;
      }), _initializer15$1 = applyDecoratedInitializer(_class2$b.prototype, "_affectedByScale", [serializable$6], function () {
        return false;
      }), _initializer16$1 = applyDecoratedInitializer(_class2$b.prototype, "_isAlign", [serializable$6], function () {
        return false;
      })), _class2$b)) || _class$f) || _class$f) || _class$f); exports({ Layout: Layout, LayoutComponent: Layout });
      legacyCC.Layout = Layout;

      var _dec$e, _dec2$c, _dec3$b, _dec4$8, _dec5$8, _class$e, _class2$a, _initializer$a, _initializer2$a, _initializer3$8, _initializer4$7, _initializer5$5, _class3$7;
      var Mode;
      (function (Mode) {
        Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
        Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
        Mode[Mode["FILLED"] = 2] = "FILLED";
      })(Mode || (Mode = {}));
      Enum(Mode);
      let ProgressBar = (_dec$e = ccclass$6('cc.ProgressBar'), _dec2$c = executionOrder$1(110), _dec3$b = requireComponent(UITransform), _dec4$8 = type$6(Sprite), _dec5$8 = type$6(Mode), _dec$e(_class$e = _dec2$c(_class$e = _dec3$b(_class$e = (_class2$a = (_class3$7 = class ProgressBar extends Component {
        constructor(...args) {
          super(...args);
          this._barSprite = _initializer$a && _initializer$a();
          this._mode = _initializer2$a && _initializer2$a();
          this._totalLength = _initializer3$8 && _initializer3$8();
          this._progress = _initializer4$7 && _initializer4$7();
          this._reverse = _initializer5$5 && _initializer5$5();
        }
        get barSprite() {
          return this._barSprite;
        }
        set barSprite(value) {
          if (this._barSprite === value) {
            return;
          }
          this._barSprite = value;
          this._initBarSprite();
        }
        get mode() {
          return this._mode;
        }
        set mode(value) {
          if (this._mode === value) {
            return;
          }
          this._mode = value;
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const entitySize = entity._uiProps.uiTransformComp.contentSize;
            if (this._mode === Mode.HORIZONTAL) {
              this.totalLength = entitySize.width;
            } else if (this._mode === Mode.VERTICAL) {
              this.totalLength = entitySize.height;
            } else if (this._mode === Mode.FILLED) {
              this.totalLength = this._barSprite.fillRange;
            }
          }
        }
        get totalLength() {
          return this._totalLength;
        }
        set totalLength(value) {
          if (this._mode === Mode.FILLED) {
            value = clamp01(value);
          }
          if (this._totalLength === value) {
            return;
          }
          this._totalLength = value;
          this._updateBarStatus();
        }
        get progress() {
          return this._progress;
        }
        set progress(value) {
          if (this._progress === value) {
            return;
          }
          this._progress = value;
          this._updateBarStatus();
        }
        get reverse() {
          return this._reverse;
        }
        set reverse(value) {
          if (this._reverse === value) {
            return;
          }
          this._reverse = value;
          if (this._barSprite) {
            this._barSprite.fillStart = 1 - this._barSprite.fillStart;
          }
          this._updateBarStatus();
        }
        onLoad() {
          this._updateBarStatus();
        }
        _initBarSprite() {
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const trans = this.node._uiProps.uiTransformComp;
            const nodeSize = trans.contentSize;
            const nodeAnchor = trans.anchorPoint;
            const barSpriteSize = entity._uiProps.uiTransformComp.contentSize;
            if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
              this._mode = Mode.FILLED;
            }
            if (this._mode === Mode.HORIZONTAL) {
              this.totalLength = barSpriteSize.width;
            } else if (this._mode === Mode.VERTICAL) {
              this.totalLength = barSpriteSize.height;
            } else {
              this.totalLength = this._barSprite.fillRange;
            }
            if (entity.parent === this.node) {
              const x = -nodeSize.width * nodeAnchor.x;
              entity.setPosition(x, 0, 0);
            }
          }
        }
        _updateBarStatus() {
          if (this._barSprite) {
            const entity = this._barSprite.node;
            if (!entity) {
              return;
            }
            const entTrans = entity._uiProps.uiTransformComp;
            const entityAnchorPoint = entTrans.anchorPoint;
            const entitySize = entTrans.contentSize;
            const entityPosition = entity.getPosition();
            let anchorPoint = new Vec2(0, 0.5);
            const progress = clamp01(this._progress);
            let actualLenth = this._totalLength * progress;
            let finalContentSize = entitySize;
            let totalWidth = 0;
            let totalHeight = 0;
            switch (this._mode) {
              case Mode.HORIZONTAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(1, 0.5);
                }
                finalContentSize = new Size$1(actualLenth, entitySize.height);
                totalWidth = this._totalLength;
                totalHeight = entitySize.height;
                break;
              case Mode.VERTICAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(0.5, 1);
                } else {
                  anchorPoint = new Vec2(0.5, 0);
                }
                finalContentSize = new Size$1(entitySize.width, actualLenth);
                totalWidth = entitySize.width;
                totalHeight = this._totalLength;
                break;
            }
            if (this._mode === Mode.FILLED) {
              if (this._barSprite.type !== Sprite.Type.FILLED) {
                warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
              } else {
                if (this._reverse) {
                  actualLenth *= -1;
                }
                this._barSprite.fillRange = actualLenth;
              }
            } else if (this._barSprite.type !== Sprite.Type.FILLED) {
              const anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
              const anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
              const finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
              entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
              entTrans.setAnchorPoint(anchorPoint);
              entTrans.setContentSize(finalContentSize);
            } else {
              warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
            }
          }
        }
      }, _class3$7.Mode = Mode, _class3$7), (_applyDecoratedDescriptor(_class2$a.prototype, "barSprite", [_dec4$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "barSprite"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "mode", [_dec5$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "mode"), _class2$a.prototype), _initializer$a = applyDecoratedInitializer(_class2$a.prototype, "_barSprite", [serializable$6], function () {
        return null;
      }), _initializer2$a = applyDecoratedInitializer(_class2$a.prototype, "_mode", [serializable$6], function () {
        return Mode.HORIZONTAL;
      }), _initializer3$8 = applyDecoratedInitializer(_class2$a.prototype, "_totalLength", [serializable$6], function () {
        return 1;
      }), _initializer4$7 = applyDecoratedInitializer(_class2$a.prototype, "_progress", [serializable$6], function () {
        return 0.1;
      }), _initializer5$5 = applyDecoratedInitializer(_class2$a.prototype, "_reverse", [serializable$6], function () {
        return false;
      })), _class2$a)) || _class$e) || _class$e) || _class$e); exports({ ProgressBar: ProgressBar, ProgressBarComponent: ProgressBar });
      legacyCC.ProgressBar = ProgressBar;

      var _dec$d, _dec2$b, _dec3$a, _dec4$7, _dec5$7, _class$d, _class2$9, _initializer$9, _initializer2$9, _initializer3$7, _initializer4$6, _initializer5$4, _class3$6;
      const GETTING_SHORTER_FACTOR = 20;
      const _tempPos_1 = new Vec3();
      const _tempPos_2 = new Vec3();
      const _tempVec3$1 = new Vec3();
      const defaultAnchor = new Vec2();
      const _tempColor = new Color$1();
      const _tempVec2$2 = new Vec2();
      var Direction$3;
      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$3 || (Direction$3 = {}));
      ccenum(Direction$3);
      let ScrollBar = (_dec$d = ccclass$6('cc.ScrollBar'), _dec2$b = executionOrder$1(110), _dec3$a = requireComponent(UITransform), _dec4$7 = type$6(Sprite), _dec5$7 = type$6(Direction$3), _dec$d(_class$d = _dec2$b(_class$d = _dec3$a(_class$d = (_class2$9 = (_class3$6 = class ScrollBar extends Component {
        constructor(...args) {
          super(...args);
          this._scrollView = _initializer$9 && _initializer$9();
          this._handle = _initializer2$9 && _initializer2$9();
          this._direction = _initializer3$7 && _initializer3$7();
          this._enableAutoHide = _initializer4$6 && _initializer4$6();
          this._autoHideTime = _initializer5$4 && _initializer5$4();
          this._touching = false;
          this._opacity = 255;
          this._autoHideRemainingTime = 0;
        }
        get handle() {
          return this._handle;
        }
        set handle(value) {
          if (this._handle === value) {
            return;
          }
          this._handle = value;
          this.onScroll(Vec2.ZERO);
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this.onScroll(Vec2.ZERO);
        }
        get enableAutoHide() {
          return this._enableAutoHide;
        }
        set enableAutoHide(value) {
          if (this._enableAutoHide === value) {
            return;
          }
          this._enableAutoHide = value;
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        }
        get autoHideTime() {
          return this._autoHideTime;
        }
        set autoHideTime(value) {
          if (this._autoHideTime === value) {
            return;
          }
          this._autoHideTime = value;
        }
        hide() {
          this._autoHideRemainingTime = 0;
          this._setOpacity(0);
        }
        show() {
          this._autoHideRemainingTime = this._autoHideTime;
          this._opacity = 255;
          this._setOpacity(this._opacity);
        }
        onScroll(outOfBoundary) {
          if (!this._scrollView) {
            return;
          }
          const content = this._scrollView.content;
          if (!content) {
            return;
          }
          const contentSize = content._uiProps.uiTransformComp.contentSize;
          const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
          const barSize = this.node._uiProps.uiTransformComp.contentSize;
          if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
            return;
          }
          if (this._enableAutoHide) {
            this._autoHideRemainingTime = this._autoHideTime;
            this._setOpacity(this._opacity);
          }
          let contentMeasure = 0;
          let scrollViewMeasure = 0;
          let outOfBoundaryValue = 0;
          let contentPosition = 0;
          let handleNodeMeasure = 0;
          const outOfContentPosition = _tempVec2$2;
          outOfContentPosition.set(0, 0);
          if (this._direction === Direction$3.HORIZONTAL) {
            contentMeasure = contentSize.width;
            scrollViewMeasure = scrollViewSize.width;
            handleNodeMeasure = barSize.width;
            outOfBoundaryValue = outOfBoundary.x;
            this._convertToScrollViewSpace(outOfContentPosition, content);
            contentPosition = -outOfContentPosition.x;
          } else if (this._direction === Direction$3.VERTICAL) {
            contentMeasure = contentSize.height;
            scrollViewMeasure = scrollViewSize.height;
            handleNodeMeasure = barSize.height;
            outOfBoundaryValue = outOfBoundary.y;
            this._convertToScrollViewSpace(outOfContentPosition, content);
            contentPosition = -outOfContentPosition.y;
          }
          const length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
          const position = _tempVec2$2;
          this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
          this._updateLength(length);
          this._updateHandlerPosition(position);
        }
        setScrollView(scrollView) {
          this._scrollView = scrollView;
        }
        onTouchBegan() {
          if (!this._enableAutoHide) {
            return;
          }
          this._touching = true;
        }
        onTouchEnded() {
          if (!this._enableAutoHide) {
            return;
          }
          this._touching = false;
          if (this._autoHideTime <= 0) {
            return;
          }
          if (this._scrollView) {
            const content = this._scrollView.content;
            if (content) {
              const contentSize = content._uiProps.uiTransformComp.contentSize;
              const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
              if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                return;
              }
            }
          }
          this._autoHideRemainingTime = this._autoHideTime;
        }
        onEnable() {
          const renderComp = this.node.getComponent(Sprite);
          if (renderComp) {
            this._opacity = renderComp.color.a;
          }
        }
        start() {
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        }
        update(dt) {
          this._processAutoHide(dt);
        }
        _convertToScrollViewSpace(out, content) {
          const scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
          const contentTrans = content._uiProps.uiTransformComp;
          if (!scrollTrans || !contentTrans) {
            out.set(Vec2.ZERO);
          } else {
            _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);
            contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
            const scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
            scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
            scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
            out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
          }
        }
        _setOpacity(opacity) {
          if (this._handle) {
            let renderComp = this.node.getComponent(Sprite);
            if (renderComp) {
              _tempColor.set(renderComp.color);
              _tempColor.a = opacity;
              renderComp.color = _tempColor;
            }
            renderComp = this._handle.getComponent(Sprite);
            if (renderComp) {
              _tempColor.set(renderComp.color);
              _tempColor.a = opacity;
              renderComp.color = _tempColor;
            }
          }
        }
        _updateHandlerPosition(position) {
          if (this._handle) {
            const oldPosition = _tempVec3$1;
            this._fixupHandlerPosition(oldPosition);
            this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
          }
        }
        _fixupHandlerPosition(out) {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const barSize = uiTrans.contentSize;
          const barAnchor = uiTrans.anchorPoint;
          const handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
          const handleParent = this.handle.node.parent;
          Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
          const leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
          const fixupPosition = out;
          fixupPosition.set(0, 0, 0);
          handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);
          if (this.direction === Direction$3.HORIZONTAL) {
            fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
          } else if (this.direction === Direction$3.VERTICAL) {
            fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
          }
          this.handle.node.setPosition(fixupPosition);
        }
        _conditionalDisableScrollBar(contentSize, scrollViewSize) {
          if (contentSize.width <= scrollViewSize.width && this._direction === Direction$3.HORIZONTAL) {
            return true;
          }
          if (contentSize.height <= scrollViewSize.height && this._direction === Direction$3.VERTICAL) {
            return true;
          }
          return false;
        }
        _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
          let denominatorValue = contentMeasure;
          if (outOfBoundary) {
            denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
          }
          const lengthRation = scrollViewMeasure / denominatorValue;
          return handleNodeMeasure * lengthRation;
        }
        _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
          let denominatorValue = contentMeasure - scrollViewMeasure;
          if (outOfBoundary) {
            denominatorValue += Math.abs(outOfBoundary);
          }
          let positionRatio = 0;
          if (denominatorValue) {
            positionRatio = contentPosition / denominatorValue;
            positionRatio = clamp01(positionRatio);
          }
          const position = (handleNodeMeasure - actualLenth) * positionRatio;
          if (this._direction === Direction$3.VERTICAL) {
            out.set(0, position);
          } else {
            out.set(position, 0);
          }
        }
        _updateLength(length) {
          if (this._handle) {
            const handleNode = this._handle.node;
            const handleTrans = handleNode._uiProps.uiTransformComp;
            const handleNodeSize = handleTrans.contentSize;
            const anchor = handleTrans.anchorPoint;
            if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
              handleTrans.setAnchorPoint(defaultAnchor);
            }
            if (this._direction === Direction$3.HORIZONTAL) {
              handleTrans.setContentSize(length, handleNodeSize.height);
            } else {
              handleTrans.setContentSize(handleNodeSize.width, length);
            }
          }
        }
        _processAutoHide(deltaTime) {
          if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
            return;
          } else if (this._touching) {
            return;
          }
          this._autoHideRemainingTime -= deltaTime;
          if (this._autoHideRemainingTime <= this._autoHideTime) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            const opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
            this._setOpacity(opacity);
          }
        }
      }, _class3$6.Direction = Direction$3, _class3$6), (_applyDecoratedDescriptor(_class2$9.prototype, "handle", [_dec4$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "handle"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "direction", [_dec5$7], Object.getOwnPropertyDescriptor(_class2$9.prototype, "direction"), _class2$9.prototype), _initializer$9 = applyDecoratedInitializer(_class2$9.prototype, "_scrollView", [serializable$6], function () {
        return null;
      }), _initializer2$9 = applyDecoratedInitializer(_class2$9.prototype, "_handle", [serializable$6], function () {
        return null;
      }), _initializer3$7 = applyDecoratedInitializer(_class2$9.prototype, "_direction", [serializable$6], function () {
        return Direction$3.HORIZONTAL;
      }), _initializer4$6 = applyDecoratedInitializer(_class2$9.prototype, "_enableAutoHide", [serializable$6], function () {
        return false;
      }), _initializer5$4 = applyDecoratedInitializer(_class2$9.prototype, "_autoHideTime", [serializable$6], function () {
        return 1.0;
      })), _class2$9)) || _class$d) || _class$d) || _class$d); exports({ ScrollBar: ScrollBar, ScrollBarComponent: ScrollBar });
      legacyCC.ScrollBar = ScrollBar;

      var _dec$c, _dec2$a, _class$c;
      let ViewGroup = exports('ViewGroup', (_dec$c = ccclass$6('cc.ViewGroup'), _dec2$a = executionOrder$1(110), _dec$c(_class$c = _dec2$a(_class$c = class ViewGroup extends Component {}) || _class$c) || _class$c));
      legacyCC.ViewGroup = ViewGroup;

      var _dec$b, _dec2$9, _dec3$9, _dec4$6, _dec5$6, _dec6$2, _dec7$1, _class$b, _class2$8, _initializer$8, _initializer2$8, _initializer3$6, _initializer4$5, _initializer5$3, _initializer6$2, _initializer7$2, _initializer8$2, _initializer9$2, _initializer10$2, _initializer11$2, _class3$5;
      const NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
      const OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
      const EPSILON = 1e-4;
      const TOLERANCE = 1e4;
      const MOVEMENT_FACTOR = 0.7;
      const _tempVec3 = new Vec3();
      const _tempVec3_1 = new Vec3();
      const _tempVec2$1 = new Vec2();
      const _tempVec2_1$1 = new Vec2();
      const quintEaseOut = time => {
        time -= 1;
        return time * time * time * time * time + 1;
      };
      const getTimeInMilliseconds = () => {
        const currentTime = new Date();
        return currentTime.getMilliseconds();
      };
      const eventMap = {
        'scroll-to-top': 0,
        'scroll-to-bottom': 1,
        'scroll-to-left': 2,
        'scroll-to-right': 3,
        'scrolling': 4,
        'bounce-bottom': 6,
        'bounce-left': 7,
        'bounce-right': 8,
        'bounce-top': 5,
        'scroll-ended': 9,
        'touch-up': 10,
        'scroll-ended-with-threshold': 11,
        'scroll-began': 12
      };
      let EventType$2;
      (function (EventType) {
        EventType["NONE"] = "";
        EventType["SCROLL_TO_TOP"] = "scroll-to-top";
        EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
        EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
        EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
        EventType["SCROLL_BEGAN"] = "scroll-began";
        EventType["SCROLL_ENDED"] = "scroll-ended";
        EventType["BOUNCE_TOP"] = "bounce-top";
        EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
        EventType["BOUNCE_LEFT"] = "bounce-left";
        EventType["BOUNCE_RIGHT"] = "bounce-right";
        EventType["SCROLLING"] = "scrolling";
        EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
        EventType["TOUCH_UP"] = "touch-up";
      })(EventType$2 || (EventType$2 = {}));
      var XrhoverType;
      (function (XrhoverType) {
        XrhoverType[XrhoverType["NONE"] = 0] = "NONE";
        XrhoverType[XrhoverType["LEFT"] = 1] = "LEFT";
        XrhoverType[XrhoverType["RIGHT"] = 2] = "RIGHT";
      })(XrhoverType || (XrhoverType = {}));
      let ScrollView = (_dec$b = ccclass$6('cc.ScrollView'), _dec2$9 = executionOrder$1(110), _dec3$9 = requireComponent(UITransform), _dec4$6 = type$6(Node$1), _dec5$6 = type$6(ScrollBar), _dec6$2 = type$6(ScrollBar), _dec7$1 = type$6([EventHandler]), _dec$b(_class$b = _dec2$9(_class$b = _dec3$9(_class$b = (_class2$8 = (_class3$5 = class ScrollView extends ViewGroup {
        constructor(...args) {
          super(...args);
          this.bounceDuration = _initializer$8 && _initializer$8();
          this.brake = _initializer2$8 && _initializer2$8();
          this.elastic = _initializer3$6 && _initializer3$6();
          this.inertia = _initializer4$5 && _initializer4$5();
          this.horizontal = _initializer5$3 && _initializer5$3();
          this.vertical = _initializer6$2 && _initializer6$2();
          this.cancelInnerEvents = _initializer7$2 && _initializer7$2();
          this.scrollEvents = _initializer8$2 && _initializer8$2();
          this._autoScrolling = false;
          this._scrolling = false;
          this._content = _initializer9$2 && _initializer9$2();
          this._horizontalScrollBar = _initializer10$2 && _initializer10$2();
          this._verticalScrollBar = _initializer11$2 && _initializer11$2();
          this._topBoundary = 0;
          this._bottomBoundary = 0;
          this._leftBoundary = 0;
          this._rightBoundary = 0;
          this._touchMoveDisplacements = [];
          this._touchMoveTimeDeltas = [];
          this._touchMovePreviousTimestamp = 0;
          this._touchMoved = false;
          this._autoScrollAttenuate = false;
          this._autoScrollStartPosition = new Vec3();
          this._autoScrollTargetDelta = new Vec3();
          this._autoScrollTotalTime = 0;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollCurrentlyOutOfBoundary = false;
          this._autoScrollBraking = false;
          this._autoScrollBrakingStartPosition = new Vec3();
          this._outOfBoundaryAmount = new Vec3();
          this._outOfBoundaryAmountDirty = true;
          this._stopMouseWheel = false;
          this._mouseWheelEventElapsedTime = 0.0;
          this._isScrollEndedWithThresholdEventFired = false;
          this._scrollEventEmitMask = 0;
          this._isBouncing = false;
          this._contentPos = new Vec3();
          this._deltaPos = new Vec3();
          this._deltaAmount = new Vec3();
          this._hoverIn = XrhoverType.NONE;
        }
        get content() {
          return this._content;
        }
        set content(value) {
          if (this._content === value) {
            return;
          }
          const viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;
          if (value && (!value || !viewTrans)) {
            logID(4302);
            return;
          }
          this._content = value;
          this._calculateBoundary();
        }
        get horizontalScrollBar() {
          if (this._horizontalScrollBar && !this._horizontalScrollBar.isValid) {
            errorID(4303, 'horizontal', this.node.name);
          }
          return this._horizontalScrollBar;
        }
        set horizontalScrollBar(value) {
          if (this._horizontalScrollBar === value) {
            return;
          }
          this._horizontalScrollBar = value;
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.setScrollView(this);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        get verticalScrollBar() {
          if (this._verticalScrollBar && !this._verticalScrollBar.isValid) {
            errorID(4303, 'vertical', this.node.name);
          }
          return this._verticalScrollBar;
        }
        set verticalScrollBar(value) {
          if (this._verticalScrollBar === value) {
            return;
          }
          this._verticalScrollBar = value;
          if (this._verticalScrollBar) {
            this._verticalScrollBar.setScrollView(this);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        get view() {
          const parent = this._content && this._content.parent;
          if (!parent) {
            return null;
          }
          return parent._uiProps.uiTransformComp;
        }
        scrollToBottom(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta, true);
          }
        }
        scrollToTop(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToTopLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToTopRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToBottomLeft(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToBottomRight(timeInSecond, attenuated = true) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToOffset(offset, timeInSecond, attenuated = true) {
          const maxScrollOffset = this.getMaxScrollOffset();
          const anchor = new Vec2(0, 0);
          if (maxScrollOffset.x === 0) {
            anchor.x = 0;
          } else {
            anchor.x = offset.x / maxScrollOffset.x;
          }
          if (maxScrollOffset.y === 0) {
            anchor.y = 1;
          } else {
            anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
          }
          this.scrollTo(anchor, timeInSecond, attenuated);
        }
        getScrollOffset() {
          const topDelta = this._getContentTopBoundary() - this._topBoundary;
          const leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          return new Vec2(leftDelta, topDelta);
        }
        getMaxScrollOffset() {
          if (!this._content || !this.view) {
            return Vec2.ZERO;
          }
          const contentSize = this._content._uiProps.uiTransformComp.contentSize;
          let horizontalMaximizeOffset = contentSize.width - this.view.width;
          let verticalMaximizeOffset = contentSize.height - this.view.height;
          horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
          verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
          return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
        }
        scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(percent, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollTo(anchor, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(anchor),
            applyToHorizontal: true,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        }
        scrollToPercentVertical(percent, timeInSecond, attenuated) {
          const moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, percent),
            applyToHorizontal: false,
            applyToVertical: true
          });
          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        }
        stopAutoScroll() {
          this._autoScrolling = false;
          this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }
        setContentPosition(position) {
          this._setContentPosition(position);
        }
        _setContentPosition(position) {
          if (!this._content) {
            return;
          }
          const contentPos = this._getContentPosition();
          if (Math.abs(position.x - contentPos.x) < EPSILON && Math.abs(position.y - contentPos.y) < EPSILON) {
            return;
          }
          this._content.setPosition(position);
          this._outOfBoundaryAmountDirty = true;
        }
        getContentPosition() {
          return this._getContentPosition();
        }
        _getContentPosition() {
          if (!this._content) {
            return Vec3.ZERO.clone();
          }
          this._contentPos.set(this._content.position);
          return this._contentPos;
        }
        isScrolling() {
          return this._scrolling;
        }
        isAutoScrolling() {
          return this._autoScrolling;
        }
        getScrollEndedEventTiming() {
          return EPSILON;
        }
        start() {
          this._calculateBoundary();
          if (this._content) {
            director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
          }
        }
        onEnable() {
          {
            this._registerEvent();
            if (this._content) {
              this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
              if (this.view) {
                this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
            this._calculateBoundary();
          }
          this._updateScrollBarState();
        }
        update(dt) {
          const deltaAmount = this._deltaAmount;
          if (this._autoScrolling) {
            this._processAutoScrolling(dt);
            deltaAmount.x = 0;
            deltaAmount.y = 0;
          } else if (deltaAmount.x !== 0 || deltaAmount.y !== 0) {
            this._processDeltaMove(deltaAmount);
            deltaAmount.x = 0;
            deltaAmount.y = 0;
          }
        }
        onDisable() {
          {
            this._unregisterEvent();
            if (this._content) {
              this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
              if (this.view) {
                this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
          }
          this._deltaAmount.set(0, 0);
          this._hideScrollBar();
          this.stopAutoScroll();
        }
        _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.on(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.on(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.on(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        }
        _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
          this.node.off(XrUIPressEventType.XRUI_HOVER_ENTERED, this._xrHoverEnter, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_EXITED, this._xrHoverExit, this);
          input.off(Input.EventType.HANDLE_INPUT, this._dispatchEventHandleInput, this);
          input.off(Input.EventType.GAMEPAD_INPUT, this._dispatchEventHandleInput, this);
        }
        _onMouseWheel(event, captureListeners) {
          if (!this.enabledInHierarchy) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          const deltaMove = new Vec3();
          const wheelPrecision = -0.1;
          const scrollY = event.getScrollY();
          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }
          this._mouseWheelEventElapsedTime = 0;
          this._deltaAmount.add(deltaMove);
          if (!this._stopMouseWheel) {
            this._handlePressLogic();
            this.schedule(this._checkMouseWheel, 1.0 / 60);
            this._stopMouseWheel = true;
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchBegan(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          this._handlePressLogic();
          this._touchMoved = false;
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchMoved(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          const touch = event.touch;
          this._handleMoveLogic(touch);
          if (!this.cancelInnerEvents) {
            return;
          }
          const deltaMove = touch.getUILocation(_tempVec2$1);
          deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1$1));
          if (deltaMove.length() > 7) {
            if (!this._touchMoved && event.target !== this.node) {
              const cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
              cancelEvent.touch = event.touch;
              cancelEvent.simulate = true;
              event.target.dispatchEvent(cancelEvent);
              this._touchMoved = true;
            }
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _onTouchEnded(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content || !event) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          this._dispatchEvent(EventType$2.TOUCH_UP);
          const touch = event.touch;
          this._handleReleaseLogic(touch);
          if (this._touchMoved) {
            event.propagationStopped = true;
          } else {
            this._stopPropagationIfTargetIsMe(event);
          }
        }
        _onTouchCancelled(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }
          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }
          if (event && !event.simulate) {
            const touch = event.touch;
            this._handleReleaseLogic(touch);
          }
          this._stopPropagationIfTargetIsMe(event);
        }
        _calculateBoundary() {
          if (this._content && this.view) {
            const layout = this._content.getComponent(Layout);
            if (layout && layout.enabledInHierarchy) {
              layout.updateLayout();
            }
            const viewTrans = this.view;
            const anchorX = viewTrans.width * viewTrans.anchorX;
            const anchorY = viewTrans.height * viewTrans.anchorY;
            this._leftBoundary = -anchorX;
            this._bottomBoundary = -anchorY;
            this._rightBoundary = this._leftBoundary + viewTrans.width;
            this._topBoundary = this._bottomBoundary + viewTrans.height;
            this._moveContentToTopLeft(viewTrans.contentSize);
          }
        }
        _hasNestedViewGroup(event, captureListeners) {
          if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
            return false;
          }
          if (captureListeners) {
            for (const listener of captureListeners) {
              const item = listener;
              if (this.node === item) {
                if (event.target && event.target.getComponent(ViewGroup)) {
                  return true;
                }
                return false;
              }
              if (item.getComponent(ViewGroup)) {
                return true;
              }
            }
          }
          return false;
        }
        _startInertiaScroll(touchMoveVelocity) {
          const inertiaTotalMovement = new Vec3(touchMoveVelocity);
          inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);
          this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        }
        _calculateAttenuatedFactor(distance) {
          if (this.brake <= 0) {
            return 1 - this.brake;
          }
          return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
        }
        _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
          const targetDelta = deltaMove.clone();
          targetDelta.normalize();
          if (this._content && this.view) {
            const contentSize = this._content._uiProps.uiTransformComp.contentSize;
            const scrollViewSize = this.view.contentSize;
            const totalMoveWidth = contentSize.width - scrollViewSize.width;
            const totalMoveHeight = contentSize.height - scrollViewSize.height;
            const attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
            const attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
            targetDelta.z = 0;
          }
          const originalMoveLength = deltaMove.length();
          let factor = targetDelta.length() / originalMoveLength;
          targetDelta.add(deltaMove);
          if (this.brake > 0 && factor > 7) {
            factor = Math.sqrt(factor);
            const clonedDeltaMove = deltaMove.clone();
            clonedDeltaMove.multiplyScalar(factor);
            targetDelta.set(clonedDeltaMove);
            targetDelta.add(deltaMove);
          }
          let time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());
          if (this.brake > 0 && factor > 3) {
            factor = 3;
            time *= factor;
          }
          if (this.brake === 0 && factor > 1) {
            time *= factor;
          }
          this._startAutoScroll(targetDelta, time, true);
        }
        _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
          return Math.sqrt(Math.sqrt(initialSpeed / 5));
        }
        _startAutoScroll(deltaMove, timeInSecond, attenuated = false) {
          const adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
          this._autoScrolling = true;
          this._autoScrollTargetDelta = adjustedDeltaMove;
          this._autoScrollAttenuate = attenuated;
          Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
          this._autoScrollTotalTime = timeInSecond;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollBraking = false;
          this._isScrollEndedWithThresholdEventFired = false;
          this._autoScrollBrakingStartPosition.set(0, 0, 0);
          const currentOutOfBoundary = this._getHowMuchOutOfBoundary();
          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON)) {
            this._autoScrollCurrentlyOutOfBoundary = true;
          }
        }
        _calculateTouchMoveVelocity() {
          const out = new Vec3();
          let totalTime = 0;
          totalTime = this._touchMoveTimeDeltas.reduce((a, b) => a + b, totalTime);
          if (totalTime <= 0 || totalTime >= 0.5) {
            out.set(Vec3.ZERO);
          } else {
            let totalMovement = new Vec3();
            totalMovement = this._touchMoveDisplacements.reduce((a, b) => {
              a.add(b);
              return a;
            }, totalMovement);
            out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
          }
          return out;
        }
        _flattenVectorByDirection(vector) {
          const result = vector;
          result.x = this.horizontal ? result.x : 0;
          result.y = this.vertical ? result.y : 0;
          return result;
        }
        _moveContent(deltaMove, canStartBounceBack) {
          const adjustedMove = this._flattenVectorByDirection(deltaMove);
          _tempVec3.set(this._getContentPosition());
          _tempVec3.add(adjustedMove);
          _tempVec3.set(Math.round(_tempVec3.x * TOLERANCE) * EPSILON, Math.round(_tempVec3.y * TOLERANCE) * EPSILON, _tempVec3.z);
          this._setContentPosition(_tempVec3);
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);
          this._updateScrollBar(_tempVec2$1);
          if (this.elastic && canStartBounceBack) {
            this._startBounceBackIfNeeded();
          }
        }
        _getContentLeftBoundary() {
          if (!this._content) {
            return -1;
          }
          const contentPos = this._getContentPosition();
          const uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.x - uiTrans.anchorX * uiTrans.width;
        }
        _getContentRightBoundary() {
          if (!this._content) {
            return -1;
          }
          const uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentLeftBoundary() + uiTrans.width;
        }
        _getContentTopBoundary() {
          if (!this._content) {
            return -1;
          }
          const uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentBottomBoundary() + uiTrans.height;
        }
        _getContentBottomBoundary() {
          if (!this._content) {
            return -1;
          }
          const contentPos = this._getContentPosition();
          const uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.y - uiTrans.anchorY * uiTrans.height;
        }
        _getHowMuchOutOfBoundary(addition) {
          addition = addition || new Vec3();
          if (addition.equals(Vec3.ZERO, EPSILON) && !this._outOfBoundaryAmountDirty) {
            return this._outOfBoundaryAmount;
          }
          const outOfBoundaryAmount = new Vec3();
          const tempLeftBoundary = this._getContentLeftBoundary();
          const tempRightBoundary = this._getContentRightBoundary();
          if (tempLeftBoundary + addition.x > this._leftBoundary) {
            outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
          } else if (tempRightBoundary + addition.x < this._rightBoundary) {
            outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
          }
          const tempTopBoundary = this._getContentTopBoundary();
          const tempBottomBoundary = this._getContentBottomBoundary();
          if (tempTopBoundary + addition.y < this._topBoundary) {
            outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
          } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
            outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
          }
          if (addition.equals(Vec3.ZERO, EPSILON)) {
            this._outOfBoundaryAmount = outOfBoundaryAmount;
            this._outOfBoundaryAmountDirty = false;
          }
          this._clampDelta(outOfBoundaryAmount);
          return outOfBoundaryAmount;
        }
        _updateScrollBar(outOfBoundary) {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onScroll(outOfBoundary);
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onScroll(outOfBoundary);
          }
        }
        _onScrollBarTouchBegan() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onTouchBegan();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onTouchBegan();
          }
        }
        _onScrollBarTouchEnded() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.onTouchEnded();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.onTouchEnded();
          }
        }
        _dispatchEvent(event) {
          if (event === EventType$2.SCROLL_ENDED) {
            this._scrollEventEmitMask = 0;
          } else if (event === EventType$2.SCROLL_TO_TOP || event === EventType$2.SCROLL_TO_BOTTOM || event === EventType$2.SCROLL_TO_LEFT || event === EventType$2.SCROLL_TO_RIGHT) {
            const flag = 1 << eventMap[event];
            if (this._scrollEventEmitMask & flag) {
              return;
            } else {
              this._scrollEventEmitMask |= flag;
            }
          }
          EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
          this.node.emit(event, this);
        }
        _adjustContentOutOfBoundary() {
          if (!this._content) {
            return;
          }
          this._outOfBoundaryAmountDirty = true;
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          const _isOutOfBoundary = !outOfBoundary.equals(Vec3.ZERO, EPSILON);
          if (_isOutOfBoundary) {
            _tempVec3.set(this._getContentPosition());
            _tempVec3.add(outOfBoundary);
            this._setContentPosition(_tempVec3);
            this._updateScrollBar(Vec2.ZERO);
          }
        }
        _hideScrollBar() {
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            this._horizontalScrollBar.hide();
          }
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            this._verticalScrollBar.hide();
          }
        }
        _updateScrollBarState() {
          if (!this._content || !this.view) {
            return;
          }
          const viewTrans = this.view;
          const uiTrans = this._content._uiProps.uiTransformComp;
          if (this._verticalScrollBar && this._verticalScrollBar.isValid) {
            if (uiTrans.height < viewTrans.height || approx(uiTrans.height, viewTrans.height)) {
              this._verticalScrollBar.hide();
            } else {
              this._verticalScrollBar.show();
            }
          }
          if (this._horizontalScrollBar && this._horizontalScrollBar.isValid) {
            if (uiTrans.width < viewTrans.width || approx(uiTrans.width, viewTrans.width)) {
              this._horizontalScrollBar.hide();
            } else {
              this._horizontalScrollBar.show();
            }
          }
        }
        _stopPropagationIfTargetIsMe(event) {
          if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
            event.propagationStopped = true;
          }
        }
        _processDeltaMove(deltaMove) {
          this._scrollChildren(deltaMove);
          this._gatherTouchMove(deltaMove);
        }
        _handleMoveLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);
          this._deltaAmount.add(this._deltaPos);
        }
        _handleReleaseLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);
          this._gatherTouchMove(this._deltaPos);
          this._processInertiaScroll();
          if (this._scrolling) {
            this._scrolling = false;
            if (!this._autoScrolling) {
              this._dispatchEvent(EventType$2.SCROLL_ENDED);
            }
          }
        }
        _getLocalAxisAlignDelta(out, touch) {
          const uiTransformComp = this.node._uiProps.uiTransformComp;
          const vec = new Vec3();
          if (uiTransformComp) {
            touch.getUILocation(_tempVec2$1);
            touch.getUIPreviousLocation(_tempVec2_1$1);
            _tempVec3.set(_tempVec2$1.x, _tempVec2$1.y, 0);
            _tempVec3_1.set(_tempVec2_1$1.x, _tempVec2_1$1.y, 0);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3, _tempVec3);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
            Vec3.subtract(vec, _tempVec3, _tempVec3_1);
          }
          out.set(vec);
        }
        _scrollChildren(deltaMove) {
          this._clampDelta(deltaMove);
          const realMove = deltaMove;
          let outOfBoundary;
          if (this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary();
            realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
            realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
          }
          if (!this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
            realMove.add(outOfBoundary);
          }
          let verticalScrollEventType = EventType$2.NONE;
          let horizontalScrollEventType = EventType$2.NONE;
          if (this._content) {
            const {
              anchorX,
              anchorY,
              width,
              height
            } = this._content._uiProps.uiTransformComp;
            const pos = this._content.position || Vec3.ZERO;
            if (this.vertical) {
              if (realMove.y > 0) {
                const icBottomPos = pos.y - anchorY * height;
                if (icBottomPos + realMove.y >= this._bottomBoundary) {
                  verticalScrollEventType = EventType$2.SCROLL_TO_BOTTOM;
                }
              } else if (realMove.y < 0) {
                const icTopPos = pos.y - anchorY * height + height;
                if (icTopPos + realMove.y <= this._topBoundary) {
                  verticalScrollEventType = EventType$2.SCROLL_TO_TOP;
                }
              }
            }
            if (this.horizontal) {
              if (realMove.x < 0) {
                const icRightPos = pos.x - anchorX * width + width;
                if (icRightPos + realMove.x <= this._rightBoundary) {
                  horizontalScrollEventType = EventType$2.SCROLL_TO_RIGHT;
                }
              } else if (realMove.x > 0) {
                const icLeftPos = pos.x - anchorX * width;
                if (icLeftPos + realMove.x >= this._leftBoundary) {
                  horizontalScrollEventType = EventType$2.SCROLL_TO_LEFT;
                }
              }
            }
          }
          this._moveContent(realMove, false);
          if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
            if (!this._scrolling) {
              this._scrolling = true;
              this._dispatchEvent(EventType$2.SCROLL_BEGAN);
            }
            this._dispatchEvent(EventType$2.SCROLLING);
          }
          if (verticalScrollEventType !== EventType$2.NONE) {
            this._dispatchEvent(verticalScrollEventType);
          }
          if (horizontalScrollEventType !== EventType$2.NONE) {
            this._dispatchEvent(horizontalScrollEventType);
          }
        }
        _handlePressLogic() {
          if (this._autoScrolling) {
            this._dispatchEvent(EventType$2.SCROLL_ENDED);
          }
          this._autoScrolling = false;
          this._isBouncing = false;
          this._touchMovePreviousTimestamp = getTimeInMilliseconds();
          this._touchMoveDisplacements.length = 0;
          this._touchMoveTimeDeltas.length = 0;
          this._onScrollBarTouchBegan();
        }
        _clampDelta(out) {
          if (this._content && this.view) {
            const scrollViewSize = this.view.contentSize;
            const uiTrans = this._content._uiProps.uiTransformComp;
            if (uiTrans.width < scrollViewSize.width) {
              out.x = 0;
            }
            if (uiTrans.height < scrollViewSize.height) {
              out.y = 0;
            }
          }
        }
        _gatherTouchMove(delta) {
          const clampDt = delta.clone();
          this._clampDelta(clampDt);
          while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
            this._touchMoveDisplacements.shift();
            this._touchMoveTimeDeltas.shift();
          }
          this._touchMoveDisplacements.push(clampDt);
          const timeStamp = getTimeInMilliseconds();
          this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);
          this._touchMovePreviousTimestamp = timeStamp;
        }
        _startBounceBackIfNeeded() {
          if (!this.elastic) {
            return false;
          }
          const bounceBackAmount = this._getHowMuchOutOfBoundary();
          this._clampDelta(bounceBackAmount);
          if (bounceBackAmount.equals(Vec3.ZERO, EPSILON)) {
            return false;
          }
          const bounceBackTime = Math.max(this.bounceDuration, 0);
          this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
          if (!this._isBouncing) {
            if (bounceBackAmount.y > 0) {
              this._dispatchEvent(EventType$2.BOUNCE_TOP);
            }
            if (bounceBackAmount.y < 0) {
              this._dispatchEvent(EventType$2.BOUNCE_BOTTOM);
            }
            if (bounceBackAmount.x > 0) {
              this._dispatchEvent(EventType$2.BOUNCE_RIGHT);
            }
            if (bounceBackAmount.x < 0) {
              this._dispatchEvent(EventType$2.BOUNCE_LEFT);
            }
            this._isBouncing = true;
          }
          return true;
        }
        _processInertiaScroll() {
          const bounceBackStarted = this._startBounceBackIfNeeded();
          if (!bounceBackStarted && this.inertia) {
            const touchMoveVelocity = this._calculateTouchMoveVelocity();
            if (!touchMoveVelocity.equals(_tempVec3, EPSILON) && this.brake < 1) {
              this._startInertiaScroll(touchMoveVelocity);
            }
          }
          this._onScrollBarTouchEnded();
        }
        _isOutOfBoundary() {
          const outOfBoundary = this._getHowMuchOutOfBoundary();
          return !outOfBoundary.equals(Vec3.ZERO, EPSILON);
        }
        _isNecessaryAutoScrollBrake() {
          if (this._autoScrollBraking) {
            return true;
          }
          if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary) {
              this._autoScrollCurrentlyOutOfBoundary = true;
              this._autoScrollBraking = true;
              Vec3.copy(this._autoScrollBrakingStartPosition, this._getContentPosition());
              return true;
            }
          } else {
            this._autoScrollCurrentlyOutOfBoundary = false;
          }
          return false;
        }
        _processAutoScrolling(dt) {
          const isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
          const brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
          this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
          let percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
          if (this._autoScrollAttenuate) {
            percentage = quintEaseOut(percentage);
          }
          const clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();
          clonedAutoScrollTargetDelta.multiplyScalar(percentage);
          const clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();
          clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
          let reachedEnd = Math.abs(percentage - 1) <= EPSILON;
          const fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
          if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
            this._dispatchEvent(EventType$2.SCROLL_ENG_WITH_THRESHOLD);
            this._isScrollEndedWithThresholdEventFired = true;
          }
          if (this.elastic) {
            const brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
            brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);
            if (isAutoScrollBrake) {
              brakeOffsetPosition.multiplyScalar(brakingFactor);
            }
            clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
            clonedAutoScrollStartPosition.add(brakeOffsetPosition);
          } else {
            const moveDelta = clonedAutoScrollStartPosition.clone();
            moveDelta.subtract(this.getContentPosition());
            const outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
            if (!outOfBoundary.equals(Vec3.ZERO, EPSILON)) {
              clonedAutoScrollStartPosition.add(outOfBoundary);
              reachedEnd = true;
            }
          }
          if (reachedEnd) {
            this._autoScrolling = false;
          }
          const deltaMove = clonedAutoScrollStartPosition.clone();
          deltaMove.subtract(this._getContentPosition());
          this._clampDelta(deltaMove);
          this._moveContent(deltaMove, reachedEnd);
          this._dispatchEvent(EventType$2.SCROLLING);
          if (!this._autoScrolling) {
            this._isBouncing = false;
            this._scrolling = false;
            this._dispatchEvent(EventType$2.SCROLL_ENDED);
          }
        }
        _checkMouseWheel(dt) {
          const currentOutOfBoundary = this._getHowMuchOutOfBoundary();
          const maxElapsedTime = 0.1;
          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON)) {
            this._processInertiaScroll();
            if (this._scrolling) {
              this._scrolling = false;
              if (!this._autoScrolling) {
                this._dispatchEvent(EventType$2.SCROLL_ENDED);
              }
            }
            this.unschedule(this._checkMouseWheel);
            this._stopMouseWheel = false;
            return;
          }
          this._mouseWheelEventElapsedTime += dt;
          if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
            this._onScrollBarTouchEnded();
            if (this._scrolling) {
              this._scrolling = false;
              if (!this._autoScrolling) {
                this._dispatchEvent(EventType$2.SCROLL_ENDED);
              }
            }
            this.unschedule(this._checkMouseWheel);
            this._stopMouseWheel = false;
          }
        }
        _calculateMovePercentDelta(options) {
          const anchor = options.anchor;
          const applyToHorizontal = options.applyToHorizontal;
          const applyToVertical = options.applyToVertical;
          this._calculateBoundary();
          anchor.clampf(Vec2.ZERO, Vec2.ONE);
          let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
          bottomDelta = -bottomDelta;
          let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          leftDelta = -leftDelta;
          const moveDelta = new Vec3();
          if (this._content && this.view) {
            let totalScrollDelta = 0;
            const uiTrans = this._content._uiProps.uiTransformComp;
            const contentSize = uiTrans.contentSize;
            const scrollSize = this.view.contentSize;
            if (applyToHorizontal) {
              totalScrollDelta = contentSize.width - scrollSize.width;
              moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
            }
            if (applyToVertical) {
              totalScrollDelta = contentSize.height - scrollSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
            }
          }
          return moveDelta;
        }
        _moveContentToTopLeft(scrollViewSize) {
          let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
          bottomDelta = -bottomDelta;
          const moveDelta = new Vec3();
          let totalScrollDelta = 0;
          let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
          leftDelta = -leftDelta;
          if (this._content) {
            const uiTrans = this._content._uiProps.uiTransformComp;
            const contentSize = uiTrans.contentSize;
            if (contentSize.height < scrollViewSize.height) {
              totalScrollDelta = contentSize.height - scrollViewSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta;
            }
            if (contentSize.width < scrollViewSize.width) {
              totalScrollDelta = contentSize.width - scrollViewSize.width;
              moveDelta.x = leftDelta;
            }
          }
          this._updateScrollBarState();
          this._moveContent(moveDelta);
          this._adjustContentOutOfBoundary();
        }
        _scaleChanged(value) {
          if (value === TransformBit.SCALE) {
            this._calculateBoundary();
          }
        }
        _xrHoverEnter(event) {
          if (event.deviceType === DeviceType.Left) {
            this._hoverIn = XrhoverType.LEFT;
          } else if (event.deviceType === DeviceType.Right) {
            this._hoverIn = XrhoverType.RIGHT;
          }
        }
        _xrHoverExit(event) {
          this._hoverIn = XrhoverType.NONE;
        }
        _dispatchEventHandleInput(event) {
          let handleInputDevice;
          if (event instanceof EventGamepad) {
            handleInputDevice = event.gamepad;
          } else if (event instanceof EventHandle) {
            handleInputDevice = event.handleInputDevice;
          }
          let value;
          if (!this.enabledInHierarchy || this._hoverIn === XrhoverType.NONE) {
            return;
          }
          if (this._hoverIn === XrhoverType.LEFT) {
            value = handleInputDevice.leftStick.getValue();
            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          } else if (this._hoverIn === XrhoverType.RIGHT) {
            value = handleInputDevice.rightStick.getValue();
            if (!value.equals(Vec2.ZERO)) {
              this._xrThumbStickMove(value);
            }
          }
        }
        _xrThumbStickMove(event) {
          if (!this.enabledInHierarchy) {
            return;
          }
          const deltaMove = new Vec3();
          const wheelPrecision = -62.5;
          const scrollY = event.y;
          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }
          this._mouseWheelEventElapsedTime = 0;
          this._deltaAmount.add(deltaMove);
          if (!this._stopMouseWheel) {
            this._handlePressLogic();
            this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
            this._stopMouseWheel = true;
          }
        }
      }, _class3$5.EventType = EventType$2, _class3$5), (_initializer$8 = applyDecoratedInitializer(_class2$8.prototype, "bounceDuration", [serializable$6], function () {
        return 1;
      }), _initializer2$8 = applyDecoratedInitializer(_class2$8.prototype, "brake", [serializable$6], function () {
        return 0.5;
      }), _initializer3$6 = applyDecoratedInitializer(_class2$8.prototype, "elastic", [serializable$6], function () {
        return true;
      }), _initializer4$5 = applyDecoratedInitializer(_class2$8.prototype, "inertia", [serializable$6], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "content", [_dec4$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "content"), _class2$8.prototype), _initializer5$3 = applyDecoratedInitializer(_class2$8.prototype, "horizontal", [serializable$6], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "horizontalScrollBar", [_dec5$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "horizontalScrollBar"), _class2$8.prototype), _initializer6$2 = applyDecoratedInitializer(_class2$8.prototype, "vertical", [serializable$6], function () {
        return true;
      }), _applyDecoratedDescriptor(_class2$8.prototype, "verticalScrollBar", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$8.prototype, "verticalScrollBar"), _class2$8.prototype), _initializer7$2 = applyDecoratedInitializer(_class2$8.prototype, "cancelInnerEvents", [serializable$6], function () {
        return true;
      }), _initializer8$2 = applyDecoratedInitializer(_class2$8.prototype, "scrollEvents", [_dec7$1, serializable$6], function () {
        return [];
      }), _initializer9$2 = applyDecoratedInitializer(_class2$8.prototype, "_content", [serializable$6], function () {
        return null;
      }), _initializer10$2 = applyDecoratedInitializer(_class2$8.prototype, "_horizontalScrollBar", [serializable$6], function () {
        return null;
      }), _initializer11$2 = applyDecoratedInitializer(_class2$8.prototype, "_verticalScrollBar", [serializable$6], function () {
        return null;
      })), _class2$8)) || _class$b) || _class$b) || _class$b); exports({ ScrollView: ScrollView, ScrollViewComponent: ScrollView });
      legacyCC.ScrollView = ScrollView;

      var _dec$a, _dec2$8, _dec3$8, _dec4$5, _dec5$5, _dec6$1, _class$a, _class2$7, _initializer$7, _initializer2$7, _initializer3$5, _initializer4$4, _class3$4;
      const _tempPos$1 = new Vec3();
      var Direction$2;
      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$2 || (Direction$2 = {}));
      ccenum(Direction$2);
      let Slider = (_dec$a = ccclass$6('cc.Slider'), _dec2$8 = executionOrder$1(110), _dec3$8 = requireComponent(UITransform), _dec4$5 = type$6(Sprite), _dec5$5 = type$6(Direction$2), _dec6$1 = type$6([EventHandler]), _dec$a(_class$a = _dec2$8(_class$a = _dec3$8(_class$a = (_class2$7 = (_class3$4 = class Slider extends Component {
        constructor(...args) {
          super(...args);
          this.slideEvents = _initializer$7 && _initializer$7();
          this._handle = _initializer2$7 && _initializer2$7();
          this._direction = _initializer3$5 && _initializer3$5();
          this._progress = _initializer4$4 && _initializer4$4();
          this._offset = new Vec3();
          this._dragging = false;
          this._touchHandle = false;
          this._handleLocalPos = new Vec3();
          this._touchPos = new Vec3();
        }
        get handle() {
          return this._handle;
        }
        set handle(value) {
          if (this._handle === value) {
            return;
          }
          this._handle = value;
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this._changeLayout();
        }
        get progress() {
          return this._progress;
        }
        set progress(value) {
          if (this._progress === value) {
            return;
          }
          this._progress = value;
          this._updateHandlePosition();
        }
        __preload() {
          this._updateHandlePosition();
        }
        onEnable() {
          this._updateHandlePosition();
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.on(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.on(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.on(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          if (this._handle && this._handle.isValid) {
            this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);
            this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
            this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        }
        onDisable() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);
          this.node.off(XrUIPressEventType.XRUI_HOVER_STAY, this._xrHoverStay, this);
          this.node.off(XrUIPressEventType.XRUI_CLICK, this._xrClick, this);
          this.node.off(XrUIPressEventType.XRUI_UNCLICK, this._xrUnClick, this);
          if (this._handle && this._handle.isValid) {
            this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);
            this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
            this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        }
        _onHandleDragStart(event) {
          if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
            return;
          }
          this._dragging = true;
          this._touchHandle = true;
          const touhPos = event.touch.getUILocation();
          Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);
          this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);
          event.propagationStopped = true;
        }
        _onTouchBegan(event) {
          if (!this._handle || !event) {
            return;
          }
          this._dragging = true;
          if (!this._touchHandle) {
            this._handleSliderLogic(event.touch);
          }
          event.propagationStopped = true;
        }
        _onTouchMoved(event) {
          if (!this._dragging || !event) {
            return;
          }
          this._handleSliderLogic(event.touch);
          event.propagationStopped = true;
        }
        _onTouchEnded(event) {
          this._dragging = false;
          this._touchHandle = false;
          this._offset = new Vec3();
          if (event) {
            event.propagationStopped = true;
          }
        }
        _onTouchCancelled(event) {
          this._dragging = false;
          if (event) {
            event.propagationStopped = true;
          }
        }
        _handleSliderLogic(touch) {
          this._updateProgress(touch);
          this._emitSlideEvent();
        }
        _emitSlideEvent() {
          EventHandler.emitEvents(this.slideEvents, this);
          this.node.emit('slide', this);
        }
        _updateProgress(touch) {
          if (!this._handle || !touch) {
            return;
          }
          const touchPos = touch.getUILocation();
          Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
          const uiTrans = this.node._uiProps.uiTransformComp;
          const localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos$1);
          if (this.direction === Direction$2.Horizontal) {
            this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
          } else {
            this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
          }
        }
        _updateHandlePosition() {
          if (!this._handle) {
            return;
          }
          this._handleLocalPos.set(this._handle.node.getPosition());
          const uiTrans = this.node._uiProps.uiTransformComp;
          if (this._direction === Direction$2.Horizontal) {
            this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
          } else {
            this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
          }
          this._handle.node.setPosition(this._handleLocalPos);
        }
        _changeLayout() {
          const uiTrans = this.node._uiProps.uiTransformComp;
          const contentSize = uiTrans.contentSize;
          uiTrans.setContentSize(contentSize.height, contentSize.width);
          if (this._handle) {
            const pos = this._handle.node.position;
            if (this._direction === Direction$2.Horizontal) {
              this._handle.node.setPosition(pos.x, 0, pos.z);
            } else {
              this._handle.node.setPosition(0, pos.y, pos.z);
            }
            this._updateHandlePosition();
          }
        }
        _xrHandleProgress(point) {
          if (!this._touchHandle) {
            const uiTrans = this.node._uiProps.uiTransformComp;
            uiTrans.convertToNodeSpaceAR(point, _tempPos$1);
            if (this.direction === Direction$2.Horizontal) {
              this.progress = clamp01(0.5 + (_tempPos$1.x - this.node.position.x) / uiTrans.width);
            } else {
              this.progress = clamp01(0.5 + (_tempPos$1.y - this.node.position.y) / uiTrans.height);
            }
          }
        }
        _xrClick(event) {
          if (!this._handle) {
            return;
          }
          this._dragging = true;
          this._xrHandleProgress(event.hitPoint);
          this._emitSlideEvent();
        }
        _xrUnClick() {
          this._dragging = false;
          this._touchHandle = false;
        }
        _xrHoverStay(event) {
          if (!this._dragging) {
            return;
          }
          this._xrHandleProgress(event.hitPoint);
          this._emitSlideEvent();
        }
      }, _class3$4.Direction = Direction$2, _class3$4), (_applyDecoratedDescriptor(_class2$7.prototype, "handle", [_dec4$5], Object.getOwnPropertyDescriptor(_class2$7.prototype, "handle"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "direction", [_dec5$5], Object.getOwnPropertyDescriptor(_class2$7.prototype, "direction"), _class2$7.prototype), _initializer$7 = applyDecoratedInitializer(_class2$7.prototype, "slideEvents", [_dec6$1, serializable$6], function () {
        return [];
      }), _initializer2$7 = applyDecoratedInitializer(_class2$7.prototype, "_handle", [serializable$6], function () {
        return null;
      }), _initializer3$5 = applyDecoratedInitializer(_class2$7.prototype, "_direction", [serializable$6], function () {
        return Direction$2.Horizontal;
      }), _initializer4$4 = applyDecoratedInitializer(_class2$7.prototype, "_progress", [serializable$6], function () {
        return 0.1;
      })), _class2$7)) || _class$a) || _class$a) || _class$a); exports({ Slider: Slider, SliderComponent: Slider });
      legacyCC.Slider = Slider;

      function extendsEnum(...enums) {
        return Object.assign({}, ...enums);
      }

      var _dec$9, _dec2$7, _dec3$7, _dec4$4, _dec5$4, _class$9, _class2$6, _initializer$6, _initializer2$6, _initializer3$4, _class3$3;
      var EventType$1;
      (function (EventType) {
        EventType["TOGGLE"] = "toggle";
      })(EventType$1 || (EventType$1 = {}));
      let Toggle = (_dec$9 = ccclass$6('cc.Toggle'), _dec2$7 = executionOrder$1(110), _dec3$7 = requireComponent(UITransform), _dec4$4 = type$6(Sprite), _dec5$4 = type$6([EventHandler]), _dec$9(_class$9 = _dec2$7(_class$9 = _dec3$7(_class$9 = (_class2$6 = (_class3$3 = class Toggle extends Button {
        constructor(...args) {
          super(...args);
          this.checkEvents = _initializer$6 && _initializer$6();
          this._isChecked = _initializer2$6 && _initializer2$6();
          this._checkMark = _initializer3$4 && _initializer3$4();
        }
        get isChecked() {
          return this._isChecked;
        }
        set isChecked(value) {
          this._set(value);
        }
        get checkMark() {
          return this._checkMark;
        }
        set checkMark(value) {
          if (this._checkMark === value) {
            return;
          }
          this._checkMark = value;
        }
        set _resizeToTarget(value) {
          if (value) {
            this._resizeNodeToTargetNode();
          }
        }
        get _toggleContainer() {
          const parent = this.node.parent;
          if (legacyCC.Node.isNode(parent)) {
            return parent.getComponent('cc.ToggleContainer');
          }
          return null;
        }
        _internalToggle() {
          this.isChecked = !this.isChecked;
        }
        _set(value, emitEvent = true) {
          if (this._isChecked == value) return;
          this._isChecked = value;
          const group = this._toggleContainer;
          if (group && group.enabled && this.enabled) {
            if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
              this._isChecked = true;
              group.notifyToggleCheck(this, emitEvent);
            }
          }
          this.playEffect();
          if (emitEvent) {
            this._emitToggleEvents();
          }
        }
        playEffect() {
          if (this._checkMark) {
            this._checkMark.node.active = this._isChecked;
          }
        }
        setIsCheckedWithoutNotify(value) {
          this._set(value, false);
        }
        onEnable() {
          super.onEnable();
          this.playEffect();
          {
            this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        }
        onDisable() {
          super.onDisable();
          {
            this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        }
        _emitToggleEvents() {
          this.node.emit(Toggle.EventType.TOGGLE, this);
          if (this.checkEvents) {
            EventHandler.emitEvents(this.checkEvents, this);
          }
        }
      }, _class3$3.EventType = extendsEnum(EventType$1, EventType$4), _class3$3), (_applyDecoratedDescriptor(_class2$6.prototype, "checkMark", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$6.prototype, "checkMark"), _class2$6.prototype), _initializer$6 = applyDecoratedInitializer(_class2$6.prototype, "checkEvents", [_dec5$4, serializable$6], function () {
        return [];
      }), _initializer2$6 = applyDecoratedInitializer(_class2$6.prototype, "_isChecked", [serializable$6], function () {
        return true;
      }), _initializer3$4 = applyDecoratedInitializer(_class2$6.prototype, "_checkMark", [serializable$6], function () {
        return null;
      })), _class2$6)) || _class$9) || _class$9) || _class$9); exports({ Toggle: Toggle, ToggleComponent: Toggle });
      legacyCC.Toggle = Toggle;

      var _dec$8, _dec2$6, _dec3$6, _class$8, _class2$5, _initializer$5, _initializer2$5;
      let ToggleContainer = (_dec$8 = ccclass$6('cc.ToggleContainer'), _dec2$6 = executionOrder$1(110), _dec3$6 = type$6([EventHandler]), _dec$8(_class$8 = _dec2$6(_class$8 = (_class2$5 = class ToggleContainer extends Component {
        constructor(...args) {
          super(...args);
          this._allowSwitchOff = _initializer$5 && _initializer$5();
          this.checkEvents = _initializer2$5 && _initializer2$5();
        }
        get allowSwitchOff() {
          return this._allowSwitchOff;
        }
        set allowSwitchOff(value) {
          this._allowSwitchOff = value;
        }
        get toggleItems() {
          return this.node.children.map(item => {
            const toggle = item.getComponent('cc.Toggle');
            if (toggle && toggle.enabled) {
              return toggle;
            }
            return null;
          }).filter(Boolean);
        }
        onEnable() {
          this.ensureValidState();
          this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        }
        onDisable() {
          this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        }
        activeToggles() {
          return this.toggleItems.filter(x => x.isChecked);
        }
        anyTogglesChecked() {
          return !!this.toggleItems.find(x => x.isChecked);
        }
        notifyToggleCheck(toggle, emitEvent = true) {
          if (!this.enabledInHierarchy) {
            return;
          }
          for (let i = 0; i < this.toggleItems.length; i++) {
            const item = this.toggleItems[i];
            if (item === toggle) {
              continue;
            }
            if (emitEvent) {
              item.isChecked = false;
            } else {
              item.setIsCheckedWithoutNotify(false);
            }
          }
          if (this.checkEvents) {
            legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
          }
        }
        ensureValidState() {
          const toggles = this.toggleItems;
          if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
            const toggle = toggles[0];
            toggle.isChecked = true;
            this.notifyToggleCheck(toggle);
          }
          const activeToggles = this.activeToggles();
          if (activeToggles.length > 1) {
            const firstToggle = activeToggles[0];
            for (let i = 0; i < activeToggles.length; ++i) {
              const toggle = activeToggles[i];
              if (toggle === firstToggle) {
                continue;
              }
              toggle.isChecked = false;
            }
          }
        }
      }, (_initializer$5 = applyDecoratedInitializer(_class2$5.prototype, "_allowSwitchOff", [serializable$6], function () {
        return false;
      }), _initializer2$5 = applyDecoratedInitializer(_class2$5.prototype, "checkEvents", [_dec3$6, serializable$6], function () {
        return [];
      })), _class2$5)) || _class$8) || _class$8); exports({ ToggleContainer: ToggleContainer, ToggleContainerComponent: ToggleContainer });
      legacyCC.ToggleContainer = ToggleContainer;

      var _dec$7, _dec2$5, _dec3$5, _dec4$3, _dec5$3, _class$7, _class2$4, _initializer$4, _initializer2$4, _initializer3$3, _initializer4$3, _initializer5$2, _initializer6$1, _initializer7$1, _initializer8$1, _initializer9$1, _initializer10$1, _initializer11$1, _initializer12$1, _initializer13, _initializer14, _initializer15, _initializer16, _initializer17, _initializer18, _class3$2;
      const _tempScale = new Vec2();
      function getReadonlyNodeSize(parent) {
        if (parent instanceof Scene) {
          return visibleRect;
        } else if (parent._uiProps.uiTransformComp) {
          return parent._uiProps.uiTransformComp.contentSize;
        } else {
          return Size$1.ZERO;
        }
      }
      function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        if (widgetNode.parent) {
          _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
        } else {
          _tempScale.set(0, 0);
        }
        let scaleX = _tempScale.x;
        let scaleY = _tempScale.y;
        let translateX = 0;
        let translateY = 0;
        for (let node = widgetNode.parent;;) {
          if (!node) {
            out_inverseTranslate.x = out_inverseTranslate.y = 0;
            out_inverseScale.x = out_inverseScale.y = 1;
            return;
          }
          const pos = node.getPosition();
          translateX += pos.x;
          translateY += pos.y;
          node = node.parent;
          if (node !== target) {
            if (node) {
              _tempScale.set(node.getScale().x, node.getScale().y);
            } else {
              _tempScale.set(0, 0);
            }
            const sx = _tempScale.x;
            const sy = _tempScale.y;
            translateX *= sx;
            translateY *= sy;
            scaleX *= sx;
            scaleY *= sy;
          } else {
            break;
          }
        }
        out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
        out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
        out_inverseTranslate.x = -translateX;
        out_inverseTranslate.y = -translateY;
      }
      let AlignMode;
      (function (AlignMode) {
        AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
        AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
        AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
      })(AlignMode || (AlignMode = {}));
      ccenum(AlignMode);
      let AlignFlags;
      (function (AlignFlags) {
        AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
        AlignFlags[AlignFlags["MID"] = 2] = "MID";
        AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
        AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
        AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
        AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
        AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
        AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
      })(AlignFlags || (AlignFlags = {}));
      const TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
      const LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
      let Widget = (_dec$7 = ccclass$6('cc.Widget'), _dec2$5 = executionOrder$1(110), _dec3$5 = requireComponent(UITransform), _dec4$3 = type$6(Node$1), _dec5$3 = type$6(AlignMode), _dec$7(_class$7 = _dec2$5(_class$7 = _dec3$5(_class$7 = (_class2$4 = (_class3$2 = class Widget extends Component {
        constructor(...args) {
          super(...args);
          this._lastPos = new Vec3();
          this._lastSize = new Size$1();
          this._dirty = true;
          this._hadAlignOnce = false;
          this._alignFlags = _initializer$4 && _initializer$4();
          this._target = _initializer2$4 && _initializer2$4();
          this._left = _initializer3$3 && _initializer3$3();
          this._right = _initializer4$3 && _initializer4$3();
          this._top = _initializer5$2 && _initializer5$2();
          this._bottom = _initializer6$1 && _initializer6$1();
          this._horizontalCenter = _initializer7$1 && _initializer7$1();
          this._verticalCenter = _initializer8$1 && _initializer8$1();
          this._isAbsLeft = _initializer9$1 && _initializer9$1();
          this._isAbsRight = _initializer10$1 && _initializer10$1();
          this._isAbsTop = _initializer11$1 && _initializer11$1();
          this._isAbsBottom = _initializer12$1 && _initializer12$1();
          this._isAbsHorizontalCenter = _initializer13 && _initializer13();
          this._isAbsVerticalCenter = _initializer14 && _initializer14();
          this._originalWidth = _initializer15 && _initializer15();
          this._originalHeight = _initializer16 && _initializer16();
          this._alignMode = _initializer17 && _initializer17();
          this._lockFlags = _initializer18 && _initializer18();
        }
        get target() {
          return this._target;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          this._unregisterTargetEvents();
          this._target = value;
          this._registerTargetEvents();
          this._validateTargetInDEV();
          this._recursiveDirty();
        }
        get isAlignTop() {
          return (this._alignFlags & AlignFlags.TOP) > 0;
        }
        set isAlignTop(value) {
          this._setAlign(AlignFlags.TOP, value);
          this._recursiveDirty();
        }
        get isAlignBottom() {
          return (this._alignFlags & AlignFlags.BOT) > 0;
        }
        set isAlignBottom(value) {
          this._setAlign(AlignFlags.BOT, value);
          this._recursiveDirty();
        }
        get isAlignLeft() {
          return (this._alignFlags & AlignFlags.LEFT) > 0;
        }
        set isAlignLeft(value) {
          this._setAlign(AlignFlags.LEFT, value);
          this._recursiveDirty();
        }
        get isAlignRight() {
          return (this._alignFlags & AlignFlags.RIGHT) > 0;
        }
        set isAlignRight(value) {
          this._setAlign(AlignFlags.RIGHT, value);
          this._recursiveDirty();
        }
        get isAlignVerticalCenter() {
          return (this._alignFlags & AlignFlags.MID) > 0;
        }
        set isAlignVerticalCenter(value) {
          if (value) {
            this.isAlignTop = false;
            this.isAlignBottom = false;
            this._alignFlags |= AlignFlags.MID;
          } else {
            this._alignFlags &= ~AlignFlags.MID;
          }
          this._recursiveDirty();
        }
        get isAlignHorizontalCenter() {
          return (this._alignFlags & AlignFlags.CENTER) > 0;
        }
        set isAlignHorizontalCenter(value) {
          if (value) {
            this.isAlignLeft = false;
            this.isAlignRight = false;
            this._alignFlags |= AlignFlags.CENTER;
          } else {
            this._alignFlags &= ~AlignFlags.CENTER;
          }
          this._recursiveDirty();
        }
        get isStretchWidth() {
          return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
        }
        get isStretchHeight() {
          return (this._alignFlags & TOP_BOT) === TOP_BOT;
        }
        get top() {
          return this._top;
        }
        set top(value) {
          this._top = value;
          this._recursiveDirty();
        }
        get editorTop() {
          return this._isAbsTop ? this._top : this._top * 100;
        }
        set editorTop(value) {
          this._top = this._isAbsTop ? value : value / 100;
          this._recursiveDirty();
        }
        get bottom() {
          return this._bottom;
        }
        set bottom(value) {
          this._bottom = value;
          this._recursiveDirty();
        }
        get editorBottom() {
          return this._isAbsBottom ? this._bottom : this._bottom * 100;
        }
        set editorBottom(value) {
          this._bottom = this._isAbsBottom ? value : value / 100;
          this._recursiveDirty();
        }
        get left() {
          return this._left;
        }
        set left(value) {
          this._left = value;
          this._recursiveDirty();
        }
        get editorLeft() {
          return this._isAbsLeft ? this._left : this._left * 100;
        }
        set editorLeft(value) {
          this._left = this._isAbsLeft ? value : value / 100;
          this._recursiveDirty();
        }
        get right() {
          return this._right;
        }
        set right(value) {
          this._right = value;
          this._recursiveDirty();
        }
        get editorRight() {
          return this._isAbsRight ? this._right : this._right * 100;
        }
        set editorRight(value) {
          this._right = this._isAbsRight ? value : value / 100;
          this._recursiveDirty();
        }
        get horizontalCenter() {
          return this._horizontalCenter;
        }
        set horizontalCenter(value) {
          this._horizontalCenter = value;
          this._recursiveDirty();
        }
        get editorHorizontalCenter() {
          return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
        }
        set editorHorizontalCenter(value) {
          this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;
          this._recursiveDirty();
        }
        get verticalCenter() {
          return this._verticalCenter;
        }
        set verticalCenter(value) {
          this._verticalCenter = value;
          this._recursiveDirty();
        }
        get editorVerticalCenter() {
          return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
        }
        set editorVerticalCenter(value) {
          this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;
          this._recursiveDirty();
        }
        get isAbsoluteTop() {
          return this._isAbsTop;
        }
        set isAbsoluteTop(value) {
          if (this._isAbsTop === value) {
            return;
          }
          this._isAbsTop = value;
          this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
        }
        get isAbsoluteBottom() {
          return this._isAbsBottom;
        }
        set isAbsoluteBottom(value) {
          if (this._isAbsBottom === value) {
            return;
          }
          this._isAbsBottom = value;
          this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
        }
        get isAbsoluteLeft() {
          return this._isAbsLeft;
        }
        set isAbsoluteLeft(value) {
          if (this._isAbsLeft === value) {
            return;
          }
          this._isAbsLeft = value;
          this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
        }
        get isAbsoluteRight() {
          return this._isAbsRight;
        }
        set isAbsoluteRight(value) {
          if (this._isAbsRight === value) {
            return;
          }
          this._isAbsRight = value;
          this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
        }
        get isAbsoluteHorizontalCenter() {
          return this._isAbsHorizontalCenter;
        }
        set isAbsoluteHorizontalCenter(value) {
          if (this._isAbsHorizontalCenter === value) {
            return;
          }
          this._isAbsHorizontalCenter = value;
          this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
        }
        get isAbsoluteVerticalCenter() {
          return this._isAbsVerticalCenter;
        }
        set isAbsoluteVerticalCenter(value) {
          if (this._isAbsVerticalCenter === value) {
            return;
          }
          this._isAbsVerticalCenter = value;
          this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
        }
        get alignMode() {
          return this._alignMode;
        }
        set alignMode(value) {
          this._alignMode = value;
          this._recursiveDirty();
        }
        get alignFlags() {
          return this._alignFlags;
        }
        set alignFlags(value) {
          if (this._alignFlags === value) {
            return;
          }
          this._alignFlags = value;
          this._recursiveDirty();
        }
        updateAlignment() {
          legacyCC._widgetManager.updateAlignment(this.node);
        }
        _validateTargetInDEV() {
          {
            return;
          }
        }
        setDirty() {
          this._recursiveDirty();
        }
        onEnable() {
          this.node.getPosition(this._lastPos);
          this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);
          legacyCC._widgetManager.add(this);
          this._hadAlignOnce = false;
          this._registerEvent();
          this._registerTargetEvents();
        }
        onDisable() {
          legacyCC._widgetManager.remove(this);
          this._unregisterEvent();
          this._unregisterTargetEvents();
        }
        onDestroy() {
          this._removeParentEvent();
        }
        _adjustWidgetToAllowMovingInEditor(eventType) {}
        _adjustWidgetToAllowResizingInEditor() {}
        _adjustWidgetToAnchorChanged() {
          this.setDirty();
        }
        _adjustTargetToParentChanged(oldParent) {
          if (oldParent) {
            this._unregisterOldParentEvents(oldParent);
          }
          if (this.node.getParent()) {
            this._registerTargetEvents();
          }
          this._setDirtyByMode();
        }
        _registerEvent() {
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
        _unregisterEvent() {
          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        }
        _removeParentEvent() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
        _autoChangedValue(flag, isAbs) {
          const current = (this._alignFlags & flag) > 0;
          if (!current) {
            return;
          }
          const parentUiProps = this.node.parent && this.node.parent._uiProps;
          const parentTrans = parentUiProps && parentUiProps.uiTransformComp;
          const size = parentTrans ? parentTrans.contentSize : visibleRect;
          if (this.isAlignLeft && flag === AlignFlags.LEFT) {
            this._left = isAbs ? this._left * size.width : this._left / size.width;
          } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
            this._right = isAbs ? this._right * size.width : this._right / size.width;
          } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
            this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
          } else if (this.isAlignTop && flag === AlignFlags.TOP) {
            this._top = isAbs ? this._top * size.height : this._top / size.height;
          } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
            this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
          } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
            this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
          }
          this._recursiveDirty();
        }
        _registerTargetEvents() {
          const target = this._target || this.node.parent;
          if (target) {
            if (target.getComponent(UITransform)) {
              target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
            }
          }
        }
        _unregisterTargetEvents() {
          const target = this._target || this.node.parent;
          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
          }
        }
        _unregisterOldParentEvents(oldParent) {
          const target = this._target || oldParent;
          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
        }
        _setDirtyByMode() {
          if (this.alignMode === AlignMode.ALWAYS || EDITOR_NOT_IN_PREVIEW) {
            this._recursiveDirty();
          }
        }
        _setAlign(flag, isAlign) {
          const current = (this._alignFlags & flag) > 0;
          if (isAlign === current) {
            return;
          }
          const isHorizontal = (flag & LEFT_RIGHT) > 0;
          const trans = this.node._uiProps.uiTransformComp;
          if (isAlign) {
            this._alignFlags |= flag;
            if (isHorizontal) {
              this.isAlignHorizontalCenter = false;
              if (this.isStretchWidth) {
                this._originalWidth = trans.width;
              }
            } else {
              this.isAlignVerticalCenter = false;
              if (this.isStretchHeight) {
                this._originalHeight = trans.height;
              }
            }
          } else {
            if (isHorizontal) {
              if (this.isStretchWidth) {
                trans.width = this._originalWidth;
              }
            } else if (this.isStretchHeight) {
              trans.height = this._originalHeight;
            }
            this._alignFlags &= ~flag;
          }
        }
        _recursiveDirty() {
          if (this._dirty) {
            return;
          }
          this._dirty = true;
        }
      }, _class3$2.AlignMode = AlignMode, _class3$2), (_applyDecoratedDescriptor(_class2$4.prototype, "target", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "target"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "alignMode", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "alignMode"), _class2$4.prototype), _initializer$4 = applyDecoratedInitializer(_class2$4.prototype, "_alignFlags", [serializable$6], function () {
        return 0;
      }), _initializer2$4 = applyDecoratedInitializer(_class2$4.prototype, "_target", [serializable$6], function () {
        return null;
      }), _initializer3$3 = applyDecoratedInitializer(_class2$4.prototype, "_left", [serializable$6], function () {
        return 0;
      }), _initializer4$3 = applyDecoratedInitializer(_class2$4.prototype, "_right", [serializable$6], function () {
        return 0;
      }), _initializer5$2 = applyDecoratedInitializer(_class2$4.prototype, "_top", [serializable$6], function () {
        return 0;
      }), _initializer6$1 = applyDecoratedInitializer(_class2$4.prototype, "_bottom", [serializable$6], function () {
        return 0;
      }), _initializer7$1 = applyDecoratedInitializer(_class2$4.prototype, "_horizontalCenter", [serializable$6], function () {
        return 0;
      }), _initializer8$1 = applyDecoratedInitializer(_class2$4.prototype, "_verticalCenter", [serializable$6], function () {
        return 0;
      }), _initializer9$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsLeft", [serializable$6], function () {
        return true;
      }), _initializer10$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsRight", [serializable$6], function () {
        return true;
      }), _initializer11$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsTop", [serializable$6], function () {
        return true;
      }), _initializer12$1 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsBottom", [serializable$6], function () {
        return true;
      }), _initializer13 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsHorizontalCenter", [serializable$6], function () {
        return true;
      }), _initializer14 = applyDecoratedInitializer(_class2$4.prototype, "_isAbsVerticalCenter", [serializable$6], function () {
        return true;
      }), _initializer15 = applyDecoratedInitializer(_class2$4.prototype, "_originalWidth", [serializable$6], function () {
        return 0;
      }), _initializer16 = applyDecoratedInitializer(_class2$4.prototype, "_originalHeight", [serializable$6], function () {
        return 0;
      }), _initializer17 = applyDecoratedInitializer(_class2$4.prototype, "_alignMode", [serializable$6], function () {
        return AlignMode.ON_WINDOW_RESIZE;
      }), _initializer18 = applyDecoratedInitializer(_class2$4.prototype, "_lockFlags", [serializable$6, editorOnly], function () {
        return 0;
      })), _class2$4)) || _class$7) || _class$7) || _class$7); exports({ Widget: Widget, WidgetComponent: Widget });
      legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
      legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;
      legacyCC.Widget = Widget;

      var _dec$6, _dec2$4, _dec3$4, _dec4$2, _dec5$2, _class$6, _class2$3, _initializer$3, _initializer2$3, _initializer3$2, _initializer4$2, _class3$1;
      const _color = new Color$1();
      var Direction$1;
      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$1 || (Direction$1 = {}));
      ccenum(Direction$1);
      let PageViewIndicator = (_dec$6 = ccclass$6('cc.PageViewIndicator'), _dec2$4 = executionOrder$1(110), _dec3$4 = type$6(SpriteFrame), _dec4$2 = type$6(Direction$1), _dec5$2 = type$6(Size$1), _dec$6(_class$6 = _dec2$4(_class$6 = (_class2$3 = (_class3$1 = class PageViewIndicator extends Component {
        constructor(...args) {
          super(...args);
          this.spacing = _initializer$3 && _initializer$3();
          this._spriteFrame = _initializer2$3 && _initializer2$3();
          this._direction = _initializer3$2 && _initializer3$2();
          this._cellSize = _initializer4$2 && _initializer4$2();
          this._layout = null;
          this._pageView = null;
          this._indicators = [];
        }
        get spriteFrame() {
          return this._spriteFrame;
        }
        set spriteFrame(value) {
          if (this._spriteFrame === value) {
            return;
          }
          this._spriteFrame = value;
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
        }
        get cellSize() {
          return this._cellSize;
        }
        set cellSize(value) {
          if (this._cellSize === value) {
            return;
          }
          this._cellSize = value;
        }
        onLoad() {
          this._updateLayout();
        }
        setPageView(target) {
          this._pageView = target;
          this._refresh();
        }
        _updateLayout() {
          this._layout = this.getComponent(Layout);
          if (!this._layout) {
            this._layout = this.addComponent(Layout);
          }
          const layout = this._layout;
          if (this.direction === Direction$1.HORIZONTAL) {
            layout.type = Layout.Type.HORIZONTAL;
            layout.spacingX = this.spacing;
          } else if (this.direction === Direction$1.VERTICAL) {
            layout.type = Layout.Type.VERTICAL;
            layout.spacingY = this.spacing;
          }
          layout.resizeMode = Layout.ResizeMode.CONTAINER;
        }
        _createIndicator() {
          const node = new Node$1();
          node.layer = this.node.layer;
          const sprite = node.addComponent(Sprite);
          sprite.spriteFrame = this.spriteFrame;
          sprite.sizeMode = Sprite.SizeMode.CUSTOM;
          node.parent = this.node;
          node._uiProps.uiTransformComp.setContentSize(this._cellSize);
          return node;
        }
        _changedState() {
          const indicators = this._indicators;
          if (indicators.length === 0 || !this._pageView) {
            return;
          }
          const idx = this._pageView.curPageIdx;
          if (idx >= indicators.length) {
            return;
          }
          for (let i = 0; i < indicators.length; ++i) {
            const node = indicators[i];
            if (!node._uiProps.uiComp) {
              continue;
            }
            const uiComp = node._uiProps.uiComp;
            _color.set(uiComp.color);
            _color.a = 255 / 2;
            uiComp.color = _color;
          }
          if (indicators[idx]._uiProps.uiComp) {
            const comp = indicators[idx]._uiProps.uiComp;
            _color.set(comp.color);
            _color.a = 255;
            comp.color = _color;
          }
        }
        _refresh() {
          if (!this._pageView) {
            return;
          }
          const indicators = this._indicators;
          const pages = this._pageView.getPages();
          if (pages.length === indicators.length) {
            return;
          }
          let i = 0;
          if (pages.length > indicators.length) {
            for (i = 0; i < pages.length; ++i) {
              if (!indicators[i]) {
                indicators[i] = this._createIndicator();
              }
            }
          } else {
            const count = indicators.length - pages.length;
            for (i = count; i > 0; --i) {
              const node = indicators[i - 1];
              this.node.removeChild(node);
              indicators.splice(i - 1, 1);
            }
          }
          if (this._layout && this._layout.enabledInHierarchy) {
            this._layout.updateLayout();
          }
          this._changedState();
        }
      }, _class3$1.Direction = Direction$1, _class3$1), (_applyDecoratedDescriptor(_class2$3.prototype, "spriteFrame", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$3.prototype, "spriteFrame"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "direction", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "direction"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "cellSize", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "cellSize"), _class2$3.prototype), _initializer$3 = applyDecoratedInitializer(_class2$3.prototype, "spacing", [serializable$6], function () {
        return 0;
      }), _initializer2$3 = applyDecoratedInitializer(_class2$3.prototype, "_spriteFrame", [serializable$6], function () {
        return null;
      }), _initializer3$2 = applyDecoratedInitializer(_class2$3.prototype, "_direction", [serializable$6], function () {
        return Direction$1.HORIZONTAL;
      }), _initializer4$2 = applyDecoratedInitializer(_class2$3.prototype, "_cellSize", [serializable$6], function () {
        return new Size$1(20, 20);
      })), _class2$3)) || _class$6) || _class$6); exports({ PageViewIndicator: PageViewIndicator, PageViewIndicatorComponent: PageViewIndicator });
      legacyCC.PageViewIndicator = PageViewIndicator;

      var _dec$5, _dec2$3, _dec3$3, _dec4$1, _dec5$1, _dec6, _dec7, _dec8, _dec9, _class$5, _class2$2, _initializer$2, _initializer2$2, _initializer3$1, _initializer4$1, _initializer5$1, _initializer6, _initializer7, _initializer8, _initializer9, _initializer10, _initializer11, _initializer12, _class3;
      const _tempVec2 = new Vec2();
      var SizeMode;
      (function (SizeMode) {
        SizeMode[SizeMode["Unified"] = 0] = "Unified";
        SizeMode[SizeMode["Free"] = 1] = "Free";
      })(SizeMode || (SizeMode = {}));
      ccenum(SizeMode);
      var Direction;
      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction || (Direction = {}));
      ccenum(Direction);
      var EventType;
      (function (EventType) {
        EventType["PAGE_TURNING"] = "page-turning";
      })(EventType || (EventType = {}));
      let PageView = (_dec$5 = ccclass$6('cc.PageView'), _dec2$3 = executionOrder$1(110), _dec3$3 = type$6(SizeMode), _dec4$1 = type$6(Direction), _dec5$1 = type$6(PageViewIndicator), _dec6 = type$6(ScrollBar), _dec7 = type$6(ScrollBar), _dec8 = type$6([EventHandler]), _dec9 = type$6([EventHandler]), _dec$5(_class$5 = _dec2$3(_class$5 = (_class2$2 = (_class3 = class PageView extends ScrollView {
        constructor(...args) {
          super(...args);
          this.autoPageTurningThreshold = _initializer$2 && _initializer$2();
          this.horizontal = _initializer2$2 && _initializer2$2();
          this.vertical = _initializer3$1 && _initializer3$1();
          this.cancelInnerEvents = _initializer4$1 && _initializer4$1();
          this.scrollEvents = _initializer5$1 && _initializer5$1();
          this.pageTurningSpeed = _initializer6 && _initializer6();
          this.pageEvents = _initializer7 && _initializer7();
          this._sizeMode = _initializer8 && _initializer8();
          this._direction = _initializer9 && _initializer9();
          this._scrollThreshold = _initializer10 && _initializer10();
          this._pageTurningEventTiming = _initializer11 && _initializer11();
          this._indicator = _initializer12 && _initializer12();
          this._curPageIdx = 0;
          this._lastPageIdx = 0;
          this._pages = [];
          this._initContentPos = new Vec3();
          this._scrollCenterOffsetX = [];
          this._scrollCenterOffsetY = [];
          this._touchBeganPosition = new Vec2();
          this._touchEndPosition = new Vec2();
        }
        get sizeMode() {
          return this._sizeMode;
        }
        set sizeMode(value) {
          if (this._sizeMode === value) {
            return;
          }
          this._sizeMode = value;
          this._syncSizeMode();
        }
        get direction() {
          return this._direction;
        }
        set direction(value) {
          if (this._direction === value) {
            return;
          }
          this._direction = value;
          this._syncScrollDirection();
        }
        get scrollThreshold() {
          return this._scrollThreshold;
        }
        set scrollThreshold(value) {
          if (this._scrollThreshold === value) {
            return;
          }
          this._scrollThreshold = value;
        }
        get pageTurningEventTiming() {
          return this._pageTurningEventTiming;
        }
        set pageTurningEventTiming(value) {
          if (this._pageTurningEventTiming === value) {
            return;
          }
          this._pageTurningEventTiming = value;
        }
        get indicator() {
          return this._indicator;
        }
        set indicator(value) {
          if (this._indicator === value) {
            return;
          }
          this._indicator = value;
          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        }
        get curPageIdx() {
          return this._curPageIdx;
        }
        get verticalScrollBar() {
          return super.verticalScrollBar;
        }
        set verticalScrollBar(value) {
          super.verticalScrollBar = value;
        }
        get horizontalScrollBar() {
          return super.horizontalScrollBar;
        }
        set horizontalScrollBar(value) {
          super.horizontalScrollBar = value;
        }
        onEnable() {
          super.onEnable();
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
          {
            this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        }
        onDisable() {
          super.onDisable();
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
          {
            this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        }
        onLoad() {
          this._initPages();
          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        }
        getCurrentPageIndex() {
          return this._curPageIdx;
        }
        setCurrentPageIndex(index) {
          this.scrollToPage(index, 1);
        }
        getPages() {
          return this._pages;
        }
        addPage(page) {
          if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }
          if (!page._uiProps.uiTransformComp) {
            logID(4301);
            return;
          }
          this.content.addChild(page);
          this._pages.push(page);
          this._updatePageView();
        }
        insertPage(page, index) {
          if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }
          const pageCount = this._pages.length;
          if (index >= pageCount) {
            this.addPage(page);
          } else {
            if (!page._uiProps.uiTransformComp) {
              logID(4301);
              return;
            }
            this._pages.splice(index, 0, page);
            this.content.insertChild(page, index);
            this._updatePageView();
          }
        }
        removePage(page) {
          if (!page || !this.content) {
            return;
          }
          const index = this._pages.indexOf(page);
          if (index === -1) {
            warnID(4300, page.name);
            return;
          }
          this.removePageAtIndex(index);
        }
        removePageAtIndex(index) {
          const pageList = this._pages;
          if (index < 0 || index >= pageList.length) {
            return;
          }
          const page = pageList[index];
          if (!page || !this.content) {
            return;
          }
          this.content.removeChild(page);
          pageList.splice(index, 1);
          this._updatePageView();
        }
        removeAllPages() {
          if (!this.content) {
            return;
          }
          const locPages = this._pages;
          for (let i = 0, len = locPages.length; i < len; i++) {
            this.content.removeChild(locPages[i]);
          }
          this._pages.length = 0;
          this._updatePageView();
        }
        scrollToPage(idx, timeInSecond = 0.3) {
          if (idx < 0 || idx >= this._pages.length) {
            return;
          }
          this._curPageIdx = idx;
          this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
          if (this.indicator) {
            this.indicator._changedState();
          }
        }
        getScrollEndedEventTiming() {
          return this.pageTurningEventTiming;
        }
        _updatePageView() {
          if (!this.content) {
            return;
          }
          const layout = this.content.getComponent(Layout);
          if (layout && layout.enabled) {
            layout.updateLayout();
          }
          const pageCount = this._pages.length;
          if (this._curPageIdx >= pageCount) {
            this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
            this._lastPageIdx = this._curPageIdx;
          }
          const contentPos = this._initContentPos;
          for (let i = 0; i < pageCount; ++i) {
            const page = this._pages[i];
            const pos = page.position;
            if (this.direction === Direction.Horizontal) {
              this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
            } else {
              this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
          }
          if (this.indicator) {
            this.indicator._refresh();
          }
        }
        _updateAllPagesSize() {
          const viewTrans = this.view;
          if (!this.content || !viewTrans) {
            return;
          }
          if (this._sizeMode !== SizeMode.Unified) {
            return;
          }
          const locPages = this._pages;
          const selfSize = viewTrans.contentSize;
          for (let i = 0, len = locPages.length; i < len; i++) {
            locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
          }
        }
        _handleReleaseLogic() {
          this._autoScrollToPage();
          if (this._scrolling) {
            this._scrolling = false;
            if (!this._autoScrolling) {
              this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
            }
          }
        }
        _onTouchBegan(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchBeganPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchBegan(event, captureListeners);
        }
        _onTouchMoved(event, captureListeners) {
          super._onTouchMoved(event, captureListeners);
        }
        _onTouchEnded(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchEndPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchEnded(event, captureListeners);
        }
        _onTouchCancelled(event, captureListeners) {
          event.touch.getUILocation(_tempVec2);
          Vec2.set(this._touchEndPosition, _tempVec2.x, _tempVec2.y);
          super._onTouchCancelled(event, captureListeners);
        }
        _onMouseWheel() {}
        _syncScrollDirection() {
          this.horizontal = this.direction === Direction.Horizontal;
          this.vertical = this.direction === Direction.Vertical;
        }
        _syncSizeMode() {
          const viewTrans = this.view;
          if (!this.content || !viewTrans) {
            return;
          }
          const layout = this.content.getComponent(Layout);
          if (layout) {
            if (this._sizeMode === SizeMode.Free && this._pages.length > 0) {
              const firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
              const lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;
              if (this.direction === Direction.Horizontal) {
                layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
              } else if (this.direction === Direction.Vertical) {
                layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
              }
            }
            layout.updateLayout();
          }
        }
        _initPages() {
          if (!this.content) {
            return;
          }
          this._initContentPos = this.content.position;
          const children = this.content.children;
          for (let i = 0; i < children.length; ++i) {
            const page = children[i];
            if (this._pages.indexOf(page) >= 0) {
              continue;
            }
            this._pages.push(page);
          }
          this._syncScrollDirection();
          this._syncSizeMode();
          this._updatePageView();
        }
        _dispatchPageTurningEvent() {
          if (this._lastPageIdx === this._curPageIdx) {
            return;
          }
          this._lastPageIdx = this._curPageIdx;
          EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
          this.node.emit(EventType.PAGE_TURNING, this);
        }
        _isQuicklyScrollable(touchMoveVelocity) {
          if (this.direction === Direction.Horizontal) {
            if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
              return true;
            }
          } else if (this.direction === Direction.Vertical) {
            if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
              return true;
            }
          }
          return false;
        }
        _moveOffsetValue(idx) {
          const offset = new Vec2();
          if (this._sizeMode === SizeMode.Free) {
            if (this.direction === Direction.Horizontal) {
              offset.x = this._scrollCenterOffsetX[idx];
            } else if (this.direction === Direction.Vertical) {
              offset.y = this._scrollCenterOffsetY[idx];
            }
          } else {
            const viewTrans = this.view;
            if (!viewTrans) {
              return offset;
            }
            if (this.direction === Direction.Horizontal) {
              offset.x = idx * viewTrans.width;
            } else if (this.direction === Direction.Vertical) {
              offset.y = idx * viewTrans.height;
            }
          }
          return offset;
        }
        _getDragDirection(moveOffset) {
          if (this._direction === Direction.Horizontal) {
            if (moveOffset.x === 0) {
              return 0;
            }
            return moveOffset.x > 0 ? 1 : -1;
          } else {
            if (moveOffset.y === 0) {
              return 0;
            }
            return moveOffset.y < 0 ? 1 : -1;
          }
        }
        _isScrollable(offset, index, nextIndex) {
          if (this._sizeMode === SizeMode.Free) {
            let curPageCenter = 0;
            let nextPageCenter = 0;
            if (this.direction === Direction.Horizontal) {
              curPageCenter = this._scrollCenterOffsetX[index];
              nextPageCenter = this._scrollCenterOffsetX[nextIndex];
              return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else if (this.direction === Direction.Vertical) {
              curPageCenter = this._scrollCenterOffsetY[index];
              nextPageCenter = this._scrollCenterOffsetY[nextIndex];
              return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            }
          } else {
            const viewTrans = this.view;
            if (!viewTrans) {
              return false;
            }
            if (this.direction === Direction.Horizontal) {
              return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
            } else if (this.direction === Direction.Vertical) {
              return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
            }
          }
          return false;
        }
        _autoScrollToPage() {
          const bounceBackStarted = this._startBounceBackIfNeeded();
          if (bounceBackStarted) {
            const bounceBackAmount = this._getHowMuchOutOfBoundary();
            this._clampDelta(bounceBackAmount);
            if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
              this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
            }
            if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
              this._curPageIdx = 0;
            }
            if (this.indicator) {
              this.indicator._changedState();
            }
          } else {
            const moveOffset = new Vec2();
            Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
            const index = this._curPageIdx;
            const nextIndex = index + this._getDragDirection(moveOffset);
            const timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
            if (nextIndex < this._pages.length) {
              if (this._isScrollable(moveOffset, index, nextIndex)) {
                this.scrollToPage(nextIndex, timeInSecond);
                return;
              } else {
                const touchMoveVelocity = this._calculateTouchMoveVelocity();
                if (this._isQuicklyScrollable(touchMoveVelocity)) {
                  this.scrollToPage(nextIndex, timeInSecond);
                  return;
                }
              }
            }
            this.scrollToPage(index, timeInSecond);
          }
        }
      }, _class3.SizeMode = SizeMode, _class3.Direction = Direction, _class3.EventType = extendsEnum(EventType, EventType$2), _class3), (_applyDecoratedDescriptor(_class2$2.prototype, "sizeMode", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$2.prototype, "sizeMode"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "direction", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "direction"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "indicator", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "indicator"), _class2$2.prototype), _initializer$2 = applyDecoratedInitializer(_class2$2.prototype, "autoPageTurningThreshold", [serializable$6], function () {
        return 100;
      }), _applyDecoratedDescriptor(_class2$2.prototype, "verticalScrollBar", [_dec6, override], Object.getOwnPropertyDescriptor(_class2$2.prototype, "verticalScrollBar"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "horizontalScrollBar", [_dec7, override], Object.getOwnPropertyDescriptor(_class2$2.prototype, "horizontalScrollBar"), _class2$2.prototype), _initializer2$2 = applyDecoratedInitializer(_class2$2.prototype, "horizontal", [override, serializable$6], function () {
        return true;
      }), _initializer3$1 = applyDecoratedInitializer(_class2$2.prototype, "vertical", [override, serializable$6], function () {
        return true;
      }), _initializer4$1 = applyDecoratedInitializer(_class2$2.prototype, "cancelInnerEvents", [override, serializable$6], function () {
        return true;
      }), _initializer5$1 = applyDecoratedInitializer(_class2$2.prototype, "scrollEvents", [_dec8, serializable$6, override], function () {
        return [];
      }), _initializer6 = applyDecoratedInitializer(_class2$2.prototype, "pageTurningSpeed", [serializable$6], function () {
        return 0.3;
      }), _initializer7 = applyDecoratedInitializer(_class2$2.prototype, "pageEvents", [_dec9, serializable$6], function () {
        return [];
      }), _initializer8 = applyDecoratedInitializer(_class2$2.prototype, "_sizeMode", [serializable$6], function () {
        return SizeMode.Unified;
      }), _initializer9 = applyDecoratedInitializer(_class2$2.prototype, "_direction", [serializable$6], function () {
        return Direction.Horizontal;
      }), _initializer10 = applyDecoratedInitializer(_class2$2.prototype, "_scrollThreshold", [serializable$6], function () {
        return 0.5;
      }), _initializer11 = applyDecoratedInitializer(_class2$2.prototype, "_pageTurningEventTiming", [serializable$6], function () {
        return 0.1;
      }), _initializer12 = applyDecoratedInitializer(_class2$2.prototype, "_indicator", [serializable$6], function () {
        return null;
      })), _class2$2)) || _class$5) || _class$5); exports({ PageView: PageView, PageViewComponent: PageView });
      legacyCC.PageView = PageView;

      const _tempPos = new Vec3();
      const _defaultAnchor = new Vec2();
      const tInverseTranslate = new Vec2();
      const tInverseScale = new Vec2(1, 1);
      const _tempVec2_1 = new Vec2();
      const _tempVec2_2 = new Vec2();
      function align(node, widget) {
        if (widget._hadAlignOnce) return;
        if (widget.alignMode === AlignMode.ONCE) {
          widget._hadAlignOnce = true;
        }
        const hasTarget = widget.target;
        let target;
        const inverseTranslate = tInverseTranslate;
        const inverseScale = tInverseScale;
        if (hasTarget) {
          target = hasTarget;
          computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
        } else {
          target = node.parent;
        }
        const targetSize = getReadonlyNodeSize(target);
        const useGlobal = target instanceof Scene || !target.getComponent(UITransform);
        const targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
        const isRoot = useGlobal;
        node.getPosition(_tempPos);
        const uiTrans = node._uiProps.uiTransformComp;
        let x = _tempPos.x;
        let y = _tempPos.y;
        const anchor = uiTrans.anchorPoint;
        const scale = node.getScale();
        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
          let localLeft = 0;
          let localRight = 0;
          const targetWidth = targetSize.width;
          if (isRoot) {
            localLeft = visibleRect.left.x;
            localRight = visibleRect.right.x;
          } else {
            localLeft = -targetAnchor.x * targetWidth;
            localRight = localLeft + targetWidth;
          }
          localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
          localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;
          if (hasTarget) {
            localLeft += inverseTranslate.x;
            localLeft *= inverseScale.x;
            localRight += inverseTranslate.x;
            localRight *= inverseScale.x;
          }
          let width = 0;
          let anchorX = anchor.x;
          let scaleX = scale.x;
          if (scaleX < 0) {
            anchorX = 1.0 - anchorX;
            scaleX = -scaleX;
          }
          if (widget.isStretchWidth) {
            width = localRight - localLeft;
            if (scaleX !== 0) {
              uiTrans.width = width / scaleX;
            }
            x = localLeft + anchorX * width;
          } else {
            width = uiTrans.width * scaleX;
            if (widget.isAlignHorizontalCenter) {
              let localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
              let targetCenter = (0.5 - targetAnchor.x) * targetSize.width;
              if (hasTarget) {
                localHorizontalCenter *= inverseScale.x;
                targetCenter += inverseTranslate.x;
                targetCenter *= inverseScale.x;
              }
              x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
            } else if (widget.isAlignLeft) {
              x = localLeft + anchorX * width;
            } else {
              x = localRight + (anchorX - 1) * width;
            }
            if (!approx(scaleX, 0, EPSILON$2)) {
              width /= scaleX;
            } else {
              width = uiTrans.width;
            }
          }
          widget._lastSize.width = width;
        }
        if (widget.alignFlags & AlignFlags.VERTICAL) {
          let localTop = 0;
          let localBottom = 0;
          const targetHeight = targetSize.height;
          if (isRoot) {
            localBottom = visibleRect.bottom.y;
            localTop = visibleRect.top.y;
          } else {
            localBottom = -targetAnchor.y * targetHeight;
            localTop = localBottom + targetHeight;
          }
          localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
          localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;
          if (hasTarget) {
            localBottom += inverseTranslate.y;
            localBottom *= inverseScale.y;
            localTop += inverseTranslate.y;
            localTop *= inverseScale.y;
          }
          let height = 0;
          let anchorY = anchor.y;
          let scaleY = scale.y;
          if (scaleY < 0) {
            anchorY = 1.0 - anchorY;
            scaleY = -scaleY;
          }
          if (widget.isStretchHeight) {
            height = localTop - localBottom;
            if (scaleY !== 0) {
              uiTrans.height = height / scaleY;
            }
            y = localBottom + anchorY * height;
          } else {
            height = uiTrans.height * scaleY;
            if (widget.isAlignVerticalCenter) {
              let localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
              let targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;
              if (hasTarget) {
                localVerticalCenter *= inverseScale.y;
                targetMiddle += inverseTranslate.y;
                targetMiddle *= inverseScale.y;
              }
              y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
            } else if (widget.isAlignBottom) {
              y = localBottom + anchorY * height;
            } else {
              y = localTop + (anchorY - 1) * height;
            }
            if (!approx(scaleY, 0, EPSILON$2)) {
              height /= scaleY;
            } else {
              height = uiTrans.height;
            }
          }
          widget._lastSize.height = height;
        }
        node.setPosition(x, y, _tempPos.z);
        Vec3.set(widget._lastPos, x, y, _tempPos.z);
      }
      function visitNode(node) {
        const widget = node.getComponent(Widget);
        if (widget && widget.enabled) {
          if (!legacyCC.isValid(node, true)) {
            return;
          }
          activeWidgets.push(widget);
        }
        const children = node.children;
        for (const child of children) {
          if (child.active) {
            visitNode(child);
          }
        }
      }
      function refreshScene() {
        const scene = director.getScene();
        if (scene) {
          widgetManager.isAligning = true;
          if (widgetManager._nodesOrderDirty) {
            activeWidgets.length = 0;
            visitNode(scene);
            widgetManager._nodesOrderDirty = false;
          }
          let widget = null;
          const iterator = widgetManager._activeWidgetsIterator;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            if (widget._dirty) {
              align(widget.node, widget);
              widget._dirty = false;
            }
          }
          widgetManager.isAligning = false;
        }
      }
      const activeWidgets = [];
      function updateAlignment(node) {
        const parent = node.parent;
        if (parent && Node$1.isNode(parent)) {
          updateAlignment(parent);
        }
        const widget = node.getComponent(Widget);
        if (widget && parent) {
          align(node, widget);
        }
      }
      const widgetManager = exports('widgetManager', legacyCC._widgetManager = {
        isAligning: false,
        _nodesOrderDirty: false,
        _activeWidgetsIterator: new MutableForwardIterator(activeWidgets),
        animationState: null,
        init() {
          director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
          director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
          View.instance.on('design-resolution-changed', this.onResized, this);
          {
            const thisOnResized = this.onResized.bind(this);
            View.instance.on('canvas-resize', thisOnResized);
            screenAdapter.on('window-resize', thisOnResized);
          }
        },
        add(widget) {
          this._nodesOrderDirty = true;
        },
        remove(widget) {
          this._activeWidgetsIterator.remove(widget);
        },
        onResized() {
          const scene = director.getScene();
          if (scene) {
            this.refreshWidgetOnResized(scene);
          }
        },
        refreshWidgetOnResized(node) {
          const widget = Node$1.isNode(node) && node.getComponent(Widget);
          if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
            widget.setDirty();
          }
          const children = node.children;
          for (const child of children) {
            this.refreshWidgetOnResized(child);
          }
        },
        updateOffsetsToStayPut(widget, e) {
          function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
          }
          const widgetNode = widget.node;
          let widgetParent = widgetNode.parent;
          if (widgetParent) {
            const zero = _tempVec2_1;
            zero.set(0, 0);
            const one = _tempVec2_2;
            one.set(1, 1);
            if (widget.target) {
              widgetParent = widget.target;
              computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
            }
            if (!e) {
              return;
            }
            const parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
            const parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
            const trans = widgetNode._uiProps.uiTransformComp;
            const matchSize = getReadonlyNodeSize(widgetParent);
            const myAP = trans.anchorPoint;
            const pos = widgetNode.getPosition();
            const alignFlags = AlignFlags;
            const widgetNodeScale = widgetNode.getScale();
            let temp = 0;
            if (e & alignFlags.LEFT) {
              let l = -parentAP.x * matchSize.width;
              l += zero.x;
              l *= one.x;
              temp = pos.x - myAP.x * trans.width * Math.abs(widgetNodeScale.x) - l;
              if (!widget.isAbsoluteLeft) {
                temp /= matchSize.width;
              }
              temp /= one.x;
              widget.left = i(widget.left, temp);
            }
            if (e & alignFlags.RIGHT) {
              let r = (1 - parentAP.x) * matchSize.width;
              r += zero.x;
              temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * Math.abs(widgetNodeScale.x));
              if (!widget.isAbsoluteRight) {
                temp /= matchSize.width;
              }
              temp /= one.x;
              widget.right = i(widget.right, temp);
            }
            if (e & alignFlags.TOP) {
              let t = (1 - parentAP.y) * matchSize.height;
              t += zero.y;
              temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * Math.abs(widgetNodeScale.y));
              if (!widget.isAbsoluteTop) {
                temp /= matchSize.height;
              }
              temp /= one.y;
              widget.top = i(widget.top, temp);
            }
            if (e & alignFlags.BOT) {
              let b = -parentAP.y * matchSize.height;
              b += zero.y;
              b *= one.y;
              temp = pos.y - myAP.y * trans.height * Math.abs(widgetNodeScale.y) - b;
              if (!widget.isAbsoluteBottom) {
                temp /= matchSize.height;
              }
              temp /= one.y;
              widget.bottom = i(widget.bottom, temp);
            }
          }
        },
        updateAlignment,
        AlignMode,
        AlignFlags
      });
      director.on(Director.EVENT_INIT, () => {
        widgetManager.init();
      });

      var _dec$4, _dec2$2, _dec3$2, _class$4;
      let SafeArea = (_dec$4 = ccclass$6('cc.SafeArea'), _dec2$2 = executionOrder$1(110), _dec3$2 = requireComponent(Widget), _dec$4(_class$4 = _dec2$2(_class$4 = _dec3$2(_class$4 = class SafeArea extends Component {
        onEnable() {
          this.updateArea();
          screenAdapter.on('window-resize', this.updateArea, this);
          screenAdapter.on('orientation-change', this.updateArea, this);
        }
        onDisable() {
          screenAdapter.off('window-resize', this.updateArea, this);
          screenAdapter.off('orientation-change', this.updateArea, this);
        }
        updateArea() {
          const widget = this.node.getComponent(Widget);
          const uiTransComp = this.node.getComponent(UITransform);
          if (!widget || !uiTransComp) {
            return;
          }
          widget.updateAlignment();
          const lastPos = this.node.position.clone();
          const lastAnchorPoint = uiTransComp.anchorPoint.clone();
          widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
          const visibleSize = view.getVisibleSize();
          const screenWidth = visibleSize.width;
          const screenHeight = visibleSize.height;
          const safeArea = sys.getSafeAreaRect();
          widget.top = screenHeight - safeArea.y - safeArea.height;
          widget.bottom = safeArea.y;
          widget.left = safeArea.x;
          widget.right = screenWidth - safeArea.x - safeArea.width;
          widget.updateAlignment();
          const curPos = this.node.position.clone();
          const anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
          const anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
          uiTransComp.setAnchorPoint(anchorX, anchorY);
          widgetManager.add(widget);
        }
      }) || _class$4) || _class$4) || _class$4); exports({ SafeArea: SafeArea, SafeAreaComponent: SafeArea });
      legacyCC.SafeArea = SafeArea;

      var _dec$3, _dec2$1, _dec3$1, _dec4, _dec5, _class$3, _class2$1, _initializer$1, _initializer2$1, _initializer3, _initializer4, _initializer5;
      let UICoordinateTracker = (_dec$3 = ccclass$6('cc.UICoordinateTracker'), _dec2$1 = executionOrder$1(110), _dec3$1 = type$6(Node$1), _dec4 = type$6(Camera), _dec5 = type$6([EventHandler]), _dec$3(_class$3 = _dec2$1(_class$3 = (_class2$1 = class UICoordinateTracker extends Component {
        constructor(...args) {
          super(...args);
          this.syncEvents = _initializer$1 && _initializer$1();
          this._target = _initializer2$1 && _initializer2$1();
          this._camera = _initializer3 && _initializer3();
          this._useScale = _initializer4 && _initializer4();
          this._distance = _initializer5 && _initializer5();
          this._transformPos = new Vec3();
          this._viewPos = new Vec3();
          this._canMove = true;
          this._lastWPos = new Vec3();
          this._lastCameraPos = new Vec3();
        }
        get target() {
          return this._target;
        }
        set target(value) {
          if (this._target === value) {
            return;
          }
          this._target = value;
          this._checkCanMove();
        }
        get camera() {
          return this._camera;
        }
        set camera(value) {
          if (this._camera === value) {
            return;
          }
          this._camera = value;
          this._checkCanMove();
        }
        get useScale() {
          return this._useScale;
        }
        set useScale(value) {
          if (this._useScale === value) {
            return;
          }
          this._useScale = value;
        }
        get distance() {
          return this._distance;
        }
        set distance(value) {
          if (this._distance === value) {
            return;
          }
          this._distance = value;
        }
        onEnable() {
          this._checkCanMove();
        }
        update() {
          const wPos = this.node.worldPosition;
          const camera = this._camera;
          if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
            return;
          }
          this._lastWPos.set(wPos);
          this._lastCameraPos.set(camera.node.worldPosition);
          camera.camera.update();
          camera.convertToUINode(wPos, this._target, this._transformPos);
          if (this._useScale) {
            Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
          }
          if (this.syncEvents.length > 0) {
            const data = this._distance / Math.abs(this._viewPos.z);
            EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
          }
        }
        _checkCanMove() {
          this._canMove = !!(this._camera && this._target);
        }
      }, (_applyDecoratedDescriptor(_class2$1.prototype, "target", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "target"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "camera", [_dec4], Object.getOwnPropertyDescriptor(_class2$1.prototype, "camera"), _class2$1.prototype), _initializer$1 = applyDecoratedInitializer(_class2$1.prototype, "syncEvents", [_dec5, serializable$6], function () {
        return [];
      }), _initializer2$1 = applyDecoratedInitializer(_class2$1.prototype, "_target", [serializable$6], function () {
        return null;
      }), _initializer3 = applyDecoratedInitializer(_class2$1.prototype, "_camera", [serializable$6], function () {
        return null;
      }), _initializer4 = applyDecoratedInitializer(_class2$1.prototype, "_useScale", [serializable$6], function () {
        return true;
      }), _initializer5 = applyDecoratedInitializer(_class2$1.prototype, "_distance", [serializable$6], function () {
        return 1;
      })), _class2$1)) || _class$3) || _class$3); exports({ UICoordinateTracker: UICoordinateTracker, UICoordinateTrackerComponent: UICoordinateTracker });

      var _dec$2, _class$2;
      const BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];
      function stopPropagation(event) {
        event.propagationStopped = true;
      }
      let BlockInputEvents = (_dec$2 = ccclass$6('cc.BlockInputEvents'), _dec$2(_class$2 = class BlockInputEvents extends Component {
        onEnable() {
          for (let i = 0; i < BlockEvents.length; i++) {
            this.node.on(BlockEvents[i], stopPropagation, this);
          }
        }
        onDisable() {
          for (let i = 0; i < BlockEvents.length; i++) {
            this.node.off(BlockEvents[i], stopPropagation, this);
          }
        }
      }) || _class$2); exports({ BlockInputEvents: BlockInputEvents, BlockInputEventsComponent: BlockInputEvents });

      var _dec$1, _dec2, _dec3, _class$1, _class2, _initializer, _initializer2;
      let SubContextView = exports('SubContextView', (_dec$1 = ccclass$6('cc.SubContextView'), _dec2 = executionOrder$1(110), _dec3 = requireComponent(UITransform), _dec$1(_class$1 = _dec2(_class$1 = _dec3(_class$1 = (_class2 = class SubContextView extends Component {
        get designResolutionSize() {
          return this._designResolutionSize;
        }
        set designResolutionSize(value) {
          {
            return;
          }
        }
        get fps() {
          return this._fps;
        }
        set fps(value) {
          if (this._fps === value) {
            return;
          }
          this._fps = value;
          this._updateInterval = 1000 / value;
        }
        constructor() {
          super();
          this._fps = _initializer && _initializer();
          this._sprite = void 0;
          this._imageAsset = void 0;
          this._texture = void 0;
          this._updatedTime = 0;
          this._updateInterval = 0;
          this._openDataContext = void 0;
          this._content = void 0;
          this._designResolutionSize = _initializer2 && _initializer2();
          this._content = new Node$1('content');
          this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
          this._sprite = null;
          this._imageAsset = new ImageAsset$1();
          this._openDataContext = null;
          this._updatedTime = performance.now();
          this._texture = new Texture2D$1();
        }
        onLoad() {
          if (minigame.getOpenDataContext) {
            this._updateInterval = 1000 / this._fps;
            this._openDataContext = minigame.getOpenDataContext();
            this._initSharedCanvas();
            this._initContentNode();
            this._updateSubContextView();
            this._updateContentLayer();
          } else {
            this.enabled = false;
          }
        }
        onEnable() {
          this._registerNodeEvent();
        }
        onDisable() {
          this._unregisterNodeEvent();
        }
        _initSharedCanvas() {
          if (this._openDataContext) {
            const sharedCanvas = this._openDataContext.canvas;
            let designWidth = this._designResolutionSize.width;
            let designHeight = this._designResolutionSize.height;
            sharedCanvas.width = designWidth;
            sharedCanvas.height = designHeight;
          }
        }
        _initContentNode() {
          if (this._openDataContext) {
            const sharedCanvas = this._openDataContext.canvas;
            const image = this._imageAsset;
            image.reset(sharedCanvas);
            this._texture.image = image;
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
            this._sprite = this._content.getComponent(Sprite);
            if (!this._sprite) {
              this._sprite = this._content.addComponent(Sprite);
            }
            if (this._sprite.spriteFrame) {
              this._sprite.spriteFrame.texture = this._texture;
            } else {
              const sp = new SpriteFrame();
              sp.texture = this._texture;
              this._sprite.spriteFrame = sp;
            }
            this._content.parent = this.node;
          }
        }
        _updateSubContextView() {
          if (!this._openDataContext) {
            return;
          }
          const nodeTrans = this.node.getComponent(UITransform);
          const contentTrans = this._content.getComponent(UITransform);
          const scaleX = nodeTrans.width / contentTrans.width;
          const scaleY = nodeTrans.height / contentTrans.height;
          const scale = scaleX > scaleY ? scaleY : scaleX;
          contentTrans.width *= scale;
          contentTrans.height *= scale;
          const viewportRect = view.getViewportRect();
          const box = contentTrans.getBoundingBoxToWorld();
          const visibleSize = view.getVisibleSize();
          const dpr = screenAdapter.devicePixelRatio;
          const x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
          const y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
          const width = viewportRect.width * (box.width / visibleSize.width) / dpr;
          const height = viewportRect.height * (box.height / visibleSize.height) / dpr;
          this._openDataContext.postMessage({
            fromEngine: true,
            type: 'engine',
            event: 'viewport',
            x,
            y,
            width,
            height
          });
        }
        _updateSubContextTexture() {
          const img = this._imageAsset;
          if (!img || !this._openDataContext) {
            return;
          }
          if (img.width <= 0 || img.height <= 0) {
            return;
          }
          const sharedCanvas = this._openDataContext.canvas;
          img.reset(sharedCanvas);
          if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
          }
          this._texture.uploadData(sharedCanvas);
        }
        _registerNodeEvent() {
          this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        }
        _unregisterNodeEvent() {
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        }
        _updateContentLayer() {
          this._content.layer = this.node.layer;
        }
        update(dt) {
          const calledUpdateManually = dt === undefined;
          if (calledUpdateManually) {
            this._updateSubContextTexture();
            return;
          }
          const now = performance.now();
          const deltaTime = now - this._updatedTime;
          if (deltaTime >= this._updateInterval) {
            this._updatedTime += this._updateInterval;
            this._updateSubContextTexture();
          }
        }
        onDestroy() {
          this._content.destroy();
          this._texture.destroy();
          if (this._sprite) {
            this._sprite.destroy();
          }
          this._imageAsset.destroy();
          this._openDataContext = null;
        }
      }, (_initializer = applyDecoratedInitializer(_class2.prototype, "_fps", [serializable$6], function () {
        return 60;
      }), _initializer2 = applyDecoratedInitializer(_class2.prototype, "_designResolutionSize", [serializable$6], function () {
        return new Size$1(640, 960);
      })), _class2)) || _class$1) || _class$1) || _class$1));
      legacyCC.SubContextView = SubContextView;

      deprecateModuleExportedName({
        ButtonComponent: {
          newName: 'Button',
          since: '1.2.0',
          removed: false
        },
        EditBoxComponent: {
          newName: 'EditBox',
          since: '1.2.0',
          removed: false
        },
        LayoutComponent: {
          newName: 'Layout',
          since: '1.2.0',
          removed: false
        },
        ProgressBarComponent: {
          newName: 'ProgressBar',
          since: '1.2.0',
          removed: false
        },
        ScrollViewComponent: {
          newName: 'ScrollView',
          since: '1.2.0',
          removed: false
        },
        ScrollBarComponent: {
          newName: 'ScrollBar',
          since: '1.2.0',
          removed: false
        },
        SliderComponent: {
          newName: 'Slider',
          since: '1.2.0',
          removed: false
        },
        ToggleComponent: {
          newName: 'Toggle',
          since: '1.2.0',
          removed: false
        },
        ToggleContainerComponent: {
          newName: 'ToggleContainer',
          since: '1.2.0',
          removed: false
        },
        WidgetComponent: {
          newName: 'Widget',
          since: '1.2.0',
          removed: false
        },
        PageViewComponent: {
          newName: 'PageView',
          since: '1.2.0',
          removed: false
        },
        PageViewIndicatorComponent: {
          newName: 'PageViewIndicator',
          since: '1.2.0',
          removed: false
        },
        SafeAreaComponent: {
          newName: 'SafeArea',
          since: '1.2.0',
          removed: false
        },
        UICoordinateTrackerComponent: {
          newName: 'UICoordinateTracker',
          since: '1.2.0',
          removed: false
        },
        BlockInputEventsComponent: {
          newName: 'BlockInputEvents',
          since: '1.2.0',
          removed: false
        }
      });

      var _dec, _class;
      let UIReorderComponent = exports('UIReorderComponent', (_dec = ccclass$6('cc.UIReorderComponent'), _dec(_class = class UIReorderComponent {
        constructor() {
          warnID(1408, 'UIReorderComponent');
        }
      }) || _class));
      legacyCC.UIReorderComponent = UIReorderComponent;
      legacyCC.ButtonComponent = Button;
      setClassAlias(Button, 'cc.ButtonComponent');
      legacyCC.EditBoxComponent = EditBox;
      setClassAlias(EditBox, 'cc.EditBoxComponent');
      legacyCC.LayoutComponent = Layout;
      setClassAlias(Layout, 'cc.LayoutComponent');
      legacyCC.ProgressBarComponent = ProgressBar;
      setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
      legacyCC.ScrollViewComponent = ScrollView;
      setClassAlias(ScrollView, 'cc.ScrollViewComponent');
      legacyCC.ScrollBarComponent = ScrollBar;
      setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
      legacyCC.SliderComponent = Slider;
      setClassAlias(Slider, 'cc.SliderComponent');
      legacyCC.ToggleComponent = Toggle;
      setClassAlias(Toggle, 'cc.ToggleComponent');
      legacyCC.ToggleContainerComponent = ToggleContainer;
      setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
      legacyCC.WidgetComponent = Widget;
      setClassAlias(Widget, 'cc.WidgetComponent');
      legacyCC.PageViewComponent = PageView;
      setClassAlias(PageView, 'cc.PageViewComponent');
      legacyCC.PageViewIndicatorComponent = PageViewIndicator;
      setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
      legacyCC.SafeAreaComponent = SafeArea;
      setClassAlias(SafeArea, 'cc.SafeAreaComponent');
      setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
      legacyCC.BlockInputEventsComponent = BlockInputEvents;
      setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');
      removeProperty(View.prototype, 'View.prototype', [{
        name: 'isAntiAliasEnabled',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }, {
        name: 'enableAntiAlias',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }]);
      markAsWarning(View.prototype, 'View.prototype', [{
        name: 'adjustViewportMeta'
      }, {
        name: 'enableAutoFullScreen',
        suggest: 'use screen.requestFullScreen() instead.'
      }, {
        name: 'isAutoFullScreenEnabled'
      }, {
        name: 'setCanvasSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getCanvasSize',
        suggest: 'please use screen.windowSize instead.'
      }, {
        name: 'getFrameSize',
        suggest: 'getting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'setFrameSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getDevicePixelRatio',
        suggest: 'use screen.devicePixelRatio instead.'
      }, {
        name: 'convertToLocationInView'
      }, {
        name: 'enableRetina'
      }, {
        name: 'isRetinaEnabled'
      }, {
        name: 'setRealPixelResolution'
      }]);

    })
  };
}));
